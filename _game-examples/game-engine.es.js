var AI = Object.defineProperty;
var h = (n, t) => AI(n, "name", { value: t, configurable: !0 });
var mc = {
  ui8: "ui8",
  ui16: "ui16",
  i32: "i32",
  ui32: "ui32",
  f32: "f32",
  f64: "f64",
  eid: "eid"
}, bx = {
  i8: "Int8",
  ui8: "Uint8",
  ui8c: "Uint8Clamped",
  i16: "Int16",
  ui16: "Uint16",
  i32: "Int32",
  ui32: "Uint32",
  eid: "Uint32",
  f32: "Float32",
  f64: "Float64"
}, ta = {
  i8: Int8Array,
  ui8: Uint8Array,
  ui8c: Uint8ClampedArray,
  i16: Int16Array,
  ui16: Uint16Array,
  i32: Int32Array,
  ui32: Uint32Array,
  f32: Float32Array,
  f64: Float64Array,
  eid: Uint32Array
}, yx = {
  uint8: 2 ** 8,
  uint16: 2 ** 16
}, MI = /* @__PURE__ */ h((n) => (t) => Math.ceil(t / n) * n, "roundToMultiple"), CI = MI(4), EI = Symbol("storeRef"), dp = Symbol("storeSize"), TI = Symbol("storeMaps"), ca = Symbol("storeFlattened"), ju = Symbol("storeBase"), II = Symbol("storeType"), yA = Symbol("storeArrayElementCounts"), Rh = Symbol("storeSubarrays"), xA = Symbol("subarrayCursors"), BI = Symbol("subarray"), mp = Symbol("parentArray"), wA = Symbol("tagStore"), xx = Symbol("indexType"), wx = Symbol("indexBytes"), SA = Symbol("isEidType"), so = {}, PI = /* @__PURE__ */ h((n, t) => {
  if (ArrayBuffer.isView(n))
    n[t] = n.slice(0);
  else {
    const e = n[mp].slice(0);
    n[t] = n.map((s, i) => {
      const { length: o } = n[i], r = o * i, a = r + o;
      return e.subarray(r, a);
    });
  }
}, "createShadow"), AA = /* @__PURE__ */ h((n, t) => {
  n[ca] && n[ca].forEach((e) => {
    ArrayBuffer.isView(e) ? e[t] = 0 : e[t].fill(0);
  });
}, "resetStoreFor"), RI = /* @__PURE__ */ h((n, t) => {
  const e = t * ta[n].BYTES_PER_ELEMENT, s = new ArrayBuffer(e), i = new ta[n](s);
  return i[SA] = n === mc.eid, i;
}, "createTypeStore"), DI = /* @__PURE__ */ h((n, t, e) => {
  const s = n[dp], i = Array(s).fill(0);
  i[II] = t, i[SA] = t === mc.eid;
  const o = n[xA], r = e <= yx.uint8 ? mc.ui8 : e <= yx.uint16 ? mc.ui16 : mc.ui32;
  if (!e)
    throw new Error("bitECS - Must define component array length");
  if (!ta[t])
    throw new Error(`bitECS - Invalid component array property type ${t}`);
  if (!n[Rh][t]) {
    const c = n[yA][t], u = new ta[t](CI(c * s));
    u[xx] = bx[r], u[wx] = ta[r].BYTES_PER_ELEMENT, n[Rh][t] = u;
  }
  const a = o[t], l = a + s * e;
  o[t] = l, i[mp] = n[Rh][t].subarray(a, l);
  for (let c = 0; c < s; c++) {
    const u = e * c, m = u + e;
    i[c] = i[mp].subarray(u, m), i[c][xx] = bx[r], i[c][wx] = ta[r].BYTES_PER_ELEMENT, i[c][BI] = !0;
  }
  return i;
}, "createArrayStore"), Sx = /* @__PURE__ */ h((n) => Array.isArray(n) && typeof n[0] == "string" && typeof n[1] == "number", "isArrayType"), VI = /* @__PURE__ */ h((n, t) => {
  const e = Symbol("store");
  if (!n || !Object.keys(n).length)
    return so[e] = {
      [dp]: t,
      [wA]: !0,
      [ju]: () => so[e]
    }, so[e];
  n = JSON.parse(JSON.stringify(n));
  const s = {}, i = /* @__PURE__ */ h((r) => {
    const a = Object.keys(r);
    for (const l of a)
      Sx(r[l]) ? (s[r[l][0]] || (s[r[l][0]] = 0), s[r[l][0]] += r[l][1]) : r[l] instanceof Object && i(r[l]);
  }, "collectArrayElementCounts");
  i(n);
  const o = {
    [dp]: t,
    [TI]: {},
    [Rh]: {},
    [EI]: e,
    [xA]: Object.keys(ta).reduce((r, a) => ({ ...r, [a]: 0 }), {}),
    [ca]: [],
    [yA]: s
  };
  if (n instanceof Object && Object.keys(n).length) {
    const r = /* @__PURE__ */ h((a, l) => {
      if (typeof a[l] == "string")
        a[l] = RI(a[l], t), a[l][ju] = () => so[e], o[ca].push(a[l]);
      else if (Sx(a[l])) {
        const [c, u] = a[l];
        a[l] = DI(o, c, u), a[l][ju] = () => so[e], o[ca].push(a[l]);
      } else a[l] instanceof Object && (a[l] = Object.keys(a[l]).reduce(r, a[l]));
      return a;
    }, "recursiveTransform");
    return so[e] = Object.assign(Object.keys(n).reduce(r, n), o), so[e][ju] = () => so[e], so[e];
  }
}, "createStore"), yl = /* @__PURE__ */ h(() => {
  const n = [], t = [];
  n.sort = function(r) {
    const a = Array.prototype.sort.call(this, r);
    for (let l = 0; l < n.length; l++)
      t[n[l]] = l;
    return a;
  };
  const e = /* @__PURE__ */ h((r) => n[t[r]] === r, "has");
  return {
    add: /* @__PURE__ */ h((r) => {
      e(r) || (t[r] = n.push(r) - 1);
    }, "add"),
    remove: /* @__PURE__ */ h((r) => {
      if (!e(r))
        return;
      const a = t[r], l = n.pop();
      l !== r && (n[a] = l, t[l] = a);
    }, "remove"),
    has: e,
    sparse: t,
    dense: n,
    reset: /* @__PURE__ */ h(() => {
      n.length = 0, t.length = 0;
    }, "reset")
  };
}, "SparseSet"), Uo = Symbol("entityMasks"), Iu = Symbol("entityComponents"), fr = Symbol("entitySparseSet"), Cl = Symbol("entityArray"), LI = 1e5, fp = 0, MA = LI, Rg = /* @__PURE__ */ h(() => MA, "getGlobalSize"), xl = [], NI = 0.01, zI = NI, kI = /* @__PURE__ */ h(() => fp, "getEntityCursor"), UI = /* @__PURE__ */ new Map(), Io = /* @__PURE__ */ h((n) => {
  const t = n[zg] ? xl.length ? xl.shift() : fp++ : xl.length > Math.round(MA * zI) ? xl.shift() : fp++;
  if (t > n[Ng])
    throw new Error("bitECS - max entities reached");
  return n[fr].add(t), UI.set(t, n), n[Dg].forEach((e) => {
    ym(n, e, t) && xm(e, t);
  }), n[Iu].set(t, /* @__PURE__ */ new Set()), t;
}, "addEntity"), CA = /* @__PURE__ */ h((n, t) => {
  if (n[fr].has(t)) {
    n[bm].forEach((e) => {
      Lg(n, e, t);
    }), n[zg] || xl.push(t), n[fr].remove(t), n[Iu].delete(t), n[PA].delete(n[_p].get(t)), n[_p].delete(t);
    for (let e = 0; e < n[Uo].length; e++)
      n[Uo][e][t] = 0;
  }
}, "removeEntity"), EA = Symbol("$modifier");
function TA(n, t) {
  const e = /* @__PURE__ */ h(() => [n, t], "inner");
  return e[EA] = !0, e;
}
h(TA, "modifier");
var OI = /* @__PURE__ */ h((n) => TA(n, "not"), "Not"), $I = /* @__PURE__ */ h((n) => TA(n, "changed"), "Changed"), bm = Symbol("queries"), Dg = Symbol("notQueries"), FI = Symbol("queryAny"), GI = Symbol("queryAll"), HI = Symbol("queryNone"), pr = Symbol("queryMap"), El = Symbol("$dirtyQueries"), IA = Symbol("queryComponents"), BA = Object.freeze([]), jI = /* @__PURE__ */ h((n) => (t) => {
  t[pr].has(n) || Vg(t, n);
  const e = t[pr].get(n);
  if (e.entered.dense.length === 0)
    return BA;
  {
    const s = e.entered.dense.slice();
    return e.entered.reset(), s;
  }
}, "enterQuery"), WI = /* @__PURE__ */ h((n) => (t) => {
  t[pr].has(n) || Vg(t, n);
  const e = t[pr].get(n);
  if (e.exited.dense.length === 0)
    return BA;
  {
    const s = e.exited.dense.slice();
    return e.exited.reset(), s;
  }
}, "exitQuery"), Vg = /* @__PURE__ */ h((n, t) => {
  const e = [], s = [], i = [];
  t[IA].forEach((A) => {
    if (typeof A == "function" && A[EA]) {
      const [C, M] = A();
      n[Hs].has(C) || pp(n, C), M === "not" && s.push(C), M === "changed" && (i.push(C), e.push(C));
    } else
      n[Hs].has(A) || pp(n, A), e.push(A);
  });
  const o = /* @__PURE__ */ h((A) => n[Hs].get(A), "mapComponents"), r = e.concat(s).map(o), a = yl(), l = [], c = [], u = yl(), m = yl(), d = yl(), f = r.map((A) => A.generationId).reduce((A, C) => (A.includes(C) || A.push(C), A), []), p = /* @__PURE__ */ h((A, C) => (A[C.generationId] || (A[C.generationId] = 0), A[C.generationId] |= C.bitflag, A), "reduceBitflags"), v = e.map(o).reduce(p, {}), _ = s.map(o).reduce(p, {}), g = r.reduce(p, {}), w = e.filter((A) => !A[wA]).map((A) => Object.getOwnPropertySymbols(A).includes(ca) ? A[ca] : [A]).reduce((A, C) => A.concat(C), []), x = Object.assign(a, {
    archetypes: l,
    changed: c,
    components: e,
    notComponents: s,
    changedComponents: i,
    allComponents: r,
    masks: v,
    notMasks: _,
    hasMasks: g,
    generations: f,
    flatProps: w,
    toRemove: u,
    entered: m,
    exited: d,
    shadows: []
  });
  n[pr].set(t, x), n[bm].add(x), r.forEach((A) => {
    A.queries.add(x);
  }), s.length && n[Dg].add(x);
  for (let A = 0; A < kI(); A++) {
    if (!n[fr].has(A))
      continue;
    ym(n, x, A) && xm(x, A);
  }
}, "registerQuery"), qI = /* @__PURE__ */ h((n, t) => {
  const e = Symbol(), s = n.flatProps[t];
  return PI(s, e), n.shadows[t] = s[e], s[e];
}, "generateShadow"), XI = /* @__PURE__ */ h((n, t) => {
  t && (n.changed = []);
  const { flatProps: e, shadows: s } = n;
  for (let i = 0; i < n.dense.length; i++) {
    const o = n.dense[i];
    let r = !1;
    for (let a = 0; a < e.length; a++) {
      const l = e[a], c = s[a] || qI(n, a);
      if (ArrayBuffer.isView(l[o])) {
        for (let u = 0; u < l[o].length; u++)
          if (l[o][u] !== c[o][u]) {
            r = !0;
            break;
          }
        c[o].set(l[o]);
      } else
        l[o] !== c[o] && (r = !0, c[o] = l[o]);
    }
    r && n.changed.push(o);
  }
  return n.changed;
}, "diff"), ZI = /* @__PURE__ */ h((...n) => {
  let t, e, s, i;
  if (Array.isArray(n[0]) && (t = n[0]), t === void 0 || t[Hs] !== void 0)
    return (r) => r ? r[Cl] : t[Cl];
  const o = /* @__PURE__ */ h(function(r, a = !0) {
    r[pr].has(o) || Vg(r, o);
    const l = r[pr].get(o);
    return JI(r), l.changedComponents.length ? XI(l, a) : l.dense;
  }, "query");
  return o[IA] = t, o[FI] = e, o[GI] = s, o[HI] = i, o;
}, "defineQuery"), ym = /* @__PURE__ */ h((n, t, e) => {
  const { masks: s, notMasks: i, generations: o } = t;
  for (let r = 0; r < o.length; r++) {
    const a = o[r], l = s[a], c = i[a], u = n[Uo][a][e];
    if (c && u & c || l && (u & l) !== l)
      return !1;
  }
  return !0;
}, "queryCheckEntity"), xm = /* @__PURE__ */ h((n, t) => {
  n.toRemove.remove(t), n.entered.add(t), n.add(t);
}, "queryAddEntity"), YI = /* @__PURE__ */ h((n) => {
  for (let t = n.toRemove.dense.length - 1; t >= 0; t--) {
    const e = n.toRemove.dense[t];
    n.toRemove.remove(e), n.remove(e);
  }
}, "queryCommitRemovals"), JI = /* @__PURE__ */ h((n) => {
  n[El].size && (n[El].forEach(YI), n[El].clear());
}, "commitRemovals"), Lg = /* @__PURE__ */ h((n, t, e) => {
  !t.has(e) || t.toRemove.has(e) || (t.toRemove.add(e), n[El].add(t), t.exited.add(e));
}, "queryRemoveEntity"), Hs = Symbol("componentMap"), oi = /* @__PURE__ */ h((n, t) => {
  const e = VI(n, Rg());
  return n && Object.keys(n).length, e;
}, "defineComponent"), KI = /* @__PURE__ */ h((n) => {
  n[Tl] *= 2, n[Tl] >= 2 ** 31 && (n[Tl] = 1, n[Uo].push(new Uint32Array(n[Ng])));
}, "incrementBitflag"), pp = /* @__PURE__ */ h((n, t) => {
  if (!t)
    throw new Error("bitECS - Cannot register null or undefined component");
  const e = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
  n[bm].forEach((o) => {
    o.allComponents.includes(t) && e.add(o);
  }), n[Hs].set(t, {
    generationId: n[Uo].length - 1,
    bitflag: n[Tl],
    store: t,
    queries: e,
    notQueries: s,
    changedQueries: i
  }), KI(n);
}, "registerComponent"), Zi = /* @__PURE__ */ h((n, t, e) => {
  const s = n[Hs].get(t);
  if (!s)
    return !1;
  const { generationId: i, bitflag: o } = s;
  return (n[Uo][i][e] & o) === o;
}, "hasComponent"), wn = /* @__PURE__ */ h((n, t, e, s = !1) => {
  if (e === void 0)
    throw new Error("bitECS - entity is undefined.");
  if (!n[fr].has(e))
    throw new Error("bitECS - entity does not exist in the world.");
  if (n[Hs].has(t) || pp(n, t), Zi(n, t, e))
    return;
  const i = n[Hs].get(t), { generationId: o, bitflag: r, queries: a, notQueries: l } = i;
  n[Uo][o][e] |= r, a.forEach((c) => {
    c.toRemove.remove(e);
    const u = ym(n, c, e);
    u && (c.exited.remove(e), xm(c, e)), u || (c.entered.remove(e), Lg(n, c, e));
  }), n[Iu].get(e).add(t), s && AA(t, e);
}, "addComponent"), QI = /* @__PURE__ */ h((n, t, e, s = !0) => {
  if (e === void 0)
    throw new Error("bitECS - entity is undefined.");
  if (!n[fr].has(e))
    throw new Error("bitECS - entity does not exist in the world.");
  if (!Zi(n, t, e))
    return;
  const i = n[Hs].get(t), { generationId: o, bitflag: r, queries: a } = i;
  n[Uo][o][e] &= ~r, a.forEach((l) => {
    l.toRemove.remove(e);
    const c = ym(n, l, e);
    c && (l.exited.remove(e), xm(l, e)), c || (l.entered.remove(e), Lg(n, l, e));
  }), n[Iu].get(e).delete(t), s && AA(t, e);
}, "removeComponent"), Ng = Symbol("size"), Tl = Symbol("bitflag"), tB = Symbol("archetypes"), PA = Symbol("localEntities"), _p = Symbol("localEntityLookup"), zg = Symbol("manualEntityRecycling"), eB = /* @__PURE__ */ h((...n) => {
  const t = typeof n[0] == "object" ? n[0] : {}, e = typeof n[0] == "number" ? n[0] : typeof n[1] == "number" ? n[1] : Rg();
  return nB(t, e), t;
}, "createWorld"), nB = /* @__PURE__ */ h((n, t = Rg()) => (n[Ng] = t, n[Cl] && n[Cl].forEach((e) => CA(n, e)), n[Uo] = [new Uint32Array(t)], n[Iu] = /* @__PURE__ */ new Map(), n[tB] = [], n[fr] = yl(), n[Cl] = n[fr].dense, n[Tl] = 1, n[Hs] = /* @__PURE__ */ new Map(), n[pr] = /* @__PURE__ */ new Map(), n[bm] = /* @__PURE__ */ new Set(), n[Dg] = /* @__PURE__ */ new Set(), n[El] = /* @__PURE__ */ new Set(), n[PA] = /* @__PURE__ */ new Map(), n[_p] = /* @__PURE__ */ new Map(), n[zg] = !1, n), "resetWorld"), Q = mc;
const RA = Object.freeze({
  status: "aborted"
});
function Z(n, t, e) {
  var a;
  function s(c, u) {
    var d, f;
    var m;
    Object.defineProperty(c, "_zod", {
      value: (d = c._zod) != null ? d : {},
      enumerable: !1
    }), (f = (m = c._zod).traits) != null || (m.traits = /* @__PURE__ */ new Set()), c._zod.traits.add(n), t(c, u);
    for (const p in r.prototype)
      p in c || Object.defineProperty(c, p, { value: r.prototype[p].bind(c) });
    c._zod.constr = r, c._zod.def = u;
  }
  h(s, "init");
  const i = (a = e == null ? void 0 : e.Parent) != null ? a : Object, l = class l extends i {
  };
  h(l, "Definition");
  let o = l;
  Object.defineProperty(o, "name", { value: n });
  function r(c) {
    var d;
    var u;
    const m = e != null && e.Parent ? new o() : this;
    s(m, c), (d = (u = m._zod).deferred) != null || (u.deferred = []);
    for (const f of m._zod.deferred)
      f();
    return m;
  }
  return h(r, "_"), Object.defineProperty(r, "init", { value: s }), Object.defineProperty(r, Symbol.hasInstance, {
    value: /* @__PURE__ */ h((c) => {
      var u, m;
      return e != null && e.Parent && c instanceof e.Parent ? !0 : (m = (u = c == null ? void 0 : c._zod) == null ? void 0 : u.traits) == null ? void 0 : m.has(n);
    }, "value")
  }), Object.defineProperty(r, "name", { value: n }), r;
}
h(Z, "$constructor");
const DA = Symbol("zod_brand"), K2 = class K2 extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
};
h(K2, "$ZodAsyncError");
let _r = K2;
const kh = {};
function Si(n) {
  return n && Object.assign(kh, n), kh;
}
h(Si, "config$1");
function iB(n) {
  return n;
}
h(iB, "assertEqual");
function sB(n) {
  return n;
}
h(sB, "assertNotEqual");
function oB(n) {
}
h(oB, "assertIs");
function rB(n) {
  throw new Error();
}
h(rB, "assertNever");
function aB(n) {
}
h(aB, "assert");
function kg(n) {
  const t = Object.values(n).filter((s) => typeof s == "number");
  return Object.entries(n).filter(([s, i]) => t.indexOf(+s) === -1).map(([s, i]) => i);
}
h(kg, "getEnumValues");
function Vt(n, t = "|") {
  return n.map((e) => Ee(e)).join(t);
}
h(Vt, "joinValues");
function VA(n, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
h(VA, "jsonStringifyReplacer");
function wm(n) {
  return {
    get value() {
      {
        const t = n();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
h(wm, "cached");
function Da(n) {
  return n == null;
}
h(Da, "nullish$1");
function Sm(n) {
  const t = n.startsWith("^") ? 1 : 0, e = n.endsWith("$") ? n.length - 1 : n.length;
  return n.slice(t, e);
}
h(Sm, "cleanRegex");
function LA(n, t) {
  const e = (n.toString().split(".")[1] || "").length, s = (t.toString().split(".")[1] || "").length, i = e > s ? e : s, o = Number.parseInt(n.toFixed(i).replace(".", "")), r = Number.parseInt(t.toFixed(i).replace(".", ""));
  return o % r / 10 ** i;
}
h(LA, "floatSafeRemainder");
function en(n, t, e) {
  Object.defineProperty(n, t, {
    get() {
      {
        const s = e();
        return n[t] = s, s;
      }
    },
    set(s) {
      Object.defineProperty(n, t, {
        value: s
      });
    },
    configurable: !0
  });
}
h(en, "defineLazy");
function Yc(n, t, e) {
  Object.defineProperty(n, t, {
    value: e,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
h(Yc, "assignProp");
function cB(n, t) {
  return t ? t.reduce((e, s) => e == null ? void 0 : e[s], n) : n;
}
h(cB, "getElementAtPath");
function lB(n) {
  const t = Object.keys(n), e = t.map((s) => n[s]);
  return Promise.all(e).then((s) => {
    const i = {};
    for (let o = 0; o < t.length; o++)
      i[t[o]] = s[o];
    return i;
  });
}
h(lB, "promiseAllObject");
function uB(n = 10) {
  const t = "abcdefghijklmnopqrstuvwxyz";
  let e = "";
  for (let s = 0; s < n; s++)
    e += t[Math.floor(Math.random() * t.length)];
  return e;
}
h(uB, "randomString");
function uc(n) {
  return JSON.stringify(n);
}
h(uc, "esc");
const Ug = Error.captureStackTrace ? Error.captureStackTrace : (...n) => {
};
function ql(n) {
  return typeof n == "object" && n !== null && !Array.isArray(n);
}
h(ql, "isObject");
const NA = wm(() => {
  var n;
  if (typeof navigator != "undefined" && ((n = navigator == null ? void 0 : navigator.userAgent) != null && n.includes("Cloudflare")))
    return !1;
  try {
    const t = Function;
    return new t(""), !0;
  } catch {
    return !1;
  }
});
function Xl(n) {
  if (ql(n) === !1)
    return !1;
  const t = n.constructor;
  if (t === void 0)
    return !0;
  const e = t.prototype;
  return !(ql(e) === !1 || Object.prototype.hasOwnProperty.call(e, "isPrototypeOf") === !1);
}
h(Xl, "isPlainObject");
function hB(n) {
  let t = 0;
  for (const e in n)
    Object.prototype.hasOwnProperty.call(n, e) && t++;
  return t;
}
h(hB, "numKeys");
const dB = /* @__PURE__ */ h((n) => {
  const t = typeof n;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(n) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      return Array.isArray(n) ? "array" : n === null ? "null" : n.then && typeof n.then == "function" && n.catch && typeof n.catch == "function" ? "promise" : typeof Map != "undefined" && n instanceof Map ? "map" : typeof Set != "undefined" && n instanceof Set ? "set" : typeof Date != "undefined" && n instanceof Date ? "date" : typeof File != "undefined" && n instanceof File ? "file" : "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, "getParsedType"), Uh = /* @__PURE__ */ new Set(["string", "number", "symbol"]), zA = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function Va(n) {
  return n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
h(Va, "escapeRegex");
function no(n, t, e) {
  const s = new n._zod.constr(t != null ? t : n._zod.def);
  return (!t || e != null && e.parent) && (s._zod.parent = n), s;
}
h(no, "clone");
function pt(n) {
  const t = n;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: /* @__PURE__ */ h(() => t, "error") };
  if ((t == null ? void 0 : t.message) !== void 0) {
    if ((t == null ? void 0 : t.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: /* @__PURE__ */ h(() => t.error, "error") } : t;
}
h(pt, "normalizeParams");
function mB(n) {
  let t;
  return new Proxy({}, {
    get(e, s, i) {
      return t != null || (t = n()), Reflect.get(t, s, i);
    },
    set(e, s, i, o) {
      return t != null || (t = n()), Reflect.set(t, s, i, o);
    },
    has(e, s) {
      return t != null || (t = n()), Reflect.has(t, s);
    },
    deleteProperty(e, s) {
      return t != null || (t = n()), Reflect.deleteProperty(t, s);
    },
    ownKeys(e) {
      return t != null || (t = n()), Reflect.ownKeys(t);
    },
    getOwnPropertyDescriptor(e, s) {
      return t != null || (t = n()), Reflect.getOwnPropertyDescriptor(t, s);
    },
    defineProperty(e, s, i) {
      return t != null || (t = n()), Reflect.defineProperty(t, s, i);
    }
  });
}
h(mB, "createTransparentProxy");
function Ee(n) {
  return typeof n == "bigint" ? n.toString() + "n" : typeof n == "string" ? `"${n}"` : `${n}`;
}
h(Ee, "stringifyPrimitive");
function kA(n) {
  return Object.keys(n).filter((t) => n[t]._zod.optin === "optional" && n[t]._zod.optout === "optional");
}
h(kA, "optionalKeys");
const UA = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
}, OA = {
  int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
  uint64: [BigInt(0), BigInt("18446744073709551615")]
};
function $A(n, t) {
  const e = {}, s = n._zod.def;
  for (const i in t) {
    if (!(i in s.shape))
      throw new Error(`Unrecognized key: "${i}"`);
    t[i] && (e[i] = s.shape[i]);
  }
  return no(n, {
    ...n._zod.def,
    shape: e,
    checks: []
  });
}
h($A, "pick");
function FA(n, t) {
  const e = { ...n._zod.def.shape }, s = n._zod.def;
  for (const i in t) {
    if (!(i in s.shape))
      throw new Error(`Unrecognized key: "${i}"`);
    t[i] && delete e[i];
  }
  return no(n, {
    ...n._zod.def,
    shape: e,
    checks: []
  });
}
h(FA, "omit");
function GA(n, t) {
  if (!Xl(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const e = {
    ...n._zod.def,
    get shape() {
      const s = { ...n._zod.def.shape, ...t };
      return Yc(this, "shape", s), s;
    },
    checks: []
  };
  return no(n, e);
}
h(GA, "extend");
function HA(n, t) {
  return no(n, {
    ...n._zod.def,
    get shape() {
      const e = { ...n._zod.def.shape, ...t._zod.def.shape };
      return Yc(this, "shape", e), e;
    },
    catchall: t._zod.def.catchall,
    checks: []
  });
}
h(HA, "merge");
function jA(n, t, e) {
  const s = t._zod.def.shape, i = { ...s };
  if (e)
    for (const o in e) {
      if (!(o in s))
        throw new Error(`Unrecognized key: "${o}"`);
      e[o] && (i[o] = n ? new n({
        type: "optional",
        innerType: s[o]
      }) : s[o]);
    }
  else
    for (const o in s)
      i[o] = n ? new n({
        type: "optional",
        innerType: s[o]
      }) : s[o];
  return no(t, {
    ...t._zod.def,
    shape: i,
    checks: []
  });
}
h(jA, "partial");
function WA(n, t, e) {
  const s = t._zod.def.shape, i = { ...s };
  if (e)
    for (const o in e) {
      if (!(o in i))
        throw new Error(`Unrecognized key: "${o}"`);
      e[o] && (i[o] = new n({
        type: "nonoptional",
        innerType: s[o]
      }));
    }
  else
    for (const o in s)
      i[o] = new n({
        type: "nonoptional",
        innerType: s[o]
      });
  return no(t, {
    ...t._zod.def,
    shape: i,
    checks: []
  });
}
h(WA, "required");
function xc(n, t = 0) {
  var e;
  for (let s = t; s < n.issues.length; s++)
    if (((e = n.issues[s]) == null ? void 0 : e.continue) !== !0)
      return !0;
  return !1;
}
h(xc, "aborted");
function cs(n, t) {
  return t.map((e) => {
    var i;
    var s;
    return (i = (s = e).path) != null || (s.path = []), e.path.unshift(n), e;
  });
}
h(cs, "prefixIssues");
function wl(n) {
  return typeof n == "string" ? n : n == null ? void 0 : n.message;
}
h(wl, "unwrapMessage");
function Is(n, t, e) {
  var i, o, r, a, l, c, u, m, d, f, p;
  const s = { ...n, path: (i = n.path) != null ? i : [] };
  if (!n.message) {
    const v = (p = (f = (m = (c = wl((a = (r = (o = n.inst) == null ? void 0 : o._zod.def) == null ? void 0 : r.error) == null ? void 0 : a.call(r, n))) != null ? c : wl((l = t == null ? void 0 : t.error) == null ? void 0 : l.call(t, n))) != null ? m : wl((u = e.customError) == null ? void 0 : u.call(e, n))) != null ? f : wl((d = e.localeError) == null ? void 0 : d.call(e, n))) != null ? p : "Invalid input";
    s.message = v;
  }
  return delete s.inst, delete s.continue, t != null && t.reportInput || delete s.input, s;
}
h(Is, "finalizeIssue");
function Am(n) {
  return n instanceof Set ? "set" : n instanceof Map ? "map" : n instanceof File ? "file" : "unknown";
}
h(Am, "getSizableOrigin");
function Mm(n) {
  return Array.isArray(n) ? "array" : typeof n == "string" ? "string" : "unknown";
}
h(Mm, "getLengthableOrigin");
function Pc(...n) {
  const [t, e, s] = n;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: e,
    inst: s
  } : { ...t };
}
h(Pc, "issue");
function fB(n) {
  return Object.entries(n).filter(([t, e]) => Number.isNaN(Number.parseInt(t, 10))).map((t) => t[1]);
}
h(fB, "cleanEnum");
const Q2 = class Q2 {
  constructor(...t) {
  }
};
h(Q2, "Class");
let gp = Q2;
const pB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BIGINT_FORMAT_RANGES: OA,
  Class: gp,
  NUMBER_FORMAT_RANGES: UA,
  aborted: xc,
  allowsEval: NA,
  assert: aB,
  assertEqual: iB,
  assertIs: oB,
  assertNever: rB,
  assertNotEqual: sB,
  assignProp: Yc,
  cached: wm,
  captureStackTrace: Ug,
  cleanEnum: fB,
  cleanRegex: Sm,
  clone: no,
  createTransparentProxy: mB,
  defineLazy: en,
  esc: uc,
  escapeRegex: Va,
  extend: GA,
  finalizeIssue: Is,
  floatSafeRemainder: LA,
  getElementAtPath: cB,
  getEnumValues: kg,
  getLengthableOrigin: Mm,
  getParsedType: dB,
  getSizableOrigin: Am,
  isObject: ql,
  isPlainObject: Xl,
  issue: Pc,
  joinValues: Vt,
  jsonStringifyReplacer: VA,
  merge: HA,
  normalizeParams: pt,
  nullish: Da,
  numKeys: hB,
  omit: FA,
  optionalKeys: kA,
  partial: jA,
  pick: $A,
  prefixIssues: cs,
  primitiveTypes: zA,
  promiseAllObject: lB,
  propertyKeyTypes: Uh,
  randomString: uB,
  required: WA,
  stringifyPrimitive: Ee,
  unwrapMessage: wl
}, Symbol.toStringTag, { value: "Module" })), qA = /* @__PURE__ */ h((n, t) => {
  n.name = "$ZodError", Object.defineProperty(n, "_zod", {
    value: n._zod,
    enumerable: !1
  }), Object.defineProperty(n, "issues", {
    value: t,
    enumerable: !1
  }), Object.defineProperty(n, "message", {
    get() {
      return JSON.stringify(t, VA, 2);
    },
    enumerable: !0
  }), Object.defineProperty(n, "toString", {
    value: /* @__PURE__ */ h(() => n.message, "value"),
    enumerable: !1
  });
}, "initializer$1"), Og = Z("$ZodError", qA), Bu = Z("$ZodError", qA, { Parent: Error });
function $g(n, t = (e) => e.message) {
  const e = {}, s = [];
  for (const i of n.issues)
    i.path.length > 0 ? (e[i.path[0]] = e[i.path[0]] || [], e[i.path[0]].push(t(i))) : s.push(t(i));
  return { formErrors: s, fieldErrors: e };
}
h($g, "flattenError");
function Fg(n, t) {
  const e = t || function(o) {
    return o.message;
  }, s = { _errors: [] }, i = /* @__PURE__ */ h((o) => {
    for (const r of o.issues)
      if (r.code === "invalid_union" && r.errors.length)
        r.errors.map((a) => i({ issues: a }));
      else if (r.code === "invalid_key")
        i({ issues: r.issues });
      else if (r.code === "invalid_element")
        i({ issues: r.issues });
      else if (r.path.length === 0)
        s._errors.push(e(r));
      else {
        let a = s, l = 0;
        for (; l < r.path.length; ) {
          const c = r.path[l];
          l === r.path.length - 1 ? (a[c] = a[c] || { _errors: [] }, a[c]._errors.push(e(r))) : a[c] = a[c] || { _errors: [] }, a = a[c], l++;
        }
      }
  }, "processError");
  return i(n), s;
}
h(Fg, "formatError");
function XA(n, t) {
  const e = t || function(o) {
    return o.message;
  }, s = { errors: [] }, i = /* @__PURE__ */ h((o, r = []) => {
    var c, u, m, d;
    var a, l;
    for (const f of o.issues)
      if (f.code === "invalid_union" && f.errors.length)
        f.errors.map((p) => i({ issues: p }, f.path));
      else if (f.code === "invalid_key")
        i({ issues: f.issues }, f.path);
      else if (f.code === "invalid_element")
        i({ issues: f.issues }, f.path);
      else {
        const p = [...r, ...f.path];
        if (p.length === 0) {
          s.errors.push(e(f));
          continue;
        }
        let v = s, _ = 0;
        for (; _ < p.length; ) {
          const g = p[_], w = _ === p.length - 1;
          typeof g == "string" ? ((c = v.properties) != null || (v.properties = {}), (u = (a = v.properties)[g]) != null || (a[g] = { errors: [] }), v = v.properties[g]) : ((m = v.items) != null || (v.items = []), (d = (l = v.items)[g]) != null || (l[g] = { errors: [] }), v = v.items[g]), w && v.errors.push(e(f)), _++;
        }
      }
  }, "processError");
  return i(n), s;
}
h(XA, "treeifyError");
function ZA(n) {
  const t = [];
  for (const e of n)
    typeof e == "number" ? t.push(`[${e}]`) : typeof e == "symbol" ? t.push(`[${JSON.stringify(String(e))}]`) : /[^\w$]/.test(e) ? t.push(`[${JSON.stringify(e)}]`) : (t.length && t.push("."), t.push(e));
  return t.join("");
}
h(ZA, "toDotPath");
function YA(n) {
  var s;
  const t = [], e = [...n.issues].sort((i, o) => i.path.length - o.path.length);
  for (const i of e)
    t.push(`✖ ${i.message}`), (s = i.path) != null && s.length && t.push(`  → at ${ZA(i.path)}`);
  return t.join(`
`);
}
h(YA, "prettifyError");
const Gg = /* @__PURE__ */ h((n) => (t, e, s, i) => {
  var a;
  const o = s ? Object.assign(s, { async: !1 }) : { async: !1 }, r = t._zod.run({ value: e, issues: [] }, o);
  if (r instanceof Promise)
    throw new _r();
  if (r.issues.length) {
    const l = new ((a = i == null ? void 0 : i.Err) != null ? a : n)(r.issues.map((c) => Is(c, o, Si())));
    throw Ug(l, i == null ? void 0 : i.callee), l;
  }
  return r.value;
}, "_parse"), vp = Gg(Bu), Hg = /* @__PURE__ */ h((n) => async (t, e, s, i) => {
  var a;
  const o = s ? Object.assign(s, { async: !0 }) : { async: !0 };
  let r = t._zod.run({ value: e, issues: [] }, o);
  if (r instanceof Promise && (r = await r), r.issues.length) {
    const l = new ((a = i == null ? void 0 : i.Err) != null ? a : n)(r.issues.map((c) => Is(c, o, Si())));
    throw Ug(l, i == null ? void 0 : i.callee), l;
  }
  return r.value;
}, "_parseAsync"), bp = Hg(Bu), jg = /* @__PURE__ */ h((n) => (t, e, s) => {
  const i = s ? { ...s, async: !1 } : { async: !1 }, o = t._zod.run({ value: e, issues: [] }, i);
  if (o instanceof Promise)
    throw new _r();
  return o.issues.length ? {
    success: !1,
    error: new (n != null ? n : Og)(o.issues.map((r) => Is(r, i, Si())))
  } : { success: !0, data: o.value };
}, "_safeParse"), JA = jg(Bu), Wg = /* @__PURE__ */ h((n) => async (t, e, s) => {
  const i = s ? Object.assign(s, { async: !0 }) : { async: !0 };
  let o = t._zod.run({ value: e, issues: [] }, i);
  return o instanceof Promise && (o = await o), o.issues.length ? {
    success: !1,
    error: new n(o.issues.map((r) => Is(r, i, Si())))
  } : { success: !0, data: o.value };
}, "_safeParseAsync"), KA = Wg(Bu), QA = /^[cC][^\s-]{8,}$/, tM = /^[0-9a-z]+$/, eM = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, nM = /^[0-9a-vA-V]{20}$/, iM = /^[A-Za-z0-9]{27}$/, sM = /^[a-zA-Z0-9_-]{21}$/, oM = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, _B = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, rM = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, Rc = /* @__PURE__ */ h((n) => n ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${n}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/, "uuid$1"), gB = Rc(4), vB = Rc(6), bB = Rc(7), aM = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, yB = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, xB = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, wB = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, SB = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, cM = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function lM() {
  return new RegExp(cM, "u");
}
h(lM, "emoji$1");
const uM = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, hM = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/, dM = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, mM = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, fM = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, qg = /^[A-Za-z0-9_-]*$/, pM = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/, AB = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, _M = /^\+(?:[0-9]){6,14}[0-9]$/, gM = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", vM = new RegExp(`^${gM}$`);
function bM(n) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof n.precision == "number" ? n.precision === -1 ? `${t}` : n.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${n.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
h(bM, "timeSource");
function yM(n) {
  return new RegExp(`^${bM(n)}$`);
}
h(yM, "time$1");
function xM(n) {
  const t = bM({ precision: n.precision }), e = ["Z"];
  n.local && e.push(""), n.offset && e.push("([+-]\\d{2}:\\d{2})");
  const s = `${t}(?:${e.join("|")})`;
  return new RegExp(`^${gM}T(?:${s})$`);
}
h(xM, "datetime$1");
const wM = /* @__PURE__ */ h((n) => {
  var e, s;
  const t = n ? `[\\s\\S]{${(e = n == null ? void 0 : n.minimum) != null ? e : 0},${(s = n == null ? void 0 : n.maximum) != null ? s : ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, "string$2"), SM = /^\d+n?$/, AM = /^\d+$/, MM = /^-?\d+(?:\.\d+)?/i, CM = /true|false/i, EM = /null/i, TM = /undefined/i, IM = /^[^A-Z]*$/, BM = /^[^a-z]*$/, PM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _emoji: cM,
  base64: fM,
  base64url: qg,
  bigint: SM,
  boolean: CM,
  browserEmail: SB,
  cidrv4: dM,
  cidrv6: mM,
  cuid: QA,
  cuid2: tM,
  date: vM,
  datetime: xM,
  domain: AB,
  duration: oM,
  e164: _M,
  email: aM,
  emoji: lM,
  extendedDuration: _B,
  guid: rM,
  hostname: pM,
  html5Email: yB,
  integer: AM,
  ipv4: uM,
  ipv6: hM,
  ksuid: iM,
  lowercase: IM,
  nanoid: sM,
  null: EM,
  number: MM,
  rfc5322Email: xB,
  string: wM,
  time: yM,
  ulid: eM,
  undefined: TM,
  unicodeEmail: wB,
  uppercase: BM,
  uuid: Rc,
  uuid4: gB,
  uuid6: vB,
  uuid7: bB,
  xid: nM
}, Symbol.toStringTag, { value: "Module" })), kn = Z("$ZodCheck", (n, t) => {
  var s, i;
  var e;
  (s = n._zod) != null || (n._zod = {}), n._zod.def = t, (i = (e = n._zod).onattach) != null || (e.onattach = []);
}), RM = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, Xg = Z("$ZodCheckLessThan", (n, t) => {
  kn.init(n, t);
  const e = RM[typeof t.value];
  n._zod.onattach.push((s) => {
    var r;
    const i = s._zod.bag, o = (r = t.inclusive ? i.maximum : i.exclusiveMaximum) != null ? r : Number.POSITIVE_INFINITY;
    t.value < o && (t.inclusive ? i.maximum = t.value : i.exclusiveMaximum = t.value);
  }), n._zod.check = (s) => {
    (t.inclusive ? s.value <= t.value : s.value < t.value) || s.issues.push({
      origin: e,
      code: "too_big",
      maximum: t.value,
      input: s.value,
      inclusive: t.inclusive,
      inst: n,
      continue: !t.abort
    });
  };
}), Zg = Z("$ZodCheckGreaterThan", (n, t) => {
  kn.init(n, t);
  const e = RM[typeof t.value];
  n._zod.onattach.push((s) => {
    var r;
    const i = s._zod.bag, o = (r = t.inclusive ? i.minimum : i.exclusiveMinimum) != null ? r : Number.NEGATIVE_INFINITY;
    t.value > o && (t.inclusive ? i.minimum = t.value : i.exclusiveMinimum = t.value);
  }), n._zod.check = (s) => {
    (t.inclusive ? s.value >= t.value : s.value > t.value) || s.issues.push({
      origin: e,
      code: "too_small",
      minimum: t.value,
      input: s.value,
      inclusive: t.inclusive,
      inst: n,
      continue: !t.abort
    });
  };
}), DM = Z("$ZodCheckMultipleOf", (n, t) => {
  kn.init(n, t), n._zod.onattach.push((e) => {
    var i;
    var s;
    (i = (s = e._zod.bag).multipleOf) != null || (s.multipleOf = t.value);
  }), n._zod.check = (e) => {
    if (typeof e.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof e.value == "bigint" ? e.value % t.value === BigInt(0) : LA(e.value, t.value) === 0) || e.issues.push({
      origin: typeof e.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: e.value,
      inst: n,
      continue: !t.abort
    });
  };
}), VM = Z("$ZodCheckNumberFormat", (n, t) => {
  var r;
  kn.init(n, t), t.format = t.format || "float64";
  const e = (r = t.format) == null ? void 0 : r.includes("int"), s = e ? "int" : "number", [i, o] = UA[t.format];
  n._zod.onattach.push((a) => {
    const l = a._zod.bag;
    l.format = t.format, l.minimum = i, l.maximum = o, e && (l.pattern = AM);
  }), n._zod.check = (a) => {
    const l = a.value;
    if (e) {
      if (!Number.isInteger(l)) {
        a.issues.push({
          expected: s,
          format: t.format,
          code: "invalid_type",
          input: l,
          inst: n
        });
        return;
      }
      if (!Number.isSafeInteger(l)) {
        l > 0 ? a.issues.push({
          input: l,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: n,
          origin: s,
          continue: !t.abort
        }) : a.issues.push({
          input: l,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: n,
          origin: s,
          continue: !t.abort
        });
        return;
      }
    }
    l < i && a.issues.push({
      origin: "number",
      input: l,
      code: "too_small",
      minimum: i,
      inclusive: !0,
      inst: n,
      continue: !t.abort
    }), l > o && a.issues.push({
      origin: "number",
      input: l,
      code: "too_big",
      maximum: o,
      inst: n
    });
  };
}), LM = Z("$ZodCheckBigIntFormat", (n, t) => {
  kn.init(n, t);
  const [e, s] = OA[t.format];
  n._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.format = t.format, o.minimum = e, o.maximum = s;
  }), n._zod.check = (i) => {
    const o = i.value;
    o < e && i.issues.push({
      origin: "bigint",
      input: o,
      code: "too_small",
      minimum: e,
      inclusive: !0,
      inst: n,
      continue: !t.abort
    }), o > s && i.issues.push({
      origin: "bigint",
      input: o,
      code: "too_big",
      maximum: s,
      inst: n
    });
  };
}), NM = Z("$ZodCheckMaxSize", (n, t) => {
  var s;
  var e;
  kn.init(n, t), (s = (e = n._zod.def).when) != null || (e.when = (i) => {
    const o = i.value;
    return !Da(o) && o.size !== void 0;
  }), n._zod.onattach.push((i) => {
    var r;
    const o = (r = i._zod.bag.maximum) != null ? r : Number.POSITIVE_INFINITY;
    t.maximum < o && (i._zod.bag.maximum = t.maximum);
  }), n._zod.check = (i) => {
    const o = i.value;
    o.size <= t.maximum || i.issues.push({
      origin: Am(o),
      code: "too_big",
      maximum: t.maximum,
      input: o,
      inst: n,
      continue: !t.abort
    });
  };
}), zM = Z("$ZodCheckMinSize", (n, t) => {
  var s;
  var e;
  kn.init(n, t), (s = (e = n._zod.def).when) != null || (e.when = (i) => {
    const o = i.value;
    return !Da(o) && o.size !== void 0;
  }), n._zod.onattach.push((i) => {
    var r;
    const o = (r = i._zod.bag.minimum) != null ? r : Number.NEGATIVE_INFINITY;
    t.minimum > o && (i._zod.bag.minimum = t.minimum);
  }), n._zod.check = (i) => {
    const o = i.value;
    o.size >= t.minimum || i.issues.push({
      origin: Am(o),
      code: "too_small",
      minimum: t.minimum,
      input: o,
      inst: n,
      continue: !t.abort
    });
  };
}), kM = Z("$ZodCheckSizeEquals", (n, t) => {
  var s;
  var e;
  kn.init(n, t), (s = (e = n._zod.def).when) != null || (e.when = (i) => {
    const o = i.value;
    return !Da(o) && o.size !== void 0;
  }), n._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.minimum = t.size, o.maximum = t.size, o.size = t.size;
  }), n._zod.check = (i) => {
    const o = i.value, r = o.size;
    if (r === t.size)
      return;
    const a = r > t.size;
    i.issues.push({
      origin: Am(o),
      ...a ? { code: "too_big", maximum: t.size } : { code: "too_small", minimum: t.size },
      inclusive: !0,
      exact: !0,
      input: i.value,
      inst: n,
      continue: !t.abort
    });
  };
}), UM = Z("$ZodCheckMaxLength", (n, t) => {
  var s;
  var e;
  kn.init(n, t), (s = (e = n._zod.def).when) != null || (e.when = (i) => {
    const o = i.value;
    return !Da(o) && o.length !== void 0;
  }), n._zod.onattach.push((i) => {
    var r;
    const o = (r = i._zod.bag.maximum) != null ? r : Number.POSITIVE_INFINITY;
    t.maximum < o && (i._zod.bag.maximum = t.maximum);
  }), n._zod.check = (i) => {
    const o = i.value;
    if (o.length <= t.maximum)
      return;
    const a = Mm(o);
    i.issues.push({
      origin: a,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: o,
      inst: n,
      continue: !t.abort
    });
  };
}), OM = Z("$ZodCheckMinLength", (n, t) => {
  var s;
  var e;
  kn.init(n, t), (s = (e = n._zod.def).when) != null || (e.when = (i) => {
    const o = i.value;
    return !Da(o) && o.length !== void 0;
  }), n._zod.onattach.push((i) => {
    var r;
    const o = (r = i._zod.bag.minimum) != null ? r : Number.NEGATIVE_INFINITY;
    t.minimum > o && (i._zod.bag.minimum = t.minimum);
  }), n._zod.check = (i) => {
    const o = i.value;
    if (o.length >= t.minimum)
      return;
    const a = Mm(o);
    i.issues.push({
      origin: a,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: o,
      inst: n,
      continue: !t.abort
    });
  };
}), Yg = Z("$ZodCheckLengthEquals", (n, t) => {
  var s;
  var e;
  kn.init(n, t), (s = (e = n._zod.def).when) != null || (e.when = (i) => {
    const o = i.value;
    return !Da(o) && o.length !== void 0;
  }), n._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.minimum = t.length, o.maximum = t.length, o.length = t.length;
  }), n._zod.check = (i) => {
    const o = i.value, r = o.length;
    if (r === t.length)
      return;
    const a = Mm(o), l = r > t.length;
    i.issues.push({
      origin: a,
      ...l ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: i.value,
      inst: n,
      continue: !t.abort
    });
  };
}), Pu = Z("$ZodCheckStringFormat", (n, t) => {
  var i, o;
  var e, s;
  kn.init(n, t), n._zod.onattach.push((r) => {
    var l;
    const a = r._zod.bag;
    a.format = t.format, t.pattern && ((l = a.patterns) != null || (a.patterns = /* @__PURE__ */ new Set()), a.patterns.add(t.pattern));
  }), t.pattern ? (i = (e = n._zod).check) != null || (e.check = (r) => {
    t.pattern.lastIndex = 0, !t.pattern.test(r.value) && r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: r.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: n,
      continue: !t.abort
    });
  }) : (o = (s = n._zod).check) != null || (s.check = () => {
  });
}), $M = Z("$ZodCheckRegex", (n, t) => {
  Pu.init(n, t), n._zod.check = (e) => {
    t.pattern.lastIndex = 0, !t.pattern.test(e.value) && e.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: e.value,
      pattern: t.pattern.toString(),
      inst: n,
      continue: !t.abort
    });
  };
}), FM = Z("$ZodCheckLowerCase", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = IM), Pu.init(n, t);
}), GM = Z("$ZodCheckUpperCase", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = BM), Pu.init(n, t);
}), HM = Z("$ZodCheckIncludes", (n, t) => {
  kn.init(n, t);
  const e = Va(t.includes), s = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${e}` : e);
  t.pattern = s, n._zod.onattach.push((i) => {
    var r;
    const o = i._zod.bag;
    (r = o.patterns) != null || (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(s);
  }), n._zod.check = (i) => {
    i.value.includes(t.includes, t.position) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: i.value,
      inst: n,
      continue: !t.abort
    });
  };
}), jM = Z("$ZodCheckStartsWith", (n, t) => {
  var s;
  kn.init(n, t);
  const e = new RegExp(`^${Va(t.prefix)}.*`);
  (s = t.pattern) != null || (t.pattern = e), n._zod.onattach.push((i) => {
    var r;
    const o = i._zod.bag;
    (r = o.patterns) != null || (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(e);
  }), n._zod.check = (i) => {
    i.value.startsWith(t.prefix) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: i.value,
      inst: n,
      continue: !t.abort
    });
  };
}), WM = Z("$ZodCheckEndsWith", (n, t) => {
  var s;
  kn.init(n, t);
  const e = new RegExp(`.*${Va(t.suffix)}$`);
  (s = t.pattern) != null || (t.pattern = e), n._zod.onattach.push((i) => {
    var r;
    const o = i._zod.bag;
    (r = o.patterns) != null || (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(e);
  }), n._zod.check = (i) => {
    i.value.endsWith(t.suffix) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: i.value,
      inst: n,
      continue: !t.abort
    });
  };
});
function Ax(n, t, e) {
  n.issues.length && t.issues.push(...cs(e, n.issues));
}
h(Ax, "handleCheckPropertyResult");
const qM = Z("$ZodCheckProperty", (n, t) => {
  kn.init(n, t), n._zod.check = (e) => {
    const s = t.schema._zod.run({
      value: e.value[t.property],
      issues: []
    }, {});
    if (s instanceof Promise)
      return s.then((i) => Ax(i, e, t.property));
    Ax(s, e, t.property);
  };
}), XM = Z("$ZodCheckMimeType", (n, t) => {
  kn.init(n, t);
  const e = new Set(t.mime);
  n._zod.onattach.push((s) => {
    s._zod.bag.mime = t.mime;
  }), n._zod.check = (s) => {
    e.has(s.value.type) || s.issues.push({
      code: "invalid_value",
      values: t.mime,
      input: s.value.type,
      inst: n
    });
  };
}), ZM = Z("$ZodCheckOverwrite", (n, t) => {
  kn.init(n, t), n._zod.check = (e) => {
    e.value = t.tx(e.value);
  };
}), tb = class tb {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const s = t.split(`
`).filter((r) => r), i = Math.min(...s.map((r) => r.length - r.trimStart().length)), o = s.map((r) => r.slice(i)).map((r) => " ".repeat(this.indent * 2) + r);
    for (const r of o)
      this.content.push(r);
  }
  compile() {
    var o;
    const t = Function, e = this == null ? void 0 : this.args, i = [...((o = this == null ? void 0 : this.content) != null ? o : [""]).map((r) => `  ${r}`)];
    return new t(...e, i.join(`
`));
  }
};
h(tb, "Doc");
let Oh = tb;
const YM = {
  major: 4,
  minor: 0,
  patch: 0
}, ve = Z("$ZodType", (n, t) => {
  var i, o, r;
  var e;
  n != null || (n = {}), n._zod.def = t, n._zod.bag = n._zod.bag || {}, n._zod.version = YM;
  const s = [...(i = n._zod.def.checks) != null ? i : []];
  n._zod.traits.has("$ZodCheck") && s.unshift(n);
  for (const a of s)
    for (const l of a._zod.onattach)
      l(n);
  if (s.length === 0)
    (o = (e = n._zod).deferred) != null || (e.deferred = []), (r = n._zod.deferred) == null || r.push(() => {
      n._zod.run = n._zod.parse;
    });
  else {
    const a = /* @__PURE__ */ h((l, c, u) => {
      let m = xc(l), d;
      for (const f of c) {
        if (f._zod.def.when) {
          if (!f._zod.def.when(l))
            continue;
        } else if (m)
          continue;
        const p = l.issues.length, v = f._zod.check(l);
        if (v instanceof Promise && (u == null ? void 0 : u.async) === !1)
          throw new _r();
        if (d || v instanceof Promise)
          d = (d != null ? d : Promise.resolve()).then(async () => {
            await v, l.issues.length !== p && (m || (m = xc(l, p)));
          });
        else {
          if (l.issues.length === p)
            continue;
          m || (m = xc(l, p));
        }
      }
      return d ? d.then(() => l) : l;
    }, "runChecks");
    n._zod.run = (l, c) => {
      const u = n._zod.parse(l, c);
      if (u instanceof Promise) {
        if (c.async === !1)
          throw new _r();
        return u.then((m) => a(m, s, c));
      }
      return a(u, s, c);
    };
  }
  n["~standard"] = {
    validate: /* @__PURE__ */ h((a) => {
      var l;
      try {
        const c = JA(n, a);
        return c.success ? { value: c.data } : { issues: (l = c.error) == null ? void 0 : l.issues };
      } catch {
        return KA(n, a).then((u) => {
          var m;
          return u.success ? { value: u.data } : { issues: (m = u.error) == null ? void 0 : m.issues };
        });
      }
    }, "validate"),
    vendor: "zod",
    version: 1
  };
}), Ru = Z("$ZodString", (n, t) => {
  var e, s, i;
  ve.init(n, t), n._zod.pattern = (i = [...(s = (e = n == null ? void 0 : n._zod.bag) == null ? void 0 : e.patterns) != null ? s : []].pop()) != null ? i : wM(n._zod.bag), n._zod.parse = (o, r) => {
    if (t.coerce)
      try {
        o.value = String(o.value);
      } catch {
      }
    return typeof o.value == "string" || o.issues.push({
      expected: "string",
      code: "invalid_type",
      input: o.value,
      inst: n
    }), o;
  };
}), Sn = Z("$ZodStringFormat", (n, t) => {
  Pu.init(n, t), Ru.init(n, t);
}), JM = Z("$ZodGUID", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = rM), Sn.init(n, t);
}), KM = Z("$ZodUUID", (n, t) => {
  var e, s;
  if (t.version) {
    const o = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (o === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    (e = t.pattern) != null || (t.pattern = Rc(o));
  } else
    (s = t.pattern) != null || (t.pattern = Rc());
  Sn.init(n, t);
}), QM = Z("$ZodEmail", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = aM), Sn.init(n, t);
}), tC = Z("$ZodURL", (n, t) => {
  Sn.init(n, t), n._zod.check = (e) => {
    try {
      const s = e.value, i = new URL(s), o = i.href;
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(i.hostname) || e.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: pM.source,
        input: e.value,
        inst: n,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(i.protocol.endsWith(":") ? i.protocol.slice(0, -1) : i.protocol) || e.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: e.value,
        inst: n,
        continue: !t.abort
      })), !s.endsWith("/") && o.endsWith("/") ? e.value = o.slice(0, -1) : e.value = o;
      return;
    } catch {
      e.issues.push({
        code: "invalid_format",
        format: "url",
        input: e.value,
        inst: n,
        continue: !t.abort
      });
    }
  };
}), eC = Z("$ZodEmoji", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = lM()), Sn.init(n, t);
}), nC = Z("$ZodNanoID", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = sM), Sn.init(n, t);
}), iC = Z("$ZodCUID", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = QA), Sn.init(n, t);
}), sC = Z("$ZodCUID2", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = tM), Sn.init(n, t);
}), oC = Z("$ZodULID", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = eM), Sn.init(n, t);
}), rC = Z("$ZodXID", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = nM), Sn.init(n, t);
}), aC = Z("$ZodKSUID", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = iM), Sn.init(n, t);
}), cC = Z("$ZodISODateTime", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = xM(t)), Sn.init(n, t);
}), lC = Z("$ZodISODate", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = vM), Sn.init(n, t);
}), uC = Z("$ZodISOTime", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = yM(t)), Sn.init(n, t);
}), hC = Z("$ZodISODuration", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = oM), Sn.init(n, t);
}), dC = Z("$ZodIPv4", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = uM), Sn.init(n, t), n._zod.onattach.push((s) => {
    const i = s._zod.bag;
    i.format = "ipv4";
  });
}), mC = Z("$ZodIPv6", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = hM), Sn.init(n, t), n._zod.onattach.push((s) => {
    const i = s._zod.bag;
    i.format = "ipv6";
  }), n._zod.check = (s) => {
    try {
      new URL(`http://[${s.value}]`);
    } catch {
      s.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: s.value,
        inst: n,
        continue: !t.abort
      });
    }
  };
}), fC = Z("$ZodCIDRv4", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = dM), Sn.init(n, t);
}), pC = Z("$ZodCIDRv6", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = mM), Sn.init(n, t), n._zod.check = (s) => {
    const [i, o] = s.value.split("/");
    try {
      if (!o)
        throw new Error();
      const r = Number(o);
      if (`${r}` !== o)
        throw new Error();
      if (r < 0 || r > 128)
        throw new Error();
      new URL(`http://[${i}]`);
    } catch {
      s.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: s.value,
        inst: n,
        continue: !t.abort
      });
    }
  };
});
function Jg(n) {
  if (n === "")
    return !0;
  if (n.length % 4 !== 0)
    return !1;
  try {
    return atob(n), !0;
  } catch {
    return !1;
  }
}
h(Jg, "isValidBase64");
const _C = Z("$ZodBase64", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = fM), Sn.init(n, t), n._zod.onattach.push((s) => {
    s._zod.bag.contentEncoding = "base64";
  }), n._zod.check = (s) => {
    Jg(s.value) || s.issues.push({
      code: "invalid_format",
      format: "base64",
      input: s.value,
      inst: n,
      continue: !t.abort
    });
  };
});
function gC(n) {
  if (!qg.test(n))
    return !1;
  const t = n.replace(/[-_]/g, (s) => s === "-" ? "+" : "/"), e = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return Jg(e);
}
h(gC, "isValidBase64URL");
const vC = Z("$ZodBase64URL", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = qg), Sn.init(n, t), n._zod.onattach.push((s) => {
    s._zod.bag.contentEncoding = "base64url";
  }), n._zod.check = (s) => {
    gC(s.value) || s.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: s.value,
      inst: n,
      continue: !t.abort
    });
  };
}), bC = Z("$ZodE164", (n, t) => {
  var e;
  (e = t.pattern) != null || (t.pattern = _M), Sn.init(n, t);
});
function yC(n, t = null) {
  try {
    const e = n.split(".");
    if (e.length !== 3)
      return !1;
    const [s] = e;
    if (!s)
      return !1;
    const i = JSON.parse(atob(s));
    return !("typ" in i && (i == null ? void 0 : i.typ) !== "JWT" || !i.alg || t && (!("alg" in i) || i.alg !== t));
  } catch {
    return !1;
  }
}
h(yC, "isValidJWT");
const xC = Z("$ZodJWT", (n, t) => {
  Sn.init(n, t), n._zod.check = (e) => {
    yC(e.value, t.alg) || e.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: e.value,
      inst: n,
      continue: !t.abort
    });
  };
}), wC = Z("$ZodCustomStringFormat", (n, t) => {
  Sn.init(n, t), n._zod.check = (e) => {
    t.fn(e.value) || e.issues.push({
      code: "invalid_format",
      format: t.format,
      input: e.value,
      inst: n,
      continue: !t.abort
    });
  };
}), Kg = Z("$ZodNumber", (n, t) => {
  var e;
  ve.init(n, t), n._zod.pattern = (e = n._zod.bag.pattern) != null ? e : MM, n._zod.parse = (s, i) => {
    if (t.coerce)
      try {
        s.value = Number(s.value);
      } catch {
      }
    const o = s.value;
    if (typeof o == "number" && !Number.isNaN(o) && Number.isFinite(o))
      return s;
    const r = typeof o == "number" ? Number.isNaN(o) ? "NaN" : Number.isFinite(o) ? void 0 : "Infinity" : void 0;
    return s.issues.push({
      expected: "number",
      code: "invalid_type",
      input: o,
      inst: n,
      ...r ? { received: r } : {}
    }), s;
  };
}), SC = Z("$ZodNumber", (n, t) => {
  VM.init(n, t), Kg.init(n, t);
}), Qg = Z("$ZodBoolean", (n, t) => {
  ve.init(n, t), n._zod.pattern = CM, n._zod.parse = (e, s) => {
    if (t.coerce)
      try {
        e.value = !!e.value;
      } catch {
      }
    const i = e.value;
    return typeof i == "boolean" || e.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: i,
      inst: n
    }), e;
  };
}), tv = Z("$ZodBigInt", (n, t) => {
  ve.init(n, t), n._zod.pattern = SM, n._zod.parse = (e, s) => {
    if (t.coerce)
      try {
        e.value = BigInt(e.value);
      } catch {
      }
    return typeof e.value == "bigint" || e.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: e.value,
      inst: n
    }), e;
  };
}), AC = Z("$ZodBigInt", (n, t) => {
  LM.init(n, t), tv.init(n, t);
}), MC = Z("$ZodSymbol", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => {
    const i = e.value;
    return typeof i == "symbol" || e.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input: i,
      inst: n
    }), e;
  };
}), CC = Z("$ZodUndefined", (n, t) => {
  ve.init(n, t), n._zod.pattern = TM, n._zod.values = /* @__PURE__ */ new Set([void 0]), n._zod.optin = "optional", n._zod.optout = "optional", n._zod.parse = (e, s) => {
    const i = e.value;
    return typeof i == "undefined" || e.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input: i,
      inst: n
    }), e;
  };
}), EC = Z("$ZodNull", (n, t) => {
  ve.init(n, t), n._zod.pattern = EM, n._zod.values = /* @__PURE__ */ new Set([null]), n._zod.parse = (e, s) => {
    const i = e.value;
    return i === null || e.issues.push({
      expected: "null",
      code: "invalid_type",
      input: i,
      inst: n
    }), e;
  };
}), TC = Z("$ZodAny", (n, t) => {
  ve.init(n, t), n._zod.parse = (e) => e;
}), $h = Z("$ZodUnknown", (n, t) => {
  ve.init(n, t), n._zod.parse = (e) => e;
}), IC = Z("$ZodNever", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => (e.issues.push({
    expected: "never",
    code: "invalid_type",
    input: e.value,
    inst: n
  }), e);
}), BC = Z("$ZodVoid", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => {
    const i = e.value;
    return typeof i == "undefined" || e.issues.push({
      expected: "void",
      code: "invalid_type",
      input: i,
      inst: n
    }), e;
  };
}), PC = Z("$ZodDate", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => {
    if (t.coerce)
      try {
        e.value = new Date(e.value);
      } catch {
      }
    const i = e.value, o = i instanceof Date;
    return o && !Number.isNaN(i.getTime()) || e.issues.push({
      expected: "date",
      code: "invalid_type",
      input: i,
      ...o ? { received: "Invalid Date" } : {},
      inst: n
    }), e;
  };
});
function Mx(n, t, e) {
  n.issues.length && t.issues.push(...cs(e, n.issues)), t.value[e] = n.value;
}
h(Mx, "handleArrayResult");
const ev = Z("$ZodArray", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => {
    const i = e.value;
    if (!Array.isArray(i))
      return e.issues.push({
        expected: "array",
        code: "invalid_type",
        input: i,
        inst: n
      }), e;
    e.value = Array(i.length);
    const o = [];
    for (let r = 0; r < i.length; r++) {
      const a = i[r], l = t.element._zod.run({
        value: a,
        issues: []
      }, s);
      l instanceof Promise ? o.push(l.then((c) => Mx(c, e, r))) : Mx(l, e, r);
    }
    return o.length ? Promise.all(o).then(() => e) : e;
  };
});
function Wu(n, t, e) {
  n.issues.length && t.issues.push(...cs(e, n.issues)), t.value[e] = n.value;
}
h(Wu, "handleObjectResult");
function Cx(n, t, e, s) {
  n.issues.length ? s[e] === void 0 ? e in s ? t.value[e] = void 0 : t.value[e] = n.value : t.issues.push(...cs(e, n.issues)) : n.value === void 0 ? e in s && (t.value[e] = void 0) : t.value[e] = n.value;
}
h(Cx, "handleOptionalObjectResult");
const RC = Z("$ZodObject", (n, t) => {
  ve.init(n, t);
  const e = wm(() => {
    const m = Object.keys(t.shape);
    for (const f of m)
      if (!(t.shape[f] instanceof ve))
        throw new Error(`Invalid element at key "${f}": expected a Zod schema`);
    const d = kA(t.shape);
    return {
      shape: t.shape,
      keys: m,
      keySet: new Set(m),
      numKeys: m.length,
      optionalKeys: new Set(d)
    };
  });
  en(n._zod, "propValues", () => {
    var f;
    const m = t.shape, d = {};
    for (const p in m) {
      const v = m[p]._zod;
      if (v.values) {
        (f = d[p]) != null || (d[p] = /* @__PURE__ */ new Set());
        for (const _ of v.values)
          d[p].add(_);
      }
    }
    return d;
  });
  const s = /* @__PURE__ */ h((m) => {
    const d = new Oh(["shape", "payload", "ctx"]), f = e.value, p = /* @__PURE__ */ h((w) => {
      const S = uc(w);
      return `shape[${S}]._zod.run({ value: input[${S}], issues: [] }, ctx)`;
    }, "parseStr");
    d.write("const input = payload.value;");
    const v = /* @__PURE__ */ Object.create(null);
    let _ = 0;
    for (const w of f.keys)
      v[w] = `key_${_++}`;
    d.write("const newResult = {}");
    for (const w of f.keys)
      if (f.optionalKeys.has(w)) {
        const S = v[w];
        d.write(`const ${S} = ${p(w)};`);
        const x = uc(w);
        d.write(`
        if (${S}.issues.length) {
          if (input[${x}] === undefined) {
            if (${x} in input) {
              newResult[${x}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${S}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${x}, ...iss.path] : [${x}],
              }))
            );
          }
        } else if (${S}.value === undefined) {
          if (${x} in input) newResult[${x}] = undefined;
        } else {
          newResult[${x}] = ${S}.value;
        }
        `);
      } else {
        const S = v[w];
        d.write(`const ${S} = ${p(w)};`), d.write(`
          if (${S}.issues.length) payload.issues = payload.issues.concat(${S}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${uc(w)}, ...iss.path] : [${uc(w)}]
          })));`), d.write(`newResult[${uc(w)}] = ${S}.value`);
      }
    d.write("payload.value = newResult;"), d.write("return payload;");
    const g = d.compile();
    return (w, S) => g(m, w, S);
  }, "generateFastpass");
  let i;
  const o = ql, r = !kh.jitless, l = r && NA.value, c = t.catchall;
  let u;
  n._zod.parse = (m, d) => {
    u != null || (u = e.value);
    const f = m.value;
    if (!o(f))
      return m.issues.push({
        expected: "object",
        code: "invalid_type",
        input: f,
        inst: n
      }), m;
    const p = [];
    if (r && l && (d == null ? void 0 : d.async) === !1 && d.jitless !== !0)
      i || (i = s(t.shape)), m = i(m, d);
    else {
      m.value = {};
      const S = u.shape;
      for (const x of u.keys) {
        const A = S[x], C = A._zod.run({ value: f[x], issues: [] }, d), M = A._zod.optin === "optional" && A._zod.optout === "optional";
        C instanceof Promise ? p.push(C.then((T) => M ? Cx(T, m, x, f) : Wu(T, m, x))) : M ? Cx(C, m, x, f) : Wu(C, m, x);
      }
    }
    if (!c)
      return p.length ? Promise.all(p).then(() => m) : m;
    const v = [], _ = u.keySet, g = c._zod, w = g.def.type;
    for (const S of Object.keys(f)) {
      if (_.has(S))
        continue;
      if (w === "never") {
        v.push(S);
        continue;
      }
      const x = g.run({ value: f[S], issues: [] }, d);
      x instanceof Promise ? p.push(x.then((A) => Wu(A, m, S))) : Wu(x, m, S);
    }
    return v.length && m.issues.push({
      code: "unrecognized_keys",
      keys: v,
      input: f,
      inst: n
    }), p.length ? Promise.all(p).then(() => m) : m;
  };
});
function Ex(n, t, e, s) {
  for (const i of n)
    if (i.issues.length === 0)
      return t.value = i.value, t;
  return t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: e,
    errors: n.map((i) => i.issues.map((o) => Is(o, s, Si())))
  }), t;
}
h(Ex, "handleUnionResults");
const nv = Z("$ZodUnion", (n, t) => {
  ve.init(n, t), en(n._zod, "optin", () => t.options.some((e) => e._zod.optin === "optional") ? "optional" : void 0), en(n._zod, "optout", () => t.options.some((e) => e._zod.optout === "optional") ? "optional" : void 0), en(n._zod, "values", () => {
    if (t.options.every((e) => e._zod.values))
      return new Set(t.options.flatMap((e) => Array.from(e._zod.values)));
  }), en(n._zod, "pattern", () => {
    if (t.options.every((e) => e._zod.pattern)) {
      const e = t.options.map((s) => s._zod.pattern);
      return new RegExp(`^(${e.map((s) => Sm(s.source)).join("|")})$`);
    }
  }), n._zod.parse = (e, s) => {
    let i = !1;
    const o = [];
    for (const r of t.options) {
      const a = r._zod.run({
        value: e.value,
        issues: []
      }, s);
      if (a instanceof Promise)
        o.push(a), i = !0;
      else {
        if (a.issues.length === 0)
          return a;
        o.push(a);
      }
    }
    return i ? Promise.all(o).then((r) => Ex(r, e, n, s)) : Ex(o, e, n, s);
  };
}), DC = Z("$ZodDiscriminatedUnion", (n, t) => {
  nv.init(n, t);
  const e = n._zod.parse;
  en(n._zod, "propValues", () => {
    const i = {};
    for (const o of t.options) {
      const r = o._zod.propValues;
      if (!r || Object.keys(r).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(o)}"`);
      for (const [a, l] of Object.entries(r)) {
        i[a] || (i[a] = /* @__PURE__ */ new Set());
        for (const c of l)
          i[a].add(c);
      }
    }
    return i;
  });
  const s = wm(() => {
    const i = t.options, o = /* @__PURE__ */ new Map();
    for (const r of i) {
      const a = r._zod.propValues[t.discriminator];
      if (!a || a.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(r)}"`);
      for (const l of a) {
        if (o.has(l))
          throw new Error(`Duplicate discriminator value "${String(l)}"`);
        o.set(l, r);
      }
    }
    return o;
  });
  n._zod.parse = (i, o) => {
    const r = i.value;
    if (!ql(r))
      return i.issues.push({
        code: "invalid_type",
        expected: "object",
        input: r,
        inst: n
      }), i;
    const a = s.value.get(r == null ? void 0 : r[t.discriminator]);
    return a ? a._zod.run(i, o) : t.unionFallback ? e(i, o) : (i.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input: r,
      path: [t.discriminator],
      inst: n
    }), i);
  };
}), VC = Z("$ZodIntersection", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => {
    const i = e.value, o = t.left._zod.run({ value: i, issues: [] }, s), r = t.right._zod.run({ value: i, issues: [] }, s);
    return o instanceof Promise || r instanceof Promise ? Promise.all([o, r]).then(([l, c]) => Tx(e, l, c)) : Tx(e, o, r);
  };
});
function yp(n, t) {
  if (n === t)
    return { valid: !0, data: n };
  if (n instanceof Date && t instanceof Date && +n == +t)
    return { valid: !0, data: n };
  if (Xl(n) && Xl(t)) {
    const e = Object.keys(t), s = Object.keys(n).filter((o) => e.indexOf(o) !== -1), i = { ...n, ...t };
    for (const o of s) {
      const r = yp(n[o], t[o]);
      if (!r.valid)
        return {
          valid: !1,
          mergeErrorPath: [o, ...r.mergeErrorPath]
        };
      i[o] = r.data;
    }
    return { valid: !0, data: i };
  }
  if (Array.isArray(n) && Array.isArray(t)) {
    if (n.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const e = [];
    for (let s = 0; s < n.length; s++) {
      const i = n[s], o = t[s], r = yp(i, o);
      if (!r.valid)
        return {
          valid: !1,
          mergeErrorPath: [s, ...r.mergeErrorPath]
        };
      e.push(r.data);
    }
    return { valid: !0, data: e };
  }
  return { valid: !1, mergeErrorPath: [] };
}
h(yp, "mergeValues");
function Tx(n, t, e) {
  if (t.issues.length && n.issues.push(...t.issues), e.issues.length && n.issues.push(...e.issues), xc(n))
    return n;
  const s = yp(t.value, e.value);
  if (!s.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(s.mergeErrorPath)}`);
  return n.value = s.data, n;
}
h(Tx, "handleIntersectionResults");
const Cm = Z("$ZodTuple", (n, t) => {
  ve.init(n, t);
  const e = t.items, s = e.length - [...e].reverse().findIndex((i) => i._zod.optin !== "optional");
  n._zod.parse = (i, o) => {
    const r = i.value;
    if (!Array.isArray(r))
      return i.issues.push({
        input: r,
        inst: n,
        expected: "tuple",
        code: "invalid_type"
      }), i;
    i.value = [];
    const a = [];
    if (!t.rest) {
      const c = r.length > e.length, u = r.length < s - 1;
      if (c || u)
        return i.issues.push({
          input: r,
          inst: n,
          origin: "array",
          ...c ? { code: "too_big", maximum: e.length } : { code: "too_small", minimum: e.length }
        }), i;
    }
    let l = -1;
    for (const c of e) {
      if (l++, l >= r.length && l >= s)
        continue;
      const u = c._zod.run({
        value: r[l],
        issues: []
      }, o);
      u instanceof Promise ? a.push(u.then((m) => qu(m, i, l))) : qu(u, i, l);
    }
    if (t.rest) {
      const c = r.slice(e.length);
      for (const u of c) {
        l++;
        const m = t.rest._zod.run({
          value: u,
          issues: []
        }, o);
        m instanceof Promise ? a.push(m.then((d) => qu(d, i, l))) : qu(m, i, l);
      }
    }
    return a.length ? Promise.all(a).then(() => i) : i;
  };
});
function qu(n, t, e) {
  n.issues.length && t.issues.push(...cs(e, n.issues)), t.value[e] = n.value;
}
h(qu, "handleTupleResult");
const LC = Z("$ZodRecord", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => {
    const i = e.value;
    if (!Xl(i))
      return e.issues.push({
        expected: "record",
        code: "invalid_type",
        input: i,
        inst: n
      }), e;
    const o = [];
    if (t.keyType._zod.values) {
      const r = t.keyType._zod.values;
      e.value = {};
      for (const l of r)
        if (typeof l == "string" || typeof l == "number" || typeof l == "symbol") {
          const c = t.valueType._zod.run({ value: i[l], issues: [] }, s);
          c instanceof Promise ? o.push(c.then((u) => {
            u.issues.length && e.issues.push(...cs(l, u.issues)), e.value[l] = u.value;
          })) : (c.issues.length && e.issues.push(...cs(l, c.issues)), e.value[l] = c.value);
        }
      let a;
      for (const l in i)
        r.has(l) || (a = a != null ? a : [], a.push(l));
      a && a.length > 0 && e.issues.push({
        code: "unrecognized_keys",
        input: i,
        inst: n,
        keys: a
      });
    } else {
      e.value = {};
      for (const r of Reflect.ownKeys(i)) {
        if (r === "__proto__")
          continue;
        const a = t.keyType._zod.run({ value: r, issues: [] }, s);
        if (a instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (a.issues.length) {
          e.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: a.issues.map((c) => Is(c, s, Si())),
            input: r,
            path: [r],
            inst: n
          }), e.value[a.value] = a.value;
          continue;
        }
        const l = t.valueType._zod.run({ value: i[r], issues: [] }, s);
        l instanceof Promise ? o.push(l.then((c) => {
          c.issues.length && e.issues.push(...cs(r, c.issues)), e.value[a.value] = c.value;
        })) : (l.issues.length && e.issues.push(...cs(r, l.issues)), e.value[a.value] = l.value);
      }
    }
    return o.length ? Promise.all(o).then(() => e) : e;
  };
}), NC = Z("$ZodMap", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => {
    const i = e.value;
    if (!(i instanceof Map))
      return e.issues.push({
        expected: "map",
        code: "invalid_type",
        input: i,
        inst: n
      }), e;
    const o = [];
    e.value = /* @__PURE__ */ new Map();
    for (const [r, a] of i) {
      const l = t.keyType._zod.run({ value: r, issues: [] }, s), c = t.valueType._zod.run({ value: a, issues: [] }, s);
      l instanceof Promise || c instanceof Promise ? o.push(Promise.all([l, c]).then(([u, m]) => {
        Ix(u, m, e, r, i, n, s);
      })) : Ix(l, c, e, r, i, n, s);
    }
    return o.length ? Promise.all(o).then(() => e) : e;
  };
});
function Ix(n, t, e, s, i, o, r) {
  n.issues.length && (Uh.has(typeof s) ? e.issues.push(...cs(s, n.issues)) : e.issues.push({
    origin: "map",
    code: "invalid_key",
    input: i,
    inst: o,
    issues: n.issues.map((a) => Is(a, r, Si()))
  })), t.issues.length && (Uh.has(typeof s) ? e.issues.push(...cs(s, t.issues)) : e.issues.push({
    origin: "map",
    code: "invalid_element",
    input: i,
    inst: o,
    key: s,
    issues: t.issues.map((a) => Is(a, r, Si()))
  })), e.value.set(n.value, t.value);
}
h(Ix, "handleMapResult");
const zC = Z("$ZodSet", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => {
    const i = e.value;
    if (!(i instanceof Set))
      return e.issues.push({
        input: i,
        inst: n,
        expected: "set",
        code: "invalid_type"
      }), e;
    const o = [];
    e.value = /* @__PURE__ */ new Set();
    for (const r of i) {
      const a = t.valueType._zod.run({ value: r, issues: [] }, s);
      a instanceof Promise ? o.push(a.then((l) => Bx(l, e))) : Bx(a, e);
    }
    return o.length ? Promise.all(o).then(() => e) : e;
  };
});
function Bx(n, t) {
  n.issues.length && t.issues.push(...n.issues), t.value.add(n.value);
}
h(Bx, "handleSetResult");
const kC = Z("$ZodEnum", (n, t) => {
  ve.init(n, t);
  const e = kg(t.entries);
  n._zod.values = new Set(e), n._zod.pattern = new RegExp(`^(${e.filter((s) => Uh.has(typeof s)).map((s) => typeof s == "string" ? Va(s) : s.toString()).join("|")})$`), n._zod.parse = (s, i) => {
    const o = s.value;
    return n._zod.values.has(o) || s.issues.push({
      code: "invalid_value",
      values: e,
      input: o,
      inst: n
    }), s;
  };
}), UC = Z("$ZodLiteral", (n, t) => {
  ve.init(n, t), n._zod.values = new Set(t.values), n._zod.pattern = new RegExp(`^(${t.values.map((e) => typeof e == "string" ? Va(e) : e ? e.toString() : String(e)).join("|")})$`), n._zod.parse = (e, s) => {
    const i = e.value;
    return n._zod.values.has(i) || e.issues.push({
      code: "invalid_value",
      values: t.values,
      input: i,
      inst: n
    }), e;
  };
}), OC = Z("$ZodFile", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => {
    const i = e.value;
    return i instanceof File || e.issues.push({
      expected: "file",
      code: "invalid_type",
      input: i,
      inst: n
    }), e;
  };
}), iv = Z("$ZodTransform", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => {
    const i = t.transform(e.value, e);
    if (s.async)
      return (i instanceof Promise ? i : Promise.resolve(i)).then((r) => (e.value = r, e));
    if (i instanceof Promise)
      throw new _r();
    return e.value = i, e;
  };
}), $C = Z("$ZodOptional", (n, t) => {
  ve.init(n, t), n._zod.optin = "optional", n._zod.optout = "optional", en(n._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), en(n._zod, "pattern", () => {
    const e = t.innerType._zod.pattern;
    return e ? new RegExp(`^(${Sm(e.source)})?$`) : void 0;
  }), n._zod.parse = (e, s) => t.innerType._zod.optin === "optional" ? t.innerType._zod.run(e, s) : e.value === void 0 ? e : t.innerType._zod.run(e, s);
}), FC = Z("$ZodNullable", (n, t) => {
  ve.init(n, t), en(n._zod, "optin", () => t.innerType._zod.optin), en(n._zod, "optout", () => t.innerType._zod.optout), en(n._zod, "pattern", () => {
    const e = t.innerType._zod.pattern;
    return e ? new RegExp(`^(${Sm(e.source)}|null)$`) : void 0;
  }), en(n._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), n._zod.parse = (e, s) => e.value === null ? e : t.innerType._zod.run(e, s);
}), GC = Z("$ZodDefault", (n, t) => {
  ve.init(n, t), n._zod.optin = "optional", en(n._zod, "values", () => t.innerType._zod.values), n._zod.parse = (e, s) => {
    if (e.value === void 0)
      return e.value = t.defaultValue, e;
    const i = t.innerType._zod.run(e, s);
    return i instanceof Promise ? i.then((o) => Px(o, t)) : Px(i, t);
  };
});
function Px(n, t) {
  return n.value === void 0 && (n.value = t.defaultValue), n;
}
h(Px, "handleDefaultResult");
const HC = Z("$ZodPrefault", (n, t) => {
  ve.init(n, t), n._zod.optin = "optional", en(n._zod, "values", () => t.innerType._zod.values), n._zod.parse = (e, s) => (e.value === void 0 && (e.value = t.defaultValue), t.innerType._zod.run(e, s));
}), jC = Z("$ZodNonOptional", (n, t) => {
  ve.init(n, t), en(n._zod, "values", () => {
    const e = t.innerType._zod.values;
    return e ? new Set([...e].filter((s) => s !== void 0)) : void 0;
  }), n._zod.parse = (e, s) => {
    const i = t.innerType._zod.run(e, s);
    return i instanceof Promise ? i.then((o) => Rx(o, n)) : Rx(i, n);
  };
});
function Rx(n, t) {
  return !n.issues.length && n.value === void 0 && n.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: n.value,
    inst: t
  }), n;
}
h(Rx, "handleNonOptionalResult");
const WC = Z("$ZodSuccess", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => {
    const i = t.innerType._zod.run(e, s);
    return i instanceof Promise ? i.then((o) => (e.value = o.issues.length === 0, e)) : (e.value = i.issues.length === 0, e);
  };
}), qC = Z("$ZodCatch", (n, t) => {
  ve.init(n, t), n._zod.optin = "optional", en(n._zod, "optout", () => t.innerType._zod.optout), en(n._zod, "values", () => t.innerType._zod.values), n._zod.parse = (e, s) => {
    const i = t.innerType._zod.run(e, s);
    return i instanceof Promise ? i.then((o) => (e.value = o.value, o.issues.length && (e.value = t.catchValue({
      ...e,
      error: {
        issues: o.issues.map((r) => Is(r, s, Si()))
      },
      input: e.value
    }), e.issues = []), e)) : (e.value = i.value, i.issues.length && (e.value = t.catchValue({
      ...e,
      error: {
        issues: i.issues.map((o) => Is(o, s, Si()))
      },
      input: e.value
    }), e.issues = []), e);
  };
}), XC = Z("$ZodNaN", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => ((typeof e.value != "number" || !Number.isNaN(e.value)) && e.issues.push({
    input: e.value,
    inst: n,
    expected: "nan",
    code: "invalid_type"
  }), e);
}), sv = Z("$ZodPipe", (n, t) => {
  ve.init(n, t), en(n._zod, "values", () => t.in._zod.values), en(n._zod, "optin", () => t.in._zod.optin), en(n._zod, "optout", () => t.out._zod.optout), n._zod.parse = (e, s) => {
    const i = t.in._zod.run(e, s);
    return i instanceof Promise ? i.then((o) => Dx(o, t, s)) : Dx(i, t, s);
  };
});
function Dx(n, t, e) {
  return xc(n) ? n : t.out._zod.run({ value: n.value, issues: n.issues }, e);
}
h(Dx, "handlePipeResult");
const ZC = Z("$ZodReadonly", (n, t) => {
  ve.init(n, t), en(n._zod, "propValues", () => t.innerType._zod.propValues), en(n._zod, "values", () => t.innerType._zod.values), en(n._zod, "optin", () => t.innerType._zod.optin), en(n._zod, "optout", () => t.innerType._zod.optout), n._zod.parse = (e, s) => {
    const i = t.innerType._zod.run(e, s);
    return i instanceof Promise ? i.then(Vx) : Vx(i);
  };
});
function Vx(n) {
  return n.value = Object.freeze(n.value), n;
}
h(Vx, "handleReadonlyResult");
const YC = Z("$ZodTemplateLiteral", (n, t) => {
  ve.init(n, t);
  const e = [];
  for (const s of t.parts)
    if (s instanceof ve) {
      if (!s._zod.pattern)
        throw new Error(`Invalid template literal part, no pattern found: ${[...s._zod.traits].shift()}`);
      const i = s._zod.pattern instanceof RegExp ? s._zod.pattern.source : s._zod.pattern;
      if (!i)
        throw new Error(`Invalid template literal part: ${s._zod.traits}`);
      const o = i.startsWith("^") ? 1 : 0, r = i.endsWith("$") ? i.length - 1 : i.length;
      e.push(i.slice(o, r));
    } else if (s === null || zA.has(typeof s))
      e.push(Va(`${s}`));
    else
      throw new Error(`Invalid template literal part: ${s}`);
  n._zod.pattern = new RegExp(`^${e.join("")}$`), n._zod.parse = (s, i) => typeof s.value != "string" ? (s.issues.push({
    input: s.value,
    inst: n,
    expected: "template_literal",
    code: "invalid_type"
  }), s) : (n._zod.pattern.lastIndex = 0, n._zod.pattern.test(s.value) || s.issues.push({
    input: s.value,
    inst: n,
    code: "invalid_format",
    format: "template_literal",
    pattern: n._zod.pattern.source
  }), s);
}), JC = Z("$ZodPromise", (n, t) => {
  ve.init(n, t), n._zod.parse = (e, s) => Promise.resolve(e.value).then((i) => t.innerType._zod.run({ value: i, issues: [] }, s));
}), KC = Z("$ZodLazy", (n, t) => {
  ve.init(n, t), en(n._zod, "innerType", () => t.getter()), en(n._zod, "pattern", () => n._zod.innerType._zod.pattern), en(n._zod, "propValues", () => n._zod.innerType._zod.propValues), en(n._zod, "optin", () => n._zod.innerType._zod.optin), en(n._zod, "optout", () => n._zod.innerType._zod.optout), n._zod.parse = (e, s) => n._zod.innerType._zod.run(e, s);
}), QC = Z("$ZodCustom", (n, t) => {
  kn.init(n, t), ve.init(n, t), n._zod.parse = (e, s) => e, n._zod.check = (e) => {
    const s = e.value, i = t.fn(s);
    if (i instanceof Promise)
      return i.then((o) => Lx(o, e, s, n));
    Lx(i, e, s, n);
  };
});
function Lx(n, t, e, s) {
  var i;
  if (!n) {
    const o = {
      code: "custom",
      input: e,
      inst: s,
      path: [...(i = s._zod.def.path) != null ? i : []],
      continue: !s._zod.def.abort
    };
    s._zod.def.params && (o.params = s._zod.def.params), t.issues.push(Pc(o));
  }
}
h(Lx, "handleRefineResult");
const MB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "حرف", verb: "أن يحوي" },
    file: { unit: "بايت", verb: "أن يحوي" },
    array: { unit: "عنصر", verb: "أن يحوي" },
    set: { unit: "عنصر", verb: "أن يحوي" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "مدخل",
    email: "بريد إلكتروني",
    url: "رابط",
    emoji: "إيموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاريخ ووقت بمعيار ISO",
    date: "تاريخ بمعيار ISO",
    time: "وقت بمعيار ISO",
    duration: "مدة بمعيار ISO",
    ipv4: "عنوان IPv4",
    ipv6: "عنوان IPv6",
    cidrv4: "مدى عناوين بصيغة IPv4",
    cidrv6: "مدى عناوين بصيغة IPv6",
    base64: "نَص بترميز base64-encoded",
    base64url: "نَص بترميز base64url-encoded",
    json_string: "نَص على هيئة JSON",
    e164: "رقم هاتف بمعيار E.164",
    jwt: "JWT",
    template_literal: "مدخل"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `مدخلات غير مقبولة: يفترض إدخال ${i.expected}، ولكن تم إدخال ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `مدخلات غير مقبولة: يفترض إدخال ${Ee(i.values[0])}` : `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? ` أكبر من اللازم: يفترض أن تكون ${(o = i.origin) != null ? o : "القيمة"} ${c} ${i.maximum.toString()} ${(r = u.unit) != null ? r : "عنصر"}` : `أكبر من اللازم: يفترض أن تكون ${(a = i.origin) != null ? a : "القيمة"} ${c} ${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `أصغر من اللازم: يفترض لـ ${i.origin} أن يكون ${c} ${i.minimum.toString()} ${u.unit}` : `أصغر من اللازم: يفترض لـ ${i.origin} أن يكون ${c} ${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `نَص غير مقبول: يجب أن يبدأ بـ "${i.prefix}"` : c.format === "ends_with" ? `نَص غير مقبول: يجب أن ينتهي بـ "${c.suffix}"` : c.format === "includes" ? `نَص غير مقبول: يجب أن يتضمَّن "${c.includes}"` : c.format === "regex" ? `نَص غير مقبول: يجب أن يطابق النمط ${c.pattern}` : `${(l = s[c.format]) != null ? l : i.format} غير مقبول`;
      }
      case "not_multiple_of":
        return `رقم غير مقبول: يجب أن يكون من مضاعفات ${i.divisor}`;
      case "unrecognized_keys":
        return `معرف${i.keys.length > 1 ? "ات" : ""} غريب${i.keys.length > 1 ? "ة" : ""}: ${Vt(i.keys, "، ")}`;
      case "invalid_key":
        return `معرف غير مقبول في ${i.origin}`;
      case "invalid_union":
        return "مدخل غير مقبول";
      case "invalid_element":
        return `مدخل غير مقبول في ${i.origin}`;
      default:
        return "مدخل غير مقبول";
    }
  };
}, "error$C");
function CB() {
  return {
    localeError: MB()
  };
}
h(CB, "ar");
const EB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "simvol", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "element", verb: "olmalıdır" },
    set: { unit: "element", verb: "olmalıdır" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Yanlış dəyər: gözlənilən ${i.expected}, daxil olan ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Yanlış dəyər: gözlənilən ${Ee(i.values[0])}` : `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Çox böyük: gözlənilən ${(o = i.origin) != null ? o : "dəyər"} ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "element"}` : `Çox böyük: gözlənilən ${(a = i.origin) != null ? a : "dəyər"} ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Çox kiçik: gözlənilən ${i.origin} ${c}${i.minimum.toString()} ${u.unit}` : `Çox kiçik: gözlənilən ${i.origin} ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Yanlış mətn: "${c.prefix}" ilə başlamalıdır` : c.format === "ends_with" ? `Yanlış mətn: "${c.suffix}" ilə bitməlidir` : c.format === "includes" ? `Yanlış mətn: "${c.includes}" daxil olmalıdır` : c.format === "regex" ? `Yanlış mətn: ${c.pattern} şablonuna uyğun olmalıdır` : `Yanlış ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Yanlış ədəd: ${i.divisor} ilə bölünə bilən olmalıdır`;
      case "unrecognized_keys":
        return `Tanınmayan açar${i.keys.length > 1 ? "lar" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `${i.origin} daxilində yanlış açar`;
      case "invalid_union":
        return "Yanlış dəyər";
      case "invalid_element":
        return `${i.origin} daxilində yanlış dəyər`;
      default:
        return "Yanlış dəyər";
    }
  };
}, "error$B");
function TB() {
  return {
    localeError: EB()
  };
}
h(TB, "az");
function Nx(n, t, e, s) {
  const i = Math.abs(n), o = i % 10, r = i % 100;
  return r >= 11 && r <= 19 ? s : o === 1 ? t : o >= 2 && o <= 4 ? e : s;
}
h(Nx, "getBelarusianPlural");
const IB = /* @__PURE__ */ h(() => {
  const n = {
    string: {
      unit: {
        one: "сімвал",
        few: "сімвалы",
        many: "сімвалаў"
      },
      verb: "мець"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    file: {
      unit: {
        one: "байт",
        few: "байты",
        many: "байтаў"
      },
      verb: "мець"
    }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "лік";
      case "object": {
        if (Array.isArray(i))
          return "масіў";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "увод",
    email: "email адрас",
    url: "URL",
    emoji: "эмодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата і час",
    date: "ISO дата",
    time: "ISO час",
    duration: "ISO працягласць",
    ipv4: "IPv4 адрас",
    ipv6: "IPv6 адрас",
    cidrv4: "IPv4 дыяпазон",
    cidrv6: "IPv6 дыяпазон",
    base64: "радок у фармаце base64",
    base64url: "радок у фармаце base64url",
    json_string: "JSON радок",
    e164: "нумар E.164",
    jwt: "JWT",
    template_literal: "увод"
  };
  return (i) => {
    var o, r, a;
    switch (i.code) {
      case "invalid_type":
        return `Няправільны ўвод: чакаўся ${i.expected}, атрымана ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Няправільны ўвод: чакалася ${Ee(i.values[0])}` : `Няправільны варыянт: чакаўся адзін з ${Vt(i.values, "|")}`;
      case "too_big": {
        const l = i.inclusive ? "<=" : "<", c = t(i.origin);
        if (c) {
          const u = Number(i.maximum), m = Nx(u, c.unit.one, c.unit.few, c.unit.many);
          return `Занадта вялікі: чакалася, што ${(o = i.origin) != null ? o : "значэнне"} павінна ${c.verb} ${l}${i.maximum.toString()} ${m}`;
        }
        return `Занадта вялікі: чакалася, што ${(r = i.origin) != null ? r : "значэнне"} павінна быць ${l}${i.maximum.toString()}`;
      }
      case "too_small": {
        const l = i.inclusive ? ">=" : ">", c = t(i.origin);
        if (c) {
          const u = Number(i.minimum), m = Nx(u, c.unit.one, c.unit.few, c.unit.many);
          return `Занадта малы: чакалася, што ${i.origin} павінна ${c.verb} ${l}${i.minimum.toString()} ${m}`;
        }
        return `Занадта малы: чакалася, што ${i.origin} павінна быць ${l}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const l = i;
        return l.format === "starts_with" ? `Няправільны радок: павінен пачынацца з "${l.prefix}"` : l.format === "ends_with" ? `Няправільны радок: павінен заканчвацца на "${l.suffix}"` : l.format === "includes" ? `Няправільны радок: павінен змяшчаць "${l.includes}"` : l.format === "regex" ? `Няправільны радок: павінен адпавядаць шаблону ${l.pattern}` : `Няправільны ${(a = s[l.format]) != null ? a : i.format}`;
      }
      case "not_multiple_of":
        return `Няправільны лік: павінен быць кратным ${i.divisor}`;
      case "unrecognized_keys":
        return `Нераспазнаны ${i.keys.length > 1 ? "ключы" : "ключ"}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Няправільны ключ у ${i.origin}`;
      case "invalid_union":
        return "Няправільны ўвод";
      case "invalid_element":
        return `Няправільнае значэнне ў ${i.origin}`;
      default:
        return "Няправільны ўвод";
    }
  };
}, "error$A");
function BB() {
  return {
    localeError: IB()
  };
}
h(BB, "be");
const PB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "caràcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "entrada",
    email: "adreça electrònica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adreça IPv4",
    ipv6: "adreça IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Tipus invàlid: s'esperava ${i.expected}, s'ha rebut ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Valor invàlid: s'esperava ${Ee(i.values[0])}` : `Opció invàlida: s'esperava una de ${Vt(i.values, " o ")}`;
      case "too_big": {
        const c = i.inclusive ? "com a màxim" : "menys de", u = t(i.origin);
        return u ? `Massa gran: s'esperava que ${(o = i.origin) != null ? o : "el valor"} contingués ${c} ${i.maximum.toString()} ${(r = u.unit) != null ? r : "elements"}` : `Massa gran: s'esperava que ${(a = i.origin) != null ? a : "el valor"} fos ${c} ${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? "com a mínim" : "més de", u = t(i.origin);
        return u ? `Massa petit: s'esperava que ${i.origin} contingués ${c} ${i.minimum.toString()} ${u.unit}` : `Massa petit: s'esperava que ${i.origin} fos ${c} ${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Format invàlid: ha de començar amb "${c.prefix}"` : c.format === "ends_with" ? `Format invàlid: ha d'acabar amb "${c.suffix}"` : c.format === "includes" ? `Format invàlid: ha d'incloure "${c.includes}"` : c.format === "regex" ? `Format invàlid: ha de coincidir amb el patró ${c.pattern}` : `Format invàlid per a ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Número invàlid: ha de ser múltiple de ${i.divisor}`;
      case "unrecognized_keys":
        return `Clau${i.keys.length > 1 ? "s" : ""} no reconeguda${i.keys.length > 1 ? "s" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Clau invàlida a ${i.origin}`;
      case "invalid_union":
        return "Entrada invàlida";
      case "invalid_element":
        return `Element invàlid a ${i.origin}`;
      default:
        return "Entrada invàlida";
    }
  };
}, "error$z");
function RB() {
  return {
    localeError: PB()
  };
}
h(RB, "ca");
const DB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "znaků", verb: "mít" },
    file: { unit: "bajtů", verb: "mít" },
    array: { unit: "prvků", verb: "mít" },
    set: { unit: "prvků", verb: "mít" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "číslo";
      case "string":
        return "řetězec";
      case "boolean":
        return "boolean";
      case "bigint":
        return "bigint";
      case "function":
        return "funkce";
      case "symbol":
        return "symbol";
      case "undefined":
        return "undefined";
      case "object": {
        if (Array.isArray(i))
          return "pole";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "regulární výraz",
    email: "e-mailová adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a čas ve formátu ISO",
    date: "datum ve formátu ISO",
    time: "čas ve formátu ISO",
    duration: "doba trvání ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "řetězec zakódovaný ve formátu base64",
    base64url: "řetězec zakódovaný ve formátu base64url",
    json_string: "řetězec ve formátu JSON",
    e164: "číslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (i) => {
    var o, r, a, l, c, u, m;
    switch (i.code) {
      case "invalid_type":
        return `Neplatný vstup: očekáváno ${i.expected}, obdrženo ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Neplatný vstup: očekáváno ${Ee(i.values[0])}` : `Neplatná možnost: očekávána jedna z hodnot ${Vt(i.values, "|")}`;
      case "too_big": {
        const d = i.inclusive ? "<=" : "<", f = t(i.origin);
        return f ? `Hodnota je příliš velká: ${(o = i.origin) != null ? o : "hodnota"} musí mít ${d}${i.maximum.toString()} ${(r = f.unit) != null ? r : "prvků"}` : `Hodnota je příliš velká: ${(a = i.origin) != null ? a : "hodnota"} musí být ${d}${i.maximum.toString()}`;
      }
      case "too_small": {
        const d = i.inclusive ? ">=" : ">", f = t(i.origin);
        return f ? `Hodnota je příliš malá: ${(l = i.origin) != null ? l : "hodnota"} musí mít ${d}${i.minimum.toString()} ${(c = f.unit) != null ? c : "prvků"}` : `Hodnota je příliš malá: ${(u = i.origin) != null ? u : "hodnota"} musí být ${d}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const d = i;
        return d.format === "starts_with" ? `Neplatný řetězec: musí začínat na "${d.prefix}"` : d.format === "ends_with" ? `Neplatný řetězec: musí končit na "${d.suffix}"` : d.format === "includes" ? `Neplatný řetězec: musí obsahovat "${d.includes}"` : d.format === "regex" ? `Neplatný řetězec: musí odpovídat vzoru ${d.pattern}` : `Neplatný formát ${(m = s[d.format]) != null ? m : i.format}`;
      }
      case "not_multiple_of":
        return `Neplatné číslo: musí být násobkem ${i.divisor}`;
      case "unrecognized_keys":
        return `Neznámé klíče: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Neplatný klíč v ${i.origin}`;
      case "invalid_union":
        return "Neplatný vstup";
      case "invalid_element":
        return `Neplatná hodnota v ${i.origin}`;
      default:
        return "Neplatný vstup";
    }
  };
}, "error$y");
function VB() {
  return {
    localeError: DB()
  };
}
h(VB, "cs");
const LB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "Zahl";
      case "object": {
        if (Array.isArray(i))
          return "Array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Ungültige Eingabe: erwartet ${i.expected}, erhalten ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Ungültige Eingabe: erwartet ${Ee(i.values[0])}` : `Ungültige Option: erwartet eine von ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Zu groß: erwartet, dass ${(o = i.origin) != null ? o : "Wert"} ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "Elemente"} hat` : `Zu groß: erwartet, dass ${(a = i.origin) != null ? a : "Wert"} ${c}${i.maximum.toString()} ist`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Zu klein: erwartet, dass ${i.origin} ${c}${i.minimum.toString()} ${u.unit} hat` : `Zu klein: erwartet, dass ${i.origin} ${c}${i.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Ungültiger String: muss mit "${c.prefix}" beginnen` : c.format === "ends_with" ? `Ungültiger String: muss mit "${c.suffix}" enden` : c.format === "includes" ? `Ungültiger String: muss "${c.includes}" enthalten` : c.format === "regex" ? `Ungültiger String: muss dem Muster ${c.pattern} entsprechen` : `Ungültig: ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Ungültige Zahl: muss ein Vielfaches von ${i.divisor} sein`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Ungültiger Schlüssel in ${i.origin}`;
      case "invalid_union":
        return "Ungültige Eingabe";
      case "invalid_element":
        return `Ungültiger Wert in ${i.origin}`;
      default:
        return "Ungültige Eingabe";
    }
  };
}, "error$x");
function NB() {
  return {
    localeError: LB()
  };
}
h(NB, "de");
const zB = /* @__PURE__ */ h((n) => {
  const t = typeof n;
  switch (t) {
    case "number":
      return Number.isNaN(n) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(n))
        return "array";
      if (n === null)
        return "null";
      if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
        return n.constructor.name;
    }
  }
  return t;
}, "parsedType$2"), kB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function t(s) {
    var i;
    return (i = n[s]) != null ? i : null;
  }
  h(t, "getSizing");
  const e = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (s) => {
    var i, o, r, a;
    switch (s.code) {
      case "invalid_type":
        return `Invalid input: expected ${s.expected}, received ${zB(s.input)}`;
      case "invalid_value":
        return s.values.length === 1 ? `Invalid input: expected ${Ee(s.values[0])}` : `Invalid option: expected one of ${Vt(s.values, "|")}`;
      case "too_big": {
        const l = s.inclusive ? "<=" : "<", c = t(s.origin);
        return c ? `Too big: expected ${(i = s.origin) != null ? i : "value"} to have ${l}${s.maximum.toString()} ${(o = c.unit) != null ? o : "elements"}` : `Too big: expected ${(r = s.origin) != null ? r : "value"} to be ${l}${s.maximum.toString()}`;
      }
      case "too_small": {
        const l = s.inclusive ? ">=" : ">", c = t(s.origin);
        return c ? `Too small: expected ${s.origin} to have ${l}${s.minimum.toString()} ${c.unit}` : `Too small: expected ${s.origin} to be ${l}${s.minimum.toString()}`;
      }
      case "invalid_format": {
        const l = s;
        return l.format === "starts_with" ? `Invalid string: must start with "${l.prefix}"` : l.format === "ends_with" ? `Invalid string: must end with "${l.suffix}"` : l.format === "includes" ? `Invalid string: must include "${l.includes}"` : l.format === "regex" ? `Invalid string: must match pattern ${l.pattern}` : `Invalid ${(a = e[l.format]) != null ? a : s.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${s.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${s.keys.length > 1 ? "s" : ""}: ${Vt(s.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${s.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${s.origin}`;
      default:
        return "Invalid input";
    }
  };
}, "error$w");
function tE() {
  return {
    localeError: kB()
  };
}
h(tE, "en");
const UB = /* @__PURE__ */ h((n) => {
  const t = typeof n;
  switch (t) {
    case "number":
      return Number.isNaN(n) ? "NaN" : "nombro";
    case "object": {
      if (Array.isArray(n))
        return "tabelo";
      if (n === null)
        return "senvalora";
      if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
        return n.constructor.name;
    }
  }
  return t;
}, "parsedType$1"), OB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function t(s) {
    var i;
    return (i = n[s]) != null ? i : null;
  }
  h(t, "getSizing");
  const e = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoĝio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daŭro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (s) => {
    var i, o, r, a;
    switch (s.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiĝis ${s.expected}, riceviĝis ${UB(s.input)}`;
      case "invalid_value":
        return s.values.length === 1 ? `Nevalida enigo: atendiĝis ${Ee(s.values[0])}` : `Nevalida opcio: atendiĝis unu el ${Vt(s.values, "|")}`;
      case "too_big": {
        const l = s.inclusive ? "<=" : "<", c = t(s.origin);
        return c ? `Tro granda: atendiĝis ke ${(i = s.origin) != null ? i : "valoro"} havu ${l}${s.maximum.toString()} ${(o = c.unit) != null ? o : "elementojn"}` : `Tro granda: atendiĝis ke ${(r = s.origin) != null ? r : "valoro"} havu ${l}${s.maximum.toString()}`;
      }
      case "too_small": {
        const l = s.inclusive ? ">=" : ">", c = t(s.origin);
        return c ? `Tro malgranda: atendiĝis ke ${s.origin} havu ${l}${s.minimum.toString()} ${c.unit}` : `Tro malgranda: atendiĝis ke ${s.origin} estu ${l}${s.minimum.toString()}`;
      }
      case "invalid_format": {
        const l = s;
        return l.format === "starts_with" ? `Nevalida karaktraro: devas komenciĝi per "${l.prefix}"` : l.format === "ends_with" ? `Nevalida karaktraro: devas finiĝi per "${l.suffix}"` : l.format === "includes" ? `Nevalida karaktraro: devas inkluzivi "${l.includes}"` : l.format === "regex" ? `Nevalida karaktraro: devas kongrui kun la modelo ${l.pattern}` : `Nevalida ${(a = e[l.format]) != null ? a : s.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${s.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${s.keys.length > 1 ? "j" : ""} ŝlosilo${s.keys.length > 1 ? "j" : ""}: ${Vt(s.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida ŝlosilo en ${s.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${s.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
}, "error$v");
function $B() {
  return {
    localeError: OB()
  };
}
h($B, "eo");
const FB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "número";
      case "object": {
        if (Array.isArray(i))
          return "arreglo";
        if (i === null)
          return "nulo";
        if (Object.getPrototypeOf(i) !== Object.prototype)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "entrada",
    email: "dirección de correo electrónico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duración ISO",
    ipv4: "dirección IPv4",
    ipv6: "dirección IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Entrada inválida: se esperaba ${i.expected}, recibido ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Entrada inválida: se esperaba ${Ee(i.values[0])}` : `Opción inválida: se esperaba una de ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Demasiado grande: se esperaba que ${(o = i.origin) != null ? o : "valor"} tuviera ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "elementos"}` : `Demasiado grande: se esperaba que ${(a = i.origin) != null ? a : "valor"} fuera ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Demasiado pequeño: se esperaba que ${i.origin} tuviera ${c}${i.minimum.toString()} ${u.unit}` : `Demasiado pequeño: se esperaba que ${i.origin} fuera ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Cadena inválida: debe comenzar con "${c.prefix}"` : c.format === "ends_with" ? `Cadena inválida: debe terminar en "${c.suffix}"` : c.format === "includes" ? `Cadena inválida: debe incluir "${c.includes}"` : c.format === "regex" ? `Cadena inválida: debe coincidir con el patrón ${c.pattern}` : `Inválido ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Número inválido: debe ser múltiplo de ${i.divisor}`;
      case "unrecognized_keys":
        return `Llave${i.keys.length > 1 ? "s" : ""} desconocida${i.keys.length > 1 ? "s" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Llave inválida en ${i.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido en ${i.origin}`;
      default:
        return "Entrada inválida";
    }
  };
}, "error$u");
function GB() {
  return {
    localeError: FB()
  };
}
h(GB, "es");
const HB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "کاراکتر", verb: "داشته باشد" },
    file: { unit: "بایت", verb: "داشته باشد" },
    array: { unit: "آیتم", verb: "داشته باشد" },
    set: { unit: "آیتم", verb: "داشته باشد" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "عدد";
      case "object": {
        if (Array.isArray(i))
          return "آرایه";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "ورودی",
    email: "آدرس ایمیل",
    url: "URL",
    emoji: "ایموجی",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاریخ و زمان ایزو",
    date: "تاریخ ایزو",
    time: "زمان ایزو",
    duration: "مدت زمان ایزو",
    ipv4: "IPv4 آدرس",
    ipv6: "IPv6 آدرس",
    cidrv4: "IPv4 دامنه",
    cidrv6: "IPv6 دامنه",
    base64: "base64-encoded رشته",
    base64url: "base64url-encoded رشته",
    json_string: "JSON رشته",
    e164: "E.164 عدد",
    jwt: "JWT",
    template_literal: "ورودی"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `ورودی نامعتبر: می‌بایست ${i.expected} می‌بود، ${e(i.input)} دریافت شد`;
      case "invalid_value":
        return i.values.length === 1 ? `ورودی نامعتبر: می‌بایست ${Ee(i.values[0])} می‌بود` : `گزینه نامعتبر: می‌بایست یکی از ${Vt(i.values, "|")} می‌بود`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `خیلی بزرگ: ${(o = i.origin) != null ? o : "مقدار"} باید ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "عنصر"} باشد` : `خیلی بزرگ: ${(a = i.origin) != null ? a : "مقدار"} باید ${c}${i.maximum.toString()} باشد`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `خیلی کوچک: ${i.origin} باید ${c}${i.minimum.toString()} ${u.unit} باشد` : `خیلی کوچک: ${i.origin} باید ${c}${i.minimum.toString()} باشد`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `رشته نامعتبر: باید با "${c.prefix}" شروع شود` : c.format === "ends_with" ? `رشته نامعتبر: باید با "${c.suffix}" تمام شود` : c.format === "includes" ? `رشته نامعتبر: باید شامل "${c.includes}" باشد` : c.format === "regex" ? `رشته نامعتبر: باید با الگوی ${c.pattern} مطابقت داشته باشد` : `${(l = s[c.format]) != null ? l : i.format} نامعتبر`;
      }
      case "not_multiple_of":
        return `عدد نامعتبر: باید مضرب ${i.divisor} باشد`;
      case "unrecognized_keys":
        return `کلید${i.keys.length > 1 ? "های" : ""} ناشناس: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `کلید ناشناس در ${i.origin}`;
      case "invalid_union":
        return "ورودی نامعتبر";
      case "invalid_element":
        return `مقدار نامعتبر در ${i.origin}`;
      default:
        return "ورودی نامعتبر";
    }
  };
}, "error$t");
function jB() {
  return {
    localeError: HB()
  };
}
h(jB, "fa");
const WB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "merkkiä", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "päivämäärän" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "säännöllinen lauseke",
    email: "sähköpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-päivämäärä",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (i) => {
    var o;
    switch (i.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${i.expected}, oli ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Virheellinen syöte: täytyy olla ${Ee(i.values[0])}` : `Virheellinen valinta: täytyy olla yksi seuraavista: ${Vt(i.values, "|")}`;
      case "too_big": {
        const r = i.inclusive ? "<=" : "<", a = t(i.origin);
        return a ? `Liian suuri: ${a.subject} täytyy olla ${r}${i.maximum.toString()} ${a.unit}`.trim() : `Liian suuri: arvon täytyy olla ${r}${i.maximum.toString()}`;
      }
      case "too_small": {
        const r = i.inclusive ? ">=" : ">", a = t(i.origin);
        return a ? `Liian pieni: ${a.subject} täytyy olla ${r}${i.minimum.toString()} ${a.unit}`.trim() : `Liian pieni: arvon täytyy olla ${r}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const r = i;
        return r.format === "starts_with" ? `Virheellinen syöte: täytyy alkaa "${r.prefix}"` : r.format === "ends_with" ? `Virheellinen syöte: täytyy loppua "${r.suffix}"` : r.format === "includes" ? `Virheellinen syöte: täytyy sisältää "${r.includes}"` : r.format === "regex" ? `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${r.pattern}` : `Virheellinen ${(o = s[r.format]) != null ? o : i.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: täytyy olla luvun ${i.divisor} monikerta`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syöte";
    }
  };
}, "error$s");
function qB() {
  return {
    localeError: WB()
  };
}
h(qB, "fi");
const XB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "nombre";
      case "object": {
        if (Array.isArray(i))
          return "tableau";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "entrée",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Entrée invalide : ${i.expected} attendu, ${e(i.input)} reçu`;
      case "invalid_value":
        return i.values.length === 1 ? `Entrée invalide : ${Ee(i.values[0])} attendu` : `Option invalide : une valeur parmi ${Vt(i.values, "|")} attendue`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Trop grand : ${(o = i.origin) != null ? o : "valeur"} doit ${u.verb} ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "élément(s)"}` : `Trop grand : ${(a = i.origin) != null ? a : "valeur"} doit être ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Trop petit : ${i.origin} doit ${u.verb} ${c}${i.minimum.toString()} ${u.unit}` : `Trop petit : ${i.origin} doit être ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Chaîne invalide : doit commencer par "${c.prefix}"` : c.format === "ends_with" ? `Chaîne invalide : doit se terminer par "${c.suffix}"` : c.format === "includes" ? `Chaîne invalide : doit inclure "${c.includes}"` : c.format === "regex" ? `Chaîne invalide : doit correspondre au modèle ${c.pattern}` : `${(l = s[c.format]) != null ? l : i.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${i.divisor}`;
      case "unrecognized_keys":
        return `Clé${i.keys.length > 1 ? "s" : ""} non reconnue${i.keys.length > 1 ? "s" : ""} : ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${i.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${i.origin}`;
      default:
        return "Entrée invalide";
    }
  };
}, "error$r");
function ZB() {
  return {
    localeError: XB()
  };
}
h(ZB, "fr");
const YB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "entrée",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (i) => {
    var o, r, a;
    switch (i.code) {
      case "invalid_type":
        return `Entrée invalide : attendu ${i.expected}, reçu ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Entrée invalide : attendu ${Ee(i.values[0])}` : `Option invalide : attendu l'une des valeurs suivantes ${Vt(i.values, "|")}`;
      case "too_big": {
        const l = i.inclusive ? "≤" : "<", c = t(i.origin);
        return c ? `Trop grand : attendu que ${(o = i.origin) != null ? o : "la valeur"} ait ${l}${i.maximum.toString()} ${c.unit}` : `Trop grand : attendu que ${(r = i.origin) != null ? r : "la valeur"} soit ${l}${i.maximum.toString()}`;
      }
      case "too_small": {
        const l = i.inclusive ? "≥" : ">", c = t(i.origin);
        return c ? `Trop petit : attendu que ${i.origin} ait ${l}${i.minimum.toString()} ${c.unit}` : `Trop petit : attendu que ${i.origin} soit ${l}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const l = i;
        return l.format === "starts_with" ? `Chaîne invalide : doit commencer par "${l.prefix}"` : l.format === "ends_with" ? `Chaîne invalide : doit se terminer par "${l.suffix}"` : l.format === "includes" ? `Chaîne invalide : doit inclure "${l.includes}"` : l.format === "regex" ? `Chaîne invalide : doit correspondre au motif ${l.pattern}` : `${(a = s[l.format]) != null ? a : i.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${i.divisor}`;
      case "unrecognized_keys":
        return `Clé${i.keys.length > 1 ? "s" : ""} non reconnue${i.keys.length > 1 ? "s" : ""} : ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${i.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${i.origin}`;
      default:
        return "Entrée invalide";
    }
  };
}, "error$q");
function JB() {
  return {
    localeError: YB()
  };
}
h(JB, "frCA");
const KB = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "אותיות", verb: "לכלול" },
    file: { unit: "בייטים", verb: "לכלול" },
    array: { unit: "פריטים", verb: "לכלול" },
    set: { unit: "פריטים", verb: "לכלול" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "קלט",
    email: "כתובת אימייל",
    url: "כתובת רשת",
    emoji: "אימוג'י",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "תאריך וזמן ISO",
    date: "תאריך ISO",
    time: "זמן ISO",
    duration: "משך זמן ISO",
    ipv4: "כתובת IPv4",
    ipv6: "כתובת IPv6",
    cidrv4: "טווח IPv4",
    cidrv6: "טווח IPv6",
    base64: "מחרוזת בבסיס 64",
    base64url: "מחרוזת בבסיס 64 לכתובות רשת",
    json_string: "מחרוזת JSON",
    e164: "מספר E.164",
    jwt: "JWT",
    template_literal: "קלט"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `קלט לא תקין: צריך ${i.expected}, התקבל ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `קלט לא תקין: צריך ${Ee(i.values[0])}` : `קלט לא תקין: צריך אחת מהאפשרויות  ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `גדול מדי: ${(o = i.origin) != null ? o : "value"} צריך להיות ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "elements"}` : `גדול מדי: ${(a = i.origin) != null ? a : "value"} צריך להיות ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `קטן מדי: ${i.origin} צריך להיות ${c}${i.minimum.toString()} ${u.unit}` : `קטן מדי: ${i.origin} צריך להיות ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `מחרוזת לא תקינה: חייבת להתחיל ב"${c.prefix}"` : c.format === "ends_with" ? `מחרוזת לא תקינה: חייבת להסתיים ב "${c.suffix}"` : c.format === "includes" ? `מחרוזת לא תקינה: חייבת לכלול "${c.includes}"` : c.format === "regex" ? `מחרוזת לא תקינה: חייבת להתאים לתבנית ${c.pattern}` : `${(l = s[c.format]) != null ? l : i.format} לא תקין`;
      }
      case "not_multiple_of":
        return `מספר לא תקין: חייב להיות מכפלה של ${i.divisor}`;
      case "unrecognized_keys":
        return `מפתח${i.keys.length > 1 ? "ות" : ""} לא מזוה${i.keys.length > 1 ? "ים" : "ה"}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `מפתח לא תקין ב${i.origin}`;
      case "invalid_union":
        return "קלט לא תקין";
      case "invalid_element":
        return `ערך לא תקין ב${i.origin}`;
      default:
        return "קלט לא תקין";
    }
  };
}, "error$p");
function QB() {
  return {
    localeError: KB()
  };
}
h(QB, "he");
const tP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "szám";
      case "object": {
        if (Array.isArray(i))
          return "tömb";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "bemenet",
    email: "email cím",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO időbélyeg",
    date: "ISO dátum",
    time: "ISO idő",
    duration: "ISO időintervallum",
    ipv4: "IPv4 cím",
    ipv6: "IPv6 cím",
    cidrv4: "IPv4 tartomány",
    cidrv6: "IPv6 tartomány",
    base64: "base64-kódolt string",
    base64url: "base64url-kódolt string",
    json_string: "JSON string",
    e164: "E.164 szám",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Érvénytelen bemenet: a várt érték ${i.expected}, a kapott érték ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Érvénytelen bemenet: a várt érték ${Ee(i.values[0])}` : `Érvénytelen opció: valamelyik érték várt ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Túl nagy: ${(o = i.origin) != null ? o : "érték"} mérete túl nagy ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "elem"}` : `Túl nagy: a bemeneti érték ${(a = i.origin) != null ? a : "érték"} túl nagy: ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Túl kicsi: a bemeneti érték ${i.origin} mérete túl kicsi ${c}${i.minimum.toString()} ${u.unit}` : `Túl kicsi: a bemeneti érték ${i.origin} túl kicsi ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Érvénytelen string: "${c.prefix}" értékkel kell kezdődnie` : c.format === "ends_with" ? `Érvénytelen string: "${c.suffix}" értékkel kell végződnie` : c.format === "includes" ? `Érvénytelen string: "${c.includes}" értéket kell tartalmaznia` : c.format === "regex" ? `Érvénytelen string: ${c.pattern} mintának kell megfelelnie` : `Érvénytelen ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Érvénytelen szám: ${i.divisor} többszörösének kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${i.keys.length > 1 ? "s" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Érvénytelen kulcs ${i.origin}`;
      case "invalid_union":
        return "Érvénytelen bemenet";
      case "invalid_element":
        return `Érvénytelen érték: ${i.origin}`;
      default:
        return "Érvénytelen bemenet";
    }
  };
}, "error$o");
function eP() {
  return {
    localeError: tP()
  };
}
h(eP, "hu");
const nP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${i.expected}, diterima ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Input tidak valid: diharapkan ${Ee(i.values[0])}` : `Pilihan tidak valid: diharapkan salah satu dari ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Terlalu besar: diharapkan ${(o = i.origin) != null ? o : "value"} memiliki ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "elemen"}` : `Terlalu besar: diharapkan ${(a = i.origin) != null ? a : "value"} menjadi ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Terlalu kecil: diharapkan ${i.origin} memiliki ${c}${i.minimum.toString()} ${u.unit}` : `Terlalu kecil: diharapkan ${i.origin} menjadi ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `String tidak valid: harus dimulai dengan "${c.prefix}"` : c.format === "ends_with" ? `String tidak valid: harus berakhir dengan "${c.suffix}"` : c.format === "includes" ? `String tidak valid: harus menyertakan "${c.includes}"` : c.format === "regex" ? `String tidak valid: harus sesuai pola ${c.pattern}` : `${(l = s[c.format]) != null ? l : i.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${i.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${i.keys.length > 1 ? "s" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${i.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${i.origin}`;
      default:
        return "Input tidak valid";
    }
  };
}, "error$n");
function iP() {
  return {
    localeError: nP()
  };
}
h(iP, "id");
const sP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "numero";
      case "object": {
        if (Array.isArray(i))
          return "vettore";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Input non valido: atteso ${i.expected}, ricevuto ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Input non valido: atteso ${Ee(i.values[0])}` : `Opzione non valida: atteso uno tra ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Troppo grande: ${(o = i.origin) != null ? o : "valore"} deve avere ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "elementi"}` : `Troppo grande: ${(a = i.origin) != null ? a : "valore"} deve essere ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Troppo piccolo: ${i.origin} deve avere ${c}${i.minimum.toString()} ${u.unit}` : `Troppo piccolo: ${i.origin} deve essere ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Stringa non valida: deve iniziare con "${c.prefix}"` : c.format === "ends_with" ? `Stringa non valida: deve terminare con "${c.suffix}"` : c.format === "includes" ? `Stringa non valida: deve includere "${c.includes}"` : c.format === "regex" ? `Stringa non valida: deve corrispondere al pattern ${c.pattern}` : `Invalid ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${i.divisor}`;
      case "unrecognized_keys":
        return `Chiav${i.keys.length > 1 ? "i" : "e"} non riconosciut${i.keys.length > 1 ? "e" : "a"}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${i.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${i.origin}`;
      default:
        return "Input non valido";
    }
  };
}, "error$m");
function oP() {
  return {
    localeError: sP()
  };
}
h(oP, "it");
const rP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "文字", verb: "である" },
    file: { unit: "バイト", verb: "である" },
    array: { unit: "要素", verb: "である" },
    set: { unit: "要素", verb: "である" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "数値";
      case "object": {
        if (Array.isArray(i))
          return "配列";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "入力値",
    email: "メールアドレス",
    url: "URL",
    emoji: "絵文字",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日時",
    date: "ISO日付",
    time: "ISO時刻",
    duration: "ISO期間",
    ipv4: "IPv4アドレス",
    ipv6: "IPv6アドレス",
    cidrv4: "IPv4範囲",
    cidrv6: "IPv6範囲",
    base64: "base64エンコード文字列",
    base64url: "base64urlエンコード文字列",
    json_string: "JSON文字列",
    e164: "E.164番号",
    jwt: "JWT",
    template_literal: "入力値"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `無効な入力: ${i.expected}が期待されましたが、${e(i.input)}が入力されました`;
      case "invalid_value":
        return i.values.length === 1 ? `無効な入力: ${Ee(i.values[0])}が期待されました` : `無効な選択: ${Vt(i.values, "、")}のいずれかである必要があります`;
      case "too_big": {
        const c = i.inclusive ? "以下である" : "より小さい", u = t(i.origin);
        return u ? `大きすぎる値: ${(o = i.origin) != null ? o : "値"}は${i.maximum.toString()}${(r = u.unit) != null ? r : "要素"}${c}必要があります` : `大きすぎる値: ${(a = i.origin) != null ? a : "値"}は${i.maximum.toString()}${c}必要があります`;
      }
      case "too_small": {
        const c = i.inclusive ? "以上である" : "より大きい", u = t(i.origin);
        return u ? `小さすぎる値: ${i.origin}は${i.minimum.toString()}${u.unit}${c}必要があります` : `小さすぎる値: ${i.origin}は${i.minimum.toString()}${c}必要があります`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `無効な文字列: "${c.prefix}"で始まる必要があります` : c.format === "ends_with" ? `無効な文字列: "${c.suffix}"で終わる必要があります` : c.format === "includes" ? `無効な文字列: "${c.includes}"を含む必要があります` : c.format === "regex" ? `無効な文字列: パターン${c.pattern}に一致する必要があります` : `無効な${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `無効な数値: ${i.divisor}の倍数である必要があります`;
      case "unrecognized_keys":
        return `認識されていないキー${i.keys.length > 1 ? "群" : ""}: ${Vt(i.keys, "、")}`;
      case "invalid_key":
        return `${i.origin}内の無効なキー`;
      case "invalid_union":
        return "無効な入力";
      case "invalid_element":
        return `${i.origin}内の無効な値`;
      default:
        return "無効な入力";
    }
  };
}, "error$l");
function aP() {
  return {
    localeError: rP()
  };
}
h(aP, "ja");
const cP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "តួអក្សរ", verb: "គួរមាន" },
    file: { unit: "បៃ", verb: "គួរមាន" },
    array: { unit: "ធាតុ", verb: "គួរមាន" },
    set: { unit: "ធាតុ", verb: "គួរមាន" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "មិនមែនជាលេខ (NaN)" : "លេខ";
      case "object": {
        if (Array.isArray(i))
          return "អារេ (Array)";
        if (i === null)
          return "គ្មានតម្លៃ (null)";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "ទិន្នន័យបញ្ចូល",
    email: "អាសយដ្ឋានអ៊ីមែល",
    url: "URL",
    emoji: "សញ្ញាអារម្មណ៍",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO",
    date: "កាលបរិច្ឆេទ ISO",
    time: "ម៉ោង ISO",
    duration: "រយៈពេល ISO",
    ipv4: "អាសយដ្ឋាន IPv4",
    ipv6: "អាសយដ្ឋាន IPv6",
    cidrv4: "ដែនអាសយដ្ឋាន IPv4",
    cidrv6: "ដែនអាសយដ្ឋាន IPv6",
    base64: "ខ្សែអក្សរអ៊ិកូដ base64",
    base64url: "ខ្សែអក្សរអ៊ិកូដ base64url",
    json_string: "ខ្សែអក្សរ JSON",
    e164: "លេខ E.164",
    jwt: "JWT",
    template_literal: "ទិន្នន័យបញ្ចូល"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${i.expected} ប៉ុន្តែទទួលបាន ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${Ee(i.values[0])}` : `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `ធំពេក៖ ត្រូវការ ${(o = i.origin) != null ? o : "តម្លៃ"} ${c} ${i.maximum.toString()} ${(r = u.unit) != null ? r : "ធាតុ"}` : `ធំពេក៖ ត្រូវការ ${(a = i.origin) != null ? a : "តម្លៃ"} ${c} ${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `តូចពេក៖ ត្រូវការ ${i.origin} ${c} ${i.minimum.toString()} ${u.unit}` : `តូចពេក៖ ត្រូវការ ${i.origin} ${c} ${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${c.prefix}"` : c.format === "ends_with" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${c.suffix}"` : c.format === "includes" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${c.includes}"` : c.format === "regex" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${c.pattern}` : `មិនត្រឹមត្រូវ៖ ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${i.divisor}`;
      case "unrecognized_keys":
        return `រកឃើញសោមិនស្គាល់៖ ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `សោមិនត្រឹមត្រូវនៅក្នុង ${i.origin}`;
      case "invalid_union":
        return "ទិន្នន័យមិនត្រឹមត្រូវ";
      case "invalid_element":
        return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${i.origin}`;
      default:
        return "ទិន្នន័យមិនត្រឹមត្រូវ";
    }
  };
}, "error$k");
function lP() {
  return {
    localeError: cP()
  };
}
h(lP, "kh");
const uP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "문자", verb: "to have" },
    file: { unit: "바이트", verb: "to have" },
    array: { unit: "개", verb: "to have" },
    set: { unit: "개", verb: "to have" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "입력",
    email: "이메일 주소",
    url: "URL",
    emoji: "이모지",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 날짜시간",
    date: "ISO 날짜",
    time: "ISO 시간",
    duration: "ISO 기간",
    ipv4: "IPv4 주소",
    ipv6: "IPv6 주소",
    cidrv4: "IPv4 범위",
    cidrv6: "IPv6 범위",
    base64: "base64 인코딩 문자열",
    base64url: "base64url 인코딩 문자열",
    json_string: "JSON 문자열",
    e164: "E.164 번호",
    jwt: "JWT",
    template_literal: "입력"
  };
  return (i) => {
    var o, r, a, l, c, u, m;
    switch (i.code) {
      case "invalid_type":
        return `잘못된 입력: 예상 타입은 ${i.expected}, 받은 타입은 ${e(i.input)}입니다`;
      case "invalid_value":
        return i.values.length === 1 ? `잘못된 입력: 값은 ${Ee(i.values[0])} 이어야 합니다` : `잘못된 옵션: ${Vt(i.values, "또는 ")} 중 하나여야 합니다`;
      case "too_big": {
        const d = i.inclusive ? "이하" : "미만", f = d === "미만" ? "이어야 합니다" : "여야 합니다", p = t(i.origin), v = (o = p == null ? void 0 : p.unit) != null ? o : "요소";
        return p ? `${(r = i.origin) != null ? r : "값"}이 너무 큽니다: ${i.maximum.toString()}${v} ${d}${f}` : `${(a = i.origin) != null ? a : "값"}이 너무 큽니다: ${i.maximum.toString()} ${d}${f}`;
      }
      case "too_small": {
        const d = i.inclusive ? "이상" : "초과", f = d === "이상" ? "이어야 합니다" : "여야 합니다", p = t(i.origin), v = (l = p == null ? void 0 : p.unit) != null ? l : "요소";
        return p ? `${(c = i.origin) != null ? c : "값"}이 너무 작습니다: ${i.minimum.toString()}${v} ${d}${f}` : `${(u = i.origin) != null ? u : "값"}이 너무 작습니다: ${i.minimum.toString()} ${d}${f}`;
      }
      case "invalid_format": {
        const d = i;
        return d.format === "starts_with" ? `잘못된 문자열: "${d.prefix}"(으)로 시작해야 합니다` : d.format === "ends_with" ? `잘못된 문자열: "${d.suffix}"(으)로 끝나야 합니다` : d.format === "includes" ? `잘못된 문자열: "${d.includes}"을(를) 포함해야 합니다` : d.format === "regex" ? `잘못된 문자열: 정규식 ${d.pattern} 패턴과 일치해야 합니다` : `잘못된 ${(m = s[d.format]) != null ? m : i.format}`;
      }
      case "not_multiple_of":
        return `잘못된 숫자: ${i.divisor}의 배수여야 합니다`;
      case "unrecognized_keys":
        return `인식할 수 없는 키: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `잘못된 키: ${i.origin}`;
      case "invalid_union":
        return "잘못된 입력";
      case "invalid_element":
        return `잘못된 값: ${i.origin}`;
      default:
        return "잘못된 입력";
    }
  };
}, "error$j");
function hP() {
  return {
    localeError: uP()
  };
}
h(hP, "ko");
const dP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "знаци", verb: "да имаат" },
    file: { unit: "бајти", verb: "да имаат" },
    array: { unit: "ставки", verb: "да имаат" },
    set: { unit: "ставки", verb: "да имаат" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "број";
      case "object": {
        if (Array.isArray(i))
          return "низа";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "внес",
    email: "адреса на е-пошта",
    url: "URL",
    emoji: "емоџи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO датум и време",
    date: "ISO датум",
    time: "ISO време",
    duration: "ISO времетраење",
    ipv4: "IPv4 адреса",
    ipv6: "IPv6 адреса",
    cidrv4: "IPv4 опсег",
    cidrv6: "IPv6 опсег",
    base64: "base64-енкодирана низа",
    base64url: "base64url-енкодирана низа",
    json_string: "JSON низа",
    e164: "E.164 број",
    jwt: "JWT",
    template_literal: "внес"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Грешен внес: се очекува ${i.expected}, примено ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Invalid input: expected ${Ee(i.values[0])}` : `Грешана опција: се очекува една ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Премногу голем: се очекува ${(o = i.origin) != null ? o : "вредноста"} да има ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "елементи"}` : `Премногу голем: се очекува ${(a = i.origin) != null ? a : "вредноста"} да биде ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Премногу мал: се очекува ${i.origin} да има ${c}${i.minimum.toString()} ${u.unit}` : `Премногу мал: се очекува ${i.origin} да биде ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Неважечка низа: мора да започнува со "${c.prefix}"` : c.format === "ends_with" ? `Неважечка низа: мора да завршува со "${c.suffix}"` : c.format === "includes" ? `Неважечка низа: мора да вклучува "${c.includes}"` : c.format === "regex" ? `Неважечка низа: мора да одгоара на патернот ${c.pattern}` : `Invalid ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Грешен број: мора да биде делив со ${i.divisor}`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Грешен клуч во ${i.origin}`;
      case "invalid_union":
        return "Грешен внес";
      case "invalid_element":
        return `Грешна вредност во ${i.origin}`;
      default:
        return "Грешен внес";
    }
  };
}, "error$i");
function mP() {
  return {
    localeError: dP()
  };
}
h(mP, "mk");
const fP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "nombor";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${i.expected}, diterima ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Input tidak sah: dijangka ${Ee(i.values[0])}` : `Pilihan tidak sah: dijangka salah satu daripada ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Terlalu besar: dijangka ${(o = i.origin) != null ? o : "nilai"} ${u.verb} ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "elemen"}` : `Terlalu besar: dijangka ${(a = i.origin) != null ? a : "nilai"} adalah ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Terlalu kecil: dijangka ${i.origin} ${u.verb} ${c}${i.minimum.toString()} ${u.unit}` : `Terlalu kecil: dijangka ${i.origin} adalah ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `String tidak sah: mesti bermula dengan "${c.prefix}"` : c.format === "ends_with" ? `String tidak sah: mesti berakhir dengan "${c.suffix}"` : c.format === "includes" ? `String tidak sah: mesti mengandungi "${c.includes}"` : c.format === "regex" ? `String tidak sah: mesti sepadan dengan corak ${c.pattern}` : `${(l = s[c.format]) != null ? l : i.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${i.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${i.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${i.origin}`;
      default:
        return "Input tidak sah";
    }
  };
}, "error$h");
function pP() {
  return {
    localeError: fP()
  };
}
h(pP, "ms");
const _P = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "getal";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${i.expected}, ontving ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Ongeldige invoer: verwacht ${Ee(i.values[0])}` : `Ongeldige optie: verwacht één van ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Te lang: verwacht dat ${(o = i.origin) != null ? o : "waarde"} ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "elementen"} bevat` : `Te lang: verwacht dat ${(a = i.origin) != null ? a : "waarde"} ${c}${i.maximum.toString()} is`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Te kort: verwacht dat ${i.origin} ${c}${i.minimum.toString()} ${u.unit} bevat` : `Te kort: verwacht dat ${i.origin} ${c}${i.minimum.toString()} is`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Ongeldige tekst: moet met "${c.prefix}" beginnen` : c.format === "ends_with" ? `Ongeldige tekst: moet op "${c.suffix}" eindigen` : c.format === "includes" ? `Ongeldige tekst: moet "${c.includes}" bevatten` : c.format === "regex" ? `Ongeldige tekst: moet overeenkomen met patroon ${c.pattern}` : `Ongeldig: ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${i.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${i.keys.length > 1 ? "s" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${i.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${i.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
}, "error$g");
function gP() {
  return {
    localeError: _P()
  };
}
h(gP, "nl");
const vP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "tegn", verb: "å ha" },
    file: { unit: "bytes", verb: "å ha" },
    array: { unit: "elementer", verb: "å inneholde" },
    set: { unit: "elementer", verb: "å inneholde" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "tall";
      case "object": {
        if (Array.isArray(i))
          return "liste";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${i.expected}, fikk ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Ugyldig verdi: forventet ${Ee(i.values[0])}` : `Ugyldig valg: forventet en av ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `For stor(t): forventet ${(o = i.origin) != null ? o : "value"} til å ha ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "elementer"}` : `For stor(t): forventet ${(a = i.origin) != null ? a : "value"} til å ha ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `For lite(n): forventet ${i.origin} til å ha ${c}${i.minimum.toString()} ${u.unit}` : `For lite(n): forventet ${i.origin} til å ha ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Ugyldig streng: må starte med "${c.prefix}"` : c.format === "ends_with" ? `Ugyldig streng: må ende med "${c.suffix}"` : c.format === "includes" ? `Ugyldig streng: må inneholde "${c.includes}"` : c.format === "regex" ? `Ugyldig streng: må matche mønsteret ${c.pattern}` : `Ugyldig ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: må være et multiplum av ${i.divisor}`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøkkel i ${i.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${i.origin}`;
      default:
        return "Ugyldig input";
    }
  };
}, "error$f");
function bP() {
  return {
    localeError: vP()
  };
}
h(bP, "no");
const yP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "harf", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "unsur", verb: "olmalıdır" },
    set: { unit: "unsur", verb: "olmalıdır" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "numara";
      case "object": {
        if (Array.isArray(i))
          return "saf";
        if (i === null)
          return "gayb";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "giren",
    email: "epostagâh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengâmı",
    date: "ISO tarihi",
    time: "ISO zamanı",
    duration: "ISO müddeti",
    ipv4: "IPv4 nişânı",
    ipv6: "IPv6 nişânı",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-şifreli metin",
    base64url: "base64url-şifreli metin",
    json_string: "JSON metin",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Fâsit giren: umulan ${i.expected}, alınan ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Fâsit giren: umulan ${Ee(i.values[0])}` : `Fâsit tercih: mûteberler ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Fazla büyük: ${(o = i.origin) != null ? o : "value"}, ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "elements"} sahip olmalıydı.` : `Fazla büyük: ${(a = i.origin) != null ? a : "value"}, ${c}${i.maximum.toString()} olmalıydı.`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Fazla küçük: ${i.origin}, ${c}${i.minimum.toString()} ${u.unit} sahip olmalıydı.` : `Fazla küçük: ${i.origin}, ${c}${i.minimum.toString()} olmalıydı.`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Fâsit metin: "${c.prefix}" ile başlamalı.` : c.format === "ends_with" ? `Fâsit metin: "${c.suffix}" ile bitmeli.` : c.format === "includes" ? `Fâsit metin: "${c.includes}" ihtivâ etmeli.` : c.format === "regex" ? `Fâsit metin: ${c.pattern} nakşına uymalı.` : `Fâsit ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Fâsit sayı: ${i.divisor} katı olmalıydı.`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar ${i.keys.length > 1 ? "s" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `${i.origin} için tanınmayan anahtar var.`;
      case "invalid_union":
        return "Giren tanınamadı.";
      case "invalid_element":
        return `${i.origin} için tanınmayan kıymet var.`;
      default:
        return "Kıymet tanınamadı.";
    }
  };
}, "error$e");
function xP() {
  return {
    localeError: yP()
  };
}
h(xP, "ota");
const wP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "توکي", verb: "ولري" },
    file: { unit: "بایټس", verb: "ولري" },
    array: { unit: "توکي", verb: "ولري" },
    set: { unit: "توکي", verb: "ولري" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "عدد";
      case "object": {
        if (Array.isArray(i))
          return "ارې";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "ورودي",
    email: "بریښنالیک",
    url: "یو آر ال",
    emoji: "ایموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "نیټه او وخت",
    date: "نېټه",
    time: "وخت",
    duration: "موده",
    ipv4: "د IPv4 پته",
    ipv6: "د IPv6 پته",
    cidrv4: "د IPv4 ساحه",
    cidrv6: "د IPv6 ساحه",
    base64: "base64-encoded متن",
    base64url: "base64url-encoded متن",
    json_string: "JSON متن",
    e164: "د E.164 شمېره",
    jwt: "JWT",
    template_literal: "ورودي"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `ناسم ورودي: باید ${i.expected} وای, مګر ${e(i.input)} ترلاسه شو`;
      case "invalid_value":
        return i.values.length === 1 ? `ناسم ورودي: باید ${Ee(i.values[0])} وای` : `ناسم انتخاب: باید یو له ${Vt(i.values, "|")} څخه وای`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `ډیر لوی: ${(o = i.origin) != null ? o : "ارزښت"} باید ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "عنصرونه"} ولري` : `ډیر لوی: ${(a = i.origin) != null ? a : "ارزښت"} باید ${c}${i.maximum.toString()} وي`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `ډیر کوچنی: ${i.origin} باید ${c}${i.minimum.toString()} ${u.unit} ولري` : `ډیر کوچنی: ${i.origin} باید ${c}${i.minimum.toString()} وي`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `ناسم متن: باید د "${c.prefix}" سره پیل شي` : c.format === "ends_with" ? `ناسم متن: باید د "${c.suffix}" سره پای ته ورسيږي` : c.format === "includes" ? `ناسم متن: باید "${c.includes}" ولري` : c.format === "regex" ? `ناسم متن: باید د ${c.pattern} سره مطابقت ولري` : `${(l = s[c.format]) != null ? l : i.format} ناسم دی`;
      }
      case "not_multiple_of":
        return `ناسم عدد: باید د ${i.divisor} مضرب وي`;
      case "unrecognized_keys":
        return `ناسم ${i.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `ناسم کلیډ په ${i.origin} کې`;
      case "invalid_union":
        return "ناسمه ورودي";
      case "invalid_element":
        return `ناسم عنصر په ${i.origin} کې`;
      default:
        return "ناسمه ورودي";
    }
  };
}, "error$d");
function SP() {
  return {
    localeError: wP()
  };
}
h(SP, "ps");
const AP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "znaków", verb: "mieć" },
    file: { unit: "bajtów", verb: "mieć" },
    array: { unit: "elementów", verb: "mieć" },
    set: { unit: "elementów", verb: "mieć" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "liczba";
      case "object": {
        if (Array.isArray(i))
          return "tablica";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "wyrażenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ciąg znaków zakodowany w formacie base64",
    base64url: "ciąg znaków zakodowany w formacie base64url",
    json_string: "ciąg znaków w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejście"
  };
  return (i) => {
    var o, r, a, l, c, u, m;
    switch (i.code) {
      case "invalid_type":
        return `Nieprawidłowe dane wejściowe: oczekiwano ${i.expected}, otrzymano ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Nieprawidłowe dane wejściowe: oczekiwano ${Ee(i.values[0])}` : `Nieprawidłowa opcja: oczekiwano jednej z wartości ${Vt(i.values, "|")}`;
      case "too_big": {
        const d = i.inclusive ? "<=" : "<", f = t(i.origin);
        return f ? `Za duża wartość: oczekiwano, że ${(o = i.origin) != null ? o : "wartość"} będzie mieć ${d}${i.maximum.toString()} ${(r = f.unit) != null ? r : "elementów"}` : `Zbyt duż(y/a/e): oczekiwano, że ${(a = i.origin) != null ? a : "wartość"} będzie wynosić ${d}${i.maximum.toString()}`;
      }
      case "too_small": {
        const d = i.inclusive ? ">=" : ">", f = t(i.origin);
        return f ? `Za mała wartość: oczekiwano, że ${(l = i.origin) != null ? l : "wartość"} będzie mieć ${d}${i.minimum.toString()} ${(c = f.unit) != null ? c : "elementów"}` : `Zbyt mał(y/a/e): oczekiwano, że ${(u = i.origin) != null ? u : "wartość"} będzie wynosić ${d}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const d = i;
        return d.format === "starts_with" ? `Nieprawidłowy ciąg znaków: musi zaczynać się od "${d.prefix}"` : d.format === "ends_with" ? `Nieprawidłowy ciąg znaków: musi kończyć się na "${d.suffix}"` : d.format === "includes" ? `Nieprawidłowy ciąg znaków: musi zawierać "${d.includes}"` : d.format === "regex" ? `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${d.pattern}` : `Nieprawidłow(y/a/e) ${(m = s[d.format]) != null ? m : i.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidłowa liczba: musi być wielokrotnością ${i.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${i.keys.length > 1 ? "s" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidłowy klucz w ${i.origin}`;
      case "invalid_union":
        return "Nieprawidłowe dane wejściowe";
      case "invalid_element":
        return `Nieprawidłowa wartość w ${i.origin}`;
      default:
        return "Nieprawidłowe dane wejściowe";
    }
  };
}, "error$c");
function MP() {
  return {
    localeError: AP()
  };
}
h(MP, "pl");
const CP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "número";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "nulo";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "padrão",
    email: "endereço de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "duração ISO",
    ipv4: "endereço IPv4",
    ipv6: "endereço IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Tipo inválido: esperado ${i.expected}, recebido ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Entrada inválida: esperado ${Ee(i.values[0])}` : `Opção inválida: esperada uma das ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Muito grande: esperado que ${(o = i.origin) != null ? o : "valor"} tivesse ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "elementos"}` : `Muito grande: esperado que ${(a = i.origin) != null ? a : "valor"} fosse ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Muito pequeno: esperado que ${i.origin} tivesse ${c}${i.minimum.toString()} ${u.unit}` : `Muito pequeno: esperado que ${i.origin} fosse ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Texto inválido: deve começar com "${c.prefix}"` : c.format === "ends_with" ? `Texto inválido: deve terminar com "${c.suffix}"` : c.format === "includes" ? `Texto inválido: deve incluir "${c.includes}"` : c.format === "regex" ? `Texto inválido: deve corresponder ao padrão ${c.pattern}` : `${(l = s[c.format]) != null ? l : i.format} inválido`;
      }
      case "not_multiple_of":
        return `Número inválido: deve ser múltiplo de ${i.divisor}`;
      case "unrecognized_keys":
        return `Chave${i.keys.length > 1 ? "s" : ""} desconhecida${i.keys.length > 1 ? "s" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Chave inválida em ${i.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido em ${i.origin}`;
      default:
        return "Campo inválido";
    }
  };
}, "error$b");
function EP() {
  return {
    localeError: CP()
  };
}
h(EP, "pt");
function zx(n, t, e, s) {
  const i = Math.abs(n), o = i % 10, r = i % 100;
  return r >= 11 && r <= 19 ? s : o === 1 ? t : o >= 2 && o <= 4 ? e : s;
}
h(zx, "getRussianPlural");
const TP = /* @__PURE__ */ h(() => {
  const n = {
    string: {
      unit: {
        one: "символ",
        few: "символа",
        many: "символов"
      },
      verb: "иметь"
    },
    file: {
      unit: {
        one: "байт",
        few: "байта",
        many: "байт"
      },
      verb: "иметь"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "число";
      case "object": {
        if (Array.isArray(i))
          return "массив";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "ввод",
    email: "email адрес",
    url: "URL",
    emoji: "эмодзи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата и время",
    date: "ISO дата",
    time: "ISO время",
    duration: "ISO длительность",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "строка в формате base64",
    base64url: "строка в формате base64url",
    json_string: "JSON строка",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "ввод"
  };
  return (i) => {
    var o, r, a;
    switch (i.code) {
      case "invalid_type":
        return `Неверный ввод: ожидалось ${i.expected}, получено ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Неверный ввод: ожидалось ${Ee(i.values[0])}` : `Неверный вариант: ожидалось одно из ${Vt(i.values, "|")}`;
      case "too_big": {
        const l = i.inclusive ? "<=" : "<", c = t(i.origin);
        if (c) {
          const u = Number(i.maximum), m = zx(u, c.unit.one, c.unit.few, c.unit.many);
          return `Слишком большое значение: ожидалось, что ${(o = i.origin) != null ? o : "значение"} будет иметь ${l}${i.maximum.toString()} ${m}`;
        }
        return `Слишком большое значение: ожидалось, что ${(r = i.origin) != null ? r : "значение"} будет ${l}${i.maximum.toString()}`;
      }
      case "too_small": {
        const l = i.inclusive ? ">=" : ">", c = t(i.origin);
        if (c) {
          const u = Number(i.minimum), m = zx(u, c.unit.one, c.unit.few, c.unit.many);
          return `Слишком маленькое значение: ожидалось, что ${i.origin} будет иметь ${l}${i.minimum.toString()} ${m}`;
        }
        return `Слишком маленькое значение: ожидалось, что ${i.origin} будет ${l}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const l = i;
        return l.format === "starts_with" ? `Неверная строка: должна начинаться с "${l.prefix}"` : l.format === "ends_with" ? `Неверная строка: должна заканчиваться на "${l.suffix}"` : l.format === "includes" ? `Неверная строка: должна содержать "${l.includes}"` : l.format === "regex" ? `Неверная строка: должна соответствовать шаблону ${l.pattern}` : `Неверный ${(a = s[l.format]) != null ? a : i.format}`;
      }
      case "not_multiple_of":
        return `Неверное число: должно быть кратным ${i.divisor}`;
      case "unrecognized_keys":
        return `Нераспознанн${i.keys.length > 1 ? "ые" : "ый"} ключ${i.keys.length > 1 ? "и" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Неверный ключ в ${i.origin}`;
      case "invalid_union":
        return "Неверные входные данные";
      case "invalid_element":
        return `Неверное значение в ${i.origin}`;
      default:
        return "Неверные входные данные";
    }
  };
}, "error$a");
function IP() {
  return {
    localeError: TP()
  };
}
h(IP, "ru");
const BP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "število";
      case "object": {
        if (Array.isArray(i))
          return "tabela";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "vnos",
    email: "e-poštni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in čas",
    date: "ISO datum",
    time: "ISO čas",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 številka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Neveljaven vnos: pričakovano ${i.expected}, prejeto ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Neveljaven vnos: pričakovano ${Ee(i.values[0])}` : `Neveljavna možnost: pričakovano eno izmed ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Preveliko: pričakovano, da bo ${(o = i.origin) != null ? o : "vrednost"} imelo ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "elementov"}` : `Preveliko: pričakovano, da bo ${(a = i.origin) != null ? a : "vrednost"} ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Premajhno: pričakovano, da bo ${i.origin} imelo ${c}${i.minimum.toString()} ${u.unit}` : `Premajhno: pričakovano, da bo ${i.origin} ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Neveljaven niz: mora se začeti z "${c.prefix}"` : c.format === "ends_with" ? `Neveljaven niz: mora se končati z "${c.suffix}"` : c.format === "includes" ? `Neveljaven niz: mora vsebovati "${c.includes}"` : c.format === "regex" ? `Neveljaven niz: mora ustrezati vzorcu ${c.pattern}` : `Neveljaven ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno število: mora biti večkratnik ${i.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${i.keys.length > 1 ? "i ključi" : " ključ"}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven ključ v ${i.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${i.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
}, "error$9");
function PP() {
  return {
    localeError: BP()
  };
}
h(PP, "sl");
const RP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehålla" },
    set: { unit: "objekt", verb: "att innehålla" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "antal";
      case "object": {
        if (Array.isArray(i))
          return "lista";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "reguljärt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad sträng",
    base64url: "base64url-kodad sträng",
    json_string: "JSON-sträng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (i) => {
    var o, r, a, l, c, u, m, d;
    switch (i.code) {
      case "invalid_type":
        return `Ogiltig inmatning: förväntat ${i.expected}, fick ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Ogiltig inmatning: förväntat ${Ee(i.values[0])}` : `Ogiltigt val: förväntade en av ${Vt(i.values, "|")}`;
      case "too_big": {
        const f = i.inclusive ? "<=" : "<", p = t(i.origin);
        return p ? `För stor(t): förväntade ${(o = i.origin) != null ? o : "värdet"} att ha ${f}${i.maximum.toString()} ${(r = p.unit) != null ? r : "element"}` : `För stor(t): förväntat ${(a = i.origin) != null ? a : "värdet"} att ha ${f}${i.maximum.toString()}`;
      }
      case "too_small": {
        const f = i.inclusive ? ">=" : ">", p = t(i.origin);
        return p ? `För lite(t): förväntade ${(l = i.origin) != null ? l : "värdet"} att ha ${f}${i.minimum.toString()} ${p.unit}` : `För lite(t): förväntade ${(c = i.origin) != null ? c : "värdet"} att ha ${f}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const f = i;
        return f.format === "starts_with" ? `Ogiltig sträng: måste börja med "${f.prefix}"` : f.format === "ends_with" ? `Ogiltig sträng: måste sluta med "${f.suffix}"` : f.format === "includes" ? `Ogiltig sträng: måste innehålla "${f.includes}"` : f.format === "regex" ? `Ogiltig sträng: måste matcha mönstret "${f.pattern}"` : `Ogiltig(t) ${(u = s[f.format]) != null ? u : i.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: måste vara en multipel av ${i.divisor}`;
      case "unrecognized_keys":
        return `${i.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${(m = i.origin) != null ? m : "värdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt värde i ${(d = i.origin) != null ? d : "värdet"}`;
      default:
        return "Ogiltig input";
    }
  };
}, "error$8");
function DP() {
  return {
    localeError: RP()
  };
}
h(DP, "sv");
const VP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" },
    file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" },
    array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
    set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "எண் அல்லாதது" : "எண்";
      case "object": {
        if (Array.isArray(i))
          return "அணி";
        if (i === null)
          return "வெறுமை";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "உள்ளீடு",
    email: "மின்னஞ்சல் முகவரி",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO தேதி நேரம்",
    date: "ISO தேதி",
    time: "ISO நேரம்",
    duration: "ISO கால அளவு",
    ipv4: "IPv4 முகவரி",
    ipv6: "IPv6 முகவரி",
    cidrv4: "IPv4 வரம்பு",
    cidrv6: "IPv6 வரம்பு",
    base64: "base64-encoded சரம்",
    base64url: "base64url-encoded சரம்",
    json_string: "JSON சரம்",
    e164: "E.164 எண்",
    jwt: "JWT",
    template_literal: "input"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${i.expected}, பெறப்பட்டது ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${Ee(i.values[0])}` : `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${Vt(i.values, "|")} இல் ஒன்று`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${(o = i.origin) != null ? o : "மதிப்பு"} ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "உறுப்புகள்"} ஆக இருக்க வேண்டும்` : `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${(a = i.origin) != null ? a : "மதிப்பு"} ${c}${i.maximum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${i.origin} ${c}${i.minimum.toString()} ${u.unit} ஆக இருக்க வேண்டும்` : `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${i.origin} ${c}${i.minimum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `தவறான சரம்: "${c.prefix}" இல் தொடங்க வேண்டும்` : c.format === "ends_with" ? `தவறான சரம்: "${c.suffix}" இல் முடிவடைய வேண்டும்` : c.format === "includes" ? `தவறான சரம்: "${c.includes}" ஐ உள்ளடக்க வேண்டும்` : c.format === "regex" ? `தவறான சரம்: ${c.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்` : `தவறான ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `தவறான எண்: ${i.divisor} இன் பலமாக இருக்க வேண்டும்`;
      case "unrecognized_keys":
        return `அடையாளம் தெரியாத விசை${i.keys.length > 1 ? "கள்" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `${i.origin} இல் தவறான விசை`;
      case "invalid_union":
        return "தவறான உள்ளீடு";
      case "invalid_element":
        return `${i.origin} இல் தவறான மதிப்பு`;
      default:
        return "தவறான உள்ளீடு";
    }
  };
}, "error$7");
function LP() {
  return {
    localeError: VP()
  };
}
h(LP, "ta");
const NP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "ตัวอักษร", verb: "ควรมี" },
    file: { unit: "ไบต์", verb: "ควรมี" },
    array: { unit: "รายการ", verb: "ควรมี" },
    set: { unit: "รายการ", verb: "ควรมี" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข";
      case "object": {
        if (Array.isArray(i))
          return "อาร์เรย์ (Array)";
        if (i === null)
          return "ไม่มีค่า (null)";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "ข้อมูลที่ป้อน",
    email: "ที่อยู่อีเมล",
    url: "URL",
    emoji: "อิโมจิ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "วันที่เวลาแบบ ISO",
    date: "วันที่แบบ ISO",
    time: "เวลาแบบ ISO",
    duration: "ช่วงเวลาแบบ ISO",
    ipv4: "ที่อยู่ IPv4",
    ipv6: "ที่อยู่ IPv6",
    cidrv4: "ช่วง IP แบบ IPv4",
    cidrv6: "ช่วง IP แบบ IPv6",
    base64: "ข้อความแบบ Base64",
    base64url: "ข้อความแบบ Base64 สำหรับ URL",
    json_string: "ข้อความแบบ JSON",
    e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)",
    jwt: "โทเคน JWT",
    template_literal: "ข้อมูลที่ป้อน"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${i.expected} แต่ได้รับ ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `ค่าไม่ถูกต้อง: ควรเป็น ${Ee(i.values[0])}` : `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "ไม่เกิน" : "น้อยกว่า", u = t(i.origin);
        return u ? `เกินกำหนด: ${(o = i.origin) != null ? o : "ค่า"} ควรมี${c} ${i.maximum.toString()} ${(r = u.unit) != null ? r : "รายการ"}` : `เกินกำหนด: ${(a = i.origin) != null ? a : "ค่า"} ควรมี${c} ${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? "อย่างน้อย" : "มากกว่า", u = t(i.origin);
        return u ? `น้อยกว่ากำหนด: ${i.origin} ควรมี${c} ${i.minimum.toString()} ${u.unit}` : `น้อยกว่ากำหนด: ${i.origin} ควรมี${c} ${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${c.prefix}"` : c.format === "ends_with" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${c.suffix}"` : c.format === "includes" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${c.includes}" อยู่ในข้อความ` : c.format === "regex" ? `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${c.pattern}` : `รูปแบบไม่ถูกต้อง: ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${i.divisor} ได้ลงตัว`;
      case "unrecognized_keys":
        return `พบคีย์ที่ไม่รู้จัก: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `คีย์ไม่ถูกต้องใน ${i.origin}`;
      case "invalid_union":
        return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้";
      case "invalid_element":
        return `ข้อมูลไม่ถูกต้องใน ${i.origin}`;
      default:
        return "ข้อมูลไม่ถูกต้อง";
    }
  };
}, "error$6");
function zP() {
  return {
    localeError: NP()
  };
}
h(zP, "th");
const kP = /* @__PURE__ */ h((n) => {
  const t = typeof n;
  switch (t) {
    case "number":
      return Number.isNaN(n) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(n))
        return "array";
      if (n === null)
        return "null";
      if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
        return n.constructor.name;
    }
  }
  return t;
}, "parsedType"), UP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "karakter", verb: "olmalı" },
    file: { unit: "bayt", verb: "olmalı" },
    array: { unit: "öğe", verb: "olmalı" },
    set: { unit: "öğe", verb: "olmalı" }
  };
  function t(s) {
    var i;
    return (i = n[s]) != null ? i : null;
  }
  h(t, "getSizing");
  const e = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO süre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aralığı",
    cidrv6: "IPv6 aralığı",
    base64: "base64 ile şifrelenmiş metin",
    base64url: "base64url ile şifrelenmiş metin",
    json_string: "JSON dizesi",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "Şablon dizesi"
  };
  return (s) => {
    var i, o, r, a;
    switch (s.code) {
      case "invalid_type":
        return `Geçersiz değer: beklenen ${s.expected}, alınan ${kP(s.input)}`;
      case "invalid_value":
        return s.values.length === 1 ? `Geçersiz değer: beklenen ${Ee(s.values[0])}` : `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${Vt(s.values, "|")}`;
      case "too_big": {
        const l = s.inclusive ? "<=" : "<", c = t(s.origin);
        return c ? `Çok büyük: beklenen ${(i = s.origin) != null ? i : "değer"} ${l}${s.maximum.toString()} ${(o = c.unit) != null ? o : "öğe"}` : `Çok büyük: beklenen ${(r = s.origin) != null ? r : "değer"} ${l}${s.maximum.toString()}`;
      }
      case "too_small": {
        const l = s.inclusive ? ">=" : ">", c = t(s.origin);
        return c ? `Çok küçük: beklenen ${s.origin} ${l}${s.minimum.toString()} ${c.unit}` : `Çok küçük: beklenen ${s.origin} ${l}${s.minimum.toString()}`;
      }
      case "invalid_format": {
        const l = s;
        return l.format === "starts_with" ? `Geçersiz metin: "${l.prefix}" ile başlamalı` : l.format === "ends_with" ? `Geçersiz metin: "${l.suffix}" ile bitmeli` : l.format === "includes" ? `Geçersiz metin: "${l.includes}" içermeli` : l.format === "regex" ? `Geçersiz metin: ${l.pattern} desenine uymalı` : `Geçersiz ${(a = e[l.format]) != null ? a : s.format}`;
      }
      case "not_multiple_of":
        return `Geçersiz sayı: ${s.divisor} ile tam bölünebilmeli`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar${s.keys.length > 1 ? "lar" : ""}: ${Vt(s.keys, ", ")}`;
      case "invalid_key":
        return `${s.origin} içinde geçersiz anahtar`;
      case "invalid_union":
        return "Geçersiz değer";
      case "invalid_element":
        return `${s.origin} içinde geçersiz değer`;
      default:
        return "Geçersiz değer";
    }
  };
}, "error$5");
function OP() {
  return {
    localeError: UP()
  };
}
h(OP, "tr");
const $P = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "символів", verb: "матиме" },
    file: { unit: "байтів", verb: "матиме" },
    array: { unit: "елементів", verb: "матиме" },
    set: { unit: "елементів", verb: "матиме" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "число";
      case "object": {
        if (Array.isArray(i))
          return "масив";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "вхідні дані",
    email: "адреса електронної пошти",
    url: "URL",
    emoji: "емодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "дата та час ISO",
    date: "дата ISO",
    time: "час ISO",
    duration: "тривалість ISO",
    ipv4: "адреса IPv4",
    ipv6: "адреса IPv6",
    cidrv4: "діапазон IPv4",
    cidrv6: "діапазон IPv6",
    base64: "рядок у кодуванні base64",
    base64url: "рядок у кодуванні base64url",
    json_string: "рядок JSON",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "вхідні дані"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Неправильні вхідні дані: очікується ${i.expected}, отримано ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Неправильні вхідні дані: очікується ${Ee(i.values[0])}` : `Неправильна опція: очікується одне з ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Занадто велике: очікується, що ${(o = i.origin) != null ? o : "значення"} ${u.verb} ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "елементів"}` : `Занадто велике: очікується, що ${(a = i.origin) != null ? a : "значення"} буде ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Занадто мале: очікується, що ${i.origin} ${u.verb} ${c}${i.minimum.toString()} ${u.unit}` : `Занадто мале: очікується, що ${i.origin} буде ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Неправильний рядок: повинен починатися з "${c.prefix}"` : c.format === "ends_with" ? `Неправильний рядок: повинен закінчуватися на "${c.suffix}"` : c.format === "includes" ? `Неправильний рядок: повинен містити "${c.includes}"` : c.format === "regex" ? `Неправильний рядок: повинен відповідати шаблону ${c.pattern}` : `Неправильний ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `Неправильне число: повинно бути кратним ${i.divisor}`;
      case "unrecognized_keys":
        return `Нерозпізнаний ключ${i.keys.length > 1 ? "і" : ""}: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Неправильний ключ у ${i.origin}`;
      case "invalid_union":
        return "Неправильні вхідні дані";
      case "invalid_element":
        return `Неправильне значення у ${i.origin}`;
      default:
        return "Неправильні вхідні дані";
    }
  };
}, "error$4");
function FP() {
  return {
    localeError: $P()
  };
}
h(FP, "ua");
const GP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "حروف", verb: "ہونا" },
    file: { unit: "بائٹس", verb: "ہونا" },
    array: { unit: "آئٹمز", verb: "ہونا" },
    set: { unit: "آئٹمز", verb: "ہونا" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "نمبر";
      case "object": {
        if (Array.isArray(i))
          return "آرے";
        if (i === null)
          return "نل";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "ان پٹ",
    email: "ای میل ایڈریس",
    url: "یو آر ایل",
    emoji: "ایموجی",
    uuid: "یو یو آئی ڈی",
    uuidv4: "یو یو آئی ڈی وی 4",
    uuidv6: "یو یو آئی ڈی وی 6",
    nanoid: "نینو آئی ڈی",
    guid: "جی یو آئی ڈی",
    cuid: "سی یو آئی ڈی",
    cuid2: "سی یو آئی ڈی 2",
    ulid: "یو ایل آئی ڈی",
    xid: "ایکس آئی ڈی",
    ksuid: "کے ایس یو آئی ڈی",
    datetime: "آئی ایس او ڈیٹ ٹائم",
    date: "آئی ایس او تاریخ",
    time: "آئی ایس او وقت",
    duration: "آئی ایس او مدت",
    ipv4: "آئی پی وی 4 ایڈریس",
    ipv6: "آئی پی وی 6 ایڈریس",
    cidrv4: "آئی پی وی 4 رینج",
    cidrv6: "آئی پی وی 6 رینج",
    base64: "بیس 64 ان کوڈڈ سٹرنگ",
    base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ",
    json_string: "جے ایس او این سٹرنگ",
    e164: "ای 164 نمبر",
    jwt: "جے ڈبلیو ٹی",
    template_literal: "ان پٹ"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `غلط ان پٹ: ${i.expected} متوقع تھا، ${e(i.input)} موصول ہوا`;
      case "invalid_value":
        return i.values.length === 1 ? `غلط ان پٹ: ${Ee(i.values[0])} متوقع تھا` : `غلط آپشن: ${Vt(i.values, "|")} میں سے ایک متوقع تھا`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `بہت بڑا: ${(o = i.origin) != null ? o : "ویلیو"} کے ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "عناصر"} ہونے متوقع تھے` : `بہت بڑا: ${(a = i.origin) != null ? a : "ویلیو"} کا ${c}${i.maximum.toString()} ہونا متوقع تھا`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `بہت چھوٹا: ${i.origin} کے ${c}${i.minimum.toString()} ${u.unit} ہونے متوقع تھے` : `بہت چھوٹا: ${i.origin} کا ${c}${i.minimum.toString()} ہونا متوقع تھا`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `غلط سٹرنگ: "${c.prefix}" سے شروع ہونا چاہیے` : c.format === "ends_with" ? `غلط سٹرنگ: "${c.suffix}" پر ختم ہونا چاہیے` : c.format === "includes" ? `غلط سٹرنگ: "${c.includes}" شامل ہونا چاہیے` : c.format === "regex" ? `غلط سٹرنگ: پیٹرن ${c.pattern} سے میچ ہونا چاہیے` : `غلط ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `غلط نمبر: ${i.divisor} کا مضاعف ہونا چاہیے`;
      case "unrecognized_keys":
        return `غیر تسلیم شدہ کی${i.keys.length > 1 ? "ز" : ""}: ${Vt(i.keys, "، ")}`;
      case "invalid_key":
        return `${i.origin} میں غلط کی`;
      case "invalid_union":
        return "غلط ان پٹ";
      case "invalid_element":
        return `${i.origin} میں غلط ویلیو`;
      default:
        return "غلط ان پٹ";
    }
  };
}, "error$3");
function HP() {
  return {
    localeError: GP()
  };
}
h(HP, "ur");
const jP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "ký tự", verb: "có" },
    file: { unit: "byte", verb: "có" },
    array: { unit: "phần tử", verb: "có" },
    set: { unit: "phần tử", verb: "có" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "số";
      case "object": {
        if (Array.isArray(i))
          return "mảng";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "đầu vào",
    email: "địa chỉ email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngày giờ ISO",
    date: "ngày ISO",
    time: "giờ ISO",
    duration: "khoảng thời gian ISO",
    ipv4: "địa chỉ IPv4",
    ipv6: "địa chỉ IPv6",
    cidrv4: "dải IPv4",
    cidrv6: "dải IPv6",
    base64: "chuỗi mã hóa base64",
    base64url: "chuỗi mã hóa base64url",
    json_string: "chuỗi JSON",
    e164: "số E.164",
    jwt: "JWT",
    template_literal: "đầu vào"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `Đầu vào không hợp lệ: mong đợi ${i.expected}, nhận được ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Đầu vào không hợp lệ: mong đợi ${Ee(i.values[0])}` : `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `Quá lớn: mong đợi ${(o = i.origin) != null ? o : "giá trị"} ${u.verb} ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "phần tử"}` : `Quá lớn: mong đợi ${(a = i.origin) != null ? a : "giá trị"} ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `Quá nhỏ: mong đợi ${i.origin} ${u.verb} ${c}${i.minimum.toString()} ${u.unit}` : `Quá nhỏ: mong đợi ${i.origin} ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `Chuỗi không hợp lệ: phải bắt đầu bằng "${c.prefix}"` : c.format === "ends_with" ? `Chuỗi không hợp lệ: phải kết thúc bằng "${c.suffix}"` : c.format === "includes" ? `Chuỗi không hợp lệ: phải bao gồm "${c.includes}"` : c.format === "regex" ? `Chuỗi không hợp lệ: phải khớp với mẫu ${c.pattern}` : `${(l = s[c.format]) != null ? l : i.format} không hợp lệ`;
      }
      case "not_multiple_of":
        return `Số không hợp lệ: phải là bội số của ${i.divisor}`;
      case "unrecognized_keys":
        return `Khóa không được nhận dạng: ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `Khóa không hợp lệ trong ${i.origin}`;
      case "invalid_union":
        return "Đầu vào không hợp lệ";
      case "invalid_element":
        return `Giá trị không hợp lệ trong ${i.origin}`;
      default:
        return "Đầu vào không hợp lệ";
    }
  };
}, "error$2");
function WP() {
  return {
    localeError: jP()
  };
}
h(WP, "vi");
const qP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "字符", verb: "包含" },
    file: { unit: "字节", verb: "包含" },
    array: { unit: "项", verb: "包含" },
    set: { unit: "项", verb: "包含" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "非数字(NaN)" : "数字";
      case "object": {
        if (Array.isArray(i))
          return "数组";
        if (i === null)
          return "空值(null)";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "输入",
    email: "电子邮件",
    url: "URL",
    emoji: "表情符号",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日期时间",
    date: "ISO日期",
    time: "ISO时间",
    duration: "ISO时长",
    ipv4: "IPv4地址",
    ipv6: "IPv6地址",
    cidrv4: "IPv4网段",
    cidrv6: "IPv6网段",
    base64: "base64编码字符串",
    base64url: "base64url编码字符串",
    json_string: "JSON字符串",
    e164: "E.164号码",
    jwt: "JWT",
    template_literal: "输入"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `无效输入：期望 ${i.expected}，实际接收 ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `无效输入：期望 ${Ee(i.values[0])}` : `无效选项：期望以下之一 ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `数值过大：期望 ${(o = i.origin) != null ? o : "值"} ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "个元素"}` : `数值过大：期望 ${(a = i.origin) != null ? a : "值"} ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `数值过小：期望 ${i.origin} ${c}${i.minimum.toString()} ${u.unit}` : `数值过小：期望 ${i.origin} ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `无效字符串：必须以 "${c.prefix}" 开头` : c.format === "ends_with" ? `无效字符串：必须以 "${c.suffix}" 结尾` : c.format === "includes" ? `无效字符串：必须包含 "${c.includes}"` : c.format === "regex" ? `无效字符串：必须满足正则表达式 ${c.pattern}` : `无效${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `无效数字：必须是 ${i.divisor} 的倍数`;
      case "unrecognized_keys":
        return `出现未知的键(key): ${Vt(i.keys, ", ")}`;
      case "invalid_key":
        return `${i.origin} 中的键(key)无效`;
      case "invalid_union":
        return "无效输入";
      case "invalid_element":
        return `${i.origin} 中包含无效值(value)`;
      default:
        return "无效输入";
    }
  };
}, "error$1");
function XP() {
  return {
    localeError: qP()
  };
}
h(XP, "zhCN");
const ZP = /* @__PURE__ */ h(() => {
  const n = {
    string: { unit: "字元", verb: "擁有" },
    file: { unit: "位元組", verb: "擁有" },
    array: { unit: "項目", verb: "擁有" },
    set: { unit: "項目", verb: "擁有" }
  };
  function t(i) {
    var o;
    return (o = n[i]) != null ? o : null;
  }
  h(t, "getSizing");
  const e = /* @__PURE__ */ h((i) => {
    const o = typeof i;
    switch (o) {
      case "number":
        return Number.isNaN(i) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(i))
          return "array";
        if (i === null)
          return "null";
        if (Object.getPrototypeOf(i) !== Object.prototype && i.constructor)
          return i.constructor.name;
      }
    }
    return o;
  }, "parsedType"), s = {
    regex: "輸入",
    email: "郵件地址",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 日期時間",
    date: "ISO 日期",
    time: "ISO 時間",
    duration: "ISO 期間",
    ipv4: "IPv4 位址",
    ipv6: "IPv6 位址",
    cidrv4: "IPv4 範圍",
    cidrv6: "IPv6 範圍",
    base64: "base64 編碼字串",
    base64url: "base64url 編碼字串",
    json_string: "JSON 字串",
    e164: "E.164 數值",
    jwt: "JWT",
    template_literal: "輸入"
  };
  return (i) => {
    var o, r, a, l;
    switch (i.code) {
      case "invalid_type":
        return `無效的輸入值：預期為 ${i.expected}，但收到 ${e(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `無效的輸入值：預期為 ${Ee(i.values[0])}` : `無效的選項：預期為以下其中之一 ${Vt(i.values, "|")}`;
      case "too_big": {
        const c = i.inclusive ? "<=" : "<", u = t(i.origin);
        return u ? `數值過大：預期 ${(o = i.origin) != null ? o : "值"} 應為 ${c}${i.maximum.toString()} ${(r = u.unit) != null ? r : "個元素"}` : `數值過大：預期 ${(a = i.origin) != null ? a : "值"} 應為 ${c}${i.maximum.toString()}`;
      }
      case "too_small": {
        const c = i.inclusive ? ">=" : ">", u = t(i.origin);
        return u ? `數值過小：預期 ${i.origin} 應為 ${c}${i.minimum.toString()} ${u.unit}` : `數值過小：預期 ${i.origin} 應為 ${c}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const c = i;
        return c.format === "starts_with" ? `無效的字串：必須以 "${c.prefix}" 開頭` : c.format === "ends_with" ? `無效的字串：必須以 "${c.suffix}" 結尾` : c.format === "includes" ? `無效的字串：必須包含 "${c.includes}"` : c.format === "regex" ? `無效的字串：必須符合格式 ${c.pattern}` : `無效的 ${(l = s[c.format]) != null ? l : i.format}`;
      }
      case "not_multiple_of":
        return `無效的數字：必須為 ${i.divisor} 的倍數`;
      case "unrecognized_keys":
        return `無法識別的鍵值${i.keys.length > 1 ? "們" : ""}：${Vt(i.keys, "、")}`;
      case "invalid_key":
        return `${i.origin} 中有無效的鍵值`;
      case "invalid_union":
        return "無效的輸入值";
      case "invalid_element":
        return `${i.origin} 中有無效的值`;
      default:
        return "無效的輸入值";
    }
  };
}, "error");
function YP() {
  return {
    localeError: ZP()
  };
}
h(YP, "zhTW");
const eE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ar: CB,
  az: TB,
  be: BB,
  ca: RB,
  cs: VB,
  de: NB,
  en: tE,
  eo: $B,
  es: GB,
  fa: jB,
  fi: qB,
  fr: ZB,
  frCA: JB,
  he: QB,
  hu: eP,
  id: iP,
  it: oP,
  ja: aP,
  kh: lP,
  ko: hP,
  mk: mP,
  ms: pP,
  nl: gP,
  no: bP,
  ota: xP,
  pl: MP,
  ps: SP,
  pt: EP,
  ru: IP,
  sl: PP,
  sv: DP,
  ta: LP,
  th: zP,
  tr: OP,
  ua: FP,
  ur: HP,
  vi: WP,
  zhCN: XP,
  zhTW: YP
}, Symbol.toStringTag, { value: "Module" })), nE = Symbol("ZodOutput"), iE = Symbol("ZodInput"), eb = class eb {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...e) {
    const s = e[0];
    if (this._map.set(t, s), s && typeof s == "object" && "id" in s) {
      if (this._idmap.has(s.id))
        throw new Error(`ID ${s.id} already exists in the registry`);
      this._idmap.set(s.id, t);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const e = this._map.get(t);
    return e && typeof e == "object" && "id" in e && this._idmap.delete(e.id), this._map.delete(t), this;
  }
  get(t) {
    var s;
    const e = t._zod.parent;
    if (e) {
      const i = { ...(s = this.get(e)) != null ? s : {} };
      return delete i.id, { ...i, ...this._map.get(t) };
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
};
h(eb, "$ZodRegistry");
let Zl = eb;
function ov() {
  return new Zl();
}
h(ov, "registry");
const ea = ov();
function sE(n, t) {
  return new n({
    type: "string",
    ...pt(t)
  });
}
h(sE, "_string");
function oE(n, t) {
  return new n({
    type: "string",
    coerce: !0,
    ...pt(t)
  });
}
h(oE, "_coercedString");
function rv(n, t) {
  return new n({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(rv, "_email");
function Fh(n, t) {
  return new n({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(Fh, "_guid");
function av(n, t) {
  return new n({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(av, "_uuid");
function cv(n, t) {
  return new n({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...pt(t)
  });
}
h(cv, "_uuidv4");
function lv(n, t) {
  return new n({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...pt(t)
  });
}
h(lv, "_uuidv6");
function uv(n, t) {
  return new n({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...pt(t)
  });
}
h(uv, "_uuidv7");
function hv(n, t) {
  return new n({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(hv, "_url");
function dv(n, t) {
  return new n({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(dv, "_emoji");
function mv(n, t) {
  return new n({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(mv, "_nanoid");
function fv(n, t) {
  return new n({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(fv, "_cuid");
function pv(n, t) {
  return new n({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(pv, "_cuid2");
function _v(n, t) {
  return new n({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(_v, "_ulid");
function gv(n, t) {
  return new n({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(gv, "_xid");
function vv(n, t) {
  return new n({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(vv, "_ksuid");
function bv(n, t) {
  return new n({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(bv, "_ipv4");
function yv(n, t) {
  return new n({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(yv, "_ipv6");
function xv(n, t) {
  return new n({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(xv, "_cidrv4");
function wv(n, t) {
  return new n({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(wv, "_cidrv6");
function Sv(n, t) {
  return new n({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(Sv, "_base64");
function Av(n, t) {
  return new n({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(Av, "_base64url");
function Mv(n, t) {
  return new n({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(Mv, "_e164");
function Cv(n, t) {
  return new n({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...pt(t)
  });
}
h(Cv, "_jwt");
const rE = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function aE(n, t) {
  return new n({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...pt(t)
  });
}
h(aE, "_isoDateTime");
function cE(n, t) {
  return new n({
    type: "string",
    format: "date",
    check: "string_format",
    ...pt(t)
  });
}
h(cE, "_isoDate");
function lE(n, t) {
  return new n({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...pt(t)
  });
}
h(lE, "_isoTime");
function uE(n, t) {
  return new n({
    type: "string",
    format: "duration",
    check: "string_format",
    ...pt(t)
  });
}
h(uE, "_isoDuration");
function hE(n, t) {
  return new n({
    type: "number",
    checks: [],
    ...pt(t)
  });
}
h(hE, "_number");
function dE(n, t) {
  return new n({
    type: "number",
    coerce: !0,
    checks: [],
    ...pt(t)
  });
}
h(dE, "_coercedNumber");
function mE(n, t) {
  return new n({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...pt(t)
  });
}
h(mE, "_int");
function fE(n, t) {
  return new n({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float32",
    ...pt(t)
  });
}
h(fE, "_float32");
function pE(n, t) {
  return new n({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float64",
    ...pt(t)
  });
}
h(pE, "_float64");
function _E(n, t) {
  return new n({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "int32",
    ...pt(t)
  });
}
h(_E, "_int32");
function gE(n, t) {
  return new n({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "uint32",
    ...pt(t)
  });
}
h(gE, "_uint32");
function vE(n, t) {
  return new n({
    type: "boolean",
    ...pt(t)
  });
}
h(vE, "_boolean");
function bE(n, t) {
  return new n({
    type: "boolean",
    coerce: !0,
    ...pt(t)
  });
}
h(bE, "_coercedBoolean");
function yE(n, t) {
  return new n({
    type: "bigint",
    ...pt(t)
  });
}
h(yE, "_bigint");
function xE(n, t) {
  return new n({
    type: "bigint",
    coerce: !0,
    ...pt(t)
  });
}
h(xE, "_coercedBigint");
function wE(n, t) {
  return new n({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "int64",
    ...pt(t)
  });
}
h(wE, "_int64");
function SE(n, t) {
  return new n({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "uint64",
    ...pt(t)
  });
}
h(SE, "_uint64");
function AE(n, t) {
  return new n({
    type: "symbol",
    ...pt(t)
  });
}
h(AE, "_symbol");
function ME(n, t) {
  return new n({
    type: "undefined",
    ...pt(t)
  });
}
h(ME, "_undefined$1");
function CE(n, t) {
  return new n({
    type: "null",
    ...pt(t)
  });
}
h(CE, "_null$1");
function EE(n) {
  return new n({
    type: "any"
  });
}
h(EE, "_any");
function Gh(n) {
  return new n({
    type: "unknown"
  });
}
h(Gh, "_unknown");
function TE(n, t) {
  return new n({
    type: "never",
    ...pt(t)
  });
}
h(TE, "_never");
function IE(n, t) {
  return new n({
    type: "void",
    ...pt(t)
  });
}
h(IE, "_void$1");
function BE(n, t) {
  return new n({
    type: "date",
    ...pt(t)
  });
}
h(BE, "_date");
function PE(n, t) {
  return new n({
    type: "date",
    coerce: !0,
    ...pt(t)
  });
}
h(PE, "_coercedDate");
function RE(n, t) {
  return new n({
    type: "nan",
    ...pt(t)
  });
}
h(RE, "_nan");
function fa(n, t) {
  return new Xg({
    check: "less_than",
    ...pt(t),
    value: n,
    inclusive: !1
  });
}
h(fa, "_lt");
function Cs(n, t) {
  return new Xg({
    check: "less_than",
    ...pt(t),
    value: n,
    inclusive: !0
  });
}
h(Cs, "_lte");
function pa(n, t) {
  return new Zg({
    check: "greater_than",
    ...pt(t),
    value: n,
    inclusive: !1
  });
}
h(pa, "_gt");
function ji(n, t) {
  return new Zg({
    check: "greater_than",
    ...pt(t),
    value: n,
    inclusive: !0
  });
}
h(ji, "_gte");
function DE(n) {
  return pa(0, n);
}
h(DE, "_positive");
function VE(n) {
  return fa(0, n);
}
h(VE, "_negative");
function LE(n) {
  return Cs(0, n);
}
h(LE, "_nonpositive");
function NE(n) {
  return ji(0, n);
}
h(NE, "_nonnegative");
function Yl(n, t) {
  return new DM({
    check: "multiple_of",
    ...pt(t),
    value: n
  });
}
h(Yl, "_multipleOf");
function Em(n, t) {
  return new NM({
    check: "max_size",
    ...pt(t),
    maximum: n
  });
}
h(Em, "_maxSize");
function Jl(n, t) {
  return new zM({
    check: "min_size",
    ...pt(t),
    minimum: n
  });
}
h(Jl, "_minSize");
function Ev(n, t) {
  return new kM({
    check: "size_equals",
    ...pt(t),
    size: n
  });
}
h(Ev, "_size");
function Tm(n, t) {
  return new UM({
    check: "max_length",
    ...pt(t),
    maximum: n
  });
}
h(Tm, "_maxLength");
function Dc(n, t) {
  return new OM({
    check: "min_length",
    ...pt(t),
    minimum: n
  });
}
h(Dc, "_minLength");
function Im(n, t) {
  return new Yg({
    check: "length_equals",
    ...pt(t),
    length: n
  });
}
h(Im, "_length");
function Tv(n, t) {
  return new $M({
    check: "string_format",
    format: "regex",
    ...pt(t),
    pattern: n
  });
}
h(Tv, "_regex");
function Iv(n) {
  return new FM({
    check: "string_format",
    format: "lowercase",
    ...pt(n)
  });
}
h(Iv, "_lowercase");
function Bv(n) {
  return new GM({
    check: "string_format",
    format: "uppercase",
    ...pt(n)
  });
}
h(Bv, "_uppercase");
function Pv(n, t) {
  return new HM({
    check: "string_format",
    format: "includes",
    ...pt(t),
    includes: n
  });
}
h(Pv, "_includes");
function Rv(n, t) {
  return new jM({
    check: "string_format",
    format: "starts_with",
    ...pt(t),
    prefix: n
  });
}
h(Rv, "_startsWith");
function Dv(n, t) {
  return new WM({
    check: "string_format",
    format: "ends_with",
    ...pt(t),
    suffix: n
  });
}
h(Dv, "_endsWith");
function zE(n, t, e) {
  return new qM({
    check: "property",
    property: n,
    schema: t,
    ...pt(e)
  });
}
h(zE, "_property");
function Vv(n, t) {
  return new XM({
    check: "mime_type",
    mime: n,
    ...pt(t)
  });
}
h(Vv, "_mime");
function La(n) {
  return new ZM({
    check: "overwrite",
    tx: n
  });
}
h(La, "_overwrite");
function Lv(n) {
  return La((t) => t.normalize(n));
}
h(Lv, "_normalize");
function Nv() {
  return La((n) => n.trim());
}
h(Nv, "_trim");
function zv() {
  return La((n) => n.toLowerCase());
}
h(zv, "_toLowerCase");
function kv() {
  return La((n) => n.toUpperCase());
}
h(kv, "_toUpperCase");
function Uv(n, t, e) {
  return new n({
    type: "array",
    element: t,
    ...pt(e)
  });
}
h(Uv, "_array");
function JP(n, t, e) {
  return new n({
    type: "union",
    options: t,
    ...pt(e)
  });
}
h(JP, "_union");
function KP(n, t, e, s) {
  return new n({
    type: "union",
    options: e,
    discriminator: t,
    ...pt(s)
  });
}
h(KP, "_discriminatedUnion");
function QP(n, t, e) {
  return new n({
    type: "intersection",
    left: t,
    right: e
  });
}
h(QP, "_intersection");
function kE(n, t, e, s) {
  const i = e instanceof ve, o = i ? s : e, r = i ? e : null;
  return new n({
    type: "tuple",
    items: t,
    rest: r,
    ...pt(o)
  });
}
h(kE, "_tuple");
function tR(n, t, e, s) {
  return new n({
    type: "record",
    keyType: t,
    valueType: e,
    ...pt(s)
  });
}
h(tR, "_record");
function eR(n, t, e, s) {
  return new n({
    type: "map",
    keyType: t,
    valueType: e,
    ...pt(s)
  });
}
h(eR, "_map");
function nR(n, t, e) {
  return new n({
    type: "set",
    valueType: t,
    ...pt(e)
  });
}
h(nR, "_set");
function iR(n, t, e) {
  const s = Array.isArray(t) ? Object.fromEntries(t.map((i) => [i, i])) : t;
  return new n({
    type: "enum",
    entries: s,
    ...pt(e)
  });
}
h(iR, "_enum$1");
function sR(n, t, e) {
  return new n({
    type: "enum",
    entries: t,
    ...pt(e)
  });
}
h(sR, "_nativeEnum");
function oR(n, t, e) {
  return new n({
    type: "literal",
    values: Array.isArray(t) ? t : [t],
    ...pt(e)
  });
}
h(oR, "_literal");
function UE(n, t) {
  return new n({
    type: "file",
    ...pt(t)
  });
}
h(UE, "_file");
function rR(n, t) {
  return new n({
    type: "transform",
    transform: t
  });
}
h(rR, "_transform");
function aR(n, t) {
  return new n({
    type: "optional",
    innerType: t
  });
}
h(aR, "_optional");
function cR(n, t) {
  return new n({
    type: "nullable",
    innerType: t
  });
}
h(cR, "_nullable");
function lR(n, t, e) {
  return new n({
    type: "default",
    innerType: t,
    get defaultValue() {
      return typeof e == "function" ? e() : e;
    }
  });
}
h(lR, "_default$1");
function uR(n, t, e) {
  return new n({
    type: "nonoptional",
    innerType: t,
    ...pt(e)
  });
}
h(uR, "_nonoptional");
function hR(n, t) {
  return new n({
    type: "success",
    innerType: t
  });
}
h(hR, "_success");
function dR(n, t, e) {
  return new n({
    type: "catch",
    innerType: t,
    catchValue: typeof e == "function" ? e : () => e
  });
}
h(dR, "_catch$1");
function mR(n, t, e) {
  return new n({
    type: "pipe",
    in: t,
    out: e
  });
}
h(mR, "_pipe");
function fR(n, t) {
  return new n({
    type: "readonly",
    innerType: t
  });
}
h(fR, "_readonly");
function pR(n, t, e) {
  return new n({
    type: "template_literal",
    parts: t,
    ...pt(e)
  });
}
h(pR, "_templateLiteral");
function _R(n, t) {
  return new n({
    type: "lazy",
    getter: t
  });
}
h(_R, "_lazy");
function gR(n, t) {
  return new n({
    type: "promise",
    innerType: t
  });
}
h(gR, "_promise");
function OE(n, t, e) {
  var o;
  const s = pt(e);
  return (o = s.abort) != null || (s.abort = !0), new n({
    type: "custom",
    check: "custom",
    fn: t,
    ...s
  });
}
h(OE, "_custom");
function $E(n, t, e) {
  return new n({
    type: "custom",
    check: "custom",
    fn: t,
    ...pt(e)
  });
}
h($E, "_refine");
function FE(n, t) {
  var p, v, _, g, w, S;
  const e = pt(t);
  let s = (p = e.truthy) != null ? p : ["true", "1", "yes", "on", "y", "enabled"], i = (v = e.falsy) != null ? v : ["false", "0", "no", "off", "n", "disabled"];
  e.case !== "sensitive" && (s = s.map((x) => typeof x == "string" ? x.toLowerCase() : x), i = i.map((x) => typeof x == "string" ? x.toLowerCase() : x));
  const o = new Set(s), r = new Set(i), a = (_ = n.Pipe) != null ? _ : sv, l = (g = n.Boolean) != null ? g : Qg, c = (w = n.String) != null ? w : Ru, u = (S = n.Transform) != null ? S : iv, m = new u({
    type: "transform",
    transform: /* @__PURE__ */ h((x, A) => {
      let C = x;
      return e.case !== "sensitive" && (C = C.toLowerCase()), o.has(C) ? !0 : r.has(C) ? !1 : (A.issues.push({
        code: "invalid_value",
        expected: "stringbool",
        values: [...o, ...r],
        input: A.value,
        inst: m
      }), {});
    }, "transform"),
    error: e.error
  }), d = new a({
    type: "pipe",
    in: new c({ type: "string", error: e.error }),
    out: m,
    error: e.error
  });
  return new a({
    type: "pipe",
    in: d,
    out: new l({
      type: "boolean",
      error: e.error
    }),
    error: e.error
  });
}
h(FE, "_stringbool");
function GE(n, t, e, s = {}) {
  const i = pt(s), o = {
    ...pt(s),
    check: "string_format",
    type: "string",
    format: t,
    fn: typeof e == "function" ? e : (a) => e.test(a),
    ...i
  };
  return e instanceof RegExp && (o.pattern = e), new n(o);
}
h(GE, "_stringFormat");
const nb = class nb {
  constructor(t) {
    this._def = t, this.def = t;
  }
  implement(t) {
    if (typeof t != "function")
      throw new Error("implement() must be called with a function");
    const e = /* @__PURE__ */ h((...s) => {
      const i = this._def.input ? vp(this._def.input, s, void 0, { callee: e }) : s;
      if (!Array.isArray(i))
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      const o = t(...i);
      return this._def.output ? vp(this._def.output, o, void 0, { callee: e }) : o;
    }, "impl");
    return e;
  }
  implementAsync(t) {
    if (typeof t != "function")
      throw new Error("implement() must be called with a function");
    const e = /* @__PURE__ */ h(async (...s) => {
      const i = this._def.input ? await bp(this._def.input, s, void 0, { callee: e }) : s;
      if (!Array.isArray(i))
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      const o = await t(...i);
      return this._def.output ? bp(this._def.output, o, void 0, { callee: e }) : o;
    }, "impl");
    return e;
  }
  input(...t) {
    const e = this.constructor;
    return Array.isArray(t[0]) ? new e({
      type: "function",
      input: new Cm({
        type: "tuple",
        items: t[0],
        rest: t[1]
      }),
      output: this._def.output
    }) : new e({
      type: "function",
      input: t[0],
      output: this._def.output
    });
  }
  output(t) {
    const e = this.constructor;
    return new e({
      type: "function",
      input: this._def.input,
      output: t
    });
  }
};
h(nb, "$ZodFunction");
let Hh = nb;
function HE(n) {
  var t, e;
  return new Hh({
    type: "function",
    input: Array.isArray(n == null ? void 0 : n.input) ? kE(Cm, n == null ? void 0 : n.input) : (t = n == null ? void 0 : n.input) != null ? t : Uv(ev, Gh($h)),
    output: (e = n == null ? void 0 : n.output) != null ? e : Gh($h)
  });
}
h(HE, "_function");
const ib = class ib {
  constructor(t) {
    var e, s, i, o, r;
    this.counter = 0, this.metadataRegistry = (e = t == null ? void 0 : t.metadata) != null ? e : ea, this.target = (s = t == null ? void 0 : t.target) != null ? s : "draft-2020-12", this.unrepresentable = (i = t == null ? void 0 : t.unrepresentable) != null ? i : "throw", this.override = (o = t == null ? void 0 : t.override) != null ? o : () => {
    }, this.io = (r = t == null ? void 0 : t.io) != null ? r : "output", this.seen = /* @__PURE__ */ new Map();
  }
  process(t, e = { path: [], schemaPath: [] }) {
    var m, d, f, p, v;
    var s;
    const i = t._zod.def, o = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    }, r = this.seen.get(t);
    if (r)
      return r.count++, e.schemaPath.includes(t) && (r.cycle = e.path), r.schema;
    const a = { schema: {}, count: 1, cycle: void 0, path: e.path };
    this.seen.set(t, a);
    const l = (d = (m = t._zod).toJSONSchema) == null ? void 0 : d.call(m);
    if (l)
      a.schema = l;
    else {
      const _ = {
        ...e,
        schemaPath: [...e.schemaPath, t],
        path: e.path
      }, g = t._zod.parent;
      if (g)
        a.ref = g, this.process(g, _), this.seen.get(g).isParent = !0;
      else {
        const w = a.schema;
        switch (i.type) {
          case "string": {
            const S = w;
            S.type = "string";
            const { minimum: x, maximum: A, format: C, patterns: M, contentEncoding: T } = t._zod.bag;
            if (typeof x == "number" && (S.minLength = x), typeof A == "number" && (S.maxLength = A), C && (S.format = (f = o[C]) != null ? f : C, S.format === "" && delete S.format), T && (S.contentEncoding = T), M && M.size > 0) {
              const b = [...M];
              b.length === 1 ? S.pattern = b[0].source : b.length > 1 && (a.schema.allOf = [
                ...b.map((y) => ({
                  ...this.target === "draft-7" ? { type: "string" } : {},
                  pattern: y.source
                }))
              ]);
            }
            break;
          }
          case "number": {
            const S = w, { minimum: x, maximum: A, format: C, multipleOf: M, exclusiveMaximum: T, exclusiveMinimum: b } = t._zod.bag;
            typeof C == "string" && C.includes("int") ? S.type = "integer" : S.type = "number", typeof b == "number" && (S.exclusiveMinimum = b), typeof x == "number" && (S.minimum = x, typeof b == "number" && (b >= x ? delete S.minimum : delete S.exclusiveMinimum)), typeof T == "number" && (S.exclusiveMaximum = T), typeof A == "number" && (S.maximum = A, typeof T == "number" && (T <= A ? delete S.maximum : delete S.exclusiveMaximum)), typeof M == "number" && (S.multipleOf = M);
            break;
          }
          case "boolean": {
            const S = w;
            S.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw")
              throw new Error("BigInt cannot be represented in JSON Schema");
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw")
              throw new Error("Symbols cannot be represented in JSON Schema");
            break;
          }
          case "null": {
            w.type = "null";
            break;
          }
          case "any":
            break;
          case "unknown":
            break;
          case "undefined": {
            if (this.unrepresentable === "throw")
              throw new Error("Undefined cannot be represented in JSON Schema");
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw")
              throw new Error("Void cannot be represented in JSON Schema");
            break;
          }
          case "never": {
            w.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw")
              throw new Error("Date cannot be represented in JSON Schema");
            break;
          }
          case "array": {
            const S = w, { minimum: x, maximum: A } = t._zod.bag;
            typeof x == "number" && (S.minItems = x), typeof A == "number" && (S.maxItems = A), S.type = "array", S.items = this.process(i.element, { ..._, path: [..._.path, "items"] });
            break;
          }
          case "object": {
            const S = w;
            S.type = "object", S.properties = {};
            const x = i.shape;
            for (const M in x)
              S.properties[M] = this.process(x[M], {
                ..._,
                path: [..._.path, "properties", M]
              });
            const A = new Set(Object.keys(x)), C = new Set([...A].filter((M) => {
              const T = i.shape[M]._zod;
              return this.io === "input" ? T.optin === void 0 : T.optout === void 0;
            }));
            C.size > 0 && (S.required = Array.from(C)), ((p = i.catchall) == null ? void 0 : p._zod.def.type) === "never" ? S.additionalProperties = !1 : i.catchall ? i.catchall && (S.additionalProperties = this.process(i.catchall, {
              ..._,
              path: [..._.path, "additionalProperties"]
            })) : this.io === "output" && (S.additionalProperties = !1);
            break;
          }
          case "union": {
            const S = w;
            S.anyOf = i.options.map((x, A) => this.process(x, {
              ..._,
              path: [..._.path, "anyOf", A]
            }));
            break;
          }
          case "intersection": {
            const S = w, x = this.process(i.left, {
              ..._,
              path: [..._.path, "allOf", 0]
            }), A = this.process(i.right, {
              ..._,
              path: [..._.path, "allOf", 1]
            }), C = /* @__PURE__ */ h((T) => "allOf" in T && Object.keys(T).length === 1, "isSimpleIntersection"), M = [
              ...C(x) ? x.allOf : [x],
              ...C(A) ? A.allOf : [A]
            ];
            S.allOf = M;
            break;
          }
          case "tuple": {
            const S = w;
            S.type = "array";
            const x = i.items.map((M, T) => this.process(M, { ..._, path: [..._.path, "prefixItems", T] }));
            if (this.target === "draft-2020-12" ? S.prefixItems = x : S.items = x, i.rest) {
              const M = this.process(i.rest, {
                ..._,
                path: [..._.path, "items"]
              });
              this.target === "draft-2020-12" ? S.items = M : S.additionalItems = M;
            }
            i.rest && (S.items = this.process(i.rest, {
              ..._,
              path: [..._.path, "items"]
            }));
            const { minimum: A, maximum: C } = t._zod.bag;
            typeof A == "number" && (S.minItems = A), typeof C == "number" && (S.maxItems = C);
            break;
          }
          case "record": {
            const S = w;
            S.type = "object", S.propertyNames = this.process(i.keyType, { ..._, path: [..._.path, "propertyNames"] }), S.additionalProperties = this.process(i.valueType, {
              ..._,
              path: [..._.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw")
              throw new Error("Map cannot be represented in JSON Schema");
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw")
              throw new Error("Set cannot be represented in JSON Schema");
            break;
          }
          case "enum": {
            const S = w, x = kg(i.entries);
            x.every((A) => typeof A == "number") && (S.type = "number"), x.every((A) => typeof A == "string") && (S.type = "string"), S.enum = x;
            break;
          }
          case "literal": {
            const S = w, x = [];
            for (const A of i.values)
              if (A === void 0) {
                if (this.unrepresentable === "throw")
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
              } else if (typeof A == "bigint") {
                if (this.unrepresentable === "throw")
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                x.push(Number(A));
              } else
                x.push(A);
            if (x.length !== 0) if (x.length === 1) {
              const A = x[0];
              S.type = A === null ? "null" : typeof A, S.const = A;
            } else
              x.every((A) => typeof A == "number") && (S.type = "number"), x.every((A) => typeof A == "string") && (S.type = "string"), x.every((A) => typeof A == "boolean") && (S.type = "string"), x.every((A) => A === null) && (S.type = "null"), S.enum = x;
            break;
          }
          case "file": {
            const S = w, x = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            }, { minimum: A, maximum: C, mime: M } = t._zod.bag;
            A !== void 0 && (x.minLength = A), C !== void 0 && (x.maxLength = C), M ? M.length === 1 ? (x.contentMediaType = M[0], Object.assign(S, x)) : S.anyOf = M.map((T) => ({ ...x, contentMediaType: T })) : Object.assign(S, x);
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw")
              throw new Error("Transforms cannot be represented in JSON Schema");
            break;
          }
          case "nullable": {
            const S = this.process(i.innerType, _);
            w.anyOf = [S, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(i.innerType, _), a.ref = i.innerType;
            break;
          }
          case "success": {
            const S = w;
            S.type = "boolean";
            break;
          }
          case "default": {
            this.process(i.innerType, _), a.ref = i.innerType, w.default = JSON.parse(JSON.stringify(i.defaultValue));
            break;
          }
          case "prefault": {
            this.process(i.innerType, _), a.ref = i.innerType, this.io === "input" && (w._prefault = JSON.parse(JSON.stringify(i.defaultValue)));
            break;
          }
          case "catch": {
            this.process(i.innerType, _), a.ref = i.innerType;
            let S;
            try {
              S = i.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            w.default = S;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw")
              throw new Error("NaN cannot be represented in JSON Schema");
            break;
          }
          case "template_literal": {
            const S = w, x = t._zod.pattern;
            if (!x)
              throw new Error("Pattern not found in template literal");
            S.type = "string", S.pattern = x.source;
            break;
          }
          case "pipe": {
            const S = this.io === "input" ? i.in._zod.def.type === "transform" ? i.out : i.in : i.out;
            this.process(S, _), a.ref = S;
            break;
          }
          case "readonly": {
            this.process(i.innerType, _), a.ref = i.innerType, w.readOnly = !0;
            break;
          }
          case "promise": {
            this.process(i.innerType, _), a.ref = i.innerType;
            break;
          }
          case "optional": {
            this.process(i.innerType, _), a.ref = i.innerType;
            break;
          }
          case "lazy": {
            const S = t._zod.innerType;
            this.process(S, _), a.ref = S;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw")
              throw new Error("Custom types cannot be represented in JSON Schema");
            break;
          }
        }
      }
    }
    const c = this.metadataRegistry.get(t);
    return c && Object.assign(a.schema, c), this.io === "input" && Wn(t) && (delete a.schema.examples, delete a.schema.default), this.io === "input" && a.schema._prefault && ((v = (s = a.schema).default) != null || (s.default = a.schema._prefault)), delete a.schema._prefault, this.seen.get(t).schema;
  }
  emit(t, e) {
    var u, m, d, f, p, v, _, g, w, S;
    const s = {
      cycles: (u = e == null ? void 0 : e.cycles) != null ? u : "ref",
      reused: (m = e == null ? void 0 : e.reused) != null ? m : "inline",
      external: (d = e == null ? void 0 : e.external) != null ? d : void 0
    }, i = this.seen.get(t);
    if (!i)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const o = /* @__PURE__ */ h((x) => {
      var b, y, E, I, B;
      const A = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (s.external) {
        const D = (b = s.external.registry.get(x[0])) == null ? void 0 : b.id, N = (y = s.external.uri) != null ? y : (G) => G;
        if (D)
          return { ref: N(D) };
        const V = (I = (E = x[1].defId) != null ? E : x[1].schema.id) != null ? I : `schema${this.counter++}`;
        return x[1].defId = V, { defId: V, ref: `${N("__shared")}#/${A}/${V}` };
      }
      if (x[1] === i)
        return { ref: "#" };
      const M = `#/${A}/`, T = (B = x[1].schema.id) != null ? B : `__schema${this.counter++}`;
      return { defId: T, ref: M + T };
    }, "makeURI"), r = /* @__PURE__ */ h((x) => {
      if (x[1].schema.$ref)
        return;
      const A = x[1], { ref: C, defId: M } = o(x);
      A.def = { ...A.schema }, M && (A.defId = M);
      const T = A.schema;
      for (const b in T)
        delete T[b];
      T.$ref = C;
    }, "extractToDef");
    if (s.cycles === "throw")
      for (const x of this.seen.entries()) {
        const A = x[1];
        if (A.cycle)
          throw new Error(`Cycle detected: #/${(f = A.cycle) == null ? void 0 : f.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    for (const x of this.seen.entries()) {
      const A = x[1];
      if (t === x[0]) {
        r(x);
        continue;
      }
      if (s.external) {
        const M = (p = s.external.registry.get(x[0])) == null ? void 0 : p.id;
        if (t !== x[0] && M) {
          r(x);
          continue;
        }
      }
      if ((v = this.metadataRegistry.get(x[0])) == null ? void 0 : v.id) {
        r(x);
        continue;
      }
      if (A.cycle) {
        r(x);
        continue;
      }
      if (A.count > 1 && s.reused === "ref") {
        r(x);
        continue;
      }
    }
    const a = /* @__PURE__ */ h((x, A) => {
      var y, E, I;
      const C = this.seen.get(x), M = (y = C.def) != null ? y : C.schema, T = { ...M };
      if (C.ref === null)
        return;
      const b = C.ref;
      if (C.ref = null, b) {
        a(b, A);
        const B = this.seen.get(b).schema;
        B.$ref && A.target === "draft-7" ? (M.allOf = (E = M.allOf) != null ? E : [], M.allOf.push(B)) : (Object.assign(M, B), Object.assign(M, T));
      }
      C.isParent || this.override({
        zodSchema: x,
        jsonSchema: M,
        path: (I = C.path) != null ? I : []
      });
    }, "flattenRef");
    for (const x of [...this.seen.entries()].reverse())
      a(x[0], { target: this.target });
    const l = {};
    if (this.target === "draft-2020-12" ? l.$schema = "https://json-schema.org/draft/2020-12/schema" : this.target === "draft-7" ? l.$schema = "http://json-schema.org/draft-07/schema#" : console.warn(`Invalid target: ${this.target}`), (_ = s.external) != null && _.uri) {
      const x = (g = s.external.registry.get(t)) == null ? void 0 : g.id;
      if (!x)
        throw new Error("Schema is missing an `id` property");
      l.$id = s.external.uri(x);
    }
    Object.assign(l, i.def);
    const c = (S = (w = s.external) == null ? void 0 : w.defs) != null ? S : {};
    for (const x of this.seen.entries()) {
      const A = x[1];
      A.def && A.defId && (c[A.defId] = A.def);
    }
    s.external || Object.keys(c).length > 0 && (this.target === "draft-2020-12" ? l.$defs = c : l.definitions = c);
    try {
      return JSON.parse(JSON.stringify(l));
    } catch {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
h(ib, "JSONSchemaGenerator");
let Kl = ib;
function jE(n, t) {
  if (n instanceof Zl) {
    const s = new Kl(t), i = {};
    for (const a of n._idmap.entries()) {
      const [l, c] = a;
      s.process(c);
    }
    const o = {}, r = {
      registry: n,
      uri: t == null ? void 0 : t.uri,
      defs: i
    };
    for (const a of n._idmap.entries()) {
      const [l, c] = a;
      o[l] = s.emit(c, {
        ...t,
        external: r
      });
    }
    if (Object.keys(i).length > 0) {
      const a = s.target === "draft-2020-12" ? "$defs" : "definitions";
      o.__shared = {
        [a]: i
      };
    }
    return { schemas: o };
  }
  const e = new Kl(t);
  return e.process(n), e.emit(n, t);
}
h(jE, "toJSONSchema");
function Wn(n, t) {
  const e = t != null ? t : { seen: /* @__PURE__ */ new Set() };
  if (e.seen.has(n))
    return !1;
  e.seen.add(n);
  const i = n._zod.def;
  switch (i.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return !1;
    case "array":
      return Wn(i.element, e);
    case "object": {
      for (const o in i.shape)
        if (Wn(i.shape[o], e))
          return !0;
      return !1;
    }
    case "union": {
      for (const o of i.options)
        if (Wn(o, e))
          return !0;
      return !1;
    }
    case "intersection":
      return Wn(i.left, e) || Wn(i.right, e);
    case "tuple": {
      for (const o of i.items)
        if (Wn(o, e))
          return !0;
      return !!(i.rest && Wn(i.rest, e));
    }
    case "record":
      return Wn(i.keyType, e) || Wn(i.valueType, e);
    case "map":
      return Wn(i.keyType, e) || Wn(i.valueType, e);
    case "set":
      return Wn(i.valueType, e);
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return Wn(i.innerType, e);
    case "lazy":
      return Wn(i.getter(), e);
    case "default":
      return Wn(i.innerType, e);
    case "prefault":
      return Wn(i.innerType, e);
    case "custom":
      return !1;
    case "transform":
      return !0;
    case "pipe":
      return Wn(i.in, e) || Wn(i.out, e);
    case "success":
      return !1;
    case "catch":
      return !1;
  }
  throw new Error(`Unknown schema type: ${i.type}`);
}
h(Wn, "isTransforming");
const vR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), bR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $ZodAny: TC,
  $ZodArray: ev,
  $ZodAsyncError: _r,
  $ZodBase64: _C,
  $ZodBase64URL: vC,
  $ZodBigInt: tv,
  $ZodBigIntFormat: AC,
  $ZodBoolean: Qg,
  $ZodCIDRv4: fC,
  $ZodCIDRv6: pC,
  $ZodCUID: iC,
  $ZodCUID2: sC,
  $ZodCatch: qC,
  $ZodCheck: kn,
  $ZodCheckBigIntFormat: LM,
  $ZodCheckEndsWith: WM,
  $ZodCheckGreaterThan: Zg,
  $ZodCheckIncludes: HM,
  $ZodCheckLengthEquals: Yg,
  $ZodCheckLessThan: Xg,
  $ZodCheckLowerCase: FM,
  $ZodCheckMaxLength: UM,
  $ZodCheckMaxSize: NM,
  $ZodCheckMimeType: XM,
  $ZodCheckMinLength: OM,
  $ZodCheckMinSize: zM,
  $ZodCheckMultipleOf: DM,
  $ZodCheckNumberFormat: VM,
  $ZodCheckOverwrite: ZM,
  $ZodCheckProperty: qM,
  $ZodCheckRegex: $M,
  $ZodCheckSizeEquals: kM,
  $ZodCheckStartsWith: jM,
  $ZodCheckStringFormat: Pu,
  $ZodCheckUpperCase: GM,
  $ZodCustom: QC,
  $ZodCustomStringFormat: wC,
  $ZodDate: PC,
  $ZodDefault: GC,
  $ZodDiscriminatedUnion: DC,
  $ZodE164: bC,
  $ZodEmail: QM,
  $ZodEmoji: eC,
  $ZodEnum: kC,
  $ZodError: Og,
  $ZodFile: OC,
  $ZodFunction: Hh,
  $ZodGUID: JM,
  $ZodIPv4: dC,
  $ZodIPv6: mC,
  $ZodISODate: lC,
  $ZodISODateTime: cC,
  $ZodISODuration: hC,
  $ZodISOTime: uC,
  $ZodIntersection: VC,
  $ZodJWT: xC,
  $ZodKSUID: aC,
  $ZodLazy: KC,
  $ZodLiteral: UC,
  $ZodMap: NC,
  $ZodNaN: XC,
  $ZodNanoID: nC,
  $ZodNever: IC,
  $ZodNonOptional: jC,
  $ZodNull: EC,
  $ZodNullable: FC,
  $ZodNumber: Kg,
  $ZodNumberFormat: SC,
  $ZodObject: RC,
  $ZodOptional: $C,
  $ZodPipe: sv,
  $ZodPrefault: HC,
  $ZodPromise: JC,
  $ZodReadonly: ZC,
  $ZodRealError: Bu,
  $ZodRecord: LC,
  $ZodRegistry: Zl,
  $ZodSet: zC,
  $ZodString: Ru,
  $ZodStringFormat: Sn,
  $ZodSuccess: WC,
  $ZodSymbol: MC,
  $ZodTemplateLiteral: YC,
  $ZodTransform: iv,
  $ZodTuple: Cm,
  $ZodType: ve,
  $ZodULID: oC,
  $ZodURL: tC,
  $ZodUUID: KM,
  $ZodUndefined: CC,
  $ZodUnion: nv,
  $ZodUnknown: $h,
  $ZodVoid: BC,
  $ZodXID: rC,
  $brand: DA,
  $constructor: Z,
  $input: iE,
  $output: nE,
  Doc: Oh,
  JSONSchema: vR,
  JSONSchemaGenerator: Kl,
  NEVER: RA,
  TimePrecision: rE,
  _any: EE,
  _array: Uv,
  _base64: Sv,
  _base64url: Av,
  _bigint: yE,
  _boolean: vE,
  _catch: dR,
  _cidrv4: xv,
  _cidrv6: wv,
  _coercedBigint: xE,
  _coercedBoolean: bE,
  _coercedDate: PE,
  _coercedNumber: dE,
  _coercedString: oE,
  _cuid: fv,
  _cuid2: pv,
  _custom: OE,
  _date: BE,
  _default: lR,
  _discriminatedUnion: KP,
  _e164: Mv,
  _email: rv,
  _emoji: dv,
  _endsWith: Dv,
  _enum: iR,
  _file: UE,
  _float32: fE,
  _float64: pE,
  _gt: pa,
  _gte: ji,
  _guid: Fh,
  _includes: Pv,
  _int: mE,
  _int32: _E,
  _int64: wE,
  _intersection: QP,
  _ipv4: bv,
  _ipv6: yv,
  _isoDate: cE,
  _isoDateTime: aE,
  _isoDuration: uE,
  _isoTime: lE,
  _jwt: Cv,
  _ksuid: vv,
  _lazy: _R,
  _length: Im,
  _literal: oR,
  _lowercase: Iv,
  _lt: fa,
  _lte: Cs,
  _map: eR,
  _max: Cs,
  _maxLength: Tm,
  _maxSize: Em,
  _mime: Vv,
  _min: ji,
  _minLength: Dc,
  _minSize: Jl,
  _multipleOf: Yl,
  _nan: RE,
  _nanoid: mv,
  _nativeEnum: sR,
  _negative: VE,
  _never: TE,
  _nonnegative: NE,
  _nonoptional: uR,
  _nonpositive: LE,
  _normalize: Lv,
  _null: CE,
  _nullable: cR,
  _number: hE,
  _optional: aR,
  _overwrite: La,
  _parse: Gg,
  _parseAsync: Hg,
  _pipe: mR,
  _positive: DE,
  _promise: gR,
  _property: zE,
  _readonly: fR,
  _record: tR,
  _refine: $E,
  _regex: Tv,
  _safeParse: jg,
  _safeParseAsync: Wg,
  _set: nR,
  _size: Ev,
  _startsWith: Rv,
  _string: sE,
  _stringFormat: GE,
  _stringbool: FE,
  _success: hR,
  _symbol: AE,
  _templateLiteral: pR,
  _toLowerCase: zv,
  _toUpperCase: kv,
  _transform: rR,
  _trim: Nv,
  _tuple: kE,
  _uint32: gE,
  _uint64: SE,
  _ulid: _v,
  _undefined: ME,
  _union: JP,
  _unknown: Gh,
  _uppercase: Bv,
  _url: hv,
  _uuid: av,
  _uuidv4: cv,
  _uuidv6: lv,
  _uuidv7: uv,
  _void: IE,
  _xid: gv,
  clone: no,
  config: Si,
  flattenError: $g,
  formatError: Fg,
  function: HE,
  globalConfig: kh,
  globalRegistry: ea,
  isValidBase64: Jg,
  isValidBase64URL: gC,
  isValidJWT: yC,
  locales: eE,
  parse: vp,
  parseAsync: bp,
  prettifyError: YA,
  regexes: PM,
  registry: ov,
  safeParse: JA,
  safeParseAsync: KA,
  toDotPath: ZA,
  toJSONSchema: jE,
  treeifyError: XA,
  util: pB,
  version: YM
}, Symbol.toStringTag, { value: "Module" })), Ov = Z("ZodISODateTime", (n, t) => {
  cC.init(n, t), Cn.init(n, t);
});
function WE(n) {
  return aE(Ov, n);
}
h(WE, "datetime");
const $v = Z("ZodISODate", (n, t) => {
  lC.init(n, t), Cn.init(n, t);
});
function qE(n) {
  return cE($v, n);
}
h(qE, "date$2");
const Fv = Z("ZodISOTime", (n, t) => {
  uC.init(n, t), Cn.init(n, t);
});
function XE(n) {
  return lE(Fv, n);
}
h(XE, "time");
const Gv = Z("ZodISODuration", (n, t) => {
  hC.init(n, t), Cn.init(n, t);
});
function ZE(n) {
  return uE(Gv, n);
}
h(ZE, "duration");
const yR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ZodISODate: $v,
  ZodISODateTime: Ov,
  ZodISODuration: Gv,
  ZodISOTime: Fv,
  date: qE,
  datetime: WE,
  duration: ZE,
  time: XE
}, Symbol.toStringTag, { value: "Module" })), YE = /* @__PURE__ */ h((n, t) => {
  Og.init(n, t), n.name = "ZodError", Object.defineProperties(n, {
    format: {
      value: /* @__PURE__ */ h((e) => Fg(n, e), "value")
    },
    flatten: {
      value: /* @__PURE__ */ h((e) => $g(n, e), "value")
    },
    addIssue: {
      value: /* @__PURE__ */ h((e) => n.issues.push(e), "value")
    },
    addIssues: {
      value: /* @__PURE__ */ h((e) => n.issues.push(...e), "value")
    },
    isEmpty: {
      get() {
        return n.issues.length === 0;
      }
    }
  });
}, "initializer"), xR = Z("ZodError", YE), Du = Z("ZodError", YE, {
  Parent: Error
}), JE = Gg(Du), KE = Hg(Du), QE = jg(Du), tT = Wg(Du), De = Z("ZodType", (n, t) => (ve.init(n, t), n.def = t, Object.defineProperty(n, "_def", { value: t }), n.check = (...e) => {
  var s;
  return n.clone(
    {
      ...t,
      checks: [
        ...(s = t.checks) != null ? s : [],
        ...e.map((i) => typeof i == "function" ? { _zod: { check: i, def: { check: "custom" }, onattach: [] } } : i)
      ]
    }
  );
}, n.clone = (e, s) => no(n, e, s), n.brand = () => n, n.register = (e, s) => (e.add(n, s), n), n.parse = (e, s) => JE(n, e, s, { callee: n.parse }), n.safeParse = (e, s) => QE(n, e, s), n.parseAsync = async (e, s) => KE(n, e, s, { callee: n.parseAsync }), n.safeParseAsync = async (e, s) => tT(n, e, s), n.spa = n.safeParseAsync, n.refine = (e, s) => n.check(VT(e, s)), n.superRefine = (e) => n.check(LT(e)), n.overwrite = (e) => n.check(La(e)), n.optional = () => qh(n), n.nullable = () => Xh(n), n.nullish = () => qh(Xh(n)), n.nonoptional = (e) => ST(n, e), n.array = () => We(n), n.or = (e) => cn([n, e]), n.and = (e) => dT(n, e), n.transform = (e) => Zh(n, f2(e)), n.default = (e) => yT(n, e), n.prefault = (e) => wT(n, e), n.catch = (e) => CT(n, e), n.pipe = (e) => Zh(n, e), n.readonly = () => IT(n), n.describe = (e) => {
  const s = n.clone();
  return ea.add(s, { description: e }), s;
}, Object.defineProperty(n, "description", {
  get() {
    var e;
    return (e = ea.get(n)) == null ? void 0 : e.description;
  },
  configurable: !0
}), n.meta = (...e) => {
  if (e.length === 0)
    return ea.get(n);
  const s = n.clone();
  return ea.add(s, e[0]), s;
}, n.isOptional = () => n.safeParse(void 0).success, n.isNullable = () => n.safeParse(null).success, n)), Hv = Z("_ZodString", (n, t) => {
  var s, i, o;
  Ru.init(n, t), De.init(n, t);
  const e = n._zod.bag;
  n.format = (s = e.format) != null ? s : null, n.minLength = (i = e.minimum) != null ? i : null, n.maxLength = (o = e.maximum) != null ? o : null, n.regex = (...r) => n.check(Tv(...r)), n.includes = (...r) => n.check(Pv(...r)), n.startsWith = (...r) => n.check(Rv(...r)), n.endsWith = (...r) => n.check(Dv(...r)), n.min = (...r) => n.check(Dc(...r)), n.max = (...r) => n.check(Tm(...r)), n.length = (...r) => n.check(Im(...r)), n.nonempty = (...r) => n.check(Dc(1, ...r)), n.lowercase = (r) => n.check(Iv(r)), n.uppercase = (r) => n.check(Bv(r)), n.trim = () => n.check(Nv()), n.normalize = (...r) => n.check(Lv(...r)), n.toLowerCase = () => n.check(zv()), n.toUpperCase = () => n.check(kv());
}), Vu = Z("ZodString", (n, t) => {
  Ru.init(n, t), Hv.init(n, t), n.email = (e) => n.check(rv(jv, e)), n.url = (e) => n.check(hv(Wv, e)), n.jwt = (e) => n.check(Cv(a2, e)), n.emoji = (e) => n.check(dv(qv, e)), n.guid = (e) => n.check(Fh(jh, e)), n.uuid = (e) => n.check(av(Bo, e)), n.uuidv4 = (e) => n.check(cv(Bo, e)), n.uuidv6 = (e) => n.check(lv(Bo, e)), n.uuidv7 = (e) => n.check(uv(Bo, e)), n.nanoid = (e) => n.check(mv(Xv, e)), n.guid = (e) => n.check(Fh(jh, e)), n.cuid = (e) => n.check(fv(Zv, e)), n.cuid2 = (e) => n.check(pv(Yv, e)), n.ulid = (e) => n.check(_v(Jv, e)), n.base64 = (e) => n.check(Sv(s2, e)), n.base64url = (e) => n.check(Av(o2, e)), n.xid = (e) => n.check(gv(Kv, e)), n.ksuid = (e) => n.check(vv(Qv, e)), n.ipv4 = (e) => n.check(bv(t2, e)), n.ipv6 = (e) => n.check(yv(e2, e)), n.cidrv4 = (e) => n.check(xv(n2, e)), n.cidrv6 = (e) => n.check(wv(i2, e)), n.e164 = (e) => n.check(Mv(r2, e)), n.datetime = (e) => n.check(WE(e)), n.date = (e) => n.check(qE(e)), n.time = (e) => n.check(XE(e)), n.duration = (e) => n.check(ZE(e));
});
function $t(n) {
  return sE(Vu, n);
}
h($t, "string$1");
const Cn = Z("ZodStringFormat", (n, t) => {
  Sn.init(n, t), Hv.init(n, t);
}), jv = Z("ZodEmail", (n, t) => {
  QM.init(n, t), Cn.init(n, t);
});
function wR(n) {
  return rv(jv, n);
}
h(wR, "email");
const jh = Z("ZodGUID", (n, t) => {
  JM.init(n, t), Cn.init(n, t);
});
function SR(n) {
  return Fh(jh, n);
}
h(SR, "guid");
const Bo = Z("ZodUUID", (n, t) => {
  KM.init(n, t), Cn.init(n, t);
});
function AR(n) {
  return av(Bo, n);
}
h(AR, "uuid");
function MR(n) {
  return cv(Bo, n);
}
h(MR, "uuidv4");
function CR(n) {
  return lv(Bo, n);
}
h(CR, "uuidv6");
function ER(n) {
  return uv(Bo, n);
}
h(ER, "uuidv7");
const Wv = Z("ZodURL", (n, t) => {
  tC.init(n, t), Cn.init(n, t);
});
function TR(n) {
  return hv(Wv, n);
}
h(TR, "url");
const qv = Z("ZodEmoji", (n, t) => {
  eC.init(n, t), Cn.init(n, t);
});
function IR(n) {
  return dv(qv, n);
}
h(IR, "emoji");
const Xv = Z("ZodNanoID", (n, t) => {
  nC.init(n, t), Cn.init(n, t);
});
function BR(n) {
  return mv(Xv, n);
}
h(BR, "nanoid");
const Zv = Z("ZodCUID", (n, t) => {
  iC.init(n, t), Cn.init(n, t);
});
function PR(n) {
  return fv(Zv, n);
}
h(PR, "cuid");
const Yv = Z("ZodCUID2", (n, t) => {
  sC.init(n, t), Cn.init(n, t);
});
function RR(n) {
  return pv(Yv, n);
}
h(RR, "cuid2");
const Jv = Z("ZodULID", (n, t) => {
  oC.init(n, t), Cn.init(n, t);
});
function DR(n) {
  return _v(Jv, n);
}
h(DR, "ulid");
const Kv = Z("ZodXID", (n, t) => {
  rC.init(n, t), Cn.init(n, t);
});
function VR(n) {
  return gv(Kv, n);
}
h(VR, "xid");
const Qv = Z("ZodKSUID", (n, t) => {
  aC.init(n, t), Cn.init(n, t);
});
function LR(n) {
  return vv(Qv, n);
}
h(LR, "ksuid");
const t2 = Z("ZodIPv4", (n, t) => {
  dC.init(n, t), Cn.init(n, t);
});
function NR(n) {
  return bv(t2, n);
}
h(NR, "ipv4");
const e2 = Z("ZodIPv6", (n, t) => {
  mC.init(n, t), Cn.init(n, t);
});
function zR(n) {
  return yv(e2, n);
}
h(zR, "ipv6");
const n2 = Z("ZodCIDRv4", (n, t) => {
  fC.init(n, t), Cn.init(n, t);
});
function kR(n) {
  return xv(n2, n);
}
h(kR, "cidrv4");
const i2 = Z("ZodCIDRv6", (n, t) => {
  pC.init(n, t), Cn.init(n, t);
});
function UR(n) {
  return wv(i2, n);
}
h(UR, "cidrv6");
const s2 = Z("ZodBase64", (n, t) => {
  _C.init(n, t), Cn.init(n, t);
});
function OR(n) {
  return Sv(s2, n);
}
h(OR, "base64");
const o2 = Z("ZodBase64URL", (n, t) => {
  vC.init(n, t), Cn.init(n, t);
});
function $R(n) {
  return Av(o2, n);
}
h($R, "base64url");
const r2 = Z("ZodE164", (n, t) => {
  bC.init(n, t), Cn.init(n, t);
});
function FR(n) {
  return Mv(r2, n);
}
h(FR, "e164");
const a2 = Z("ZodJWT", (n, t) => {
  xC.init(n, t), Cn.init(n, t);
});
function GR(n) {
  return Cv(a2, n);
}
h(GR, "jwt");
const eT = Z("ZodCustomStringFormat", (n, t) => {
  wC.init(n, t), Cn.init(n, t);
});
function HR(n, t, e = {}) {
  return GE(eT, n, t, e);
}
h(HR, "stringFormat");
const Jc = Z("ZodNumber", (n, t) => {
  var s, i, o, r, a, l, c, u, m;
  Kg.init(n, t), De.init(n, t), n.gt = (d, f) => n.check(pa(d, f)), n.gte = (d, f) => n.check(ji(d, f)), n.min = (d, f) => n.check(ji(d, f)), n.lt = (d, f) => n.check(fa(d, f)), n.lte = (d, f) => n.check(Cs(d, f)), n.max = (d, f) => n.check(Cs(d, f)), n.int = (d) => n.check(xp(d)), n.safe = (d) => n.check(xp(d)), n.positive = (d) => n.check(pa(0, d)), n.nonnegative = (d) => n.check(ji(0, d)), n.negative = (d) => n.check(fa(0, d)), n.nonpositive = (d) => n.check(Cs(0, d)), n.multipleOf = (d, f) => n.check(Yl(d, f)), n.step = (d, f) => n.check(Yl(d, f)), n.finite = () => n;
  const e = n._zod.bag;
  n.minValue = (o = Math.max((s = e.minimum) != null ? s : Number.NEGATIVE_INFINITY, (i = e.exclusiveMinimum) != null ? i : Number.NEGATIVE_INFINITY)) != null ? o : null, n.maxValue = (l = Math.min((r = e.maximum) != null ? r : Number.POSITIVE_INFINITY, (a = e.exclusiveMaximum) != null ? a : Number.POSITIVE_INFINITY)) != null ? l : null, n.isInt = ((c = e.format) != null ? c : "").includes("int") || Number.isSafeInteger((u = e.multipleOf) != null ? u : 0.5), n.isFinite = !0, n.format = (m = e.format) != null ? m : null;
});
function ls(n) {
  return hE(Jc, n);
}
h(ls, "number$1");
const Kc = Z("ZodNumberFormat", (n, t) => {
  SC.init(n, t), Jc.init(n, t);
});
function xp(n) {
  return mE(Kc, n);
}
h(xp, "int");
function jt(n) {
  return fE(Kc, n);
}
h(jt, "float32");
function jR(n) {
  return pE(Kc, n);
}
h(jR, "float64");
function Wh(n) {
  return _E(Kc, n);
}
h(Wh, "int32");
function la(n) {
  return gE(Kc, n);
}
h(la, "uint32");
const Lu = Z("ZodBoolean", (n, t) => {
  Qg.init(n, t), De.init(n, t);
});
function Ii(n) {
  return vE(Lu, n);
}
h(Ii, "boolean$1");
const Bm = Z("ZodBigInt", (n, t) => {
  var s, i, o;
  tv.init(n, t), De.init(n, t), n.gte = (r, a) => n.check(ji(r, a)), n.min = (r, a) => n.check(ji(r, a)), n.gt = (r, a) => n.check(pa(r, a)), n.gte = (r, a) => n.check(ji(r, a)), n.min = (r, a) => n.check(ji(r, a)), n.lt = (r, a) => n.check(fa(r, a)), n.lte = (r, a) => n.check(Cs(r, a)), n.max = (r, a) => n.check(Cs(r, a)), n.positive = (r) => n.check(pa(BigInt(0), r)), n.negative = (r) => n.check(fa(BigInt(0), r)), n.nonpositive = (r) => n.check(Cs(BigInt(0), r)), n.nonnegative = (r) => n.check(ji(BigInt(0), r)), n.multipleOf = (r, a) => n.check(Yl(r, a));
  const e = n._zod.bag;
  n.minValue = (s = e.minimum) != null ? s : null, n.maxValue = (i = e.maximum) != null ? i : null, n.format = (o = e.format) != null ? o : null;
});
function WR(n) {
  return yE(Bm, n);
}
h(WR, "bigint$1");
const c2 = Z("ZodBigIntFormat", (n, t) => {
  AC.init(n, t), Bm.init(n, t);
});
function qR(n) {
  return wE(c2, n);
}
h(qR, "int64");
function XR(n) {
  return SE(c2, n);
}
h(XR, "uint64");
const nT = Z("ZodSymbol", (n, t) => {
  MC.init(n, t), De.init(n, t);
});
function ZR(n) {
  return AE(nT, n);
}
h(ZR, "symbol");
const iT = Z("ZodUndefined", (n, t) => {
  CC.init(n, t), De.init(n, t);
});
function YR(n) {
  return ME(iT, n);
}
h(YR, "_undefined");
const sT = Z("ZodNull", (n, t) => {
  EC.init(n, t), De.init(n, t);
});
function oT(n) {
  return CE(sT, n);
}
h(oT, "_null");
const rT = Z("ZodAny", (n, t) => {
  TC.init(n, t), De.init(n, t);
});
function Il() {
  return EE(rT);
}
h(Il, "any");
const aT = Z("ZodUnknown", (n, t) => {
  $h.init(n, t), De.init(n, t);
});
function Ql() {
  return Gh(aT);
}
h(Ql, "unknown");
const cT = Z("ZodNever", (n, t) => {
  IC.init(n, t), De.init(n, t);
});
function Pm(n) {
  return TE(cT, n);
}
h(Pm, "never");
const lT = Z("ZodVoid", (n, t) => {
  BC.init(n, t), De.init(n, t);
});
function JR(n) {
  return IE(lT, n);
}
h(JR, "_void");
const l2 = Z("ZodDate", (n, t) => {
  PC.init(n, t), De.init(n, t), n.min = (s, i) => n.check(ji(s, i)), n.max = (s, i) => n.check(Cs(s, i));
  const e = n._zod.bag;
  n.minDate = e.minimum ? new Date(e.minimum) : null, n.maxDate = e.maximum ? new Date(e.maximum) : null;
});
function KR(n) {
  return BE(l2, n);
}
h(KR, "date$1");
const u2 = Z("ZodArray", (n, t) => {
  ev.init(n, t), De.init(n, t), n.element = t.element, n.min = (e, s) => n.check(Dc(e, s)), n.nonempty = (e) => n.check(Dc(1, e)), n.max = (e, s) => n.check(Tm(e, s)), n.length = (e, s) => n.check(Im(e, s)), n.unwrap = () => n.element;
});
function We(n, t) {
  return Uv(u2, n, t);
}
h(We, "array");
function QR(n) {
  const t = n._zod.def.shape;
  return jo(Object.keys(t));
}
h(QR, "keyof");
const Rm = Z("ZodObject", (n, t) => {
  RC.init(n, t), De.init(n, t), en(n, "shape", () => t.shape), n.keyof = () => Ri(Object.keys(n._zod.def.shape)), n.catchall = (e) => n.clone({ ...n._zod.def, catchall: e }), n.passthrough = () => n.clone({ ...n._zod.def, catchall: Ql() }), n.loose = () => n.clone({ ...n._zod.def, catchall: Ql() }), n.strict = () => n.clone({ ...n._zod.def, catchall: Pm() }), n.strip = () => n.clone({ ...n._zod.def, catchall: void 0 }), n.extend = (e) => GA(n, e), n.merge = (e) => HA(n, e), n.pick = (e) => $A(n, e), n.omit = (e) => FA(n, e), n.partial = (...e) => jA(Dm, n, e[0]), n.required = (...e) => WA(_2, n, e[0]);
});
function he(n, t) {
  const e = {
    type: "object",
    get shape() {
      return Yc(this, "shape", { ...n }), this.shape;
    },
    ...pt(t)
  };
  return new Rm(e);
}
h(he, "object");
function t4(n, t) {
  return new Rm({
    type: "object",
    get shape() {
      return Yc(this, "shape", { ...n }), this.shape;
    },
    catchall: Pm(),
    ...pt(t)
  });
}
h(t4, "strictObject");
function e4(n, t) {
  return new Rm({
    type: "object",
    get shape() {
      return Yc(this, "shape", { ...n }), this.shape;
    },
    catchall: Ql(),
    ...pt(t)
  });
}
h(e4, "looseObject");
const h2 = Z("ZodUnion", (n, t) => {
  nv.init(n, t), De.init(n, t), n.options = t.options;
});
function cn(n, t) {
  return new h2({
    type: "union",
    options: n,
    ...pt(t)
  });
}
h(cn, "union");
const uT = Z("ZodDiscriminatedUnion", (n, t) => {
  h2.init(n, t), DC.init(n, t);
});
function n4(n, t, e) {
  return new uT({
    type: "union",
    options: t,
    discriminator: n,
    ...pt(e)
  });
}
h(n4, "discriminatedUnion");
const hT = Z("ZodIntersection", (n, t) => {
  VC.init(n, t), De.init(n, t);
});
function dT(n, t) {
  return new hT({
    type: "intersection",
    left: n,
    right: t
  });
}
h(dT, "intersection");
const mT = Z("ZodTuple", (n, t) => {
  Cm.init(n, t), De.init(n, t), n.rest = (e) => n.clone({
    ...n._zod.def,
    rest: e
  });
});
function i4(n, t, e) {
  const s = t instanceof ve, i = s ? e : t, o = s ? t : null;
  return new mT({
    type: "tuple",
    items: n,
    rest: o,
    ...pt(i)
  });
}
h(i4, "tuple");
const d2 = Z("ZodRecord", (n, t) => {
  LC.init(n, t), De.init(n, t), n.keyType = t.keyType, n.valueType = t.valueType;
});
function fT(n, t, e) {
  return new d2({
    type: "record",
    keyType: n,
    valueType: t,
    ...pt(e)
  });
}
h(fT, "record");
function s4(n, t, e) {
  return new d2({
    type: "record",
    keyType: cn([n, Pm()]),
    valueType: t,
    ...pt(e)
  });
}
h(s4, "partialRecord");
const pT = Z("ZodMap", (n, t) => {
  NC.init(n, t), De.init(n, t), n.keyType = t.keyType, n.valueType = t.valueType;
});
function o4(n, t, e) {
  return new pT({
    type: "map",
    keyType: n,
    valueType: t,
    ...pt(e)
  });
}
h(o4, "map");
const _T = Z("ZodSet", (n, t) => {
  zC.init(n, t), De.init(n, t), n.min = (...e) => n.check(Jl(...e)), n.nonempty = (e) => n.check(Jl(1, e)), n.max = (...e) => n.check(Em(...e)), n.size = (...e) => n.check(Ev(...e));
});
function r4(n, t) {
  return new _T({
    type: "set",
    valueType: n,
    ...pt(t)
  });
}
h(r4, "set");
const Vc = Z("ZodEnum", (n, t) => {
  kC.init(n, t), De.init(n, t), n.enum = t.entries, n.options = Object.values(t.entries);
  const e = new Set(Object.keys(t.entries));
  n.extract = (s, i) => {
    const o = {};
    for (const r of s)
      if (e.has(r))
        o[r] = t.entries[r];
      else
        throw new Error(`Key ${r} not found in enum`);
    return new Vc({
      ...t,
      checks: [],
      ...pt(i),
      entries: o
    });
  }, n.exclude = (s, i) => {
    const o = { ...t.entries };
    for (const r of s)
      if (e.has(r))
        delete o[r];
      else
        throw new Error(`Key ${r} not found in enum`);
    return new Vc({
      ...t,
      checks: [],
      ...pt(i),
      entries: o
    });
  };
});
function Ri(n, t) {
  const e = Array.isArray(n) ? Object.fromEntries(n.map((s) => [s, s])) : n;
  return new Vc({
    type: "enum",
    entries: e,
    ...pt(t)
  });
}
h(Ri, "_enum");
function a4(n, t) {
  return new Vc({
    type: "enum",
    entries: n,
    ...pt(t)
  });
}
h(a4, "nativeEnum");
const gT = Z("ZodLiteral", (n, t) => {
  UC.init(n, t), De.init(n, t), n.values = new Set(t.values), Object.defineProperty(n, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function jo(n, t) {
  return new gT({
    type: "literal",
    values: Array.isArray(n) ? n : [n],
    ...pt(t)
  });
}
h(jo, "literal");
const vT = Z("ZodFile", (n, t) => {
  OC.init(n, t), De.init(n, t), n.min = (e, s) => n.check(Jl(e, s)), n.max = (e, s) => n.check(Em(e, s)), n.mime = (e, s) => n.check(Vv(Array.isArray(e) ? e : [e], s));
});
function c4(n) {
  return UE(vT, n);
}
h(c4, "file");
const m2 = Z("ZodTransform", (n, t) => {
  iv.init(n, t), De.init(n, t), n._zod.parse = (e, s) => {
    e.addIssue = (o) => {
      var r, a, l, c;
      if (typeof o == "string")
        e.issues.push(Pc(o, e.value, t));
      else {
        const u = o;
        u.fatal && (u.continue = !1), (r = u.code) != null || (u.code = "custom"), (a = u.input) != null || (u.input = e.value), (l = u.inst) != null || (u.inst = n), (c = u.continue) != null || (u.continue = !0), e.issues.push(Pc(u));
      }
    };
    const i = t.transform(e.value, e);
    return i instanceof Promise ? i.then((o) => (e.value = o, e)) : (e.value = i, e);
  };
});
function f2(n) {
  return new m2({
    type: "transform",
    transform: n
  });
}
h(f2, "transform");
const Dm = Z("ZodOptional", (n, t) => {
  $C.init(n, t), De.init(n, t), n.unwrap = () => n._zod.def.innerType;
});
function qh(n) {
  return new Dm({
    type: "optional",
    innerType: n
  });
}
h(qh, "optional");
const bT = Z("ZodNullable", (n, t) => {
  FC.init(n, t), De.init(n, t), n.unwrap = () => n._zod.def.innerType;
});
function Xh(n) {
  return new bT({
    type: "nullable",
    innerType: n
  });
}
h(Xh, "nullable");
function l4(n) {
  return qh(Xh(n));
}
h(l4, "nullish");
const p2 = Z("ZodDefault", (n, t) => {
  GC.init(n, t), De.init(n, t), n.unwrap = () => n._zod.def.innerType, n.removeDefault = n.unwrap;
});
function yT(n, t) {
  return new p2({
    type: "default",
    innerType: n,
    get defaultValue() {
      return typeof t == "function" ? t() : t;
    }
  });
}
h(yT, "_default");
const xT = Z("ZodPrefault", (n, t) => {
  HC.init(n, t), De.init(n, t), n.unwrap = () => n._zod.def.innerType;
});
function wT(n, t) {
  return new xT({
    type: "prefault",
    innerType: n,
    get defaultValue() {
      return typeof t == "function" ? t() : t;
    }
  });
}
h(wT, "prefault");
const _2 = Z("ZodNonOptional", (n, t) => {
  jC.init(n, t), De.init(n, t), n.unwrap = () => n._zod.def.innerType;
});
function ST(n, t) {
  return new _2({
    type: "nonoptional",
    innerType: n,
    ...pt(t)
  });
}
h(ST, "nonoptional");
const AT = Z("ZodSuccess", (n, t) => {
  WC.init(n, t), De.init(n, t), n.unwrap = () => n._zod.def.innerType;
});
function u4(n) {
  return new AT({
    type: "success",
    innerType: n
  });
}
h(u4, "success");
const MT = Z("ZodCatch", (n, t) => {
  qC.init(n, t), De.init(n, t), n.unwrap = () => n._zod.def.innerType, n.removeCatch = n.unwrap;
});
function CT(n, t) {
  return new MT({
    type: "catch",
    innerType: n,
    catchValue: typeof t == "function" ? t : () => t
  });
}
h(CT, "_catch");
const ET = Z("ZodNaN", (n, t) => {
  XC.init(n, t), De.init(n, t);
});
function h4(n) {
  return RE(ET, n);
}
h(h4, "nan");
const g2 = Z("ZodPipe", (n, t) => {
  sv.init(n, t), De.init(n, t), n.in = t.in, n.out = t.out;
});
function Zh(n, t) {
  return new g2({
    type: "pipe",
    in: n,
    out: t
  });
}
h(Zh, "pipe");
const TT = Z("ZodReadonly", (n, t) => {
  ZC.init(n, t), De.init(n, t);
});
function IT(n) {
  return new TT({
    type: "readonly",
    innerType: n
  });
}
h(IT, "readonly");
const BT = Z("ZodTemplateLiteral", (n, t) => {
  YC.init(n, t), De.init(n, t);
});
function d4(n, t) {
  return new BT({
    type: "template_literal",
    parts: n,
    ...pt(t)
  });
}
h(d4, "templateLiteral");
const PT = Z("ZodLazy", (n, t) => {
  KC.init(n, t), De.init(n, t), n.unwrap = () => n._zod.def.getter();
});
function v2(n) {
  return new PT({
    type: "lazy",
    getter: n
  });
}
h(v2, "lazy");
const RT = Z("ZodPromise", (n, t) => {
  JC.init(n, t), De.init(n, t), n.unwrap = () => n._zod.def.innerType;
});
function m4(n) {
  return new RT({
    type: "promise",
    innerType: n
  });
}
h(m4, "promise");
const Vm = Z("ZodCustom", (n, t) => {
  QC.init(n, t), De.init(n, t);
});
function DT(n) {
  const t = new kn({
    check: "custom"
  });
  return t._zod.check = n, t;
}
h(DT, "check");
function f4(n, t) {
  return OE(Vm, n != null ? n : () => !0, t);
}
h(f4, "custom");
function VT(n, t = {}) {
  return $E(Vm, n, t);
}
h(VT, "refine");
function LT(n) {
  const t = DT((e) => (e.addIssue = (s) => {
    var i, o, r, a;
    if (typeof s == "string")
      e.issues.push(Pc(s, e.value, t._zod.def));
    else {
      const l = s;
      l.fatal && (l.continue = !1), (i = l.code) != null || (l.code = "custom"), (o = l.input) != null || (l.input = e.value), (r = l.inst) != null || (l.inst = t), (a = l.continue) != null || (l.continue = !t._zod.def.abort), e.issues.push(Pc(l));
    }
  }, n(e.value, e)));
  return t;
}
h(LT, "superRefine");
function p4(n, t = {
  error: `Input not instance of ${n.name}`
}) {
  const e = new Vm({
    type: "custom",
    check: "custom",
    fn: /* @__PURE__ */ h((s) => s instanceof n, "fn"),
    abort: !0,
    ...pt(t)
  });
  return e._zod.bag.Class = n, e;
}
h(p4, "_instanceof");
const _4 = /* @__PURE__ */ h((...n) => FE({
  Pipe: g2,
  Boolean: Lu,
  String: Vu,
  Transform: m2
}, ...n), "stringbool");
function g4(n) {
  const t = v2(() => cn([$t(n), ls(), Ii(), oT(), We(t), fT($t(), t)]));
  return t;
}
h(g4, "json");
function v4(n, t) {
  return Zh(f2(n), t);
}
h(v4, "preprocess");
const b4 = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function y4(n) {
  Si({
    customError: n
  });
}
h(y4, "setErrorMap");
function x4() {
  return Si().customError;
}
h(x4, "getErrorMap");
function w4(n) {
  return oE(Vu, n);
}
h(w4, "string");
function ct(n) {
  return dE(Jc, n);
}
h(ct, "number");
function je(n) {
  return bE(Lu, n);
}
h(je, "boolean");
function S4(n) {
  return xE(Bm, n);
}
h(S4, "bigint");
function A4(n) {
  return PE(l2, n);
}
h(A4, "date");
const M4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bigint: S4,
  boolean: je,
  date: A4,
  number: ct,
  string: w4
}, Symbol.toStringTag, { value: "Module" }));
Si(tE());
const VH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $brand: DA,
  $input: iE,
  $output: nE,
  NEVER: RA,
  TimePrecision: rE,
  ZodAny: rT,
  ZodArray: u2,
  ZodBase64: s2,
  ZodBase64URL: o2,
  ZodBigInt: Bm,
  ZodBigIntFormat: c2,
  ZodBoolean: Lu,
  ZodCIDRv4: n2,
  ZodCIDRv6: i2,
  ZodCUID: Zv,
  ZodCUID2: Yv,
  ZodCatch: MT,
  ZodCustom: Vm,
  ZodCustomStringFormat: eT,
  ZodDate: l2,
  ZodDefault: p2,
  ZodDiscriminatedUnion: uT,
  ZodE164: r2,
  ZodEmail: jv,
  ZodEmoji: qv,
  ZodEnum: Vc,
  ZodError: xR,
  ZodFile: vT,
  ZodGUID: jh,
  ZodIPv4: t2,
  ZodIPv6: e2,
  ZodISODate: $v,
  ZodISODateTime: Ov,
  ZodISODuration: Gv,
  ZodISOTime: Fv,
  ZodIntersection: hT,
  ZodIssueCode: b4,
  ZodJWT: a2,
  ZodKSUID: Qv,
  ZodLazy: PT,
  ZodLiteral: gT,
  ZodMap: pT,
  ZodNaN: ET,
  ZodNanoID: Xv,
  ZodNever: cT,
  ZodNonOptional: _2,
  ZodNull: sT,
  ZodNullable: bT,
  ZodNumber: Jc,
  ZodNumberFormat: Kc,
  ZodObject: Rm,
  ZodOptional: Dm,
  ZodPipe: g2,
  ZodPrefault: xT,
  ZodPromise: RT,
  ZodReadonly: TT,
  ZodRealError: Du,
  ZodRecord: d2,
  ZodSet: _T,
  ZodString: Vu,
  ZodStringFormat: Cn,
  ZodSuccess: AT,
  ZodSymbol: nT,
  ZodTemplateLiteral: BT,
  ZodTransform: m2,
  ZodTuple: mT,
  ZodType: De,
  ZodULID: Jv,
  ZodURL: Wv,
  ZodUUID: Bo,
  ZodUndefined: iT,
  ZodUnion: h2,
  ZodUnknown: aT,
  ZodVoid: lT,
  ZodXID: Kv,
  _ZodString: Hv,
  _default: yT,
  any: Il,
  array: We,
  base64: OR,
  base64url: $R,
  bigint: WR,
  boolean: Ii,
  catch: CT,
  check: DT,
  cidrv4: kR,
  cidrv6: UR,
  clone: no,
  coerce: M4,
  config: Si,
  core: bR,
  cuid: PR,
  cuid2: RR,
  custom: f4,
  date: KR,
  discriminatedUnion: n4,
  e164: FR,
  email: wR,
  emoji: IR,
  endsWith: Dv,
  enum: Ri,
  file: c4,
  flattenError: $g,
  float32: jt,
  float64: jR,
  formatError: Fg,
  function: HE,
  getErrorMap: x4,
  globalRegistry: ea,
  gt: pa,
  gte: ji,
  guid: SR,
  includes: Pv,
  instanceof: p4,
  int: xp,
  int32: Wh,
  int64: qR,
  intersection: dT,
  ipv4: NR,
  ipv6: zR,
  iso: yR,
  json: g4,
  jwt: GR,
  keyof: QR,
  ksuid: LR,
  lazy: v2,
  length: Im,
  literal: jo,
  locales: eE,
  looseObject: e4,
  lowercase: Iv,
  lt: fa,
  lte: Cs,
  map: o4,
  maxLength: Tm,
  maxSize: Em,
  mime: Vv,
  minLength: Dc,
  minSize: Jl,
  multipleOf: Yl,
  nan: h4,
  nanoid: BR,
  nativeEnum: a4,
  negative: VE,
  never: Pm,
  nonnegative: NE,
  nonoptional: ST,
  nonpositive: LE,
  normalize: Lv,
  null: oT,
  nullable: Xh,
  nullish: l4,
  number: ls,
  object: he,
  optional: qh,
  overwrite: La,
  parse: JE,
  parseAsync: KE,
  partialRecord: s4,
  pipe: Zh,
  positive: DE,
  prefault: wT,
  preprocess: v4,
  prettifyError: YA,
  promise: m4,
  property: zE,
  readonly: IT,
  record: fT,
  refine: VT,
  regex: Tv,
  regexes: PM,
  registry: ov,
  safeParse: QE,
  safeParseAsync: tT,
  set: r4,
  setErrorMap: y4,
  size: Ev,
  startsWith: Rv,
  strictObject: t4,
  string: $t,
  stringFormat: HR,
  stringbool: _4,
  success: u4,
  superRefine: LT,
  symbol: ZR,
  templateLiteral: d4,
  toJSONSchema: jE,
  toLowerCase: zv,
  toUpperCase: kv,
  transform: f2,
  treeifyError: XA,
  trim: Nv,
  tuple: i4,
  uint32: la,
  uint64: XR,
  ulid: DR,
  undefined: YR,
  union: cn,
  unknown: Ql,
  uppercase: Bv,
  url: TR,
  uuid: AR,
  uuidv4: MR,
  uuidv6: CR,
  uuidv7: ER,
  void: JR,
  xid: VR
}, Symbol.toStringTag, { value: "Module" })), { min: C4, max: E4 } = Math, ua = /* @__PURE__ */ h((n, t = 0, e = 1) => C4(E4(t, n), e), "limit"), b2 = /* @__PURE__ */ h((n) => {
  n._clipped = !1, n._unclipped = n.slice(0);
  for (let t = 0; t <= 3; t++)
    t < 3 ? ((n[t] < 0 || n[t] > 255) && (n._clipped = !0), n[t] = ua(n[t], 0, 255)) : t === 3 && (n[t] = ua(n[t], 0, 1));
  return n;
}, "clip_rgb"), NT = {};
for (let n of [
  "Boolean",
  "Number",
  "String",
  "Function",
  "Array",
  "Date",
  "RegExp",
  "Undefined",
  "Null"
])
  NT[`[object ${n}]`] = n.toLowerCase();
function Ve(n) {
  return NT[Object.prototype.toString.call(n)] || "object";
}
h(Ve, "type");
const we = /* @__PURE__ */ h((n, t = null) => n.length >= 3 ? Array.prototype.slice.call(n) : Ve(n[0]) == "object" && t ? t.split("").filter((e) => n[0][e] !== void 0).map((e) => n[0][e]) : n[0].slice(0), "unpack"), Qc = /* @__PURE__ */ h((n) => {
  if (n.length < 2) return null;
  const t = n.length - 1;
  return Ve(n[t]) == "string" ? n[t].toLowerCase() : null;
}, "last"), { PI: Lm, min: zT, max: kT } = Math, hs = /* @__PURE__ */ h((n) => Math.round(n * 100) / 100, "rnd2"), wp = /* @__PURE__ */ h((n) => Math.round(n * 100) / 100, "rnd3"), Mo = Lm * 2, rf = Lm / 3, T4 = Lm / 180, I4 = 180 / Lm;
function UT(n) {
  return [...n.slice(0, 3).reverse(), ...n.slice(3)];
}
h(UT, "reverse3");
const xe = {
  format: {},
  autodetect: []
};
var Cc;
let xt = (Cc = class {
  constructor(...t) {
    const e = this;
    if (Ve(t[0]) === "object" && t[0].constructor && t[0].constructor === this.constructor)
      return t[0];
    let s = Qc(t), i = !1;
    if (!s) {
      i = !0, xe.sorted || (xe.autodetect = xe.autodetect.sort((o, r) => r.p - o.p), xe.sorted = !0);
      for (let o of xe.autodetect)
        if (s = o.test(...t), s) break;
    }
    if (xe.format[s]) {
      const o = xe.format[s].apply(
        null,
        i ? t : t.slice(0, -1)
      );
      e._rgb = b2(o);
    } else
      throw new Error("unknown format: " + t);
    e._rgb.length === 3 && e._rgb.push(1);
  }
  toString() {
    return Ve(this.hex) == "function" ? this.hex() : `[${this._rgb.join(",")}]`;
  }
}, h(Cc, "Color"), Cc);
const B4 = "3.1.2", Ie = /* @__PURE__ */ h((...n) => new xt(...n), "chroma");
Ie.version = B4;
const Lc = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
}, P4 = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, R4 = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/, OT = /* @__PURE__ */ h((n) => {
  if (n.match(P4)) {
    (n.length === 4 || n.length === 7) && (n = n.substr(1)), n.length === 3 && (n = n.split(""), n = n[0] + n[0] + n[1] + n[1] + n[2] + n[2]);
    const t = parseInt(n, 16), e = t >> 16, s = t >> 8 & 255, i = t & 255;
    return [e, s, i, 1];
  }
  if (n.match(R4)) {
    (n.length === 5 || n.length === 9) && (n = n.substr(1)), n.length === 4 && (n = n.split(""), n = n[0] + n[0] + n[1] + n[1] + n[2] + n[2] + n[3] + n[3]);
    const t = parseInt(n, 16), e = t >> 24 & 255, s = t >> 16 & 255, i = t >> 8 & 255, o = Math.round((t & 255) / 255 * 100) / 100;
    return [e, s, i, o];
  }
  throw new Error(`unknown hex color: ${n}`);
}, "hex2rgb"), { round: Xu } = Math, $T = /* @__PURE__ */ h((...n) => {
  let [t, e, s, i] = we(n, "rgba"), o = Qc(n) || "auto";
  i === void 0 && (i = 1), o === "auto" && (o = i < 1 ? "rgba" : "rgb"), t = Xu(t), e = Xu(e), s = Xu(s);
  let a = "000000" + (t << 16 | e << 8 | s).toString(16);
  a = a.substr(a.length - 6);
  let l = "0" + Xu(i * 255).toString(16);
  switch (l = l.substr(l.length - 2), o.toLowerCase()) {
    case "rgba":
      return `#${a}${l}`;
    case "argb":
      return `#${l}${a}`;
    default:
      return `#${a}`;
  }
}, "rgb2hex");
xt.prototype.name = function() {
  const n = $T(this._rgb, "rgb");
  for (let t of Object.keys(Lc))
    if (Lc[t] === n) return t.toLowerCase();
  return n;
};
xe.format.named = (n) => {
  if (n = n.toLowerCase(), Lc[n]) return OT(Lc[n]);
  throw new Error("unknown color name: " + n);
};
xe.autodetect.push({
  p: 5,
  test: /* @__PURE__ */ h((n, ...t) => {
    if (!t.length && Ve(n) === "string" && Lc[n.toLowerCase()])
      return "named";
  }, "test")
});
xt.prototype.alpha = function(n, t = !1) {
  return n !== void 0 && Ve(n) === "number" ? t ? (this._rgb[3] = n, this) : new xt([this._rgb[0], this._rgb[1], this._rgb[2], n], "rgb") : this._rgb[3];
};
xt.prototype.clipped = function() {
  return this._rgb._clipped || !1;
};
const js = {
  Kn: 18,
  labWhitePoint: "d65",
  Xn: 0.95047,
  Yn: 1,
  Zn: 1.08883,
  kE: 216 / 24389,
  kKE: 8,
  kK: 24389 / 27,
  RefWhiteRGB: {
    X: 0.95047,
    Y: 1,
    Z: 1.08883
  },
  MtxRGB2XYZ: {
    m00: 0.4124564390896922,
    m01: 0.21267285140562253,
    m02: 0.0193338955823293,
    m10: 0.357576077643909,
    m11: 0.715152155287818,
    m12: 0.11919202588130297,
    m20: 0.18043748326639894,
    m21: 0.07217499330655958,
    m22: 0.9503040785363679
  },
  MtxXYZ2RGB: {
    m00: 3.2404541621141045,
    m01: -0.9692660305051868,
    m02: 0.055643430959114726,
    m10: -1.5371385127977166,
    m11: 1.8760108454466942,
    m12: -0.2040259135167538,
    m20: -0.498531409556016,
    m21: 0.041556017530349834,
    m22: 1.0572251882231791
  },
  As: 0.9414285350000001,
  Bs: 1.040417467,
  Cs: 1.089532651,
  MtxAdaptMa: {
    m00: 0.8951,
    m01: -0.7502,
    m02: 0.0389,
    m10: 0.2664,
    m11: 1.7135,
    m12: -0.0685,
    m20: -0.1614,
    m21: 0.0367,
    m22: 1.0296
  },
  MtxAdaptMaI: {
    m00: 0.9869929054667123,
    m01: 0.43230526972339456,
    m02: -0.008528664575177328,
    m10: -0.14705425642099013,
    m11: 0.5183602715367776,
    m12: 0.04004282165408487,
    m20: 0.15996265166373125,
    m21: 0.0492912282128556,
    m22: 0.9684866957875502
  }
}, D4 = /* @__PURE__ */ new Map([
  ["a", [1.0985, 0.35585]],
  ["b", [1.0985, 0.35585]],
  ["c", [0.98074, 1.18232]],
  ["d50", [0.96422, 0.82521]],
  ["d55", [0.95682, 0.92149]],
  ["d65", [0.95047, 1.08883]],
  ["e", [1, 1, 1]],
  ["f2", [0.99186, 0.67393]],
  ["f7", [0.95041, 1.08747]],
  ["f11", [1.00962, 0.6435]],
  ["icc", [0.96422, 0.82521]]
]);
function Po(n) {
  const t = D4.get(String(n).toLowerCase());
  if (!t)
    throw new Error("unknown Lab illuminant " + n);
  js.labWhitePoint = n, js.Xn = t[0], js.Zn = t[1];
}
h(Po, "setLabWhitePoint");
function tu() {
  return js.labWhitePoint;
}
h(tu, "getLabWhitePoint");
const y2 = /* @__PURE__ */ h((...n) => {
  n = we(n, "lab");
  const [t, e, s] = n, [i, o, r] = V4(t, e, s), [a, l, c] = FT(i, o, r);
  return [a, l, c, n.length > 3 ? n[3] : 1];
}, "lab2rgb"), V4 = /* @__PURE__ */ h((n, t, e) => {
  const { kE: s, kK: i, kKE: o, Xn: r, Yn: a, Zn: l } = js, c = (n + 16) / 116, u = 2e-3 * t + c, m = c - 5e-3 * e, d = u * u * u, f = m * m * m, p = d > s ? d : (116 * u - 16) / i, v = n > o ? Math.pow((n + 16) / 116, 3) : n / i, _ = f > s ? f : (116 * m - 16) / i, g = p * r, w = v * a, S = _ * l;
  return [g, w, S];
}, "lab2xyz"), af = /* @__PURE__ */ h((n) => {
  const t = Math.sign(n);
  return n = Math.abs(n), (n <= 31308e-7 ? n * 12.92 : 1.055 * Math.pow(n, 1 / 2.4) - 0.055) * t;
}, "compand"), FT = /* @__PURE__ */ h((n, t, e) => {
  const { MtxAdaptMa: s, MtxAdaptMaI: i, MtxXYZ2RGB: o, RefWhiteRGB: r, Xn: a, Yn: l, Zn: c } = js, u = a * s.m00 + l * s.m10 + c * s.m20, m = a * s.m01 + l * s.m11 + c * s.m21, d = a * s.m02 + l * s.m12 + c * s.m22, f = r.X * s.m00 + r.Y * s.m10 + r.Z * s.m20, p = r.X * s.m01 + r.Y * s.m11 + r.Z * s.m21, v = r.X * s.m02 + r.Y * s.m12 + r.Z * s.m22, _ = (n * s.m00 + t * s.m10 + e * s.m20) * (f / u), g = (n * s.m01 + t * s.m11 + e * s.m21) * (p / m), w = (n * s.m02 + t * s.m12 + e * s.m22) * (v / d), S = _ * i.m00 + g * i.m10 + w * i.m20, x = _ * i.m01 + g * i.m11 + w * i.m21, A = _ * i.m02 + g * i.m12 + w * i.m22, C = af(
    S * o.m00 + x * o.m10 + A * o.m20
  ), M = af(
    S * o.m01 + x * o.m11 + A * o.m21
  ), T = af(
    S * o.m02 + x * o.m12 + A * o.m22
  );
  return [C * 255, M * 255, T * 255];
}, "xyz2rgb"), x2 = /* @__PURE__ */ h((...n) => {
  const [t, e, s, ...i] = we(n, "rgb"), [o, r, a] = GT(t, e, s), [l, c, u] = L4(o, r, a);
  return [l, c, u, ...i.length > 0 && i[0] < 1 ? [i[0]] : []];
}, "rgb2lab");
function L4(n, t, e) {
  const { Xn: s, Yn: i, Zn: o, kE: r, kK: a } = js, l = n / s, c = t / i, u = e / o, m = l > r ? Math.pow(l, 1 / 3) : (a * l + 16) / 116, d = c > r ? Math.pow(c, 1 / 3) : (a * c + 16) / 116, f = u > r ? Math.pow(u, 1 / 3) : (a * u + 16) / 116;
  return [116 * d - 16, 500 * (m - d), 200 * (d - f)];
}
h(L4, "xyz2lab");
function cf(n) {
  const t = Math.sign(n);
  return n = Math.abs(n), (n <= 0.04045 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4)) * t;
}
h(cf, "gammaAdjustSRGB");
const GT = /* @__PURE__ */ h((n, t, e) => {
  n = cf(n / 255), t = cf(t / 255), e = cf(e / 255);
  const { MtxRGB2XYZ: s, MtxAdaptMa: i, MtxAdaptMaI: o, Xn: r, Yn: a, Zn: l, As: c, Bs: u, Cs: m } = js;
  let d = n * s.m00 + t * s.m10 + e * s.m20, f = n * s.m01 + t * s.m11 + e * s.m21, p = n * s.m02 + t * s.m12 + e * s.m22;
  const v = r * i.m00 + a * i.m10 + l * i.m20, _ = r * i.m01 + a * i.m11 + l * i.m21, g = r * i.m02 + a * i.m12 + l * i.m22;
  let w = d * i.m00 + f * i.m10 + p * i.m20, S = d * i.m01 + f * i.m11 + p * i.m21, x = d * i.m02 + f * i.m12 + p * i.m22;
  return w *= v / c, S *= _ / u, x *= g / m, d = w * o.m00 + S * o.m10 + x * o.m20, f = w * o.m01 + S * o.m11 + x * o.m21, p = w * o.m02 + S * o.m12 + x * o.m22, [d, f, p];
}, "rgb2xyz");
xt.prototype.lab = function() {
  return x2(this._rgb);
};
const N4 = /* @__PURE__ */ h((...n) => new xt(...n, "lab"), "lab$1");
Object.assign(Ie, { lab: N4, getLabWhitePoint: tu, setLabWhitePoint: Po });
xe.format.lab = y2;
xe.autodetect.push({
  p: 2,
  test: /* @__PURE__ */ h((...n) => {
    if (n = we(n, "lab"), Ve(n) === "array" && n.length === 3)
      return "lab";
  }, "test")
});
xt.prototype.darken = function(n = 1) {
  const t = this, e = t.lab();
  return e[0] -= js.Kn * n, new xt(e, "lab").alpha(t.alpha(), !0);
};
xt.prototype.brighten = function(n = 1) {
  return this.darken(-n);
};
xt.prototype.darker = xt.prototype.darken;
xt.prototype.brighter = xt.prototype.brighten;
xt.prototype.get = function(n) {
  const [t, e] = n.split("."), s = this[t]();
  if (e) {
    const i = t.indexOf(e) - (t.substr(0, 2) === "ok" ? 2 : 0);
    if (i > -1) return s[i];
    throw new Error(`unknown channel ${e} in mode ${t}`);
  } else
    return s;
};
const { pow: z4 } = Math, k4 = 1e-7, U4 = 20;
xt.prototype.luminance = function(n, t = "rgb") {
  if (n !== void 0 && Ve(n) === "number") {
    if (n === 0)
      return new xt([0, 0, 0, this._rgb[3]], "rgb");
    if (n === 1)
      return new xt([255, 255, 255, this._rgb[3]], "rgb");
    let e = this.luminance(), s = U4;
    const i = /* @__PURE__ */ h((r, a) => {
      const l = r.interpolate(a, 0.5, t), c = l.luminance();
      return Math.abs(n - c) < k4 || !s-- ? l : c > n ? i(r, l) : i(l, a);
    }, "test"), o = (e > n ? i(new xt([0, 0, 0]), this) : i(this, new xt([255, 255, 255]))).rgb();
    return new xt([...o, this._rgb[3]]);
  }
  return O4(...this._rgb.slice(0, 3));
};
const O4 = /* @__PURE__ */ h((n, t, e) => (n = lf(n), t = lf(t), e = lf(e), 0.2126 * n + 0.7152 * t + 0.0722 * e), "rgb2luminance"), lf = /* @__PURE__ */ h((n) => (n /= 255, n <= 0.03928 ? n / 12.92 : z4((n + 0.055) / 1.055, 2.4)), "luminance_x"), di = {}, Nc = /* @__PURE__ */ h((n, t, e = 0.5, ...s) => {
  let i = s[0] || "lrgb";
  if (!di[i] && !s.length && (i = Object.keys(di)[0]), !di[i])
    throw new Error(`interpolation mode ${i} is not defined`);
  return Ve(n) !== "object" && (n = new xt(n)), Ve(t) !== "object" && (t = new xt(t)), di[i](n, t, e).alpha(
    n.alpha() + e * (t.alpha() - n.alpha())
  );
}, "mix");
xt.prototype.mix = xt.prototype.interpolate = function(n, t = 0.5, ...e) {
  return Nc(this, n, t, ...e);
};
xt.prototype.premultiply = function(n = !1) {
  const t = this._rgb, e = t[3];
  return n ? (this._rgb = [t[0] * e, t[1] * e, t[2] * e, e], this) : new xt([t[0] * e, t[1] * e, t[2] * e, e], "rgb");
};
const { sin: $4, cos: F4 } = Math, HT = /* @__PURE__ */ h((...n) => {
  let [t, e, s] = we(n, "lch");
  return isNaN(s) && (s = 0), s = s * T4, [t, F4(s) * e, $4(s) * e];
}, "lch2lab"), w2 = /* @__PURE__ */ h((...n) => {
  n = we(n, "lch");
  const [t, e, s] = n, [i, o, r] = HT(t, e, s), [a, l, c] = y2(i, o, r);
  return [a, l, c, n.length > 3 ? n[3] : 1];
}, "lch2rgb"), G4 = /* @__PURE__ */ h((...n) => {
  const t = UT(we(n, "hcl"));
  return w2(...t);
}, "hcl2rgb"), { sqrt: H4, atan2: j4, round: W4 } = Math, jT = /* @__PURE__ */ h((...n) => {
  const [t, e, s] = we(n, "lab"), i = H4(e * e + s * s);
  let o = (j4(s, e) * I4 + 360) % 360;
  return W4(i * 1e4) === 0 && (o = Number.NaN), [t, i, o];
}, "lab2lch"), S2 = /* @__PURE__ */ h((...n) => {
  const [t, e, s, ...i] = we(n, "rgb"), [o, r, a] = x2(t, e, s), [l, c, u] = jT(o, r, a);
  return [l, c, u, ...i.length > 0 && i[0] < 1 ? [i[0]] : []];
}, "rgb2lch");
xt.prototype.lch = function() {
  return S2(this._rgb);
};
xt.prototype.hcl = function() {
  return UT(S2(this._rgb));
};
const q4 = /* @__PURE__ */ h((...n) => new xt(...n, "lch"), "lch$1"), X4 = /* @__PURE__ */ h((...n) => new xt(...n, "hcl"), "hcl");
Object.assign(Ie, { lch: q4, hcl: X4 });
xe.format.lch = w2;
xe.format.hcl = G4;
["lch", "hcl"].forEach(
  (n) => xe.autodetect.push({
    p: 2,
    test: /* @__PURE__ */ h((...t) => {
      if (t = we(t, n), Ve(t) === "array" && t.length === 3)
        return n;
    }, "test")
  })
);
xt.prototype.saturate = function(n = 1) {
  const t = this, e = t.lch();
  return e[1] += js.Kn * n, e[1] < 0 && (e[1] = 0), new xt(e, "lch").alpha(t.alpha(), !0);
};
xt.prototype.desaturate = function(n = 1) {
  return this.saturate(-n);
};
xt.prototype.set = function(n, t, e = !1) {
  const [s, i] = n.split("."), o = this[s]();
  if (i) {
    const r = s.indexOf(i) - (s.substr(0, 2) === "ok" ? 2 : 0);
    if (r > -1) {
      if (Ve(t) == "string")
        switch (t.charAt(0)) {
          case "+":
            o[r] += +t;
            break;
          case "-":
            o[r] += +t;
            break;
          case "*":
            o[r] *= +t.substr(1);
            break;
          case "/":
            o[r] /= +t.substr(1);
            break;
          default:
            o[r] = +t;
        }
      else if (Ve(t) === "number")
        o[r] = t;
      else
        throw new Error("unsupported value for Color.set");
      const a = new xt(o, s);
      return e ? (this._rgb = a._rgb, this) : a;
    }
    throw new Error(`unknown channel ${i} in mode ${s}`);
  } else
    return o;
};
xt.prototype.tint = function(n = 0.5, ...t) {
  return Nc(this, "white", n, ...t);
};
xt.prototype.shade = function(n = 0.5, ...t) {
  return Nc(this, "black", n, ...t);
};
const Z4 = /* @__PURE__ */ h((n, t, e) => {
  const s = n._rgb, i = t._rgb;
  return new xt(
    s[0] + e * (i[0] - s[0]),
    s[1] + e * (i[1] - s[1]),
    s[2] + e * (i[2] - s[2]),
    "rgb"
  );
}, "rgb$1");
di.rgb = Z4;
const { sqrt: uf, pow: $a } = Math, Y4 = /* @__PURE__ */ h((n, t, e) => {
  const [s, i, o] = n._rgb, [r, a, l] = t._rgb;
  return new xt(
    uf($a(s, 2) * (1 - e) + $a(r, 2) * e),
    uf($a(i, 2) * (1 - e) + $a(a, 2) * e),
    uf($a(o, 2) * (1 - e) + $a(l, 2) * e),
    "rgb"
  );
}, "lrgb");
di.lrgb = Y4;
const J4 = /* @__PURE__ */ h((n, t, e) => {
  const s = n.lab(), i = t.lab();
  return new xt(
    s[0] + e * (i[0] - s[0]),
    s[1] + e * (i[1] - s[1]),
    s[2] + e * (i[2] - s[2]),
    "lab"
  );
}, "lab");
di.lab = J4;
const tl = /* @__PURE__ */ h((n, t, e, s) => {
  let i, o;
  s === "hsl" ? (i = n.hsl(), o = t.hsl()) : s === "hsv" ? (i = n.hsv(), o = t.hsv()) : s === "hcg" ? (i = n.hcg(), o = t.hcg()) : s === "hsi" ? (i = n.hsi(), o = t.hsi()) : s === "lch" || s === "hcl" ? (s = "hcl", i = n.hcl(), o = t.hcl()) : s === "oklch" && (i = n.oklch().reverse(), o = t.oklch().reverse());
  let r, a, l, c, u, m;
  (s.substr(0, 1) === "h" || s === "oklch") && ([r, l, u] = i, [a, c, m] = o);
  let d, f, p, v;
  return !isNaN(r) && !isNaN(a) ? (a > r && a - r > 180 ? v = a - (r + 360) : a < r && r - a > 180 ? v = a + 360 - r : v = a - r, f = r + e * v) : isNaN(r) ? isNaN(a) ? f = Number.NaN : (f = a, (u == 1 || u == 0) && s != "hsv" && (d = c)) : (f = r, (m == 1 || m == 0) && s != "hsv" && (d = l)), d === void 0 && (d = l + e * (c - l)), p = u + e * (m - u), s === "oklch" ? new xt([p, d, f], s) : new xt([f, d, p], s);
}, "interpolate_hsx"), WT = /* @__PURE__ */ h((n, t, e) => tl(n, t, e, "lch"), "lch");
di.lch = WT;
di.hcl = WT;
const K4 = /* @__PURE__ */ h((n) => {
  if (Ve(n) == "number" && n >= 0 && n <= 16777215) {
    const t = n >> 16, e = n >> 8 & 255, s = n & 255;
    return [t, e, s, 1];
  }
  throw new Error("unknown num color: " + n);
}, "num2rgb"), Q4 = /* @__PURE__ */ h((...n) => {
  const [t, e, s] = we(n, "rgb");
  return (t << 16) + (e << 8) + s;
}, "rgb2num");
xt.prototype.num = function() {
  return Q4(this._rgb);
};
const tD = /* @__PURE__ */ h((...n) => new xt(...n, "num"), "num$1");
Object.assign(Ie, { num: tD });
xe.format.num = K4;
xe.autodetect.push({
  p: 5,
  test: /* @__PURE__ */ h((...n) => {
    if (n.length === 1 && Ve(n[0]) === "number" && n[0] >= 0 && n[0] <= 16777215)
      return "num";
  }, "test")
});
const eD = /* @__PURE__ */ h((n, t, e) => {
  const s = n.num(), i = t.num();
  return new xt(s + e * (i - s), "num");
}, "num");
di.num = eD;
const { floor: nD } = Math, iD = /* @__PURE__ */ h((...n) => {
  n = we(n, "hcg");
  let [t, e, s] = n, i, o, r;
  s = s * 255;
  const a = e * 255;
  if (e === 0)
    i = o = r = s;
  else {
    t === 360 && (t = 0), t > 360 && (t -= 360), t < 0 && (t += 360), t /= 60;
    const l = nD(t), c = t - l, u = s * (1 - e), m = u + a * (1 - c), d = u + a * c, f = u + a;
    switch (l) {
      case 0:
        [i, o, r] = [f, d, u];
        break;
      case 1:
        [i, o, r] = [m, f, u];
        break;
      case 2:
        [i, o, r] = [u, f, d];
        break;
      case 3:
        [i, o, r] = [u, m, f];
        break;
      case 4:
        [i, o, r] = [d, u, f];
        break;
      case 5:
        [i, o, r] = [f, u, m];
        break;
    }
  }
  return [i, o, r, n.length > 3 ? n[3] : 1];
}, "hcg2rgb"), sD = /* @__PURE__ */ h((...n) => {
  const [t, e, s] = we(n, "rgb"), i = zT(t, e, s), o = kT(t, e, s), r = o - i, a = r * 100 / 255, l = i / (255 - r) * 100;
  let c;
  return r === 0 ? c = Number.NaN : (t === o && (c = (e - s) / r), e === o && (c = 2 + (s - t) / r), s === o && (c = 4 + (t - e) / r), c *= 60, c < 0 && (c += 360)), [c, a, l];
}, "rgb2hcg");
xt.prototype.hcg = function() {
  return sD(this._rgb);
};
const oD = /* @__PURE__ */ h((...n) => new xt(...n, "hcg"), "hcg$1");
Ie.hcg = oD;
xe.format.hcg = iD;
xe.autodetect.push({
  p: 1,
  test: /* @__PURE__ */ h((...n) => {
    if (n = we(n, "hcg"), Ve(n) === "array" && n.length === 3)
      return "hcg";
  }, "test")
});
const rD = /* @__PURE__ */ h((n, t, e) => tl(n, t, e, "hcg"), "hcg");
di.hcg = rD;
const { cos: Fa } = Math, aD = /* @__PURE__ */ h((...n) => {
  n = we(n, "hsi");
  let [t, e, s] = n, i, o, r;
  return isNaN(t) && (t = 0), isNaN(e) && (e = 0), t > 360 && (t -= 360), t < 0 && (t += 360), t /= 360, t < 1 / 3 ? (r = (1 - e) / 3, i = (1 + e * Fa(Mo * t) / Fa(rf - Mo * t)) / 3, o = 1 - (r + i)) : t < 2 / 3 ? (t -= 1 / 3, i = (1 - e) / 3, o = (1 + e * Fa(Mo * t) / Fa(rf - Mo * t)) / 3, r = 1 - (i + o)) : (t -= 2 / 3, o = (1 - e) / 3, r = (1 + e * Fa(Mo * t) / Fa(rf - Mo * t)) / 3, i = 1 - (o + r)), i = ua(s * i * 3), o = ua(s * o * 3), r = ua(s * r * 3), [i * 255, o * 255, r * 255, n.length > 3 ? n[3] : 1];
}, "hsi2rgb"), { min: cD, sqrt: lD, acos: uD } = Math, hD = /* @__PURE__ */ h((...n) => {
  let [t, e, s] = we(n, "rgb");
  t /= 255, e /= 255, s /= 255;
  let i;
  const o = cD(t, e, s), r = (t + e + s) / 3, a = r > 0 ? 1 - o / r : 0;
  return a === 0 ? i = NaN : (i = (t - e + (t - s)) / 2, i /= lD((t - e) * (t - e) + (t - s) * (e - s)), i = uD(i), s > e && (i = Mo - i), i /= Mo), [i * 360, a, r];
}, "rgb2hsi");
xt.prototype.hsi = function() {
  return hD(this._rgb);
};
const dD = /* @__PURE__ */ h((...n) => new xt(...n, "hsi"), "hsi$1");
Ie.hsi = dD;
xe.format.hsi = aD;
xe.autodetect.push({
  p: 2,
  test: /* @__PURE__ */ h((...n) => {
    if (n = we(n, "hsi"), Ve(n) === "array" && n.length === 3)
      return "hsi";
  }, "test")
});
const mD = /* @__PURE__ */ h((n, t, e) => tl(n, t, e, "hsi"), "hsi");
di.hsi = mD;
const Sp = /* @__PURE__ */ h((...n) => {
  n = we(n, "hsl");
  const [t, e, s] = n;
  let i, o, r;
  if (e === 0)
    i = o = r = s * 255;
  else {
    const a = [0, 0, 0], l = [0, 0, 0], c = s < 0.5 ? s * (1 + e) : s + e - s * e, u = 2 * s - c, m = t / 360;
    a[0] = m + 1 / 3, a[1] = m, a[2] = m - 1 / 3;
    for (let d = 0; d < 3; d++)
      a[d] < 0 && (a[d] += 1), a[d] > 1 && (a[d] -= 1), 6 * a[d] < 1 ? l[d] = u + (c - u) * 6 * a[d] : 2 * a[d] < 1 ? l[d] = c : 3 * a[d] < 2 ? l[d] = u + (c - u) * (2 / 3 - a[d]) * 6 : l[d] = u;
    [i, o, r] = [l[0] * 255, l[1] * 255, l[2] * 255];
  }
  return n.length > 3 ? [i, o, r, n[3]] : [i, o, r, 1];
}, "hsl2rgb"), qT = /* @__PURE__ */ h((...n) => {
  n = we(n, "rgba");
  let [t, e, s] = n;
  t /= 255, e /= 255, s /= 255;
  const i = zT(t, e, s), o = kT(t, e, s), r = (o + i) / 2;
  let a, l;
  return o === i ? (a = 0, l = Number.NaN) : a = r < 0.5 ? (o - i) / (o + i) : (o - i) / (2 - o - i), t == o ? l = (e - s) / (o - i) : e == o ? l = 2 + (s - t) / (o - i) : s == o && (l = 4 + (t - e) / (o - i)), l *= 60, l < 0 && (l += 360), n.length > 3 && n[3] !== void 0 ? [l, a, r, n[3]] : [l, a, r];
}, "rgb2hsl$1");
xt.prototype.hsl = function() {
  return qT(this._rgb);
};
const fD = /* @__PURE__ */ h((...n) => new xt(...n, "hsl"), "hsl$1");
Ie.hsl = fD;
xe.format.hsl = Sp;
xe.autodetect.push({
  p: 2,
  test: /* @__PURE__ */ h((...n) => {
    if (n = we(n, "hsl"), Ve(n) === "array" && n.length === 3)
      return "hsl";
  }, "test")
});
const pD = /* @__PURE__ */ h((n, t, e) => tl(n, t, e, "hsl"), "hsl");
di.hsl = pD;
const { floor: _D } = Math, gD = /* @__PURE__ */ h((...n) => {
  n = we(n, "hsv");
  let [t, e, s] = n, i, o, r;
  if (s *= 255, e === 0)
    i = o = r = s;
  else {
    t === 360 && (t = 0), t > 360 && (t -= 360), t < 0 && (t += 360), t /= 60;
    const a = _D(t), l = t - a, c = s * (1 - e), u = s * (1 - e * l), m = s * (1 - e * (1 - l));
    switch (a) {
      case 0:
        [i, o, r] = [s, m, c];
        break;
      case 1:
        [i, o, r] = [u, s, c];
        break;
      case 2:
        [i, o, r] = [c, s, m];
        break;
      case 3:
        [i, o, r] = [c, u, s];
        break;
      case 4:
        [i, o, r] = [m, c, s];
        break;
      case 5:
        [i, o, r] = [s, c, u];
        break;
    }
  }
  return [i, o, r, n.length > 3 ? n[3] : 1];
}, "hsv2rgb"), { min: vD, max: bD } = Math, yD = /* @__PURE__ */ h((...n) => {
  n = we(n, "rgb");
  let [t, e, s] = n;
  const i = vD(t, e, s), o = bD(t, e, s), r = o - i;
  let a, l, c;
  return c = o / 255, o === 0 ? (a = Number.NaN, l = 0) : (l = r / o, t === o && (a = (e - s) / r), e === o && (a = 2 + (s - t) / r), s === o && (a = 4 + (t - e) / r), a *= 60, a < 0 && (a += 360)), [a, l, c];
}, "rgb2hsl");
xt.prototype.hsv = function() {
  return yD(this._rgb);
};
const xD = /* @__PURE__ */ h((...n) => new xt(...n, "hsv"), "hsv$1");
Ie.hsv = xD;
xe.format.hsv = gD;
xe.autodetect.push({
  p: 2,
  test: /* @__PURE__ */ h((...n) => {
    if (n = we(n, "hsv"), Ve(n) === "array" && n.length === 3)
      return "hsv";
  }, "test")
});
const wD = /* @__PURE__ */ h((n, t, e) => tl(n, t, e, "hsv"), "hsv");
di.hsv = wD;
function Yh(n, t) {
  let e = n.length;
  Array.isArray(n[0]) || (n = [n]), Array.isArray(t[0]) || (t = t.map((r) => [r]));
  let s = t[0].length, i = t[0].map((r, a) => t.map((l) => l[a])), o = n.map(
    (r) => i.map((a) => Array.isArray(r) ? r.reduce((l, c, u) => l + c * (a[u] || 0), 0) : a.reduce((l, c) => l + c * r, 0))
  );
  return e === 1 && (o = o[0]), s === 1 ? o.map((r) => r[0]) : o;
}
h(Yh, "multiplyMatrices$1");
const A2 = /* @__PURE__ */ h((...n) => {
  n = we(n, "lab");
  const [t, e, s, ...i] = n, [o, r, a] = SD([t, e, s]), [l, c, u] = FT(o, r, a);
  return [l, c, u, ...i.length > 0 && i[0] < 1 ? [i[0]] : []];
}, "oklab2rgb");
function SD(n) {
  var t = [
    [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],
    [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],
    [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]
  ], e = [
    [1, 0.3963377773761749, 0.2158037573099136],
    [1, -0.1055613458156586, -0.0638541728258133],
    [1, -0.0894841775298119, -1.2914855480194092]
  ], s = Yh(e, n);
  return Yh(
    t,
    s.map((i) => i ** 3)
  );
}
h(SD, "OKLab_to_XYZ");
const M2 = /* @__PURE__ */ h((...n) => {
  const [t, e, s, ...i] = we(n, "rgb"), o = GT(t, e, s);
  return [...AD(o), ...i.length > 0 && i[0] < 1 ? [i[0]] : []];
}, "rgb2oklab");
function AD(n) {
  const t = [
    [0.819022437996703, 0.3619062600528904, -0.1288737815209879],
    [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],
    [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]
  ], e = [
    [0.210454268309314, 0.7936177747023054, -0.0040720430116193],
    [1.9779985324311684, -2.42859224204858, 0.450593709617411],
    [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]
  ], s = Yh(t, n);
  return Yh(
    e,
    s.map((i) => Math.cbrt(i))
  );
}
h(AD, "XYZ_to_OKLab");
xt.prototype.oklab = function() {
  return M2(this._rgb);
};
const MD = /* @__PURE__ */ h((...n) => new xt(...n, "oklab"), "oklab$1");
Object.assign(Ie, { oklab: MD });
xe.format.oklab = A2;
xe.autodetect.push({
  p: 2,
  test: /* @__PURE__ */ h((...n) => {
    if (n = we(n, "oklab"), Ve(n) === "array" && n.length === 3)
      return "oklab";
  }, "test")
});
const CD = /* @__PURE__ */ h((n, t, e) => {
  const s = n.oklab(), i = t.oklab();
  return new xt(
    s[0] + e * (i[0] - s[0]),
    s[1] + e * (i[1] - s[1]),
    s[2] + e * (i[2] - s[2]),
    "oklab"
  );
}, "oklab");
di.oklab = CD;
const ED = /* @__PURE__ */ h((n, t, e) => tl(n, t, e, "oklch"), "oklch$1");
di.oklch = ED;
const { pow: hf, sqrt: df, PI: mf, cos: kx, sin: Ux, atan2: TD } = Math, ID = /* @__PURE__ */ h((n, t = "lrgb", e = null) => {
  const s = n.length;
  e || (e = Array.from(new Array(s)).map(() => 1));
  const i = s / e.reduce(function(m, d) {
    return m + d;
  });
  if (e.forEach((m, d) => {
    e[d] *= i;
  }), n = n.map((m) => new xt(m)), t === "lrgb")
    return BD(n, e);
  const o = n.shift(), r = o.get(t), a = [];
  let l = 0, c = 0;
  for (let m = 0; m < r.length; m++)
    if (r[m] = (r[m] || 0) * e[0], a.push(isNaN(r[m]) ? 0 : e[0]), t.charAt(m) === "h" && !isNaN(r[m])) {
      const d = r[m] / 180 * mf;
      l += kx(d) * e[0], c += Ux(d) * e[0];
    }
  let u = o.alpha() * e[0];
  n.forEach((m, d) => {
    const f = m.get(t);
    u += m.alpha() * e[d + 1];
    for (let p = 0; p < r.length; p++)
      if (!isNaN(f[p]))
        if (a[p] += e[d + 1], t.charAt(p) === "h") {
          const v = f[p] / 180 * mf;
          l += kx(v) * e[d + 1], c += Ux(v) * e[d + 1];
        } else
          r[p] += f[p] * e[d + 1];
  });
  for (let m = 0; m < r.length; m++)
    if (t.charAt(m) === "h") {
      let d = TD(c / a[m], l / a[m]) / mf * 180;
      for (; d < 0; ) d += 360;
      for (; d >= 360; ) d -= 360;
      r[m] = d;
    } else
      r[m] = r[m] / a[m];
  return u /= s, new xt(r, t).alpha(u > 0.99999 ? 1 : u, !0);
}, "average"), BD = /* @__PURE__ */ h((n, t) => {
  const e = n.length, s = [0, 0, 0, 0];
  for (let i = 0; i < n.length; i++) {
    const o = n[i], r = t[i] / e, a = o._rgb;
    s[0] += hf(a[0], 2) * r, s[1] += hf(a[1], 2) * r, s[2] += hf(a[2], 2) * r, s[3] += a[3] * r;
  }
  return s[0] = df(s[0]), s[1] = df(s[1]), s[2] = df(s[2]), s[3] > 0.9999999 && (s[3] = 1), new xt(b2(s));
}, "_average_lrgb"), { pow: PD } = Math;
function Jh(n) {
  let t = "rgb", e = Ie("#ccc"), s = 0, i = [0, 1], o = [], r = [0, 0], a = !1, l = [], c = !1, u = 0, m = 1, d = !1, f = {}, p = !0, v = 1;
  const _ = /* @__PURE__ */ h(function(M) {
    if (M = M || ["#fff", "#000"], M && Ve(M) === "string" && Ie.brewer && Ie.brewer[M.toLowerCase()] && (M = Ie.brewer[M.toLowerCase()]), Ve(M) === "array") {
      M.length === 1 && (M = [M[0], M[0]]), M = M.slice(0);
      for (let T = 0; T < M.length; T++)
        M[T] = Ie(M[T]);
      o.length = 0;
      for (let T = 0; T < M.length; T++)
        o.push(T / (M.length - 1));
    }
    return A(), l = M;
  }, "setColors"), g = /* @__PURE__ */ h(function(M) {
    if (a != null) {
      const T = a.length - 1;
      let b = 0;
      for (; b < T && M >= a[b]; )
        b++;
      return b - 1;
    }
    return 0;
  }, "getClass");
  let w = /* @__PURE__ */ h((M) => M, "tMapLightness"), S = /* @__PURE__ */ h((M) => M, "tMapDomain");
  const x = /* @__PURE__ */ h(function(M, T) {
    let b, y;
    if (T == null && (T = !1), isNaN(M) || M === null)
      return e;
    T ? y = M : a && a.length > 2 ? y = g(M) / (a.length - 2) : m !== u ? y = (M - u) / (m - u) : y = 1, y = S(y), T || (y = w(y)), v !== 1 && (y = PD(y, v)), y = r[0] + y * (1 - r[0] - r[1]), y = ua(y, 0, 1);
    const E = Math.floor(y * 1e4);
    if (p && f[E])
      b = f[E];
    else {
      if (Ve(l) === "array")
        for (let I = 0; I < o.length; I++) {
          const B = o[I];
          if (y <= B) {
            b = l[I];
            break;
          }
          if (y >= B && I === o.length - 1) {
            b = l[I];
            break;
          }
          if (y > B && y < o[I + 1]) {
            y = (y - B) / (o[I + 1] - B), b = Ie.interpolate(
              l[I],
              l[I + 1],
              y,
              t
            );
            break;
          }
        }
      else Ve(l) === "function" && (b = l(y));
      p && (f[E] = b);
    }
    return b;
  }, "getColor");
  var A = /* @__PURE__ */ h(() => f = {}, "resetCache");
  _(n);
  const C = /* @__PURE__ */ h(function(M) {
    const T = Ie(x(M));
    return c && T[c] ? T[c]() : T;
  }, "f");
  return C.classes = function(M) {
    if (M != null) {
      if (Ve(M) === "array")
        a = M, i = [M[0], M[M.length - 1]];
      else {
        const T = Ie.analyze(i);
        M === 0 ? a = [T.min, T.max] : a = Ie.limits(T, "e", M);
      }
      return C;
    }
    return a;
  }, C.domain = function(M) {
    if (!arguments.length)
      return i;
    u = M[0], m = M[M.length - 1], o = [];
    const T = l.length;
    if (M.length === T && u !== m)
      for (let b of Array.from(M))
        o.push((b - u) / (m - u));
    else {
      for (let b = 0; b < T; b++)
        o.push(b / (T - 1));
      if (M.length > 2) {
        const b = M.map((E, I) => I / (M.length - 1)), y = M.map((E) => (E - u) / (m - u));
        y.every((E, I) => b[I] === E) || (S = /* @__PURE__ */ h((E) => {
          if (E <= 0 || E >= 1) return E;
          let I = 0;
          for (; E >= y[I + 1]; ) I++;
          const B = (E - y[I]) / (y[I + 1] - y[I]);
          return b[I] + B * (b[I + 1] - b[I]);
        }, "tMapDomain"));
      }
    }
    return i = [u, m], C;
  }, C.mode = function(M) {
    return arguments.length ? (t = M, A(), C) : t;
  }, C.range = function(M, T) {
    return _(M), C;
  }, C.out = function(M) {
    return c = M, C;
  }, C.spread = function(M) {
    return arguments.length ? (s = M, C) : s;
  }, C.correctLightness = function(M) {
    return M == null && (M = !0), d = M, A(), d ? w = /* @__PURE__ */ h(function(T) {
      const b = x(0, !0).lab()[0], y = x(1, !0).lab()[0], E = b > y;
      let I = x(T, !0).lab()[0];
      const B = b + (y - b) * T;
      let D = I - B, N = 0, V = 1, G = 20;
      for (; Math.abs(D) > 0.01 && G-- > 0; )
        (function() {
          return E && (D *= -1), D < 0 ? (N = T, T += (V - T) * 0.5) : (V = T, T += (N - T) * 0.5), I = x(T, !0).lab()[0], D = I - B;
        })();
      return T;
    }, "tMapLightness") : w = /* @__PURE__ */ h((T) => T, "tMapLightness"), C;
  }, C.padding = function(M) {
    return M != null ? (Ve(M) === "number" && (M = [M, M]), r = M, C) : r;
  }, C.colors = function(M, T) {
    arguments.length < 2 && (T = "hex");
    let b = [];
    if (arguments.length === 0)
      b = l.slice(0);
    else if (M === 1)
      b = [C(0.5)];
    else if (M > 1) {
      const y = i[0], E = i[1] - y;
      b = RD(0, M).map(
        (I) => C(y + I / (M - 1) * E)
      );
    } else {
      n = [];
      let y = [];
      if (a && a.length > 2)
        for (let E = 1, I = a.length, B = 1 <= I; B ? E < I : E > I; B ? E++ : E--)
          y.push((a[E - 1] + a[E]) * 0.5);
      else
        y = i;
      b = y.map((E) => C(E));
    }
    return Ie[T] && (b = b.map((y) => y[T]())), b;
  }, C.cache = function(M) {
    return M != null ? (p = M, C) : p;
  }, C.gamma = function(M) {
    return M != null ? (v = M, C) : v;
  }, C.nodata = function(M) {
    return M != null ? (e = Ie(M), C) : e;
  }, C;
}
h(Jh, "scale");
function RD(n, t, e) {
  let s = [], i = n < t, o = t;
  for (let r = n; i ? r < o : r > o; i ? r++ : r--)
    s.push(r);
  return s;
}
h(RD, "__range__");
const DD = /* @__PURE__ */ h(function(n) {
  let t = [1, 1];
  for (let e = 1; e < n; e++) {
    let s = [1];
    for (let i = 1; i <= t.length; i++)
      s[i] = (t[i] || 0) + t[i - 1];
    t = s;
  }
  return t;
}, "binom_row"), VD = /* @__PURE__ */ h(function(n) {
  let t, e, s, i;
  if (n = n.map((o) => new xt(o)), n.length === 2)
    [e, s] = n.map((o) => o.lab()), t = /* @__PURE__ */ h(function(o) {
      const r = [0, 1, 2].map((a) => e[a] + o * (s[a] - e[a]));
      return new xt(r, "lab");
    }, "I");
  else if (n.length === 3)
    [e, s, i] = n.map((o) => o.lab()), t = /* @__PURE__ */ h(function(o) {
      const r = [0, 1, 2].map(
        (a) => (1 - o) * (1 - o) * e[a] + 2 * (1 - o) * o * s[a] + o * o * i[a]
      );
      return new xt(r, "lab");
    }, "I");
  else if (n.length === 4) {
    let o;
    [e, s, i, o] = n.map((r) => r.lab()), t = /* @__PURE__ */ h(function(r) {
      const a = [0, 1, 2].map(
        (l) => (1 - r) * (1 - r) * (1 - r) * e[l] + 3 * (1 - r) * (1 - r) * r * s[l] + 3 * (1 - r) * r * r * i[l] + r * r * r * o[l]
      );
      return new xt(a, "lab");
    }, "I");
  } else if (n.length >= 5) {
    let o, r, a;
    o = n.map((l) => l.lab()), a = n.length - 1, r = DD(a), t = /* @__PURE__ */ h(function(l) {
      const c = 1 - l, u = [0, 1, 2].map(
        (m) => o.reduce(
          (d, f, p) => d + r[p] * c ** (a - p) * l ** p * f[m],
          0
        )
      );
      return new xt(u, "lab");
    }, "I");
  } else
    throw new RangeError("No point in running bezier with only one color.");
  return t;
}, "bezier"), LD = /* @__PURE__ */ h((n) => {
  const t = VD(n);
  return t.scale = () => Jh(t), t;
}, "bezier$1"), { round: XT } = Math;
xt.prototype.rgb = function(n = !0) {
  return n === !1 ? this._rgb.slice(0, 3) : this._rgb.slice(0, 3).map(XT);
};
xt.prototype.rgba = function(n = !0) {
  return this._rgb.slice(0, 4).map((t, e) => e < 3 ? n === !1 ? t : XT(t) : t);
};
const ND = /* @__PURE__ */ h((...n) => new xt(...n, "rgb"), "rgb");
Object.assign(Ie, { rgb: ND });
xe.format.rgb = (...n) => {
  const t = we(n, "rgba");
  return t[3] === void 0 && (t[3] = 1), t;
};
xe.autodetect.push({
  p: 3,
  test: /* @__PURE__ */ h((...n) => {
    if (n = we(n, "rgba"), Ve(n) === "array" && (n.length === 3 || n.length === 4 && Ve(n[3]) == "number" && n[3] >= 0 && n[3] <= 1))
      return "rgb";
  }, "test")
});
const Bs = /* @__PURE__ */ h((n, t, e) => {
  if (!Bs[e])
    throw new Error("unknown blend mode " + e);
  return Bs[e](n, t);
}, "blend"), Er = /* @__PURE__ */ h((n) => (t, e) => {
  const s = Ie(e).rgb(), i = Ie(t).rgb();
  return Ie.rgb(n(s, i));
}, "blend_f"), Tr = /* @__PURE__ */ h((n) => (t, e) => {
  const s = [];
  return s[0] = n(t[0], e[0]), s[1] = n(t[1], e[1]), s[2] = n(t[2], e[2]), s;
}, "each"), zD = /* @__PURE__ */ h((n) => n, "normal"), kD = /* @__PURE__ */ h((n, t) => n * t / 255, "multiply"), UD = /* @__PURE__ */ h((n, t) => n > t ? t : n, "darken"), OD = /* @__PURE__ */ h((n, t) => n > t ? n : t, "lighten"), $D = /* @__PURE__ */ h((n, t) => 255 * (1 - (1 - n / 255) * (1 - t / 255)), "screen"), FD = /* @__PURE__ */ h((n, t) => t < 128 ? 2 * n * t / 255 : 255 * (1 - 2 * (1 - n / 255) * (1 - t / 255)), "overlay"), GD = /* @__PURE__ */ h((n, t) => 255 * (1 - (1 - t / 255) / (n / 255)), "burn"), HD = /* @__PURE__ */ h((n, t) => n === 255 ? 255 : (n = 255 * (t / 255) / (1 - n / 255), n > 255 ? 255 : n), "dodge");
Bs.normal = Er(Tr(zD));
Bs.multiply = Er(Tr(kD));
Bs.screen = Er(Tr($D));
Bs.overlay = Er(Tr(FD));
Bs.darken = Er(Tr(UD));
Bs.lighten = Er(Tr(OD));
Bs.dodge = Er(Tr(HD));
Bs.burn = Er(Tr(GD));
const { pow: jD, sin: WD, cos: qD } = Math;
function XD(n = 300, t = -1.5, e = 1, s = 1, i = [0, 1]) {
  let o = 0, r;
  Ve(i) === "array" ? r = i[1] - i[0] : (r = 0, i = [i, i]);
  const a = /* @__PURE__ */ h(function(l) {
    const c = Mo * ((n + 120) / 360 + t * l), u = jD(i[0] + r * l, s), d = (o !== 0 ? e[0] + l * o : e) * u * (1 - u) / 2, f = qD(c), p = WD(c), v = u + d * (-0.14861 * f + 1.78277 * p), _ = u + d * (-0.29227 * f - 0.90649 * p), g = u + d * (1.97294 * f);
    return Ie(b2([v * 255, _ * 255, g * 255, 1]));
  }, "f");
  return a.start = function(l) {
    return l == null ? n : (n = l, a);
  }, a.rotations = function(l) {
    return l == null ? t : (t = l, a);
  }, a.gamma = function(l) {
    return l == null ? s : (s = l, a);
  }, a.hue = function(l) {
    return l == null ? e : (e = l, Ve(e) === "array" ? (o = e[1] - e[0], o === 0 && (e = e[1])) : o = 0, a);
  }, a.lightness = function(l) {
    return l == null ? i : (Ve(l) === "array" ? (i = l, r = l[1] - l[0]) : (i = [l, l], r = 0), a);
  }, a.scale = () => Ie.scale(a), a.hue(e), a;
}
h(XD, "cubehelix");
const ZD = "0123456789abcdef", { floor: YD, random: JD } = Math, KD = /* @__PURE__ */ h(() => {
  let n = "#";
  for (let t = 0; t < 6; t++)
    n += ZD.charAt(YD(JD() * 16));
  return new xt(n, "hex");
}, "random$1"), { log: Ox, pow: QD, floor: tV, abs: eV } = Math;
function ZT(n, t = null) {
  const e = {
    min: Number.MAX_VALUE,
    max: Number.MAX_VALUE * -1,
    sum: 0,
    values: [],
    count: 0
  };
  return Ve(n) === "object" && (n = Object.values(n)), n.forEach((s) => {
    t && Ve(s) === "object" && (s = s[t]), s != null && !isNaN(s) && (e.values.push(s), e.sum += s, s < e.min && (e.min = s), s > e.max && (e.max = s), e.count += 1);
  }), e.domain = [e.min, e.max], e.limits = (s, i) => YT(e, s, i), e;
}
h(ZT, "analyze");
function YT(n, t = "equal", e = 7) {
  Ve(n) == "array" && (n = ZT(n));
  const { min: s, max: i } = n, o = n.values.sort((a, l) => a - l);
  if (e === 1)
    return [s, i];
  const r = [];
  if (t.substr(0, 1) === "c" && (r.push(s), r.push(i)), t.substr(0, 1) === "e") {
    r.push(s);
    for (let a = 1; a < e; a++)
      r.push(s + a / e * (i - s));
    r.push(i);
  } else if (t.substr(0, 1) === "l") {
    if (s <= 0)
      throw new Error(
        "Logarithmic scales are only possible for values > 0"
      );
    const a = Math.LOG10E * Ox(s), l = Math.LOG10E * Ox(i);
    r.push(s);
    for (let c = 1; c < e; c++)
      r.push(QD(10, a + c / e * (l - a)));
    r.push(i);
  } else if (t.substr(0, 1) === "q") {
    r.push(s);
    for (let a = 1; a < e; a++) {
      const l = (o.length - 1) * a / e, c = tV(l);
      if (c === l)
        r.push(o[c]);
      else {
        const u = l - c;
        r.push(o[c] * (1 - u) + o[c + 1] * u);
      }
    }
    r.push(i);
  } else if (t.substr(0, 1) === "k") {
    let a;
    const l = o.length, c = new Array(l), u = new Array(e);
    let m = !0, d = 0, f = null;
    f = [], f.push(s);
    for (let _ = 1; _ < e; _++)
      f.push(s + _ / e * (i - s));
    for (f.push(i); m; ) {
      for (let g = 0; g < e; g++)
        u[g] = 0;
      for (let g = 0; g < l; g++) {
        const w = o[g];
        let S = Number.MAX_VALUE, x;
        for (let A = 0; A < e; A++) {
          const C = eV(f[A] - w);
          C < S && (S = C, x = A), u[x]++, c[g] = x;
        }
      }
      const _ = new Array(e);
      for (let g = 0; g < e; g++)
        _[g] = null;
      for (let g = 0; g < l; g++)
        a = c[g], _[a] === null ? _[a] = o[g] : _[a] += o[g];
      for (let g = 0; g < e; g++)
        _[g] *= 1 / u[g];
      m = !1;
      for (let g = 0; g < e; g++)
        if (_[g] !== f[g]) {
          m = !0;
          break;
        }
      f = _, d++, d > 200 && (m = !1);
    }
    const p = {};
    for (let _ = 0; _ < e; _++)
      p[_] = [];
    for (let _ = 0; _ < l; _++)
      a = c[_], p[a].push(o[_]);
    let v = [];
    for (let _ = 0; _ < e; _++)
      v.push(p[_][0]), v.push(p[_][p[_].length - 1]);
    v = v.sort((_, g) => _ - g), r.push(v[0]);
    for (let _ = 1; _ < v.length; _ += 2) {
      const g = v[_];
      !isNaN(g) && r.indexOf(g) === -1 && r.push(g);
    }
  }
  return r;
}
h(YT, "limits");
const nV = /* @__PURE__ */ h((n, t) => {
  n = new xt(n), t = new xt(t);
  const e = n.luminance(), s = t.luminance();
  return e > s ? (e + 0.05) / (s + 0.05) : (s + 0.05) / (e + 0.05);
}, "contrast"), $x = 0.027, iV = 5e-4, sV = 0.1, Fx = 1.14, Zu = 0.022, Gx = 1.414, oV = /* @__PURE__ */ h((n, t) => {
  n = new xt(n), t = new xt(t), n.alpha() < 1 && (n = Nc(t, n, n.alpha(), "rgb"));
  const e = Hx(...n.rgb()), s = Hx(...t.rgb()), i = e >= Zu ? e : e + Math.pow(Zu - e, Gx), o = s >= Zu ? s : s + Math.pow(Zu - s, Gx), r = Math.pow(o, 0.56) - Math.pow(i, 0.57), a = Math.pow(o, 0.65) - Math.pow(i, 0.62), l = Math.abs(o - i) < iV ? 0 : i < o ? r * Fx : a * Fx;
  return (Math.abs(l) < sV ? 0 : l > 0 ? l - $x : l + $x) * 100;
}, "contrastAPCA");
function Hx(n, t, e) {
  return 0.2126729 * Math.pow(n / 255, 2.4) + 0.7151522 * Math.pow(t / 255, 2.4) + 0.072175 * Math.pow(e / 255, 2.4);
}
h(Hx, "lum");
const { sqrt: oo, pow: Un, min: rV, max: aV, atan2: jx, abs: Wx, cos: Yu, sin: qx, exp: cV, PI: Xx } = Math;
function lV(n, t, e = 1, s = 1, i = 1) {
  var o = /* @__PURE__ */ h(function(lt) {
    return 360 * lt / (2 * Xx);
  }, "rad2deg"), r = /* @__PURE__ */ h(function(lt) {
    return 2 * Xx * lt / 360;
  }, "deg2rad");
  n = new xt(n), t = new xt(t);
  const [a, l, c] = Array.from(n.lab()), [u, m, d] = Array.from(t.lab()), f = (a + u) / 2, p = oo(Un(l, 2) + Un(c, 2)), v = oo(Un(m, 2) + Un(d, 2)), _ = (p + v) / 2, g = 0.5 * (1 - oo(Un(_, 7) / (Un(_, 7) + Un(25, 7)))), w = l * (1 + g), S = m * (1 + g), x = oo(Un(w, 2) + Un(c, 2)), A = oo(Un(S, 2) + Un(d, 2)), C = (x + A) / 2, M = o(jx(c, w)), T = o(jx(d, S)), b = M >= 0 ? M : M + 360, y = T >= 0 ? T : T + 360, E = Wx(b - y) > 180 ? (b + y + 360) / 2 : (b + y) / 2, I = 1 - 0.17 * Yu(r(E - 30)) + 0.24 * Yu(r(2 * E)) + 0.32 * Yu(r(3 * E + 6)) - 0.2 * Yu(r(4 * E - 63));
  let B = y - b;
  B = Wx(B) <= 180 ? B : y <= b ? B + 360 : B - 360, B = 2 * oo(x * A) * qx(r(B) / 2);
  const D = u - a, N = A - x, V = 1 + 0.015 * Un(f - 50, 2) / oo(20 + Un(f - 50, 2)), G = 1 + 0.045 * C, U = 1 + 0.015 * C * I, j = 30 * cV(-Un((E - 275) / 25, 2)), K = -(2 * oo(Un(C, 7) / (Un(C, 7) + Un(25, 7)))) * qx(2 * r(j)), $ = oo(
    Un(D / (e * V), 2) + Un(N / (s * G), 2) + Un(B / (i * U), 2) + K * (N / (s * G)) * (B / (i * U))
  );
  return aV(0, rV(100, $));
}
h(lV, "deltaE");
function uV(n, t, e = "lab") {
  n = new xt(n), t = new xt(t);
  const s = n.get(e), i = t.get(e);
  let o = 0;
  for (let r in s) {
    const a = (s[r] || 0) - (i[r] || 0);
    o += a * a;
  }
  return Math.sqrt(o);
}
h(uV, "distance");
const hV = /* @__PURE__ */ h((...n) => {
  try {
    return new xt(...n), !0;
  } catch {
    return !1;
  }
}, "valid"), dV = {
  cool() {
    return Jh([Ie.hsl(180, 1, 0.9), Ie.hsl(250, 0.7, 0.4)]);
  },
  hot() {
    return Jh(["#000", "#f00", "#ff0", "#fff"]).mode(
      "rgb"
    );
  }
}, Ap = {
  OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
  PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
  BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
  Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
  BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
  YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
  YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
  Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
  RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
  Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
  YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
  Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
  GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
  Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
  YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
  PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
  Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
  PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
  Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
  Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
  RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
  RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
  PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
  PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
  RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
  BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
  RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
  PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
  Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
  Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
  Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
  Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
  Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
  Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
  Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
  Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
}, JT = Object.keys(Ap), Zx = new Map(JT.map((n) => [n.toLowerCase(), n])), mV = typeof Proxy == "function" ? new Proxy(Ap, {
  get(n, t) {
    const e = t.toLowerCase();
    if (Zx.has(e))
      return n[Zx.get(e)];
  },
  getOwnPropertyNames() {
    return Object.getOwnPropertyNames(JT);
  }
}) : Ap, fV = /* @__PURE__ */ h((...n) => {
  n = we(n, "cmyk");
  const [t, e, s, i] = n, o = n.length > 4 ? n[4] : 1;
  return i === 1 ? [0, 0, 0, o] : [
    t >= 1 ? 0 : 255 * (1 - t) * (1 - i),
    e >= 1 ? 0 : 255 * (1 - e) * (1 - i),
    s >= 1 ? 0 : 255 * (1 - s) * (1 - i),
    o
  ];
}, "cmyk2rgb"), { max: Yx } = Math, pV = /* @__PURE__ */ h((...n) => {
  let [t, e, s] = we(n, "rgb");
  t = t / 255, e = e / 255, s = s / 255;
  const i = 1 - Yx(t, Yx(e, s)), o = i < 1 ? 1 / (1 - i) : 0, r = (1 - t - i) * o, a = (1 - e - i) * o, l = (1 - s - i) * o;
  return [r, a, l, i];
}, "rgb2cmyk");
xt.prototype.cmyk = function() {
  return pV(this._rgb);
};
const _V = /* @__PURE__ */ h((...n) => new xt(...n, "cmyk"), "cmyk");
Object.assign(Ie, { cmyk: _V });
xe.format.cmyk = fV;
xe.autodetect.push({
  p: 2,
  test: /* @__PURE__ */ h((...n) => {
    if (n = we(n, "cmyk"), Ve(n) === "array" && n.length === 4)
      return "cmyk";
  }, "test")
});
const gV = /* @__PURE__ */ h((...n) => {
  const t = we(n, "hsla");
  let e = Qc(n) || "lsa";
  return t[0] = hs(t[0] || 0) + "deg", t[1] = hs(t[1] * 100) + "%", t[2] = hs(t[2] * 100) + "%", e === "hsla" || t.length > 3 && t[3] < 1 ? (t[3] = "/ " + (t.length > 3 ? t[3] : 1), e = "hsla") : t.length = 3, `${e.substr(0, 3)}(${t.join(" ")})`;
}, "hsl2css"), vV = /* @__PURE__ */ h((...n) => {
  const t = we(n, "lab");
  let e = Qc(n) || "lab";
  return t[0] = hs(t[0]) + "%", t[1] = hs(t[1]), t[2] = hs(t[2]), e === "laba" || t.length > 3 && t[3] < 1 ? t[3] = "/ " + (t.length > 3 ? t[3] : 1) : t.length = 3, `lab(${t.join(" ")})`;
}, "lab2css"), bV = /* @__PURE__ */ h((...n) => {
  const t = we(n, "lch");
  let e = Qc(n) || "lab";
  return t[0] = hs(t[0]) + "%", t[1] = hs(t[1]), t[2] = isNaN(t[2]) ? "none" : hs(t[2]) + "deg", e === "lcha" || t.length > 3 && t[3] < 1 ? t[3] = "/ " + (t.length > 3 ? t[3] : 1) : t.length = 3, `lch(${t.join(" ")})`;
}, "lch2css"), yV = /* @__PURE__ */ h((...n) => {
  const t = we(n, "lab");
  return t[0] = hs(t[0] * 100) + "%", t[1] = wp(t[1]), t[2] = wp(t[2]), t.length > 3 && t[3] < 1 ? t[3] = "/ " + (t.length > 3 ? t[3] : 1) : t.length = 3, `oklab(${t.join(" ")})`;
}, "oklab2css"), KT = /* @__PURE__ */ h((...n) => {
  const [t, e, s, ...i] = we(n, "rgb"), [o, r, a] = M2(t, e, s), [l, c, u] = jT(o, r, a);
  return [l, c, u, ...i.length > 0 && i[0] < 1 ? [i[0]] : []];
}, "rgb2oklch"), xV = /* @__PURE__ */ h((...n) => {
  const t = we(n, "lch");
  return t[0] = hs(t[0] * 100) + "%", t[1] = wp(t[1]), t[2] = isNaN(t[2]) ? "none" : hs(t[2]) + "deg", t.length > 3 && t[3] < 1 ? t[3] = "/ " + (t.length > 3 ? t[3] : 1) : t.length = 3, `oklch(${t.join(" ")})`;
}, "oklch2css"), { round: ff } = Math, wV = /* @__PURE__ */ h((...n) => {
  const t = we(n, "rgba");
  let e = Qc(n) || "rgb";
  if (e.substr(0, 3) === "hsl")
    return gV(qT(t), e);
  if (e.substr(0, 3) === "lab") {
    const s = tu();
    Po("d50");
    const i = vV(x2(t), e);
    return Po(s), i;
  }
  if (e.substr(0, 3) === "lch") {
    const s = tu();
    Po("d50");
    const i = bV(S2(t), e);
    return Po(s), i;
  }
  return e.substr(0, 5) === "oklab" ? yV(M2(t)) : e.substr(0, 5) === "oklch" ? xV(KT(t)) : (t[0] = ff(t[0]), t[1] = ff(t[1]), t[2] = ff(t[2]), (e === "rgba" || t.length > 3 && t[3] < 1) && (t[3] = "/ " + (t.length > 3 ? t[3] : 1), e = "rgba"), `${e.substr(0, 3)}(${t.slice(0, e === "rgb" ? 3 : 4).join(" ")})`);
}, "rgb2css"), QT = /* @__PURE__ */ h((...n) => {
  n = we(n, "lch");
  const [t, e, s, ...i] = n, [o, r, a] = HT(t, e, s), [l, c, u] = A2(o, r, a);
  return [l, c, u, ...i.length > 0 && i[0] < 1 ? [i[0]] : []];
}, "oklch2rgb"), Do = /((?:-?\d+)|(?:-?\d+(?:\.\d+)?)%|none)/.source, Es = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)%?)|none)/.source, Kh = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)%)|none)/.source, ms = /\s*/.source, el = /\s+/.source, C2 = /\s*,\s*/.source, Nm = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)(?:deg)?)|none)/.source, nl = /\s*(?:\/\s*((?:[01]|[01]?\.\d+)|\d+(?:\.\d+)?%))?/.source, t3 = new RegExp(
  "^rgba?\\(" + ms + [Do, Do, Do].join(el) + nl + "\\)$"
), e3 = new RegExp(
  "^rgb\\(" + ms + [Do, Do, Do].join(C2) + ms + "\\)$"
), n3 = new RegExp(
  "^rgba\\(" + ms + [Do, Do, Do, Es].join(C2) + ms + "\\)$"
), i3 = new RegExp(
  "^hsla?\\(" + ms + [Nm, Kh, Kh].join(el) + nl + "\\)$"
), s3 = new RegExp(
  "^hsl?\\(" + ms + [Nm, Kh, Kh].join(C2) + ms + "\\)$"
), o3 = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/, r3 = new RegExp(
  "^lab\\(" + ms + [Es, Es, Es].join(el) + nl + "\\)$"
), a3 = new RegExp(
  "^lch\\(" + ms + [Es, Es, Nm].join(el) + nl + "\\)$"
), c3 = new RegExp(
  "^oklab\\(" + ms + [Es, Es, Es].join(el) + nl + "\\)$"
), l3 = new RegExp(
  "^oklch\\(" + ms + [Es, Es, Nm].join(el) + nl + "\\)$"
), { round: u3 } = Math, Ga = /* @__PURE__ */ h((n) => n.map((t, e) => e <= 2 ? ua(u3(t), 0, 255) : t), "roundRGB"), On = /* @__PURE__ */ h((n, t = 0, e = 100, s = !1) => (typeof n == "string" && n.endsWith("%") && (n = parseFloat(n.substring(0, n.length - 1)) / 100, s ? n = t + (n + 1) * 0.5 * (e - t) : n = t + n * (e - t)), +n), "percentToAbsolute"), _i = /* @__PURE__ */ h((n, t) => n === "none" ? t : n, "noneToValue"), E2 = /* @__PURE__ */ h((n) => {
  if (n = n.toLowerCase().trim(), n === "transparent")
    return [0, 0, 0, 0];
  let t;
  if (xe.format.named)
    try {
      return xe.format.named(n);
    } catch {
    }
  if ((t = n.match(t3)) || (t = n.match(e3))) {
    let e = t.slice(1, 4);
    for (let i = 0; i < 3; i++)
      e[i] = +On(_i(e[i], 0), 0, 255);
    e = Ga(e);
    const s = t[4] !== void 0 ? +On(t[4], 0, 1) : 1;
    return e[3] = s, e;
  }
  if (t = n.match(n3)) {
    const e = t.slice(1, 5);
    for (let s = 0; s < 4; s++)
      e[s] = +On(e[s], 0, 255);
    return e;
  }
  if ((t = n.match(i3)) || (t = n.match(s3))) {
    const e = t.slice(1, 4);
    e[0] = +_i(e[0].replace("deg", ""), 0), e[1] = +On(_i(e[1], 0), 0, 100) * 0.01, e[2] = +On(_i(e[2], 0), 0, 100) * 0.01;
    const s = Ga(Sp(e)), i = t[4] !== void 0 ? +On(t[4], 0, 1) : 1;
    return s[3] = i, s;
  }
  if (t = n.match(o3)) {
    const e = t.slice(1, 4);
    e[1] *= 0.01, e[2] *= 0.01;
    const s = Sp(e);
    for (let i = 0; i < 3; i++)
      s[i] = u3(s[i]);
    return s[3] = +t[4], s;
  }
  if (t = n.match(r3)) {
    const e = t.slice(1, 4);
    e[0] = On(_i(e[0], 0), 0, 100), e[1] = On(_i(e[1], 0), -125, 125, !0), e[2] = On(_i(e[2], 0), -125, 125, !0);
    const s = tu();
    Po("d50");
    const i = Ga(y2(e));
    Po(s);
    const o = t[4] !== void 0 ? +On(t[4], 0, 1) : 1;
    return i[3] = o, i;
  }
  if (t = n.match(a3)) {
    const e = t.slice(1, 4);
    e[0] = On(e[0], 0, 100), e[1] = On(_i(e[1], 0), 0, 150, !1), e[2] = +_i(e[2].replace("deg", ""), 0);
    const s = tu();
    Po("d50");
    const i = Ga(w2(e));
    Po(s);
    const o = t[4] !== void 0 ? +On(t[4], 0, 1) : 1;
    return i[3] = o, i;
  }
  if (t = n.match(c3)) {
    const e = t.slice(1, 4);
    e[0] = On(_i(e[0], 0), 0, 1), e[1] = On(_i(e[1], 0), -0.4, 0.4, !0), e[2] = On(_i(e[2], 0), -0.4, 0.4, !0);
    const s = Ga(A2(e)), i = t[4] !== void 0 ? +On(t[4], 0, 1) : 1;
    return s[3] = i, s;
  }
  if (t = n.match(l3)) {
    const e = t.slice(1, 4);
    e[0] = On(_i(e[0], 0), 0, 1), e[1] = On(_i(e[1], 0), 0, 0.4, !1), e[2] = +_i(e[2].replace("deg", ""), 0);
    const s = Ga(QT(e)), i = t[4] !== void 0 ? +On(t[4], 0, 1) : 1;
    return s[3] = i, s;
  }
}, "css2rgb");
E2.test = (n) => t3.test(n) || i3.test(n) || r3.test(n) || a3.test(n) || c3.test(n) || l3.test(n) || e3.test(n) || n3.test(n) || s3.test(n) || o3.test(n) || n === "transparent";
xt.prototype.css = function(n) {
  return wV(this._rgb, n);
};
const SV = /* @__PURE__ */ h((...n) => new xt(...n, "css"), "css");
Ie.css = SV;
xe.format.css = E2;
xe.autodetect.push({
  p: 5,
  test: /* @__PURE__ */ h((n, ...t) => {
    if (!t.length && Ve(n) === "string" && E2.test(n))
      return "css";
  }, "test")
});
xe.format.gl = (...n) => {
  const t = we(n, "rgba");
  return t[0] *= 255, t[1] *= 255, t[2] *= 255, t;
};
const AV = /* @__PURE__ */ h((...n) => new xt(...n, "gl"), "gl");
Ie.gl = AV;
xt.prototype.gl = function() {
  const n = this._rgb;
  return [n[0] / 255, n[1] / 255, n[2] / 255, n[3]];
};
xt.prototype.hex = function(n) {
  return $T(this._rgb, n);
};
const MV = /* @__PURE__ */ h((...n) => new xt(...n, "hex"), "hex");
Ie.hex = MV;
xe.format.hex = OT;
xe.autodetect.push({
  p: 4,
  test: /* @__PURE__ */ h((n, ...t) => {
    if (!t.length && Ve(n) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(n.length) >= 0)
      return "hex";
  }, "test")
});
const { log: Ju } = Math, h3 = /* @__PURE__ */ h((n) => {
  const t = n / 100;
  let e, s, i;
  return t < 66 ? (e = 255, s = t < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (s = t - 2) + 104.49216199393888 * Ju(s), i = t < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (i = t - 10) + 115.67994401066147 * Ju(i)) : (e = 351.97690566805693 + 0.114206453784165 * (e = t - 55) - 40.25366309332127 * Ju(e), s = 325.4494125711974 + 0.07943456536662342 * (s = t - 50) - 28.0852963507957 * Ju(s), i = 255), [e, s, i, 1];
}, "temperature2rgb"), { round: CV } = Math, EV = /* @__PURE__ */ h((...n) => {
  const t = we(n, "rgb"), e = t[0], s = t[2];
  let i = 1e3, o = 4e4;
  const r = 0.4;
  let a;
  for (; o - i > r; ) {
    a = (o + i) * 0.5;
    const l = h3(a);
    l[2] / l[0] >= s / e ? o = a : i = a;
  }
  return CV(a);
}, "rgb2temperature");
xt.prototype.temp = xt.prototype.kelvin = xt.prototype.temperature = function() {
  return EV(this._rgb);
};
const pf = /* @__PURE__ */ h((...n) => new xt(...n, "temp"), "temp$f");
Object.assign(Ie, { temp: pf, kelvin: pf, temperature: pf });
xe.format.temp = xe.format.kelvin = xe.format.temperature = h3;
xt.prototype.oklch = function() {
  return KT(this._rgb);
};
const TV = /* @__PURE__ */ h((...n) => new xt(...n, "oklch"), "oklch");
Object.assign(Ie, { oklch: TV });
xe.format.oklch = QT;
xe.autodetect.push({
  p: 2,
  test: /* @__PURE__ */ h((...n) => {
    if (n = we(n, "oklch"), Ve(n) === "array" && n.length === 3)
      return "oklch";
  }, "test")
});
Object.assign(Ie, {
  analyze: ZT,
  average: ID,
  bezier: LD,
  blend: Bs,
  brewer: mV,
  Color: xt,
  colors: Lc,
  contrast: nV,
  contrastAPCA: oV,
  cubehelix: XD,
  deltaE: lV,
  distance: uV,
  input: xe,
  interpolate: Nc,
  limits: YT,
  mix: Nc,
  random: KD,
  scale: Jh,
  scales: dV,
  valid: hV
});
function Na(n) {
  try {
    const [t, e, s, i] = Ie(n).rgba();
    return { rgb: [t, e, s], alpha: i };
  } catch {
    return console.warn(`Invalid color format: "${n}". Falling back to white.`), { rgb: [255, 255, 255], alpha: 1 };
  }
}
h(Na, "parseColor");
function d3(n) {
  const [t, e, s] = n.rgb;
  return n.alpha < 1 ? `rgba(${t}, ${e}, ${s}, ${n.alpha.toFixed(3)})` : `rgb(${t}, ${e}, ${s})`;
}
h(d3, "formatColor");
const IV = /* @__PURE__ */ h((n) => Na(n).alpha === 1, "isColorOpaque"), T2 = /* @__PURE__ */ h((n) => typeof n == "string" && Ie.valid(n), "isCssColor"), BV = /* @__PURE__ */ h((n) => Object.fromEntries(n.map(({ name: t, ecsType: e }) => [t, e])), "fieldsToComponentDef");
function PV(n) {
  if (!DV(n))
    throw new Error("zodToComponentDef expects a ZodObject schema, got " + n._zod.def.type);
  return Object.entries(n.def.shape).map(([t, e]) => Mp(t, e));
}
h(PV, "zodToComponentFields");
function RV(n) {
  const t = {};
  for (const e of n)
    switch (e.variant) {
      case "scalar": {
        const s = ct();
        t[e.name] = e.defaultValue === void 0 ? s : s.default(e.defaultValue);
        break;
      }
      case "boolean": {
        const s = je();
        t[e.name] = e.defaultValue === void 0 ? s : s.default(!!e.defaultValue);
        break;
      }
      case "color": {
        const s = $t().refine(T2, { message: "Expected a CSS color string" });
        if (e.defaultValue !== void 0) {
          const i = d3(e.defaultValue);
          t[e.name] = s.default(i);
        } else
          t[e.name] = s;
        break;
      }
      case "enum": {
        const s = e.options, i = $t().refine((o) => s.includes(o), {
          message: `Expected one of: ${s.join(", ")}`
        });
        t[e.name] = e.defaultValue !== void 0 ? i.default(String(e.defaultValue)) : i;
        break;
      }
      case "array": {
        const s = e.ecsType[1], i = We(ct()).length(s);
        t[e.name] = e.defaultValue === void 0 ? i : i.default(e.defaultValue);
        break;
      }
      default:
        throw new Error(`Unsupported field variant ${e.variant}`);
    }
  return he(t).strip();
}
h(RV, "buildAuthoringSchemaFromFields");
function Mp(n, t, e) {
  if (t instanceof p2)
    return Mp(
      n,
      t.def.innerType,
      t.def.defaultValue
    );
  if (t instanceof Dm)
    return console.warn(`Component field "${n}" uses .optional(). Use \`.default(...)\` instead.`), Mp(
      n,
      t.def.innerType,
      e
    );
  let s;
  if (t instanceof Jc && (s = VV(t, e)), t instanceof Lu && (s = LV(t, e)), t instanceof Vu && (s = NV(t, e)), t instanceof Vc && (s = zV(n, t, e)), t instanceof u2 && (s = kV(t, e)), s) return { name: n, ...s };
  throw new Error(`Unsupported schema for ${n}: ${t._zod.def.type}`);
}
h(Mp, "unwrapField");
function DV(n) {
  return n._zod.def.type === "object";
}
h(DV, "isZodObject");
function VV(n, t) {
  const { data: e, error: s } = ct().optional().safeParse(t);
  if (s) throw new Error("Invalid default value for number field: " + s.message);
  return {
    variant: "scalar",
    ecsType: m3(n.format),
    ...e !== void 0 ? { defaultValue: e } : {}
  };
}
h(VV, "unwrapNumber");
function m3(n) {
  if (n === null) return Q.f32;
  switch (n) {
    case "safeint":
      return Q.i32;
    case "int32":
      return Q.i32;
    case "uint32":
      return Q.ui32;
    case "float32":
      return Q.f32;
    case "float64":
      return Q.f64;
    default:
      throw new Error("Unsupported number format: " + n);
  }
}
h(m3, "ecsTypeOfFormat");
function LV(n, t) {
  const { data: e, error: s } = je().optional().safeParse(t);
  if (s) throw new Error("Invalid default value for boolean field: " + s.message);
  return {
    variant: "boolean",
    ecsType: Q.ui8,
    ...e !== void 0 ? { defaultValue: e } : {}
  };
}
h(LV, "unwrapBoolean");
function NV(n, t) {
  if (!["Color", "color"].some((i) => {
    var o;
    return (o = n.description) == null ? void 0 : o.includes(i);
  })) throw new Error('Strings are only used to represent css colors, requiring `.describe("color")`.');
  let s;
  if (t !== void 0) {
    if (!T2(t))
      throw new Error("Invalid default value for color field: " + t);
    s = Na(t);
  }
  return {
    variant: "color",
    ecsType: ["ui8c", 4],
    ...s !== void 0 ? { defaultValue: s } : {}
  };
}
h(NV, "unwrapColor");
function zV(n, t, e) {
  const s = Array.isArray(t.options) ? t.options.slice() : [];
  if (s.length === 0) throw new Error(`${n}: enum has no options`);
  if (s.length > 256) throw new Error(`${n}: enum >256 not supported`);
  const i = e === void 0 ? void 0 : String(e);
  if (i !== void 0 && !s.includes(i)) throw new Error(`${n}: invalid enum default ${i}`);
  return { variant: "enum", ecsType: Q.ui8, options: s, ...i !== void 0 ? { defaultValue: i } : {} };
}
h(zV, "unwrapEnum");
function kV(n, t) {
  const e = UV(n);
  if (!e) throw new Error("Array fields must have a `.length()` check");
  const s = n.def.element;
  if (!(s instanceof Jc))
    throw new Error("Array fields must have a scalar element type");
  return {
    variant: "array",
    ecsType: [m3(s.format), e],
    ...t !== void 0 ? { defaultValue: t } : {}
  };
}
h(kV, "unwrapArray");
function UV(n) {
  var t;
  for (const e of (t = n.def.checks) != null ? t : [])
    if (e instanceof Yg)
      return e._zod.def.length;
  throw new Error("Array fields must have a length check");
}
h(UV, "getArrayLength");
function OV(n) {
  var s, i, o, r;
  const t = {};
  for (const a of n)
    switch (a.variant) {
      case "scalar": {
        const l = (s = a.defaultValue) != null ? s : 0;
        t[a.name] = ct().default(l);
        break;
      }
      case "boolean": {
        const l = (i = a.defaultValue) != null ? i : !1;
        t[a.name] = je().default(l);
        break;
      }
      case "color": {
        const l = a.defaultValue ? d3(a.defaultValue) : "#ffffff";
        t[a.name] = $t().default(l);
        break;
      }
      case "enum": {
        const l = a.options, c = (o = a.defaultValue) != null ? o : l[0];
        t[a.name] = $t().default(c);
        break;
      }
      case "array": {
        const l = a.ecsType[1], c = (r = a.defaultValue) != null ? r : Array(l).fill(0);
        t[a.name] = We(ct()).length(l).default(c);
        break;
      }
    }
  return he(t).strip().transform((a) => {
    const l = {};
    for (const c of n) {
      const u = a[c.name];
      switch (c.variant) {
        case "scalar":
          l[c.name] = Number(u);
          break;
        case "boolean":
          l[c.name] = u ? 1 : 0;
          break;
        case "color": {
          const { rgb: m, alpha: d } = Na(u), f = Math.max(0, Math.min(255, Math.round(d * 255)));
          l[c.name] = [m[0], m[1], m[2], f];
          break;
        }
        case "enum": {
          const m = c.options, d = String(u), f = m.indexOf(d);
          if (f < 0) throw new Error(`Invalid enum value for ${c.name}: ${d}`);
          l[c.name] = f;
          break;
        }
        case "array":
          l[c.name] = u;
          break;
      }
    }
    return l;
  });
}
h(OV, "buildCoercingAssignableSchemaFromFields");
function Vi(n, t) {
  const e = PV(t), s = OV(e), i = RV(e), o = oi(BV(e)), r = new Map(e.map((u) => [u.name, u])), a = /* @__PURE__ */ h((u) => {
    const m = s.safeParse(u != null ? u : {});
    if (!m.success)
      throw new Error(`Failed to coerce values for component "${n}": ${m.error.message}`);
    const d = m.data;
    return Object.keys(u != null ? u : {}).reduce((f, p) => (d[p] !== void 0 && (f[p] = d[p]), f), {});
  }, "toRaw"), l = /* @__PURE__ */ h((u, m) => {
    if (!m) return;
    const d = Object.keys(m);
    if (d.length === 0) return;
    let f;
    try {
      f = a(m);
    } catch (p) {
      console.error(p);
      return;
    }
    for (const p of d) {
      const v = o[p], _ = r.get(p);
      if (!v || !_) continue;
      const g = f[p];
      g !== void 0 && (Array.isArray(g) ? v[u].set(g) : v[u] = g);
    }
  }, "assign"), c = /* @__PURE__ */ h((u) => {
    var f;
    const m = {};
    for (const p of e) {
      const v = o[p.name];
      if (!v) continue;
      const _ = v[u];
      if (_ !== void 0)
        switch (p.variant) {
          case "scalar":
            m[p.name] = _;
            break;
          case "boolean":
            m[p.name] = _ === 1;
            break;
          case "color": {
            const g = Array.isArray(_) ? _ : Array.from(_), [w = 0, S = 0, x = 0, A = 255] = g, C = A / 255;
            m[p.name] = C < 1 ? `rgba(${w}, ${S}, ${x}, ${C.toFixed(3)})` : `rgb(${w}, ${S}, ${x})`;
            break;
          }
          case "enum": {
            const g = p.options;
            if (Array.isArray(g) && g.length > 0) {
              const w = Number(_);
              m[p.name] = (f = g[w]) != null ? f : g[0];
            } else
              m[p.name] = _;
            break;
          }
          case "array":
            m[p.name] = Array.isArray(_) ? [..._] : Array.from(_);
            break;
        }
    }
    const d = t.safeParse(m);
    return d.success ? d.data : (console.error(`Failed to read component ${n}:`, d.error.message), m);
  }, "read");
  return o.assign = l, o.read = c, {
    name: n,
    schema: t,
    assignmentSchema: s,
    fields: e,
    authoringSchema: i,
    component: o,
    assign: l,
    read: c,
    toRaw: a
  };
}
h(Vi, "createComponentType");
const sb = class sb {
  constructor() {
    this.entries = /* @__PURE__ */ new Map();
  }
  registerType(t) {
    var c;
    const { type: e, authoringSchema: s, onAdd: i } = t, { name: o } = e;
    if (this.entries.has(o))
      return console.warn(`Component "${o}" already registered. Skipping duplicate registration.`), this.entries.get(o);
    const r = i ? (u, m, d) => {
      i(u, m, d);
    } : (u, m, d) => {
      u.addComponentToEntity(e.component, m), e.assign(m, d);
    }, a = (c = s != null ? s : e.authoringSchema) != null ? c : e.schema, l = {
      name: o,
      component: e.component,
      type: e,
      schema: e.schema,
      assignmentSchema: e.assignmentSchema,
      fields: e.fields,
      authoringSchema: a,
      assign: e.assign,
      read: e.read,
      toRaw: e.toRaw,
      onAdd: r
    };
    return this.entries.set(o, l), l;
  }
  registerCustom(t) {
    const { name: e, component: s, authoringSchema: i, onAdd: o, assign: r, read: a, toRaw: l, schema: c, fields: u } = t;
    if (this.entries.has(e))
      return console.warn(`Component "${e}" already registered. Skipping duplicate registration.`), this.entries.get(e);
    const m = {
      name: e,
      component: s,
      schema: c,
      fields: u,
      authoringSchema: i,
      assign: r,
      read: a,
      toRaw: l,
      onAdd: o ? (d, f, p) => o(d, f, p) : void 0
    };
    return this.entries.set(e, m), m;
  }
  get(t) {
    return this.entries.get(t);
  }
  list() {
    return Array.from(this.entries.values());
  }
  has(t) {
    return this.entries.has(t);
  }
  assign(t, e, s) {
    const i = this.entries.get(t);
    if (!i) {
      console.warn(`Component "${t}" not registered.`);
      return;
    }
    if (i.assign) {
      i.assign(e, s);
      return;
    }
    console.warn(`Component "${t}" does not support assign().`);
  }
  read(t, e) {
    const s = this.entries.get(t);
    if (!s) {
      console.warn(`Component "${t}" not registered.`);
      return;
    }
    if (s.read) return s.read(e);
    console.warn(`Component "${t}" does not support read().`);
  }
  addFromAuthoring(t, e, s, i) {
    const o = this.entries.get(t);
    if (!o) {
      console.warn(`Component "${t}" not registered.`);
      return;
    }
    const r = o.authoringSchema.safeParse(i);
    if (!r.success) {
      console.error(`Failed to parse attributes for component ${t}:`, r.error.message);
      return;
    }
    if (o.onAdd) {
      o.onAdd(e, s, r.data);
      return;
    }
    e.addComponentToEntity(o.component, s), o.assign && o.assign(s, r.data);
  }
};
h(sb, "ComponentRegistry");
let eu = sb;
const ob = class ob {
  constructor() {
    this.components = [], this.modifiers = {
      entered: !1,
      exited: !1
    }, this._compiled = null, this._enterQuery = null, this._exitQuery = null;
  }
  with(t) {
    return this.components.push(t), this;
  }
  without(t) {
    var s;
    const e = (s = t == null ? void 0 : t.component) != null ? s : t;
    return this.components.push(OI(e)), this;
  }
  changed(t) {
    var s;
    const e = (s = t == null ? void 0 : t.component) != null ? s : t;
    return this.components.push($I(e)), this;
  }
  entered() {
    return this.modifiers.entered = !0, this;
  }
  exited() {
    return this.modifiers.exited = !0, this;
  }
  _compile() {
    if (!this._compiled) {
      const t = this.components.map((e) => {
        var s;
        return e != null && e.__c ? e : (s = e == null ? void 0 : e.component) != null ? s : e;
      });
      this._compiled = ZI(t), this.modifiers.entered && (this._enterQuery = jI(this._compiled)), this.modifiers.exited && (this._exitQuery = WI(this._compiled));
    }
    return {
      base: this._compiled,
      enter: this._enterQuery,
      exit: this._exitQuery,
      hasEntered: this.modifiers.entered,
      hasExited: this.modifiers.exited
    };
  }
};
h(ob, "Query");
let hn = ob;
const $V = he({
  x: jt().default(0),
  y: jt().default(0),
  z: jt().default(0),
  sx: jt().default(1),
  sy: jt().default(1),
  rotation: jt().default(0)
}), ue = Vi("Transform", $V), Dh = {
  default: {
    friction: 0.3,
    restitution: 0
  },
  bouncy: {
    friction: 0.1,
    restitution: 0.9
  },
  ice: {
    friction: 0.02,
    restitution: 0.1
  },
  rubber: {
    friction: 0.8,
    restitution: 0.7
  },
  metal: {
    friction: 0.3,
    restitution: 0.4
  },
  wood: {
    friction: 0.6,
    restitution: 0.3
  },
  stone: {
    friction: 0.9,
    restitution: 0.1
  }
};
function FV(n) {
  return n in Dh ? Dh[n] : (console.warn(`Unknown physics material: "${n}", using default`), Dh.default);
}
h(FV, "getPhysicsMaterial");
function f3(n) {
  var e, s;
  const t = n.material ? FV(n.material) : Dh.default;
  return {
    friction: (e = n.friction) != null ? e : t.friction,
    restitution: (s = n.restitution) != null ? s : t.restitution
  };
}
h(f3, "resolvePhysicsMaterial");
const Vo = oi({
  bodyId: Q.ui32,
  isStatic: Q.ui8,
  isSensor: Q.ui8
}), GV = he({
  shape: Ri(["rectangle", "circle"]).default("rectangle"),
  width: ct().optional(),
  height: ct().optional(),
  radius: ct().optional(),
  density: ct().default(1),
  material: Ri(["default", "bouncy", "ice", "rubber", "metal", "wood", "stone"]).optional(),
  friction: ct().optional(),
  restitution: ct().optional(),
  isStatic: je().default(!1),
  isSensor: je().default(!1),
  fixedRotation: je().default(!1),
  bullet: je().optional()
}).refine(({ shape: n, width: t, height: e, radius: s }) => {
  const i = t !== void 0, o = e !== void 0, r = s !== void 0;
  return n === "rectangle" ? i && o : n === "circle" ? r && !i && !o : !1;
}, { message: "Invalid shape" });
function HV(n, t, e) {
  var c, u, m;
  wn(n.world, Vo, t);
  const s = ue.read(t), i = (c = s.x) != null ? c : 0, o = (u = s.y) != null ? u : 0, r = (m = s.rotation) != null ? m : 0, a = f3({
    material: e.material,
    friction: e.friction,
    restitution: e.restitution
  }), l = n.physicsEngine.createBody({
    x: i,
    y: o,
    rotation: r,
    shape: e.shape,
    width: e.width,
    height: e.height,
    radius: e.radius,
    density: e.density,
    friction: a.friction,
    restitution: a.restitution,
    isStatic: e.isStatic,
    isSensor: e.isSensor,
    fixedRotation: e.fixedRotation,
    bullet: e.bullet
  });
  n.addPhysicsBody(t, l), Vo.isStatic[t] = e.isStatic ? 1 : 0, Vo.isSensor[t] = e.isSensor ? 1 : 0;
}
h(HV, "addRigidBody");
const jV = he({
  x: jt().default(0),
  y: jt().default(0),
  z: jt().default(0),
  rotationX: jt().default(0),
  rotationY: jt().default(0),
  rotationZ: jt().default(0),
  quatX: jt().default(0),
  quatY: jt().default(0),
  quatZ: jt().default(0),
  quatW: jt().default(1),
  sx: jt().default(1),
  sy: jt().default(1),
  sz: jt().default(1)
}), ne = Vi("Transform3D", jV), WV = he({
  x: jt().default(0),
  y: jt().default(0),
  z: jt().default(0),
  rotation: jt().default(0),
  sx: jt().default(1),
  sy: jt().default(1)
}), Pt = Vi("WorldTransform", WV);
function qV(n, t) {
  Zi(n, Pt.component, t) || (wn(n, Pt.component, t), Pt.component.x[t] = 0, Pt.component.y[t] = 0, Pt.component.z[t] = 0, Pt.component.rotation[t] = 0, Pt.component.sx[t] = 1, Pt.component.sy[t] = 1);
}
h(qV, "ensureWorldTransform");
const XV = he({
  parentEid: la()
}), ti = Vi("Child", XV), ZV = new hn().with(ti), YV = new hn().with(ue).without(ti);
function p3() {
  const n = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ h((s) => {
    n.clear();
    for (const i of s.query(ZV)) {
      const o = ti.component.parentEid[i] | 0;
      n.has(o) || n.set(o, []), n.get(o).push(i);
    }
  }, "rebuildChildren"), e = /* @__PURE__ */ h((s, i, o, r, a, l, c) => {
    var b;
    const u = s.world;
    if (s.doesEntityHaveComponent(i, Vo) && s.doesEntityHaveComponent(i, Pt.component)) {
      const y = Pt.component.x[i] || 0, E = Pt.component.y[i] || 0, I = Pt.component.rotation[i] || 0, B = Pt.component.sx[i] || 1, D = Pt.component.sy[i] || 1, N = (b = n.get(i)) != null ? b : [];
      for (const V of N)
        e(s, V, y, E, I, B, D);
      return;
    }
    qV(u, i);
    const m = ue.read(i), d = m.x || 0, f = m.y || 0, p = m.rotation || 0, v = m.sx || 1, _ = m.sy || 1, g = Math.cos(a), w = Math.sin(a), S = o + d * l * g - f * c * w, x = r + d * l * w + f * c * g, A = a + p, C = l * v, M = c * _;
    Pt.component.x[i] = S, Pt.component.y[i] = x, Pt.component.rotation[i] = A, Pt.component.sx[i] = C, Pt.component.sy[i] = M;
    const T = n.get(i);
    if (T) for (const y of T) e(s, y, S, x, A, C, M);
  }, "visit");
  return (s) => {
    t(s);
    const i = s.query(YV);
    for (const o of i) e(s, o, 0, 0, 0, 1, 1);
  };
}
h(p3, "createHierarchySystem");
const rb = class rb {
  constructor() {
    this.assets = /* @__PURE__ */ new Map(), this.loading = /* @__PURE__ */ new Map(), this.nextId = 1, this.keyToId = /* @__PURE__ */ new Map(), this.proceduralSprites = /* @__PURE__ */ new Map();
  }
  async loadImage(t, e) {
    if (this.loading.has(t))
      return await this.loading.get(t), this.keyToId.get(t);
    if (this.assets.has(t))
      return this.keyToId.get(t);
    const s = new Promise((o, r) => {
      const a = new Image();
      a.onload = () => {
        const l = {
          type: "image",
          data: a,
          width: a.width,
          height: a.height
        };
        this.assets.set(t, l), this.loading.delete(t), o(l);
      }, a.onerror = () => {
        this.loading.delete(t), r(new Error(`Failed to load image: ${e}`));
      }, a.src = e;
    });
    this.loading.set(t, s), await s;
    const i = this.nextId++;
    return this.keyToId.set(t, i), i;
  }
  generateProceduralSprite(t, e, s, i, o) {
    if (this.assets.has(t))
      return this.keyToId.get(t);
    const r = /* @__PURE__ */ h((p, v, _, g, w) => {
      e(p, v, _, w);
    }, "wrappedDrawFn");
    this.proceduralSprites.set(t, {
      drawFn: r,
      totalFrames: 1,
      options: o,
      currentResolution: { frameWidth: s, frameHeight: i }
    });
    const a = 32, l = Math.ceil(s * a), c = Math.ceil(i * a);
    console.log(`🎨 generateProceduralSprite: "${t}", world=${s}×${i}, pixels=${l}×${c}`);
    const u = document.createElement("canvas");
    u.width = l, u.height = c;
    const m = u.getContext("2d");
    m.clearRect(0, 0, l, c), m.setTransform(1, 0, 0, 1, 0, 0), m.translate(l / 2, c / 2), m.scale(a, a), e(m, s, i, o);
    const d = {
      type: "canvas",
      data: u,
      width: l,
      height: c
    };
    this.assets.set(t, d), this.proceduralSprites.get(t).currentResolution = { frameWidth: l, frameHeight: c };
    const f = this.nextId++;
    return this.keyToId.set(t, f), f;
  }
  generateAnimatedSprite(t, e, s, i, o, r) {
    if (this.proceduralSprites.set(t, {
      drawFn: e,
      totalFrames: s,
      options: r,
      currentResolution: { frameWidth: i, frameHeight: o }
    }), r != null && r.autoFit) {
      const a = this._measureSpriteBounds(e, s, i, o, r);
      if (r.preferredAspect && a) {
        const l = this._fitToAspectRatio(a, r.preferredAspect);
        i = l.width, o = l.height;
      } else a && (i = a.width, o = a.height);
      this.proceduralSprites.get(t).currentResolution = { frameWidth: i, frameHeight: o }, console.log(`✂️ Auto-fitted sprite "${t}": ${i}×${o}`);
    }
    return this._generateAnimatedSpriteAtResolution(t, i, o);
  }
  regenerateAnimatedSprite(t, e, s) {
    var o;
    const i = this.proceduralSprites.get(t);
    return i ? (i.currentResolution = { frameWidth: e, frameHeight: s }, this.assets.delete(t), this._generateAnimatedSpriteAtResolution(t, e, s)) : (console.warn(`Cannot regenerate sprite "${t}" - not a procedural sprite`), (o = this.keyToId.get(t)) != null ? o : 0);
  }
  _generateAnimatedSpriteAtResolution(t, e, s) {
    const i = this.proceduralSprites.get(t);
    if (!i) throw new Error(`Sprite definition not found: ${t}`);
    const o = 32, r = Math.ceil(e * o), a = Math.ceil(s * o), l = document.createElement("canvas");
    l.width = r * i.totalFrames, l.height = a;
    const c = l.getContext("2d");
    c.imageSmoothingEnabled = !1;
    for (let d = 0; d < i.totalFrames; d++) {
      const f = d * r;
      c.save(), c.clearRect(f, 0, r, a), c.translate(f + r / 2, a / 2), c.scale(o, o), i.drawFn(c, e, s, d, i.options), c.restore();
    }
    const u = {
      type: "canvas",
      data: l,
      width: l.width,
      height: l.height
    };
    if (this.assets.set(t, u), i.currentResolution = { frameWidth: r, frameHeight: a }, this.keyToId.has(t))
      return this.keyToId.get(t);
    const m = this.nextId++;
    return this.keyToId.set(t, m), m;
  }
  _getSingleFrameBounds(t, e, s) {
    const o = t.getImageData(0, 0, e, s).data;
    let r = e, a = s, l = 0, c = 0;
    for (let u = 0; u < s; u++)
      for (let m = 0; m < e; m++)
        o[(u * e + m) * 4 + 3] > 0 && (r = Math.min(r, m), a = Math.min(a, u), l = Math.max(l, m), c = Math.max(c, u));
    return l < r || c < a ? null : {
      width: l - r + 1,
      height: c - a + 1,
      offsetX: r,
      offsetY: a
    };
  }
  getSpriteResolution(t) {
    var e, s;
    return (s = (e = this.proceduralSprites.get(t)) == null ? void 0 : e.currentResolution) != null ? s : null;
  }
  isProcedural(t) {
    return this.proceduralSprites.has(t);
  }
  getAsset(t) {
    var e;
    return (e = this.assets.get(t)) != null ? e : null;
  }
  getAssetById(t) {
    var e;
    for (const [s, i] of this.keyToId.entries())
      if (i === t) return (e = this.assets.get(s)) != null ? e : null;
    return null;
  }
  getAssetId(t) {
    var e;
    return (e = this.keyToId.get(t)) != null ? e : null;
  }
  has(t) {
    return this.assets.has(t);
  }
  clear() {
    this.assets.clear(), this.loading.clear(), this.keyToId.clear(), this.nextId = 1;
  }
  remove(t) {
    this.assets.delete(t), this.keyToId.delete(t);
  }
  _measureSpriteBounds(t, e, s, i, o) {
    let r = s, a = i, l = 0, c = 0;
    for (let m = 0; m < e; m++) {
      const d = document.createElement("canvas");
      d.width = s, d.height = i;
      const f = d.getContext("2d");
      f.clearRect(0, 0, s, i), t(f, s, i, m, o);
      const v = f.getImageData(0, 0, s, i).data;
      for (let _ = 0; _ < i; _++)
        for (let g = 0; g < s; g++)
          v[(_ * s + g) * 4 + 3] > 0 && (r = Math.min(r, g), a = Math.min(a, _), l = Math.max(l, g), c = Math.max(c, _));
    }
    if (l < r || c < a) return null;
    const u = 2;
    return r = Math.max(0, r - u), a = Math.max(0, a - u), l = Math.min(s - 1, l + u), c = Math.min(i - 1, c + u), {
      width: l - r + 1,
      height: c - a + 1,
      offsetX: r,
      offsetY: a
    };
  }
  _fitToAspectRatio(t, e) {
    const s = e.split(":").map((u) => parseInt(u, 10));
    if (s.length !== 2 || s.some(isNaN))
      return console.warn(`Invalid aspect ratio "${e}", using measured bounds`), t;
    const [i, o] = s, r = i / o, a = t.width / t.height;
    let l, c;
    return a > r ? (l = t.width, c = Math.ceil(l / r)) : (c = t.height, l = Math.ceil(c * r)), l = Math.ceil(l / 8) * 8, c = Math.ceil(c / 8) * 8, { width: l, height: c };
  }
};
h(rb, "AssetManager");
let nu = rb;
const Rn = class Rn {
  static on(t, e) {
    Rn.listeners.has(t) || Rn.listeners.set(t, /* @__PURE__ */ new Set());
    const s = { event: t, callback: e, once: !1 };
    return Rn.listeners.get(t).add(s), () => Rn.off(t, e);
  }
  static once(t, e) {
    Rn.listeners.has(t) || Rn.listeners.set(t, /* @__PURE__ */ new Set());
    const s = { event: t, callback: e, once: !0 };
    return Rn.listeners.get(t).add(s), () => Rn.off(t, e);
  }
  static off(t, e) {
    const s = Rn.listeners.get(t);
    if (s) {
      for (const i of s)
        if (i.callback === e) {
          s.delete(i);
          break;
        }
      s.size === 0 && Rn.listeners.delete(t);
    }
  }
  static emit(t, e) {
    const s = Rn.listeners.get(t);
    if (Rn.eventHistory.push({ event: t, data: e, timestamp: performance.now() }), Rn.eventHistory.length > Rn.maxHistorySize && Rn.eventHistory.shift(), !s || s.size === 0) return;
    const i = Array.from(s);
    for (const o of i)
      try {
        o.callback(e), o.once && s.delete(o);
      } catch (r) {
        console.error(`[EventBus] Error in event handler for "${t}":`, r);
      }
  }
  static clear() {
    Rn.listeners.clear();
  }
};
h(Rn, "EventBus"), Rn.listeners = /* @__PURE__ */ new Map(), Rn.eventHistory = [], Rn.maxHistorySize = 100;
let Hi = Rn;
const ii = class ii {
  static get(t) {
    return ii.store[t];
  }
  static set(t) {
    for (const [e, s] of Object.entries(t))
      ii.store[e] = s, ii.notify(e, s);
  }
  static update(t) {
    const e = t({ ...ii.store });
    ii.set(e);
  }
  static watch(t, e) {
    return ii.watchers.has(t) || ii.watchers.set(t, /* @__PURE__ */ new Set()), ii.watchers.get(t).add(e), () => ii.unwatch(t, e);
  }
  static unwatch(t, e) {
    const s = ii.watchers.get(t);
    s && (s.delete(e), s.size === 0 && ii.watchers.delete(t));
  }
  static notify(t, e) {
    const s = ii.watchers.get(t);
    if (s)
      for (const i of s)
        try {
          i(e, t);
        } catch (o) {
          console.error(o);
        }
  }
};
h(ii, "GlobalState"), ii.store = /* @__PURE__ */ Object.create(null), ii.watchers = /* @__PURE__ */ new Map();
let Cp = ii;
const $l = class $l {
  static register(t, e) {
    if (this._registry.has(t))
      throw new Error(`Template "${t}" is already registered. Template names must be unique.`);
    this._registry.set(t, e), this._instanceCounters.set(t, 0);
  }
  static get(t) {
    return this._registry.get(t);
  }
  static has(t) {
    return this._registry.has(t);
  }
  static getNextInstanceNumber(t) {
    var i;
    const s = ((i = this._instanceCounters.get(t)) != null ? i : 0) + 1;
    return this._instanceCounters.set(t, s), s;
  }
  static reset() {
    this._registry.clear(), this._instanceCounters.clear();
  }
};
h($l, "TemplateManager"), $l._registry = /* @__PURE__ */ new Map(), $l._instanceCounters = /* @__PURE__ */ new Map();
let ha = $l, Ku = null, Jx = !1;
function Kx() {
  return Ku || (Ku = new eu()), Jx || (b5(Ku), Jx = !0), Ku;
}
h(Kx, "ensureInitialized");
const hi = new Proxy({}, {
  get(n, t) {
    const e = Kx(), s = e[t];
    return typeof s == "function" ? s.bind(e) : s;
  },
  getPrototypeOf() {
    return eu.prototype;
  },
  ownKeys() {
    return Object.getOwnPropertyNames(eu.prototype);
  },
  getOwnPropertyDescriptor(n, t) {
    const e = Kx(), s = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(e),
      t
    );
    if (s)
      return {
        ...s,
        configurable: !0,
        enumerable: !0
      };
  }
}), JV = he({
  shapeType: la().default(0),
  halfExtentX: jt().default(0.5),
  halfExtentY: jt().default(0.5),
  halfExtentZ: jt().default(0.5),
  radius: jt().default(0.5),
  height: jt().default(1),
  offsetX: jt().default(0),
  offsetY: jt().default(0),
  offsetZ: jt().default(0),
  friction: jt().default(0.3),
  restitution: jt().default(0.3),
  isSensor: Ii().default(!1)
}), xo = Vi("Collider3D", JV), Yr = class Yr {
  constructor(t) {
    t === void 0 && (t = [0, 0, 0, 0, 0, 0, 0, 0, 0]), this.elements = t;
  }
  identity() {
    const t = this.elements;
    t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1;
  }
  setZero() {
    const t = this.elements;
    t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 0;
  }
  setTrace(t) {
    const e = this.elements;
    e[0] = t.x, e[4] = t.y, e[8] = t.z;
  }
  getTrace(t) {
    t === void 0 && (t = new R());
    const e = this.elements;
    return t.x = e[0], t.y = e[4], t.z = e[8], t;
  }
  vmult(t, e) {
    e === void 0 && (e = new R());
    const s = this.elements, i = t.x, o = t.y, r = t.z;
    return e.x = s[0] * i + s[1] * o + s[2] * r, e.y = s[3] * i + s[4] * o + s[5] * r, e.z = s[6] * i + s[7] * o + s[8] * r, e;
  }
  smult(t) {
    for (let e = 0; e < this.elements.length; e++)
      this.elements[e] *= t;
  }
  mmult(t, e) {
    e === void 0 && (e = new Yr());
    const s = this.elements, i = t.elements, o = e.elements, r = s[0], a = s[1], l = s[2], c = s[3], u = s[4], m = s[5], d = s[6], f = s[7], p = s[8], v = i[0], _ = i[1], g = i[2], w = i[3], S = i[4], x = i[5], A = i[6], C = i[7], M = i[8];
    return o[0] = r * v + a * w + l * A, o[1] = r * _ + a * S + l * C, o[2] = r * g + a * x + l * M, o[3] = c * v + u * w + m * A, o[4] = c * _ + u * S + m * C, o[5] = c * g + u * x + m * M, o[6] = d * v + f * w + p * A, o[7] = d * _ + f * S + p * C, o[8] = d * g + f * x + p * M, e;
  }
  scale(t, e) {
    e === void 0 && (e = new Yr());
    const s = this.elements, i = e.elements;
    for (let o = 0; o !== 3; o++)
      i[3 * o + 0] = t.x * s[3 * o + 0], i[3 * o + 1] = t.y * s[3 * o + 1], i[3 * o + 2] = t.z * s[3 * o + 2];
    return e;
  }
  solve(t, e) {
    e === void 0 && (e = new R());
    const s = 3, i = 4, o = [];
    let r, a;
    for (r = 0; r < s * i; r++)
      o.push(0);
    for (r = 0; r < 3; r++)
      for (a = 0; a < 3; a++)
        o[r + i * a] = this.elements[r + 3 * a];
    o[3 + 4 * 0] = t.x, o[3 + 4 * 1] = t.y, o[3 + 4 * 2] = t.z;
    let l = 3;
    const c = l;
    let u;
    const m = 4;
    let d;
    do {
      if (r = c - l, o[r + i * r] === 0) {
        for (a = r + 1; a < c; a++)
          if (o[r + i * a] !== 0) {
            u = m;
            do
              d = m - u, o[d + i * r] += o[d + i * a];
            while (--u);
            break;
          }
      }
      if (o[r + i * r] !== 0)
        for (a = r + 1; a < c; a++) {
          const f = o[r + i * a] / o[r + i * r];
          u = m;
          do
            d = m - u, o[d + i * a] = d <= r ? 0 : o[d + i * a] - o[d + i * r] * f;
          while (--u);
        }
    } while (--l);
    if (e.z = o[2 * i + 3] / o[2 * i + 2], e.y = (o[1 * i + 3] - o[1 * i + 2] * e.z) / o[1 * i + 1], e.x = (o[0 * i + 3] - o[0 * i + 2] * e.z - o[0 * i + 1] * e.y) / o[0 * i + 0], isNaN(e.x) || isNaN(e.y) || isNaN(e.z) || e.x === 1 / 0 || e.y === 1 / 0 || e.z === 1 / 0)
      throw `Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;
    return e;
  }
  e(t, e, s) {
    if (s === void 0)
      return this.elements[e + 3 * t];
    this.elements[e + 3 * t] = s;
  }
  copy(t) {
    for (let e = 0; e < t.elements.length; e++)
      this.elements[e] = t.elements[e];
    return this;
  }
  toString() {
    let t = "";
    const e = ",";
    for (let s = 0; s < 9; s++)
      t += this.elements[s] + e;
    return t;
  }
  reverse(t) {
    t === void 0 && (t = new Yr());
    const e = 3, s = 6, i = KV;
    let o, r;
    for (o = 0; o < 3; o++)
      for (r = 0; r < 3; r++)
        i[o + s * r] = this.elements[o + 3 * r];
    i[3 + 6 * 0] = 1, i[3 + 6 * 1] = 0, i[3 + 6 * 2] = 0, i[4 + 6 * 0] = 0, i[4 + 6 * 1] = 1, i[4 + 6 * 2] = 0, i[5 + 6 * 0] = 0, i[5 + 6 * 1] = 0, i[5 + 6 * 2] = 1;
    let a = 3;
    const l = a;
    let c;
    const u = s;
    let m;
    do {
      if (o = l - a, i[o + s * o] === 0) {
        for (r = o + 1; r < l; r++)
          if (i[o + s * r] !== 0) {
            c = u;
            do
              m = u - c, i[m + s * o] += i[m + s * r];
            while (--c);
            break;
          }
      }
      if (i[o + s * o] !== 0)
        for (r = o + 1; r < l; r++) {
          const d = i[o + s * r] / i[o + s * o];
          c = u;
          do
            m = u - c, i[m + s * r] = m <= o ? 0 : i[m + s * r] - i[m + s * o] * d;
          while (--c);
        }
    } while (--a);
    o = 2;
    do {
      r = o - 1;
      do {
        const d = i[o + s * r] / i[o + s * o];
        c = s;
        do
          m = s - c, i[m + s * r] = i[m + s * r] - i[m + s * o] * d;
        while (--c);
      } while (r--);
    } while (--o);
    o = 2;
    do {
      const d = 1 / i[o + s * o];
      c = s;
      do
        m = s - c, i[m + s * o] = i[m + s * o] * d;
      while (--c);
    } while (o--);
    o = 2;
    do {
      r = 2;
      do {
        if (m = i[e + r + s * o], isNaN(m) || m === 1 / 0)
          throw `Could not reverse! A=[${this.toString()}]`;
        t.e(o, r, m);
      } while (r--);
    } while (o--);
    return t;
  }
  setRotationFromQuaternion(t) {
    const e = t.x, s = t.y, i = t.z, o = t.w, r = e + e, a = s + s, l = i + i, c = e * r, u = e * a, m = e * l, d = s * a, f = s * l, p = i * l, v = o * r, _ = o * a, g = o * l, w = this.elements;
    return w[3 * 0 + 0] = 1 - (d + p), w[3 * 0 + 1] = u - g, w[3 * 0 + 2] = m + _, w[3 * 1 + 0] = u + g, w[3 * 1 + 1] = 1 - (c + p), w[3 * 1 + 2] = f - v, w[3 * 2 + 0] = m - _, w[3 * 2 + 1] = f + v, w[3 * 2 + 2] = 1 - (c + d), this;
  }
  transpose(t) {
    t === void 0 && (t = new Yr());
    const e = this.elements, s = t.elements;
    let i;
    return s[0] = e[0], s[4] = e[4], s[8] = e[8], i = e[1], s[1] = e[3], s[3] = i, i = e[2], s[2] = e[6], s[6] = i, i = e[5], s[5] = e[7], s[7] = i, t;
  }
};
h(Yr, "Mat3");
let gr = Yr;
const KV = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], es = class es {
  constructor(t, e, s) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), s === void 0 && (s = 0), this.x = t, this.y = e, this.z = s;
  }
  cross(t, e) {
    e === void 0 && (e = new es());
    const s = t.x, i = t.y, o = t.z, r = this.x, a = this.y, l = this.z;
    return e.x = a * o - l * i, e.y = l * s - r * o, e.z = r * i - a * s, e;
  }
  set(t, e, s) {
    return this.x = t, this.y = e, this.z = s, this;
  }
  setZero() {
    this.x = this.y = this.z = 0;
  }
  vadd(t, e) {
    if (e)
      e.x = t.x + this.x, e.y = t.y + this.y, e.z = t.z + this.z;
    else
      return new es(this.x + t.x, this.y + t.y, this.z + t.z);
  }
  vsub(t, e) {
    if (e)
      e.x = this.x - t.x, e.y = this.y - t.y, e.z = this.z - t.z;
    else
      return new es(this.x - t.x, this.y - t.y, this.z - t.z);
  }
  crossmat() {
    return new gr([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  normalize() {
    const t = this.x, e = this.y, s = this.z, i = Math.sqrt(t * t + e * e + s * s);
    if (i > 0) {
      const o = 1 / i;
      this.x *= o, this.y *= o, this.z *= o;
    } else
      this.x = 0, this.y = 0, this.z = 0;
    return i;
  }
  unit(t) {
    t === void 0 && (t = new es());
    const e = this.x, s = this.y, i = this.z;
    let o = Math.sqrt(e * e + s * s + i * i);
    return o > 0 ? (o = 1 / o, t.x = e * o, t.y = s * o, t.z = i * o) : (t.x = 1, t.y = 0, t.z = 0), t;
  }
  length() {
    const t = this.x, e = this.y, s = this.z;
    return Math.sqrt(t * t + e * e + s * s);
  }
  lengthSquared() {
    return this.dot(this);
  }
  distanceTo(t) {
    const e = this.x, s = this.y, i = this.z, o = t.x, r = t.y, a = t.z;
    return Math.sqrt((o - e) * (o - e) + (r - s) * (r - s) + (a - i) * (a - i));
  }
  distanceSquared(t) {
    const e = this.x, s = this.y, i = this.z, o = t.x, r = t.y, a = t.z;
    return (o - e) * (o - e) + (r - s) * (r - s) + (a - i) * (a - i);
  }
  scale(t, e) {
    e === void 0 && (e = new es());
    const s = this.x, i = this.y, o = this.z;
    return e.x = t * s, e.y = t * i, e.z = t * o, e;
  }
  vmul(t, e) {
    return e === void 0 && (e = new es()), e.x = t.x * this.x, e.y = t.y * this.y, e.z = t.z * this.z, e;
  }
  addScaledVector(t, e, s) {
    return s === void 0 && (s = new es()), s.x = this.x + t * e.x, s.y = this.y + t * e.y, s.z = this.z + t * e.z, s;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
  }
  negate(t) {
    return t === void 0 && (t = new es()), t.x = -this.x, t.y = -this.y, t.z = -this.z, t;
  }
  tangents(t, e) {
    const s = this.length();
    if (s > 0) {
      const i = QV, o = 1 / s;
      i.set(this.x * o, this.y * o, this.z * o);
      const r = tL;
      Math.abs(i.x) < 0.9 ? (r.set(1, 0, 0), i.cross(r, t)) : (r.set(0, 1, 0), i.cross(r, t)), i.cross(t, e);
    } else
      t.set(1, 0, 0), e.set(0, 1, 0);
  }
  toString() {
    return `${this.x},${this.y},${this.z}`;
  }
  toArray() {
    return [this.x, this.y, this.z];
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  lerp(t, e, s) {
    const i = this.x, o = this.y, r = this.z;
    s.x = i + (t.x - i) * e, s.y = o + (t.y - o) * e, s.z = r + (t.z - r) * e;
  }
  almostEquals(t, e) {
    return e === void 0 && (e = 1e-6), !(Math.abs(this.x - t.x) > e || Math.abs(this.y - t.y) > e || Math.abs(this.z - t.z) > e);
  }
  almostZero(t) {
    return t === void 0 && (t = 1e-6), !(Math.abs(this.x) > t || Math.abs(this.y) > t || Math.abs(this.z) > t);
  }
  isAntiparallelTo(t, e) {
    return this.negate(Qx), Qx.almostEquals(t, e);
  }
  clone() {
    return new es(this.x, this.y, this.z);
  }
};
h(es, "Vec3");
let R = es;
R.ZERO = new R(0, 0, 0);
R.UNIT_X = new R(1, 0, 0);
R.UNIT_Y = new R(0, 1, 0);
R.UNIT_Z = new R(0, 0, 1);
const QV = new R(), tL = new R(), Qx = new R(), jd = class jd {
  constructor(t) {
    t === void 0 && (t = {}), this.lowerBound = new R(), this.upperBound = new R(), t.lowerBound && this.lowerBound.copy(t.lowerBound), t.upperBound && this.upperBound.copy(t.upperBound);
  }
  setFromPoints(t, e, s, i) {
    const o = this.lowerBound, r = this.upperBound, a = s;
    o.copy(t[0]), a && a.vmult(o, o), r.copy(o);
    for (let l = 1; l < t.length; l++) {
      let c = t[l];
      a && (a.vmult(c, tw), c = tw), c.x > r.x && (r.x = c.x), c.x < o.x && (o.x = c.x), c.y > r.y && (r.y = c.y), c.y < o.y && (o.y = c.y), c.z > r.z && (r.z = c.z), c.z < o.z && (o.z = c.z);
    }
    return e && (e.vadd(o, o), e.vadd(r, r)), i && (o.x -= i, o.y -= i, o.z -= i, r.x += i, r.y += i, r.z += i), this;
  }
  copy(t) {
    return this.lowerBound.copy(t.lowerBound), this.upperBound.copy(t.upperBound), this;
  }
  clone() {
    return new jd().copy(this);
  }
  extend(t) {
    this.lowerBound.x = Math.min(this.lowerBound.x, t.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, t.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, t.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, t.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, t.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, t.upperBound.z);
  }
  overlaps(t) {
    const e = this.lowerBound, s = this.upperBound, i = t.lowerBound, o = t.upperBound, r = i.x <= s.x && s.x <= o.x || e.x <= o.x && o.x <= s.x, a = i.y <= s.y && s.y <= o.y || e.y <= o.y && o.y <= s.y, l = i.z <= s.z && s.z <= o.z || e.z <= o.z && o.z <= s.z;
    return r && a && l;
  }
  volume() {
    const t = this.lowerBound, e = this.upperBound;
    return (e.x - t.x) * (e.y - t.y) * (e.z - t.z);
  }
  contains(t) {
    const e = this.lowerBound, s = this.upperBound, i = t.lowerBound, o = t.upperBound;
    return e.x <= i.x && s.x >= o.x && e.y <= i.y && s.y >= o.y && e.z <= i.z && s.z >= o.z;
  }
  getCorners(t, e, s, i, o, r, a, l) {
    const c = this.lowerBound, u = this.upperBound;
    t.copy(c), e.set(u.x, c.y, c.z), s.set(u.x, u.y, c.z), i.set(c.x, u.y, u.z), o.set(u.x, c.y, u.z), r.set(c.x, u.y, c.z), a.set(c.x, c.y, u.z), l.copy(u);
  }
  toLocalFrame(t, e) {
    const s = ew, i = s[0], o = s[1], r = s[2], a = s[3], l = s[4], c = s[5], u = s[6], m = s[7];
    this.getCorners(i, o, r, a, l, c, u, m);
    for (let d = 0; d !== 8; d++) {
      const f = s[d];
      t.pointToLocal(f, f);
    }
    return e.setFromPoints(s);
  }
  toWorldFrame(t, e) {
    const s = ew, i = s[0], o = s[1], r = s[2], a = s[3], l = s[4], c = s[5], u = s[6], m = s[7];
    this.getCorners(i, o, r, a, l, c, u, m);
    for (let d = 0; d !== 8; d++) {
      const f = s[d];
      t.pointToWorld(f, f);
    }
    return e.setFromPoints(s);
  }
  overlapsRay(t) {
    const {
      direction: e,
      from: s
    } = t, i = 1 / e.x, o = 1 / e.y, r = 1 / e.z, a = (this.lowerBound.x - s.x) * i, l = (this.upperBound.x - s.x) * i, c = (this.lowerBound.y - s.y) * o, u = (this.upperBound.y - s.y) * o, m = (this.lowerBound.z - s.z) * r, d = (this.upperBound.z - s.z) * r, f = Math.max(Math.max(Math.min(a, l), Math.min(c, u)), Math.min(m, d)), p = Math.min(Math.min(Math.max(a, l), Math.max(c, u)), Math.max(m, d));
    return !(p < 0 || f > p);
  }
};
h(jd, "AABB");
let Yi = jd;
const tw = new R(), ew = [new R(), new R(), new R(), new R(), new R(), new R(), new R(), new R()], ab = class ab {
  constructor() {
    this.matrix = [];
  }
  get(t, e) {
    let {
      index: s
    } = t, {
      index: i
    } = e;
    if (i > s) {
      const o = i;
      i = s, s = o;
    }
    return this.matrix[(s * (s + 1) >> 1) + i - 1];
  }
  set(t, e, s) {
    let {
      index: i
    } = t, {
      index: o
    } = e;
    if (o > i) {
      const r = o;
      o = i, i = r;
    }
    this.matrix[(i * (i + 1) >> 1) + o - 1] = s ? 1 : 0;
  }
  reset() {
    for (let t = 0, e = this.matrix.length; t !== e; t++)
      this.matrix[t] = 0;
  }
  setNumObjects(t) {
    this.matrix.length = t * (t - 1) >> 1;
  }
};
h(ab, "ArrayCollisionMatrix");
let Qh = ab;
const cb = class cb {
  addEventListener(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const s = this._listeners;
    return s[t] === void 0 && (s[t] = []), s[t].includes(e) || s[t].push(e), this;
  }
  hasEventListener(t, e) {
    if (this._listeners === void 0)
      return !1;
    const s = this._listeners;
    return !!(s[t] !== void 0 && s[t].includes(e));
  }
  hasAnyEventListener(t) {
    return this._listeners === void 0 ? !1 : this._listeners[t] !== void 0;
  }
  removeEventListener(t, e) {
    if (this._listeners === void 0)
      return this;
    const s = this._listeners;
    if (s[t] === void 0)
      return this;
    const i = s[t].indexOf(e);
    return i !== -1 && s[t].splice(i, 1), this;
  }
  dispatchEvent(t) {
    if (this._listeners === void 0)
      return this;
    const s = this._listeners[t.type];
    if (s !== void 0) {
      t.target = this;
      for (let i = 0, o = s.length; i < o; i++)
        s[i].call(this, t);
    }
    return this;
  }
};
h(cb, "EventTarget");
let td = cb;
var as;
let Wi = (as = class {
  constructor(t, e, s, i) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), s === void 0 && (s = 0), i === void 0 && (i = 1), this.x = t, this.y = e, this.z = s, this.w = i;
  }
  set(t, e, s, i) {
    return this.x = t, this.y = e, this.z = s, this.w = i, this;
  }
  toString() {
    return `${this.x},${this.y},${this.z},${this.w}`;
  }
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  setFromAxisAngle(t, e) {
    const s = Math.sin(e * 0.5);
    return this.x = t.x * s, this.y = t.y * s, this.z = t.z * s, this.w = Math.cos(e * 0.5), this;
  }
  toAxisAngle(t) {
    t === void 0 && (t = new R()), this.normalize();
    const e = 2 * Math.acos(this.w), s = Math.sqrt(1 - this.w * this.w);
    return s < 1e-3 ? (t.x = this.x, t.y = this.y, t.z = this.z) : (t.x = this.x / s, t.y = this.y / s, t.z = this.z / s), [t, e];
  }
  setFromVectors(t, e) {
    if (t.isAntiparallelTo(e)) {
      const s = eL, i = nL;
      t.tangents(s, i), this.setFromAxisAngle(s, Math.PI);
    } else {
      const s = t.cross(e);
      this.x = s.x, this.y = s.y, this.z = s.z, this.w = Math.sqrt(t.length() ** 2 * e.length() ** 2) + t.dot(e), this.normalize();
    }
    return this;
  }
  mult(t, e) {
    e === void 0 && (e = new as());
    const s = this.x, i = this.y, o = this.z, r = this.w, a = t.x, l = t.y, c = t.z, u = t.w;
    return e.x = s * u + r * a + i * c - o * l, e.y = i * u + r * l + o * a - s * c, e.z = o * u + r * c + s * l - i * a, e.w = r * u - s * a - i * l - o * c, e;
  }
  inverse(t) {
    t === void 0 && (t = new as());
    const e = this.x, s = this.y, i = this.z, o = this.w;
    this.conjugate(t);
    const r = 1 / (e * e + s * s + i * i + o * o);
    return t.x *= r, t.y *= r, t.z *= r, t.w *= r, t;
  }
  conjugate(t) {
    return t === void 0 && (t = new as()), t.x = -this.x, t.y = -this.y, t.z = -this.z, t.w = this.w, t;
  }
  normalize() {
    let t = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    return t === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (t = 1 / t, this.x *= t, this.y *= t, this.z *= t, this.w *= t), this;
  }
  normalizeFast() {
    const t = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
    return t === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= t, this.y *= t, this.z *= t, this.w *= t), this;
  }
  vmult(t, e) {
    e === void 0 && (e = new R());
    const s = t.x, i = t.y, o = t.z, r = this.x, a = this.y, l = this.z, c = this.w, u = c * s + a * o - l * i, m = c * i + l * s - r * o, d = c * o + r * i - a * s, f = -r * s - a * i - l * o;
    return e.x = u * c + f * -r + m * -l - d * -a, e.y = m * c + f * -a + d * -r - u * -l, e.z = d * c + f * -l + u * -a - m * -r, e;
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this;
  }
  toEuler(t, e) {
    e === void 0 && (e = "YZX");
    let s, i, o;
    const r = this.x, a = this.y, l = this.z, c = this.w;
    switch (e) {
      case "YZX":
        const u = r * a + l * c;
        if (u > 0.499 && (s = 2 * Math.atan2(r, c), i = Math.PI / 2, o = 0), u < -0.499 && (s = -2 * Math.atan2(r, c), i = -Math.PI / 2, o = 0), s === void 0) {
          const m = r * r, d = a * a, f = l * l;
          s = Math.atan2(2 * a * c - 2 * r * l, 1 - 2 * d - 2 * f), i = Math.asin(2 * u), o = Math.atan2(2 * r * c - 2 * a * l, 1 - 2 * m - 2 * f);
        }
        break;
      default:
        throw new Error(`Euler order ${e} not supported yet.`);
    }
    t.y = s, t.z = i, t.x = o;
  }
  setFromEuler(t, e, s, i) {
    i === void 0 && (i = "XYZ");
    const o = Math.cos(t / 2), r = Math.cos(e / 2), a = Math.cos(s / 2), l = Math.sin(t / 2), c = Math.sin(e / 2), u = Math.sin(s / 2);
    return i === "XYZ" ? (this.x = l * r * a + o * c * u, this.y = o * c * a - l * r * u, this.z = o * r * u + l * c * a, this.w = o * r * a - l * c * u) : i === "YXZ" ? (this.x = l * r * a + o * c * u, this.y = o * c * a - l * r * u, this.z = o * r * u - l * c * a, this.w = o * r * a + l * c * u) : i === "ZXY" ? (this.x = l * r * a - o * c * u, this.y = o * c * a + l * r * u, this.z = o * r * u + l * c * a, this.w = o * r * a - l * c * u) : i === "ZYX" ? (this.x = l * r * a - o * c * u, this.y = o * c * a + l * r * u, this.z = o * r * u - l * c * a, this.w = o * r * a + l * c * u) : i === "YZX" ? (this.x = l * r * a + o * c * u, this.y = o * c * a + l * r * u, this.z = o * r * u - l * c * a, this.w = o * r * a - l * c * u) : i === "XZY" && (this.x = l * r * a - o * c * u, this.y = o * c * a - l * r * u, this.z = o * r * u + l * c * a, this.w = o * r * a + l * c * u), this;
  }
  clone() {
    return new as(this.x, this.y, this.z, this.w);
  }
  slerp(t, e, s) {
    s === void 0 && (s = new as());
    const i = this.x, o = this.y, r = this.z, a = this.w;
    let l = t.x, c = t.y, u = t.z, m = t.w, d, f, p, v, _;
    return f = i * l + o * c + r * u + a * m, f < 0 && (f = -f, l = -l, c = -c, u = -u, m = -m), 1 - f > 1e-6 ? (d = Math.acos(f), p = Math.sin(d), v = Math.sin((1 - e) * d) / p, _ = Math.sin(e * d) / p) : (v = 1 - e, _ = e), s.x = v * i + _ * l, s.y = v * o + _ * c, s.z = v * r + _ * u, s.w = v * a + _ * m, s;
  }
  integrate(t, e, s, i) {
    i === void 0 && (i = new as());
    const o = t.x * s.x, r = t.y * s.y, a = t.z * s.z, l = this.x, c = this.y, u = this.z, m = this.w, d = e * 0.5;
    return i.x += d * (o * m + r * u - a * c), i.y += d * (r * m + a * l - o * u), i.z += d * (a * m + o * c - r * l), i.w += d * (-o * l - r * c - a * u), i;
  }
}, h(as, "Quaternion"), as);
const eL = new R(), nL = new R(), iL = {
  SPHERE: 1,
  PLANE: 2,
  BOX: 4,
  COMPOUND: 8,
  CONVEXPOLYHEDRON: 16,
  HEIGHTFIELD: 32,
  PARTICLE: 64,
  CYLINDER: 128,
  TRIMESH: 256
}, Wd = class Wd {
  constructor(t) {
    t === void 0 && (t = {}), this.id = Wd.idCounter++, this.type = t.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = t.collisionResponse ? t.collisionResponse : !0, this.collisionFilterGroup = t.collisionFilterGroup !== void 0 ? t.collisionFilterGroup : 1, this.collisionFilterMask = t.collisionFilterMask !== void 0 ? t.collisionFilterMask : -1, this.material = t.material ? t.material : null, this.body = null;
  }
  updateBoundingSphereRadius() {
    throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
  }
  volume() {
    throw `volume() not implemented for shape type ${this.type}`;
  }
  calculateLocalInertia(t, e) {
    throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
  }
  calculateWorldAABB(t, e, s, i) {
    throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
  }
};
h(Wd, "Shape");
let Ht = Wd;
Ht.idCounter = 0;
Ht.types = iL;
const Fl = class Fl {
  constructor(t) {
    t === void 0 && (t = {}), this.position = new R(), this.quaternion = new Wi(), t.position && this.position.copy(t.position), t.quaternion && this.quaternion.copy(t.quaternion);
  }
  pointToLocal(t, e) {
    return Fl.pointToLocalFrame(this.position, this.quaternion, t, e);
  }
  pointToWorld(t, e) {
    return Fl.pointToWorldFrame(this.position, this.quaternion, t, e);
  }
  vectorToWorldFrame(t, e) {
    return e === void 0 && (e = new R()), this.quaternion.vmult(t, e), e;
  }
  static pointToLocalFrame(t, e, s, i) {
    return i === void 0 && (i = new R()), s.vsub(t, i), e.conjugate(nw), nw.vmult(i, i), i;
  }
  static pointToWorldFrame(t, e, s, i) {
    return i === void 0 && (i = new R()), e.vmult(s, i), i.vadd(t, i), i;
  }
  static vectorToWorldFrame(t, e, s) {
    return s === void 0 && (s = new R()), t.vmult(e, s), s;
  }
  static vectorToLocalFrame(t, e, s, i) {
    return i === void 0 && (i = new R()), e.w *= -1, e.vmult(s, i), e.w *= -1, i;
  }
};
h(Fl, "Transform");
let on = Fl;
const nw = new Wi(), vc = class vc extends Ht {
  constructor(t) {
    t === void 0 && (t = {});
    const {
      vertices: e = [],
      faces: s = [],
      normals: i = [],
      axes: o,
      boundingSphereRadius: r
    } = t;
    super({
      type: Ht.types.CONVEXPOLYHEDRON
    }), this.vertices = e, this.faces = s, this.faceNormals = i, this.faceNormals.length === 0 && this.computeNormals(), r ? this.boundingSphereRadius = r : this.updateBoundingSphereRadius(), this.worldVertices = [], this.worldVerticesNeedsUpdate = !0, this.worldFaceNormals = [], this.worldFaceNormalsNeedsUpdate = !0, this.uniqueAxes = o ? o.slice() : null, this.uniqueEdges = [], this.computeEdges();
  }
  computeEdges() {
    const t = this.faces, e = this.vertices, s = this.uniqueEdges;
    s.length = 0;
    const i = new R();
    for (let o = 0; o !== t.length; o++) {
      const r = t[o], a = r.length;
      for (let l = 0; l !== a; l++) {
        const c = (l + 1) % a;
        e[r[l]].vsub(e[r[c]], i), i.normalize();
        let u = !1;
        for (let m = 0; m !== s.length; m++)
          if (s[m].almostEquals(i) || s[m].almostEquals(i)) {
            u = !0;
            break;
          }
        u || s.push(i.clone());
      }
    }
  }
  computeNormals() {
    this.faceNormals.length = this.faces.length;
    for (let t = 0; t < this.faces.length; t++) {
      for (let i = 0; i < this.faces[t].length; i++)
        if (!this.vertices[this.faces[t][i]])
          throw new Error(`Vertex ${this.faces[t][i]} not found!`);
      const e = this.faceNormals[t] || new R();
      this.getFaceNormal(t, e), e.negate(e), this.faceNormals[t] = e;
      const s = this.vertices[this.faces[t][0]];
      if (e.dot(s) < 0) {
        console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);
        for (let i = 0; i < this.faces[t].length; i++)
          console.warn(`.vertices[${this.faces[t][i]}] = Vec3(${this.vertices[this.faces[t][i]].toString()})`);
      }
    }
  }
  getFaceNormal(t, e) {
    const s = this.faces[t], i = this.vertices[s[0]], o = this.vertices[s[1]], r = this.vertices[s[2]];
    vc.computeNormal(i, o, r, e);
  }
  static computeNormal(t, e, s, i) {
    const o = new R(), r = new R();
    e.vsub(t, r), s.vsub(e, o), o.cross(r, i), i.isZero() || i.normalize();
  }
  clipAgainstHull(t, e, s, i, o, r, a, l, c) {
    const u = new R();
    let m = -1, d = -Number.MAX_VALUE;
    for (let p = 0; p < s.faces.length; p++) {
      u.copy(s.faceNormals[p]), o.vmult(u, u);
      const v = u.dot(r);
      v > d && (d = v, m = p);
    }
    const f = [];
    for (let p = 0; p < s.faces[m].length; p++) {
      const v = s.vertices[s.faces[m][p]], _ = new R();
      _.copy(v), o.vmult(_, _), i.vadd(_, _), f.push(_);
    }
    m >= 0 && this.clipFaceAgainstHull(r, t, e, f, a, l, c);
  }
  findSeparatingAxis(t, e, s, i, o, r, a, l) {
    const c = new R(), u = new R(), m = new R(), d = new R(), f = new R(), p = new R();
    let v = Number.MAX_VALUE;
    const _ = this;
    if (_.uniqueAxes)
      for (let g = 0; g !== _.uniqueAxes.length; g++) {
        s.vmult(_.uniqueAxes[g], c);
        const w = _.testSepAxis(c, t, e, s, i, o);
        if (w === !1)
          return !1;
        w < v && (v = w, r.copy(c));
      }
    else {
      const g = a ? a.length : _.faces.length;
      for (let w = 0; w < g; w++) {
        const S = a ? a[w] : w;
        c.copy(_.faceNormals[S]), s.vmult(c, c);
        const x = _.testSepAxis(c, t, e, s, i, o);
        if (x === !1)
          return !1;
        x < v && (v = x, r.copy(c));
      }
    }
    if (t.uniqueAxes)
      for (let g = 0; g !== t.uniqueAxes.length; g++) {
        o.vmult(t.uniqueAxes[g], u);
        const w = _.testSepAxis(u, t, e, s, i, o);
        if (w === !1)
          return !1;
        w < v && (v = w, r.copy(u));
      }
    else {
      const g = l ? l.length : t.faces.length;
      for (let w = 0; w < g; w++) {
        const S = l ? l[w] : w;
        u.copy(t.faceNormals[S]), o.vmult(u, u);
        const x = _.testSepAxis(u, t, e, s, i, o);
        if (x === !1)
          return !1;
        x < v && (v = x, r.copy(u));
      }
    }
    for (let g = 0; g !== _.uniqueEdges.length; g++) {
      s.vmult(_.uniqueEdges[g], d);
      for (let w = 0; w !== t.uniqueEdges.length; w++)
        if (o.vmult(t.uniqueEdges[w], f), d.cross(f, p), !p.almostZero()) {
          p.normalize();
          const S = _.testSepAxis(p, t, e, s, i, o);
          if (S === !1)
            return !1;
          S < v && (v = S, r.copy(p));
        }
    }
    return i.vsub(e, m), m.dot(r) > 0 && r.negate(r), !0;
  }
  testSepAxis(t, e, s, i, o, r) {
    const a = this;
    vc.project(a, t, s, i, _f), vc.project(e, t, o, r, gf);
    const l = _f[0], c = _f[1], u = gf[0], m = gf[1];
    if (l < m || u < c)
      return !1;
    const d = l - m, f = u - c;
    return d < f ? d : f;
  }
  calculateLocalInertia(t, e) {
    const s = new R(), i = new R();
    this.computeLocalAABB(i, s);
    const o = s.x - i.x, r = s.y - i.y, a = s.z - i.z;
    e.x = 1 / 12 * t * (2 * r * 2 * r + 2 * a * 2 * a), e.y = 1 / 12 * t * (2 * o * 2 * o + 2 * a * 2 * a), e.z = 1 / 12 * t * (2 * r * 2 * r + 2 * o * 2 * o);
  }
  getPlaneConstantOfFace(t) {
    const e = this.faces[t], s = this.faceNormals[t], i = this.vertices[e[0]];
    return -s.dot(i);
  }
  clipFaceAgainstHull(t, e, s, i, o, r, a) {
    const l = new R(), c = new R(), u = new R(), m = new R(), d = new R(), f = new R(), p = new R(), v = new R(), _ = this, g = [], w = i, S = g;
    let x = -1, A = Number.MAX_VALUE;
    for (let y = 0; y < _.faces.length; y++) {
      l.copy(_.faceNormals[y]), s.vmult(l, l);
      const E = l.dot(t);
      E < A && (A = E, x = y);
    }
    if (x < 0)
      return;
    const C = _.faces[x];
    C.connectedFaces = [];
    for (let y = 0; y < _.faces.length; y++)
      for (let E = 0; E < _.faces[y].length; E++)
        C.indexOf(_.faces[y][E]) !== -1 && y !== x && C.connectedFaces.indexOf(y) === -1 && C.connectedFaces.push(y);
    const M = C.length;
    for (let y = 0; y < M; y++) {
      const E = _.vertices[C[y]], I = _.vertices[C[(y + 1) % M]];
      E.vsub(I, c), u.copy(c), s.vmult(u, u), e.vadd(u, u), m.copy(this.faceNormals[x]), s.vmult(m, m), e.vadd(m, m), u.cross(m, d), d.negate(d), f.copy(E), s.vmult(f, f), e.vadd(f, f);
      const B = C.connectedFaces[y];
      p.copy(this.faceNormals[B]);
      const D = this.getPlaneConstantOfFace(B);
      v.copy(p), s.vmult(v, v);
      const N = D - v.dot(e);
      for (this.clipFaceAgainstPlane(w, S, v, N); w.length; )
        w.shift();
      for (; S.length; )
        w.push(S.shift());
    }
    p.copy(this.faceNormals[x]);
    const T = this.getPlaneConstantOfFace(x);
    v.copy(p), s.vmult(v, v);
    const b = T - v.dot(e);
    for (let y = 0; y < w.length; y++) {
      let E = v.dot(w[y]) + b;
      if (E <= o && (console.log(`clamped: depth=${E} to minDist=${o}`), E = o), E <= r) {
        const I = w[y];
        if (E <= 1e-6) {
          const B = {
            point: I,
            normal: v,
            depth: E
          };
          a.push(B);
        }
      }
    }
  }
  clipFaceAgainstPlane(t, e, s, i) {
    let o, r;
    const a = t.length;
    if (a < 2)
      return e;
    let l = t[t.length - 1], c = t[0];
    o = s.dot(l) + i;
    for (let u = 0; u < a; u++) {
      if (c = t[u], r = s.dot(c) + i, o < 0)
        if (r < 0) {
          const m = new R();
          m.copy(c), e.push(m);
        } else {
          const m = new R();
          l.lerp(c, o / (o - r), m), e.push(m);
        }
      else if (r < 0) {
        const m = new R();
        l.lerp(c, o / (o - r), m), e.push(m), e.push(c);
      }
      l = c, o = r;
    }
    return e;
  }
  computeWorldVertices(t, e) {
    for (; this.worldVertices.length < this.vertices.length; )
      this.worldVertices.push(new R());
    const s = this.vertices, i = this.worldVertices;
    for (let o = 0; o !== this.vertices.length; o++)
      e.vmult(s[o], i[o]), t.vadd(i[o], i[o]);
    this.worldVerticesNeedsUpdate = !1;
  }
  computeLocalAABB(t, e) {
    const s = this.vertices;
    t.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), e.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (let i = 0; i < this.vertices.length; i++) {
      const o = s[i];
      o.x < t.x ? t.x = o.x : o.x > e.x && (e.x = o.x), o.y < t.y ? t.y = o.y : o.y > e.y && (e.y = o.y), o.z < t.z ? t.z = o.z : o.z > e.z && (e.z = o.z);
    }
  }
  computeWorldFaceNormals(t) {
    const e = this.faceNormals.length;
    for (; this.worldFaceNormals.length < e; )
      this.worldFaceNormals.push(new R());
    const s = this.faceNormals, i = this.worldFaceNormals;
    for (let o = 0; o !== e; o++)
      t.vmult(s[o], i[o]);
    this.worldFaceNormalsNeedsUpdate = !1;
  }
  updateBoundingSphereRadius() {
    let t = 0;
    const e = this.vertices;
    for (let s = 0; s !== e.length; s++) {
      const i = e[s].lengthSquared();
      i > t && (t = i);
    }
    this.boundingSphereRadius = Math.sqrt(t);
  }
  calculateWorldAABB(t, e, s, i) {
    const o = this.vertices;
    let r, a, l, c, u, m, d = new R();
    for (let f = 0; f < o.length; f++) {
      d.copy(o[f]), e.vmult(d, d), t.vadd(d, d);
      const p = d;
      (r === void 0 || p.x < r) && (r = p.x), (c === void 0 || p.x > c) && (c = p.x), (a === void 0 || p.y < a) && (a = p.y), (u === void 0 || p.y > u) && (u = p.y), (l === void 0 || p.z < l) && (l = p.z), (m === void 0 || p.z > m) && (m = p.z);
    }
    s.set(r, a, l), i.set(c, u, m);
  }
  volume() {
    return 4 * Math.PI * this.boundingSphereRadius / 3;
  }
  getAveragePointLocal(t) {
    t === void 0 && (t = new R());
    const e = this.vertices;
    for (let s = 0; s < e.length; s++)
      t.vadd(e[s], t);
    return t.scale(1 / e.length, t), t;
  }
  transformAllPoints(t, e) {
    const s = this.vertices.length, i = this.vertices;
    if (e) {
      for (let o = 0; o < s; o++) {
        const r = i[o];
        e.vmult(r, r);
      }
      for (let o = 0; o < this.faceNormals.length; o++) {
        const r = this.faceNormals[o];
        e.vmult(r, r);
      }
    }
    if (t)
      for (let o = 0; o < s; o++) {
        const r = i[o];
        r.vadd(t, r);
      }
  }
  pointIsInside(t) {
    const e = this.vertices, s = this.faces, i = this.faceNormals, o = new R();
    this.getAveragePointLocal(o);
    for (let r = 0; r < this.faces.length; r++) {
      let a = i[r];
      const l = e[s[r][0]], c = new R();
      t.vsub(l, c);
      const u = a.dot(c), m = new R();
      o.vsub(l, m);
      const d = a.dot(m);
      if (u < 0 && d > 0 || u > 0 && d < 0)
        return !1;
    }
    return -1;
  }
  static project(t, e, s, i, o) {
    const r = t.vertices.length, a = sL;
    let l = 0, c = 0;
    const u = oL, m = t.vertices;
    u.setZero(), on.vectorToLocalFrame(s, i, e, a), on.pointToLocalFrame(s, i, u, u);
    const d = u.dot(a);
    c = l = m[0].dot(a);
    for (let f = 1; f < r; f++) {
      const p = m[f].dot(a);
      p > l && (l = p), p < c && (c = p);
    }
    if (c -= d, l -= d, c > l) {
      const f = c;
      c = l, l = f;
    }
    o[0] = l, o[1] = c;
  }
};
h(vc, "ConvexPolyhedron");
let ed = vc;
const _f = [], gf = [];
new R();
const sL = new R(), oL = new R(), qd = class qd extends Ht {
  constructor(t) {
    super({
      type: Ht.types.BOX
    }), this.halfExtents = t, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), this.updateBoundingSphereRadius();
  }
  updateConvexPolyhedronRepresentation() {
    const t = this.halfExtents.x, e = this.halfExtents.y, s = this.halfExtents.z, i = R, o = [new i(-t, -e, -s), new i(t, -e, -s), new i(t, e, -s), new i(-t, e, -s), new i(-t, -e, s), new i(t, -e, s), new i(t, e, s), new i(-t, e, s)], r = [
      [3, 2, 1, 0],
      [4, 5, 6, 7],
      [5, 4, 0, 1],
      [2, 3, 7, 6],
      [0, 4, 7, 3],
      [1, 2, 6, 5]
    ], a = [new i(0, 0, 1), new i(0, 1, 0), new i(1, 0, 0)], l = new ed({
      vertices: o,
      faces: r,
      axes: a
    });
    this.convexPolyhedronRepresentation = l, l.material = this.material;
  }
  calculateLocalInertia(t, e) {
    return e === void 0 && (e = new R()), qd.calculateInertia(this.halfExtents, t, e), e;
  }
  static calculateInertia(t, e, s) {
    const i = t;
    s.x = 1 / 12 * e * (2 * i.y * 2 * i.y + 2 * i.z * 2 * i.z), s.y = 1 / 12 * e * (2 * i.x * 2 * i.x + 2 * i.z * 2 * i.z), s.z = 1 / 12 * e * (2 * i.y * 2 * i.y + 2 * i.x * 2 * i.x);
  }
  getSideNormals(t, e) {
    const s = t, i = this.halfExtents;
    if (s[0].set(i.x, 0, 0), s[1].set(0, i.y, 0), s[2].set(0, 0, i.z), s[3].set(-i.x, 0, 0), s[4].set(0, -i.y, 0), s[5].set(0, 0, -i.z), e !== void 0)
      for (let o = 0; o !== s.length; o++)
        e.vmult(s[o], s[o]);
    return s;
  }
  volume() {
    return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
  }
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.halfExtents.length();
  }
  forEachWorldCorner(t, e, s) {
    const i = this.halfExtents, o = [[i.x, i.y, i.z], [-i.x, i.y, i.z], [-i.x, -i.y, i.z], [-i.x, -i.y, -i.z], [i.x, -i.y, -i.z], [i.x, i.y, -i.z], [-i.x, i.y, -i.z], [i.x, -i.y, i.z]];
    for (let r = 0; r < o.length; r++)
      Wo.set(o[r][0], o[r][1], o[r][2]), e.vmult(Wo, Wo), t.vadd(Wo, Wo), s(Wo.x, Wo.y, Wo.z);
  }
  calculateWorldAABB(t, e, s, i) {
    const o = this.halfExtents;
    Ds[0].set(o.x, o.y, o.z), Ds[1].set(-o.x, o.y, o.z), Ds[2].set(-o.x, -o.y, o.z), Ds[3].set(-o.x, -o.y, -o.z), Ds[4].set(o.x, -o.y, -o.z), Ds[5].set(o.x, o.y, -o.z), Ds[6].set(-o.x, o.y, -o.z), Ds[7].set(o.x, -o.y, o.z);
    const r = Ds[0];
    e.vmult(r, r), t.vadd(r, r), i.copy(r), s.copy(r);
    for (let a = 1; a < 8; a++) {
      const l = Ds[a];
      e.vmult(l, l), t.vadd(l, l);
      const c = l.x, u = l.y, m = l.z;
      c > i.x && (i.x = c), u > i.y && (i.y = u), m > i.z && (i.z = m), c < s.x && (s.x = c), u < s.y && (s.y = u), m < s.z && (s.z = m);
    }
  }
};
h(qd, "Box");
let nd = qd;
const Wo = new R(), Ds = [new R(), new R(), new R(), new R(), new R(), new R(), new R(), new R()], I2 = {
  DYNAMIC: 1,
  STATIC: 2,
  KINEMATIC: 4
}, B2 = {
  AWAKE: 0,
  SLEEPY: 1,
  SLEEPING: 2
}, tn = class tn extends td {
  constructor(t) {
    t === void 0 && (t = {}), super(), this.id = tn.idCounter++, this.index = -1, this.world = null, this.vlambda = new R(), this.collisionFilterGroup = typeof t.collisionFilterGroup == "number" ? t.collisionFilterGroup : 1, this.collisionFilterMask = typeof t.collisionFilterMask == "number" ? t.collisionFilterMask : -1, this.collisionResponse = typeof t.collisionResponse == "boolean" ? t.collisionResponse : !0, this.position = new R(), this.previousPosition = new R(), this.interpolatedPosition = new R(), this.initPosition = new R(), t.position && (this.position.copy(t.position), this.previousPosition.copy(t.position), this.interpolatedPosition.copy(t.position), this.initPosition.copy(t.position)), this.velocity = new R(), t.velocity && this.velocity.copy(t.velocity), this.initVelocity = new R(), this.force = new R();
    const e = typeof t.mass == "number" ? t.mass : 0;
    this.mass = e, this.invMass = e > 0 ? 1 / e : 0, this.material = t.material || null, this.linearDamping = typeof t.linearDamping == "number" ? t.linearDamping : 0.01, this.type = e <= 0 ? tn.STATIC : tn.DYNAMIC, typeof t.type == typeof tn.STATIC && (this.type = t.type), this.allowSleep = typeof t.allowSleep != "undefined" ? t.allowSleep : !0, this.sleepState = tn.AWAKE, this.sleepSpeedLimit = typeof t.sleepSpeedLimit != "undefined" ? t.sleepSpeedLimit : 0.1, this.sleepTimeLimit = typeof t.sleepTimeLimit != "undefined" ? t.sleepTimeLimit : 1, this.timeLastSleepy = 0, this.wakeUpAfterNarrowphase = !1, this.torque = new R(), this.quaternion = new Wi(), this.initQuaternion = new Wi(), this.previousQuaternion = new Wi(), this.interpolatedQuaternion = new Wi(), t.quaternion && (this.quaternion.copy(t.quaternion), this.initQuaternion.copy(t.quaternion), this.previousQuaternion.copy(t.quaternion), this.interpolatedQuaternion.copy(t.quaternion)), this.angularVelocity = new R(), t.angularVelocity && this.angularVelocity.copy(t.angularVelocity), this.initAngularVelocity = new R(), this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new R(), this.invInertia = new R(), this.invInertiaWorld = new gr(), this.invMassSolve = 0, this.invInertiaSolve = new R(), this.invInertiaWorldSolve = new gr(), this.fixedRotation = typeof t.fixedRotation != "undefined" ? t.fixedRotation : !1, this.angularDamping = typeof t.angularDamping != "undefined" ? t.angularDamping : 0.01, this.linearFactor = new R(1, 1, 1), t.linearFactor && this.linearFactor.copy(t.linearFactor), this.angularFactor = new R(1, 1, 1), t.angularFactor && this.angularFactor.copy(t.angularFactor), this.aabb = new Yi(), this.aabbNeedsUpdate = !0, this.boundingRadius = 0, this.wlambda = new R(), this.isTrigger = !!t.isTrigger, t.shape && this.addShape(t.shape), this.updateMassProperties();
  }
  wakeUp() {
    const t = this.sleepState;
    this.sleepState = tn.AWAKE, this.wakeUpAfterNarrowphase = !1, t === tn.SLEEPING && this.dispatchEvent(tn.wakeupEvent);
  }
  sleep() {
    this.sleepState = tn.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.wakeUpAfterNarrowphase = !1;
  }
  sleepTick(t) {
    if (this.allowSleep) {
      const e = this.sleepState, s = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared(), i = this.sleepSpeedLimit ** 2;
      e === tn.AWAKE && s < i ? (this.sleepState = tn.SLEEPY, this.timeLastSleepy = t, this.dispatchEvent(tn.sleepyEvent)) : e === tn.SLEEPY && s > i ? this.wakeUp() : e === tn.SLEEPY && t - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(tn.sleepEvent));
    }
  }
  updateSolveMassProperties() {
    this.sleepState === tn.SLEEPING || this.type === tn.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
  }
  pointToLocalFrame(t, e) {
    return e === void 0 && (e = new R()), t.vsub(this.position, e), this.quaternion.conjugate().vmult(e, e), e;
  }
  vectorToLocalFrame(t, e) {
    return e === void 0 && (e = new R()), this.quaternion.conjugate().vmult(t, e), e;
  }
  pointToWorldFrame(t, e) {
    return e === void 0 && (e = new R()), this.quaternion.vmult(t, e), e.vadd(this.position, e), e;
  }
  vectorToWorldFrame(t, e) {
    return e === void 0 && (e = new R()), this.quaternion.vmult(t, e), e;
  }
  addShape(t, e, s) {
    const i = new R(), o = new Wi();
    return e && i.copy(e), s && o.copy(s), this.shapes.push(t), this.shapeOffsets.push(i), this.shapeOrientations.push(o), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, t.body = this, this;
  }
  removeShape(t) {
    const e = this.shapes.indexOf(t);
    return e === -1 ? (console.warn("Shape does not belong to the body"), this) : (this.shapes.splice(e, 1), this.shapeOffsets.splice(e, 1), this.shapeOrientations.splice(e, 1), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, t.body = null, this);
  }
  updateBoundingRadius() {
    const t = this.shapes, e = this.shapeOffsets, s = t.length;
    let i = 0;
    for (let o = 0; o !== s; o++) {
      const r = t[o];
      r.updateBoundingSphereRadius();
      const a = e[o].length(), l = r.boundingSphereRadius;
      a + l > i && (i = a + l);
    }
    this.boundingRadius = i;
  }
  updateAABB() {
    const t = this.shapes, e = this.shapeOffsets, s = this.shapeOrientations, i = t.length, o = rL, r = aL, a = this.quaternion, l = this.aabb, c = cL;
    for (let u = 0; u !== i; u++) {
      const m = t[u];
      a.vmult(e[u], o), o.vadd(this.position, o), a.mult(s[u], r), m.calculateWorldAABB(o, r, c.lowerBound, c.upperBound), u === 0 ? l.copy(c) : l.extend(c);
    }
    this.aabbNeedsUpdate = !1;
  }
  updateInertiaWorld(t) {
    const e = this.invInertia;
    if (!(e.x === e.y && e.y === e.z && !t)) {
      const s = lL, i = uL;
      s.setRotationFromQuaternion(this.quaternion), s.transpose(i), s.scale(e, s), s.mmult(i, this.invInertiaWorld);
    }
  }
  applyForce(t, e) {
    if (e === void 0 && (e = new R()), this.type !== tn.DYNAMIC)
      return;
    this.sleepState === tn.SLEEPING && this.wakeUp();
    const s = hL;
    e.cross(t, s), this.force.vadd(t, this.force), this.torque.vadd(s, this.torque);
  }
  applyLocalForce(t, e) {
    if (e === void 0 && (e = new R()), this.type !== tn.DYNAMIC)
      return;
    const s = dL, i = mL;
    this.vectorToWorldFrame(t, s), this.vectorToWorldFrame(e, i), this.applyForce(s, i);
  }
  applyTorque(t) {
    this.type === tn.DYNAMIC && (this.sleepState === tn.SLEEPING && this.wakeUp(), this.torque.vadd(t, this.torque));
  }
  applyImpulse(t, e) {
    if (e === void 0 && (e = new R()), this.type !== tn.DYNAMIC)
      return;
    this.sleepState === tn.SLEEPING && this.wakeUp();
    const s = e, i = fL;
    i.copy(t), i.scale(this.invMass, i), this.velocity.vadd(i, this.velocity);
    const o = pL;
    s.cross(t, o), this.invInertiaWorld.vmult(o, o), this.angularVelocity.vadd(o, this.angularVelocity);
  }
  applyLocalImpulse(t, e) {
    if (e === void 0 && (e = new R()), this.type !== tn.DYNAMIC)
      return;
    const s = _L, i = gL;
    this.vectorToWorldFrame(t, s), this.vectorToWorldFrame(e, i), this.applyImpulse(s, i);
  }
  updateMassProperties() {
    const t = vL;
    this.invMass = this.mass > 0 ? 1 / this.mass : 0;
    const e = this.inertia, s = this.fixedRotation;
    this.updateAABB(), t.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), nd.calculateInertia(t, this.mass, e), this.invInertia.set(e.x > 0 && !s ? 1 / e.x : 0, e.y > 0 && !s ? 1 / e.y : 0, e.z > 0 && !s ? 1 / e.z : 0), this.updateInertiaWorld(!0);
  }
  getVelocityAtWorldPoint(t, e) {
    const s = new R();
    return t.vsub(this.position, s), this.angularVelocity.cross(s, e), this.velocity.vadd(e, e), e;
  }
  integrate(t, e, s) {
    if (this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), !(this.type === tn.DYNAMIC || this.type === tn.KINEMATIC) || this.sleepState === tn.SLEEPING)
      return;
    const i = this.velocity, o = this.angularVelocity, r = this.position, a = this.force, l = this.torque, c = this.quaternion, u = this.invMass, m = this.invInertiaWorld, d = this.linearFactor, f = u * t;
    i.x += a.x * f * d.x, i.y += a.y * f * d.y, i.z += a.z * f * d.z;
    const p = m.elements, v = this.angularFactor, _ = l.x * v.x, g = l.y * v.y, w = l.z * v.z;
    o.x += t * (p[0] * _ + p[1] * g + p[2] * w), o.y += t * (p[3] * _ + p[4] * g + p[5] * w), o.z += t * (p[6] * _ + p[7] * g + p[8] * w), r.x += i.x * t, r.y += i.y * t, r.z += i.z * t, c.integrate(this.angularVelocity, t, this.angularFactor, c), e && (s ? c.normalizeFast() : c.normalize()), this.aabbNeedsUpdate = !0, this.updateInertiaWorld();
  }
};
h(tn, "Body");
let Me = tn;
Me.idCounter = 0;
Me.COLLIDE_EVENT_NAME = "collide";
Me.DYNAMIC = I2.DYNAMIC;
Me.STATIC = I2.STATIC;
Me.KINEMATIC = I2.KINEMATIC;
Me.AWAKE = B2.AWAKE;
Me.SLEEPY = B2.SLEEPY;
Me.SLEEPING = B2.SLEEPING;
Me.wakeupEvent = {
  type: "wakeup"
};
Me.sleepyEvent = {
  type: "sleepy"
};
Me.sleepEvent = {
  type: "sleep"
};
const rL = new R(), aL = new Wi(), cL = new Yi(), lL = new gr(), uL = new gr();
new gr();
const hL = new R(), dL = new R(), mL = new R(), fL = new R(), pL = new R(), _L = new R(), gL = new R(), vL = new R(), lb = class lb {
  constructor() {
    this.world = null, this.useBoundingBoxes = !1, this.dirty = !0;
  }
  collisionPairs(t, e, s) {
    throw new Error("collisionPairs not implemented for this BroadPhase class!");
  }
  needBroadphaseCollision(t, e) {
    return !(!(t.collisionFilterGroup & e.collisionFilterMask) || !(e.collisionFilterGroup & t.collisionFilterMask) || (t.type & Me.STATIC || t.sleepState === Me.SLEEPING) && (e.type & Me.STATIC || e.sleepState === Me.SLEEPING));
  }
  intersectionTest(t, e, s, i) {
    this.useBoundingBoxes ? this.doBoundingBoxBroadphase(t, e, s, i) : this.doBoundingSphereBroadphase(t, e, s, i);
  }
  doBoundingSphereBroadphase(t, e, s, i) {
    const o = bL;
    e.position.vsub(t.position, o);
    const r = (t.boundingRadius + e.boundingRadius) ** 2;
    o.lengthSquared() < r && (s.push(t), i.push(e));
  }
  doBoundingBoxBroadphase(t, e, s, i) {
    t.aabbNeedsUpdate && t.updateAABB(), e.aabbNeedsUpdate && e.updateAABB(), t.aabb.overlaps(e.aabb) && (s.push(t), i.push(e));
  }
  makePairsUnique(t, e) {
    const s = yL, i = xL, o = wL, r = t.length;
    for (let a = 0; a !== r; a++)
      i[a] = t[a], o[a] = e[a];
    t.length = 0, e.length = 0;
    for (let a = 0; a !== r; a++) {
      const l = i[a].id, c = o[a].id, u = l < c ? `${l},${c}` : `${c},${l}`;
      s[u] = a, s.keys.push(u);
    }
    for (let a = 0; a !== s.keys.length; a++) {
      const l = s.keys.pop(), c = s[l];
      t.push(i[c]), e.push(o[c]), delete s[l];
    }
  }
  setWorld(t) {
  }
  static boundingSphereCheck(t, e) {
    const s = new R();
    t.position.vsub(e.position, s);
    const i = t.shapes[0], o = e.shapes[0];
    return Math.pow(i.boundingSphereRadius + o.boundingSphereRadius, 2) > s.lengthSquared();
  }
  aabbQuery(t, e, s) {
    return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), [];
  }
};
h(lb, "Broadphase");
let Ep = lb;
const bL = new R();
new R();
new Wi();
new R();
const yL = {
  keys: []
}, xL = [], wL = [];
new R();
new R();
new R();
const ub = class ub extends Ep {
  constructor() {
    super();
  }
  collisionPairs(t, e, s) {
    const i = t.bodies, o = i.length;
    let r, a;
    for (let l = 0; l !== o; l++)
      for (let c = 0; c !== l; c++)
        r = i[l], a = i[c], this.needBroadphaseCollision(r, a) && this.intersectionTest(r, a, e, s);
  }
  aabbQuery(t, e, s) {
    s === void 0 && (s = []);
    for (let i = 0; i < t.bodies.length; i++) {
      const o = t.bodies[i];
      o.aabbNeedsUpdate && o.updateAABB(), o.aabb.overlaps(e) && s.push(o);
    }
    return s;
  }
};
h(ub, "NaiveBroadphase");
let id = ub;
const hb = class hb {
  constructor() {
    this.rayFromWorld = new R(), this.rayToWorld = new R(), this.hitNormalWorld = new R(), this.hitPointWorld = new R(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  reset() {
    this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = !1;
  }
  abort() {
    this.shouldStop = !0;
  }
  set(t, e, s, i, o, r, a) {
    this.rayFromWorld.copy(t), this.rayToWorld.copy(e), this.hitNormalWorld.copy(s), this.hitPointWorld.copy(i), this.shape = o, this.body = r, this.distance = a;
  }
};
h(hb, "RaycastResult");
let _a = hb, _3, g3, v3, b3, y3, x3, w3;
const P2 = {
  CLOSEST: 1,
  ANY: 2,
  ALL: 4
};
_3 = Ht.types.SPHERE;
g3 = Ht.types.PLANE;
v3 = Ht.types.BOX;
b3 = Ht.types.CYLINDER;
y3 = Ht.types.CONVEXPOLYHEDRON;
x3 = Ht.types.HEIGHTFIELD;
w3 = Ht.types.TRIMESH;
var yi;
let Ws = (yi = class {
  get [_3]() {
    return this._intersectSphere;
  }
  get [g3]() {
    return this._intersectPlane;
  }
  get [v3]() {
    return this._intersectBox;
  }
  get [b3]() {
    return this._intersectConvex;
  }
  get [y3]() {
    return this._intersectConvex;
  }
  get [x3]() {
    return this._intersectHeightfield;
  }
  get [w3]() {
    return this._intersectTrimesh;
  }
  constructor(t, e) {
    t === void 0 && (t = new R()), e === void 0 && (e = new R()), this.from = t.clone(), this.to = e.clone(), this.direction = new R(), this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = yi.ANY, this.result = new _a(), this.hasHit = !1, this.callback = (s) => {
    };
  }
  intersectWorld(t, e) {
    return this.mode = e.mode || yi.ANY, this.result = e.result || new _a(), this.skipBackfaces = !!e.skipBackfaces, this.collisionFilterMask = typeof e.collisionFilterMask != "undefined" ? e.collisionFilterMask : -1, this.collisionFilterGroup = typeof e.collisionFilterGroup != "undefined" ? e.collisionFilterGroup : -1, this.checkCollisionResponse = typeof e.checkCollisionResponse != "undefined" ? e.checkCollisionResponse : !0, e.from && this.from.copy(e.from), e.to && this.to.copy(e.to), this.callback = e.callback || (() => {
    }), this.hasHit = !1, this.result.reset(), this.updateDirection(), this.getAABB(iw), vf.length = 0, t.broadphase.aabbQuery(t, iw, vf), this.intersectBodies(vf), this.hasHit;
  }
  intersectBody(t, e) {
    e && (this.result = e, this.updateDirection());
    const s = this.checkCollisionResponse;
    if (s && !t.collisionResponse || !(this.collisionFilterGroup & t.collisionFilterMask) || !(t.collisionFilterGroup & this.collisionFilterMask))
      return;
    const i = SL, o = AL;
    for (let r = 0, a = t.shapes.length; r < a; r++) {
      const l = t.shapes[r];
      if (!(s && !l.collisionResponse) && (t.quaternion.mult(t.shapeOrientations[r], o), t.quaternion.vmult(t.shapeOffsets[r], i), i.vadd(t.position, i), this.intersectShape(l, o, i, t), this.result.shouldStop))
        break;
    }
  }
  intersectBodies(t, e) {
    e && (this.result = e, this.updateDirection());
    for (let s = 0, i = t.length; !this.result.shouldStop && s < i; s++)
      this.intersectBody(t[s]);
  }
  updateDirection() {
    this.to.vsub(this.from, this.direction), this.direction.normalize();
  }
  intersectShape(t, e, s, i) {
    const o = this.from;
    if (kL(o, this.direction, s) > t.boundingSphereRadius)
      return;
    const a = this[t.type];
    a && a.call(this, t, e, s, i, t);
  }
  _intersectBox(t, e, s, i, o) {
    return this._intersectConvex(t.convexPolyhedronRepresentation, e, s, i, o);
  }
  _intersectPlane(t, e, s, i, o) {
    const r = this.from, a = this.to, l = this.direction, c = new R(0, 0, 1);
    e.vmult(c, c);
    const u = new R();
    r.vsub(s, u);
    const m = u.dot(c);
    a.vsub(s, u);
    const d = u.dot(c);
    if (m * d > 0 || r.distanceTo(a) < m)
      return;
    const f = c.dot(l);
    if (Math.abs(f) < this.precision)
      return;
    const p = new R(), v = new R(), _ = new R();
    r.vsub(s, p);
    const g = -c.dot(p) / f;
    l.scale(g, v), r.vadd(v, _), this.reportIntersection(c, _, o, i, -1);
  }
  getAABB(t) {
    const {
      lowerBound: e,
      upperBound: s
    } = t, i = this.to, o = this.from;
    e.x = Math.min(i.x, o.x), e.y = Math.min(i.y, o.y), e.z = Math.min(i.z, o.z), s.x = Math.max(i.x, o.x), s.y = Math.max(i.y, o.y), s.z = Math.max(i.z, o.z);
  }
  _intersectHeightfield(t, e, s, i, o) {
    t.data, t.elementSize;
    const r = ML;
    r.from.copy(this.from), r.to.copy(this.to), on.pointToLocalFrame(s, e, r.from, r.from), on.pointToLocalFrame(s, e, r.to, r.to), r.updateDirection();
    const a = CL;
    let l, c, u, m;
    l = c = 0, u = m = t.data.length - 1;
    const d = new Yi();
    r.getAABB(d), t.getIndexOfPosition(d.lowerBound.x, d.lowerBound.y, a, !0), l = Math.max(l, a[0]), c = Math.max(c, a[1]), t.getIndexOfPosition(d.upperBound.x, d.upperBound.y, a, !0), u = Math.min(u, a[0] + 1), m = Math.min(m, a[1] + 1);
    for (let f = l; f < u; f++)
      for (let p = c; p < m; p++) {
        if (this.result.shouldStop)
          return;
        if (t.getAabbAtIndex(f, p, d), !!d.overlapsRay(r)) {
          if (t.getConvexTrianglePillar(f, p, !1), on.pointToWorldFrame(s, e, t.pillarOffset, Qu), this._intersectConvex(t.pillarConvex, e, Qu, i, o, sw), this.result.shouldStop)
            return;
          t.getConvexTrianglePillar(f, p, !0), on.pointToWorldFrame(s, e, t.pillarOffset, Qu), this._intersectConvex(t.pillarConvex, e, Qu, i, o, sw);
        }
      }
  }
  _intersectSphere(t, e, s, i, o) {
    const r = this.from, a = this.to, l = t.radius, c = (a.x - r.x) ** 2 + (a.y - r.y) ** 2 + (a.z - r.z) ** 2, u = 2 * ((a.x - r.x) * (r.x - s.x) + (a.y - r.y) * (r.y - s.y) + (a.z - r.z) * (r.z - s.z)), m = (r.x - s.x) ** 2 + (r.y - s.y) ** 2 + (r.z - s.z) ** 2 - l ** 2, d = u ** 2 - 4 * c * m, f = EL, p = TL;
    if (!(d < 0))
      if (d === 0)
        r.lerp(a, d, f), f.vsub(s, p), p.normalize(), this.reportIntersection(p, f, o, i, -1);
      else {
        const v = (-u - Math.sqrt(d)) / (2 * c), _ = (-u + Math.sqrt(d)) / (2 * c);
        if (v >= 0 && v <= 1 && (r.lerp(a, v, f), f.vsub(s, p), p.normalize(), this.reportIntersection(p, f, o, i, -1)), this.result.shouldStop)
          return;
        _ >= 0 && _ <= 1 && (r.lerp(a, _, f), f.vsub(s, p), p.normalize(), this.reportIntersection(p, f, o, i, -1));
      }
  }
  _intersectConvex(t, e, s, i, o, r) {
    const a = IL, l = ow, c = r && r.faceList || null, u = t.faces, m = t.vertices, d = t.faceNormals, f = this.direction, p = this.from, v = this.to, _ = p.distanceTo(v), g = c ? c.length : u.length, w = this.result;
    for (let S = 0; !w.shouldStop && S < g; S++) {
      const x = c ? c[S] : S, A = u[x], C = d[x], M = e, T = s;
      l.copy(m[A[0]]), M.vmult(l, l), l.vadd(T, l), l.vsub(p, l), M.vmult(C, a);
      const b = f.dot(a);
      if (Math.abs(b) < this.precision)
        continue;
      const y = a.dot(l) / b;
      if (!(y < 0)) {
        f.scale(y, Ci), Ci.vadd(p, Ci), _s.copy(m[A[0]]), M.vmult(_s, _s), T.vadd(_s, _s);
        for (let E = 1; !w.shouldStop && E < A.length - 1; E++) {
          Vs.copy(m[A[E]]), Ls.copy(m[A[E + 1]]), M.vmult(Vs, Vs), M.vmult(Ls, Ls), T.vadd(Vs, Vs), T.vadd(Ls, Ls);
          const I = Ci.distanceTo(p);
          !(yi.pointInTriangle(Ci, _s, Vs, Ls) || yi.pointInTriangle(Ci, Vs, _s, Ls)) || I > _ || this.reportIntersection(a, Ci, o, i, x);
        }
      }
    }
  }
  _intersectTrimesh(t, e, s, i, o, r) {
    const a = BL, l = NL, c = zL, u = ow, m = PL, d = RL, f = DL, p = LL, v = VL, _ = t.indices;
    t.vertices;
    const g = this.from, w = this.to, S = this.direction;
    c.position.copy(s), c.quaternion.copy(e), on.vectorToLocalFrame(s, e, S, m), on.pointToLocalFrame(s, e, g, d), on.pointToLocalFrame(s, e, w, f), f.x *= t.scale.x, f.y *= t.scale.y, f.z *= t.scale.z, d.x *= t.scale.x, d.y *= t.scale.y, d.z *= t.scale.z, f.vsub(d, m), m.normalize();
    const x = d.distanceSquared(f);
    t.tree.rayQuery(this, c, l);
    for (let A = 0, C = l.length; !this.result.shouldStop && A !== C; A++) {
      const M = l[A];
      t.getNormal(M, a), t.getVertex(_[M * 3], _s), _s.vsub(d, u);
      const T = m.dot(a), b = a.dot(u) / T;
      if (b < 0)
        continue;
      m.scale(b, Ci), Ci.vadd(d, Ci), t.getVertex(_[M * 3 + 1], Vs), t.getVertex(_[M * 3 + 2], Ls);
      const y = Ci.distanceSquared(d);
      !(yi.pointInTriangle(Ci, Vs, _s, Ls) || yi.pointInTriangle(Ci, _s, Vs, Ls)) || y > x || (on.vectorToWorldFrame(e, a, v), on.pointToWorldFrame(s, e, Ci, p), this.reportIntersection(v, p, o, i, M));
    }
    l.length = 0;
  }
  reportIntersection(t, e, s, i, o) {
    const r = this.from, a = this.to, l = r.distanceTo(e), c = this.result;
    if (!(this.skipBackfaces && t.dot(this.direction) > 0))
      switch (c.hitFaceIndex = typeof o != "undefined" ? o : -1, this.mode) {
        case yi.ALL:
          this.hasHit = !0, c.set(r, a, t, e, s, i, l), c.hasHit = !0, this.callback(c);
          break;
        case yi.CLOSEST:
          (l < c.distance || !c.hasHit) && (this.hasHit = !0, c.hasHit = !0, c.set(r, a, t, e, s, i, l));
          break;
        case yi.ANY:
          this.hasHit = !0, c.hasHit = !0, c.set(r, a, t, e, s, i, l), c.shouldStop = !0;
          break;
      }
  }
  static pointInTriangle(t, e, s, i) {
    i.vsub(e, Wr), s.vsub(e, rl), t.vsub(e, bf);
    const o = Wr.dot(Wr), r = Wr.dot(rl), a = Wr.dot(bf), l = rl.dot(rl), c = rl.dot(bf);
    let u, m;
    return (u = l * a - r * c) >= 0 && (m = o * c - r * a) >= 0 && u + m < o * l - r * r;
  }
}, h(yi, "Ray"), yi);
Ws.CLOSEST = P2.CLOSEST;
Ws.ANY = P2.ANY;
Ws.ALL = P2.ALL;
const iw = new Yi(), vf = [], rl = new R(), bf = new R(), SL = new R(), AL = new Wi(), Ci = new R(), _s = new R(), Vs = new R(), Ls = new R();
new R();
new _a();
const sw = {
  faceList: [0]
}, Qu = new R(), ML = new Ws(), CL = [], EL = new R(), TL = new R(), IL = new R();
new R();
new R();
const ow = new R(), BL = new R(), PL = new R(), RL = new R(), DL = new R(), VL = new R(), LL = new R();
new Yi();
const NL = [], zL = new on(), Wr = new R(), th = new R();
function kL(n, t, e) {
  e.vsub(n, Wr);
  const s = Wr.dot(t);
  return t.scale(s, th), th.vadd(n, th), e.distanceTo(th);
}
h(kL, "distanceFromIntersection");
const db = class db {
  static defaults(t, e) {
    t === void 0 && (t = {});
    for (let s in e)
      s in t || (t[s] = e[s]);
    return t;
  }
};
h(db, "Utils");
let Tp = db;
const mb = class mb {
  constructor() {
    this.spatial = new R(), this.rotational = new R();
  }
  multiplyElement(t) {
    return t.spatial.dot(this.spatial) + t.rotational.dot(this.rotational);
  }
  multiplyVectors(t, e) {
    return t.dot(this.spatial) + e.dot(this.rotational);
  }
};
h(mb, "JacobianElement");
let sd = mb;
const Xd = class Xd {
  constructor(t, e, s, i) {
    s === void 0 && (s = -1e6), i === void 0 && (i = 1e6), this.id = Xd.idCounter++, this.minForce = s, this.maxForce = i, this.bi = t, this.bj = e, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new sd(), this.jacobianElementB = new sd(), this.enabled = !0, this.multiplier = 0, this.setSpookParams(1e7, 4, 1 / 60);
  }
  setSpookParams(t, e, s) {
    const i = e, o = t, r = s;
    this.a = 4 / (r * (1 + 4 * i)), this.b = 4 * i / (1 + 4 * i), this.eps = 4 / (r * r * o * (1 + 4 * i));
  }
  computeB(t, e, s) {
    const i = this.computeGW(), o = this.computeGq(), r = this.computeGiMf();
    return -o * t - i * e - r * s;
  }
  computeGq() {
    const t = this.jacobianElementA, e = this.jacobianElementB, s = this.bi, i = this.bj, o = s.position, r = i.position;
    return t.spatial.dot(o) + e.spatial.dot(r);
  }
  computeGW() {
    const t = this.jacobianElementA, e = this.jacobianElementB, s = this.bi, i = this.bj, o = s.velocity, r = i.velocity, a = s.angularVelocity, l = i.angularVelocity;
    return t.multiplyVectors(o, a) + e.multiplyVectors(r, l);
  }
  computeGWlambda() {
    const t = this.jacobianElementA, e = this.jacobianElementB, s = this.bi, i = this.bj, o = s.vlambda, r = i.vlambda, a = s.wlambda, l = i.wlambda;
    return t.multiplyVectors(o, a) + e.multiplyVectors(r, l);
  }
  computeGiMf() {
    const t = this.jacobianElementA, e = this.jacobianElementB, s = this.bi, i = this.bj, o = s.force, r = s.torque, a = i.force, l = i.torque, c = s.invMassSolve, u = i.invMassSolve;
    return o.scale(c, rw), a.scale(u, aw), s.invInertiaWorldSolve.vmult(r, cw), i.invInertiaWorldSolve.vmult(l, lw), t.multiplyVectors(rw, cw) + e.multiplyVectors(aw, lw);
  }
  computeGiMGt() {
    const t = this.jacobianElementA, e = this.jacobianElementB, s = this.bi, i = this.bj, o = s.invMassSolve, r = i.invMassSolve, a = s.invInertiaWorldSolve, l = i.invInertiaWorldSolve;
    let c = o + r;
    return a.vmult(t.rotational, eh), c += eh.dot(t.rotational), l.vmult(e.rotational, eh), c += eh.dot(e.rotational), c;
  }
  addToWlambda(t) {
    const e = this.jacobianElementA, s = this.jacobianElementB, i = this.bi, o = this.bj, r = UL;
    i.vlambda.addScaledVector(i.invMassSolve * t, e.spatial, i.vlambda), o.vlambda.addScaledVector(o.invMassSolve * t, s.spatial, o.vlambda), i.invInertiaWorldSolve.vmult(e.rotational, r), i.wlambda.addScaledVector(t, r, i.wlambda), o.invInertiaWorldSolve.vmult(s.rotational, r), o.wlambda.addScaledVector(t, r, o.wlambda);
  }
  computeC() {
    return this.computeGiMGt() + this.eps;
  }
};
h(Xd, "Equation");
let iu = Xd;
iu.idCounter = 0;
const rw = new R(), aw = new R(), cw = new R(), lw = new R(), eh = new R(), UL = new R(), fb = class fb extends iu {
  constructor(t, e, s) {
    s === void 0 && (s = 1e6), super(t, e, 0, s), this.restitution = 0, this.ri = new R(), this.rj = new R(), this.ni = new R();
  }
  computeB(t) {
    const e = this.a, s = this.b, i = this.bi, o = this.bj, r = this.ri, a = this.rj, l = OL, c = $L, u = i.velocity, m = i.angularVelocity;
    i.force, i.torque;
    const d = o.velocity, f = o.angularVelocity;
    o.force, o.torque;
    const p = FL, v = this.jacobianElementA, _ = this.jacobianElementB, g = this.ni;
    r.cross(g, l), a.cross(g, c), g.negate(v.spatial), l.negate(v.rotational), _.spatial.copy(g), _.rotational.copy(c), p.copy(o.position), p.vadd(a, p), p.vsub(i.position, p), p.vsub(r, p);
    const w = g.dot(p), S = this.restitution + 1, x = S * d.dot(g) - S * u.dot(g) + f.dot(c) - m.dot(l), A = this.computeGiMf();
    return -w * e - x * s - t * A;
  }
  getImpactVelocityAlongNormal() {
    const t = GL, e = HL, s = jL, i = WL, o = qL;
    return this.bi.position.vadd(this.ri, s), this.bj.position.vadd(this.rj, i), this.bi.getVelocityAtWorldPoint(s, t), this.bj.getVelocityAtWorldPoint(i, e), t.vsub(e, o), this.ni.dot(o);
  }
};
h(fb, "ContactEquation");
let Ip = fb;
const OL = new R(), $L = new R(), FL = new R(), GL = new R(), HL = new R(), jL = new R(), WL = new R(), qL = new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
const pb = class pb extends iu {
  constructor(t, e, s) {
    super(t, e, -s, s), this.ri = new R(), this.rj = new R(), this.t = new R();
  }
  computeB(t) {
    this.a;
    const e = this.b;
    this.bi, this.bj;
    const s = this.ri, i = this.rj, o = XL, r = ZL, a = this.t;
    s.cross(a, o), i.cross(a, r);
    const l = this.jacobianElementA, c = this.jacobianElementB;
    a.negate(l.spatial), o.negate(l.rotational), c.spatial.copy(a), c.rotational.copy(r);
    const u = this.computeGW(), m = this.computeGiMf();
    return -u * e - t * m;
  }
};
h(pb, "FrictionEquation");
let od = pb;
const XL = new R(), ZL = new R(), Zd = class Zd {
  constructor(t, e, s) {
    s = Tp.defaults(s, {
      friction: 0.3,
      restitution: 0.3,
      contactEquationStiffness: 1e7,
      contactEquationRelaxation: 3,
      frictionEquationStiffness: 1e7,
      frictionEquationRelaxation: 3
    }), this.id = Zd.idCounter++, this.materials = [t, e], this.friction = s.friction, this.restitution = s.restitution, this.contactEquationStiffness = s.contactEquationStiffness, this.contactEquationRelaxation = s.contactEquationRelaxation, this.frictionEquationStiffness = s.frictionEquationStiffness, this.frictionEquationRelaxation = s.frictionEquationRelaxation;
  }
};
h(Zd, "ContactMaterial");
let rd = Zd;
rd.idCounter = 0;
var ma;
let R2 = (ma = class {
  constructor(t) {
    t === void 0 && (t = {});
    let e = "";
    typeof t == "string" && (e = t, t = {}), this.name = e, this.id = ma.idCounter++, this.friction = typeof t.friction != "undefined" ? t.friction : -1, this.restitution = typeof t.restitution != "undefined" ? t.restitution : -1;
  }
}, h(ma, "Material"), ma);
R2.idCounter = 0;
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new Ws();
new R();
new R();
new R();
new R(1, 0, 0), new R(0, 1, 0), new R(0, 0, 1);
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
var Ec;
let YL = (Ec = class extends Ht {
  constructor(t) {
    if (super({
      type: Ht.types.SPHERE
    }), this.radius = t !== void 0 ? t : 1, this.radius < 0)
      throw new Error("The sphere radius cannot be negative.");
    this.updateBoundingSphereRadius();
  }
  calculateLocalInertia(t, e) {
    e === void 0 && (e = new R());
    const s = 2 * t * this.radius * this.radius / 5;
    return e.x = s, e.y = s, e.z = s, e;
  }
  volume() {
    return 4 * Math.PI * Math.pow(this.radius, 3) / 3;
  }
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.radius;
  }
  calculateWorldAABB(t, e, s, i) {
    const o = this.radius, r = ["x", "y", "z"];
    for (let a = 0; a < r.length; a++) {
      const l = r[a];
      s[l] = t[l] - o, i[l] = t[l] + o;
    }
  }
}, h(Ec, "Sphere"), Ec);
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
const _b = class _b extends ed {
  constructor(t, e, s, i) {
    if (t === void 0 && (t = 1), e === void 0 && (e = 1), s === void 0 && (s = 1), i === void 0 && (i = 8), t < 0)
      throw new Error("The cylinder radiusTop cannot be negative.");
    if (e < 0)
      throw new Error("The cylinder radiusBottom cannot be negative.");
    const o = i, r = [], a = [], l = [], c = [], u = [], m = Math.cos, d = Math.sin;
    r.push(new R(-e * d(0), -s * 0.5, e * m(0))), c.push(0), r.push(new R(-t * d(0), s * 0.5, t * m(0))), u.push(1);
    for (let p = 0; p < o; p++) {
      const v = 2 * Math.PI / o * (p + 1), _ = 2 * Math.PI / o * (p + 0.5);
      p < o - 1 ? (r.push(new R(-e * d(v), -s * 0.5, e * m(v))), c.push(2 * p + 2), r.push(new R(-t * d(v), s * 0.5, t * m(v))), u.push(2 * p + 3), l.push([2 * p, 2 * p + 1, 2 * p + 3, 2 * p + 2])) : l.push([2 * p, 2 * p + 1, 1, 0]), (o % 2 === 1 || p < o / 2) && a.push(new R(-d(_), 0, m(_)));
    }
    l.push(c), a.push(new R(0, 1, 0));
    const f = [];
    for (let p = 0; p < u.length; p++)
      f.push(u[u.length - p - 1]);
    l.push(f), super({
      vertices: r,
      faces: l,
      axes: a
    }), this.type = Ht.types.CYLINDER, this.radiusTop = t, this.radiusBottom = e, this.height = s, this.numSegments = i;
  }
};
h(_b, "Cylinder");
let Bp = _b;
var Tc;
let JL = (Tc = class extends Ht {
  constructor() {
    super({
      type: Ht.types.PLANE
    }), this.worldNormal = new R(), this.worldNormalNeedsUpdate = !0, this.boundingSphereRadius = Number.MAX_VALUE;
  }
  computeWorldNormal(t) {
    const e = this.worldNormal;
    e.set(0, 0, 1), t.vmult(e, e), this.worldNormalNeedsUpdate = !1;
  }
  calculateLocalInertia(t, e) {
    return e === void 0 && (e = new R()), e;
  }
  volume() {
    return Number.MAX_VALUE;
  }
  calculateWorldAABB(t, e, s, i) {
    ro.set(0, 0, 1), e.vmult(ro, ro);
    const o = Number.MAX_VALUE;
    s.set(-o, -o, -o), i.set(o, o, o), ro.x === 1 ? i.x = t.x : ro.x === -1 && (s.x = t.x), ro.y === 1 ? i.y = t.y : ro.y === -1 && (s.y = t.y), ro.z === 1 ? i.z = t.z : ro.z === -1 && (s.z = t.z);
  }
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = Number.MAX_VALUE;
  }
}, h(Tc, "Plane"), Tc);
const ro = new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new Yi();
new R();
new Yi();
new R();
new R();
new R();
new R();
new R();
new R();
new R();
new Yi();
new R();
new on();
new Yi();
const gb = class gb {
  constructor() {
    this.equations = [];
  }
  solve(t, e) {
    return 0;
  }
  addEquation(t) {
    t.enabled && !t.bi.isTrigger && !t.bj.isTrigger && this.equations.push(t);
  }
  removeEquation(t) {
    const e = this.equations, s = e.indexOf(t);
    s !== -1 && e.splice(s, 1);
  }
  removeAllEquations() {
    this.equations.length = 0;
  }
};
h(gb, "Solver");
let Pp = gb;
const vb = class vb extends Pp {
  constructor() {
    super(), this.iterations = 10, this.tolerance = 1e-7;
  }
  solve(t, e) {
    let s = 0;
    const i = this.iterations, o = this.tolerance * this.tolerance, r = this.equations, a = r.length, l = e.bodies, c = l.length, u = t;
    let m, d, f, p, v, _;
    if (a !== 0)
      for (let x = 0; x !== c; x++)
        l[x].updateSolveMassProperties();
    const g = QL, w = t6, S = KL;
    g.length = a, w.length = a, S.length = a;
    for (let x = 0; x !== a; x++) {
      const A = r[x];
      S[x] = 0, w[x] = A.computeB(u), g[x] = 1 / A.computeC();
    }
    if (a !== 0) {
      for (let C = 0; C !== c; C++) {
        const M = l[C], T = M.vlambda, b = M.wlambda;
        T.set(0, 0, 0), b.set(0, 0, 0);
      }
      for (s = 0; s !== i; s++) {
        p = 0;
        for (let C = 0; C !== a; C++) {
          const M = r[C];
          m = w[C], d = g[C], _ = S[C], v = M.computeGWlambda(), f = d * (m - v - M.eps * _), _ + f < M.minForce ? f = M.minForce - _ : _ + f > M.maxForce && (f = M.maxForce - _), S[C] += f, p += f > 0 ? f : -f, M.addToWlambda(f);
        }
        if (p * p < o)
          break;
      }
      for (let C = 0; C !== c; C++) {
        const M = l[C], T = M.velocity, b = M.angularVelocity;
        M.vlambda.vmul(M.linearFactor, M.vlambda), T.vadd(M.vlambda, T), M.wlambda.vmul(M.angularFactor, M.wlambda), b.vadd(M.wlambda, b);
      }
      let x = r.length;
      const A = 1 / u;
      for (; x--; )
        r[x].multiplier = S[x] * A;
    }
    return s;
  }
};
h(vb, "GSSolver");
let Rp = vb;
const KL = [], QL = [], t6 = [], bb = class bb {
  constructor() {
    this.objects = [], this.type = Object;
  }
  release() {
    const t = arguments.length;
    for (let e = 0; e !== t; e++)
      this.objects.push(e < 0 || arguments.length <= e ? void 0 : arguments[e]);
    return this;
  }
  get() {
    return this.objects.length === 0 ? this.constructObject() : this.objects.pop();
  }
  constructObject() {
    throw new Error("constructObject() not implemented in this Pool subclass yet!");
  }
  resize(t) {
    const e = this.objects;
    for (; e.length > t; )
      e.pop();
    for (; e.length < t; )
      e.push(this.constructObject());
    return this;
  }
};
h(bb, "Pool");
let Dp = bb;
const yb = class yb extends Dp {
  constructor() {
    super(...arguments), this.type = R;
  }
  constructObject() {
    return new R();
  }
};
h(yb, "Vec3Pool");
let Vp = yb;
const Mn = {
  sphereSphere: Ht.types.SPHERE,
  spherePlane: Ht.types.SPHERE | Ht.types.PLANE,
  boxBox: Ht.types.BOX | Ht.types.BOX,
  sphereBox: Ht.types.SPHERE | Ht.types.BOX,
  planeBox: Ht.types.PLANE | Ht.types.BOX,
  convexConvex: Ht.types.CONVEXPOLYHEDRON,
  sphereConvex: Ht.types.SPHERE | Ht.types.CONVEXPOLYHEDRON,
  planeConvex: Ht.types.PLANE | Ht.types.CONVEXPOLYHEDRON,
  boxConvex: Ht.types.BOX | Ht.types.CONVEXPOLYHEDRON,
  sphereHeightfield: Ht.types.SPHERE | Ht.types.HEIGHTFIELD,
  boxHeightfield: Ht.types.BOX | Ht.types.HEIGHTFIELD,
  convexHeightfield: Ht.types.CONVEXPOLYHEDRON | Ht.types.HEIGHTFIELD,
  sphereParticle: Ht.types.PARTICLE | Ht.types.SPHERE,
  planeParticle: Ht.types.PLANE | Ht.types.PARTICLE,
  boxParticle: Ht.types.BOX | Ht.types.PARTICLE,
  convexParticle: Ht.types.PARTICLE | Ht.types.CONVEXPOLYHEDRON,
  cylinderCylinder: Ht.types.CYLINDER,
  sphereCylinder: Ht.types.SPHERE | Ht.types.CYLINDER,
  planeCylinder: Ht.types.PLANE | Ht.types.CYLINDER,
  boxCylinder: Ht.types.BOX | Ht.types.CYLINDER,
  convexCylinder: Ht.types.CONVEXPOLYHEDRON | Ht.types.CYLINDER,
  heightfieldCylinder: Ht.types.HEIGHTFIELD | Ht.types.CYLINDER,
  particleCylinder: Ht.types.PARTICLE | Ht.types.CYLINDER,
  sphereTrimesh: Ht.types.SPHERE | Ht.types.TRIMESH,
  planeTrimesh: Ht.types.PLANE | Ht.types.TRIMESH
}, xb = class xb {
  get [Mn.sphereSphere]() {
    return this.sphereSphere;
  }
  get [Mn.spherePlane]() {
    return this.spherePlane;
  }
  get [Mn.boxBox]() {
    return this.boxBox;
  }
  get [Mn.sphereBox]() {
    return this.sphereBox;
  }
  get [Mn.planeBox]() {
    return this.planeBox;
  }
  get [Mn.convexConvex]() {
    return this.convexConvex;
  }
  get [Mn.sphereConvex]() {
    return this.sphereConvex;
  }
  get [Mn.planeConvex]() {
    return this.planeConvex;
  }
  get [Mn.boxConvex]() {
    return this.boxConvex;
  }
  get [Mn.sphereHeightfield]() {
    return this.sphereHeightfield;
  }
  get [Mn.boxHeightfield]() {
    return this.boxHeightfield;
  }
  get [Mn.convexHeightfield]() {
    return this.convexHeightfield;
  }
  get [Mn.sphereParticle]() {
    return this.sphereParticle;
  }
  get [Mn.planeParticle]() {
    return this.planeParticle;
  }
  get [Mn.boxParticle]() {
    return this.boxParticle;
  }
  get [Mn.convexParticle]() {
    return this.convexParticle;
  }
  get [Mn.cylinderCylinder]() {
    return this.convexConvex;
  }
  get [Mn.sphereCylinder]() {
    return this.sphereConvex;
  }
  get [Mn.planeCylinder]() {
    return this.planeConvex;
  }
  get [Mn.boxCylinder]() {
    return this.boxConvex;
  }
  get [Mn.convexCylinder]() {
    return this.convexConvex;
  }
  get [Mn.heightfieldCylinder]() {
    return this.heightfieldCylinder;
  }
  get [Mn.particleCylinder]() {
    return this.particleCylinder;
  }
  get [Mn.sphereTrimesh]() {
    return this.sphereTrimesh;
  }
  get [Mn.planeTrimesh]() {
    return this.planeTrimesh;
  }
  constructor(t) {
    this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], this.v3pool = new Vp(), this.world = t, this.currentContactMaterial = t.defaultContactMaterial, this.enableFrictionReduction = !1;
  }
  createContactEquation(t, e, s, i, o, r) {
    let a;
    this.contactPointPool.length ? (a = this.contactPointPool.pop(), a.bi = t, a.bj = e) : a = new Ip(t, e), a.enabled = t.collisionResponse && e.collisionResponse && s.collisionResponse && i.collisionResponse;
    const l = this.currentContactMaterial;
    a.restitution = l.restitution, a.setSpookParams(l.contactEquationStiffness, l.contactEquationRelaxation, this.world.dt);
    const c = s.material || t.material, u = i.material || e.material;
    return c && u && c.restitution >= 0 && u.restitution >= 0 && (a.restitution = c.restitution * u.restitution), a.si = o || s, a.sj = r || i, a;
  }
  createFrictionEquationsFromContact(t, e) {
    const s = t.bi, i = t.bj, o = t.si, r = t.sj, a = this.world, l = this.currentContactMaterial;
    let c = l.friction;
    const u = o.material || s.material, m = r.material || i.material;
    if (u && m && u.friction >= 0 && m.friction >= 0 && (c = u.friction * m.friction), c > 0) {
      const d = c * (a.frictionGravity || a.gravity).length();
      let f = s.invMass + i.invMass;
      f > 0 && (f = 1 / f);
      const p = this.frictionEquationPool, v = p.length ? p.pop() : new od(s, i, d * f), _ = p.length ? p.pop() : new od(s, i, d * f);
      return v.bi = _.bi = s, v.bj = _.bj = i, v.minForce = _.minForce = -d * f, v.maxForce = _.maxForce = d * f, v.ri.copy(t.ri), v.rj.copy(t.rj), _.ri.copy(t.ri), _.rj.copy(t.rj), t.ni.tangents(v.t, _.t), v.setSpookParams(l.frictionEquationStiffness, l.frictionEquationRelaxation, a.dt), _.setSpookParams(l.frictionEquationStiffness, l.frictionEquationRelaxation, a.dt), v.enabled = _.enabled = t.enabled, e.push(v, _), !0;
    }
    return !1;
  }
  createFrictionFromAverage(t) {
    let e = this.result[this.result.length - 1];
    if (!this.createFrictionEquationsFromContact(e, this.frictionResult) || t === 1)
      return;
    const s = this.frictionResult[this.frictionResult.length - 2], i = this.frictionResult[this.frictionResult.length - 1];
    Pr.setZero(), Ha.setZero(), ja.setZero();
    const o = e.bi;
    e.bj;
    for (let a = 0; a !== t; a++)
      e = this.result[this.result.length - 1 - a], e.bi !== o ? (Pr.vadd(e.ni, Pr), Ha.vadd(e.ri, Ha), ja.vadd(e.rj, ja)) : (Pr.vsub(e.ni, Pr), Ha.vadd(e.rj, Ha), ja.vadd(e.ri, ja));
    const r = 1 / t;
    Ha.scale(r, s.ri), ja.scale(r, s.rj), i.ri.copy(s.ri), i.rj.copy(s.rj), Pr.normalize(), Pr.tangents(s.t, i.t);
  }
  getContacts(t, e, s, i, o, r, a) {
    this.contactPointPool = o, this.frictionEquationPool = a, this.result = i, this.frictionResult = r;
    const l = i6, c = s6, u = e6, m = n6;
    for (let d = 0, f = t.length; d !== f; d++) {
      const p = t[d], v = e[d];
      let _ = null;
      p.material && v.material && (_ = s.getContactMaterial(p.material, v.material) || null);
      const g = p.type & Me.KINEMATIC && v.type & Me.STATIC || p.type & Me.STATIC && v.type & Me.KINEMATIC || p.type & Me.KINEMATIC && v.type & Me.KINEMATIC;
      for (let w = 0; w < p.shapes.length; w++) {
        p.quaternion.mult(p.shapeOrientations[w], l), p.quaternion.vmult(p.shapeOffsets[w], u), u.vadd(p.position, u);
        const S = p.shapes[w];
        for (let x = 0; x < v.shapes.length; x++) {
          v.quaternion.mult(v.shapeOrientations[x], c), v.quaternion.vmult(v.shapeOffsets[x], m), m.vadd(v.position, m);
          const A = v.shapes[x];
          if (!(S.collisionFilterMask & A.collisionFilterGroup && A.collisionFilterMask & S.collisionFilterGroup) || u.distanceTo(m) > S.boundingSphereRadius + A.boundingSphereRadius)
            continue;
          let C = null;
          S.material && A.material && (C = s.getContactMaterial(S.material, A.material) || null), this.currentContactMaterial = C || _ || s.defaultContactMaterial;
          const M = S.type | A.type, T = this[M];
          if (T) {
            let b = !1;
            S.type < A.type ? b = T.call(this, S, A, u, m, l, c, p, v, S, A, g) : b = T.call(this, A, S, m, u, c, l, v, p, S, A, g), b && g && (s.shapeOverlapKeeper.set(S.id, A.id), s.bodyOverlapKeeper.set(p.id, v.id));
          }
        }
      }
    }
  }
  sphereSphere(t, e, s, i, o, r, a, l, c, u, m) {
    if (m)
      return s.distanceSquared(i) < (t.radius + e.radius) ** 2;
    const d = this.createContactEquation(a, l, t, e, c, u);
    i.vsub(s, d.ni), d.ni.normalize(), d.ri.copy(d.ni), d.rj.copy(d.ni), d.ri.scale(t.radius, d.ri), d.rj.scale(-e.radius, d.rj), d.ri.vadd(s, d.ri), d.ri.vsub(a.position, d.ri), d.rj.vadd(i, d.rj), d.rj.vsub(l.position, d.rj), this.result.push(d), this.createFrictionEquationsFromContact(d, this.frictionResult);
  }
  spherePlane(t, e, s, i, o, r, a, l, c, u, m) {
    const d = this.createContactEquation(a, l, t, e, c, u);
    if (d.ni.set(0, 0, 1), r.vmult(d.ni, d.ni), d.ni.negate(d.ni), d.ni.normalize(), d.ni.scale(t.radius, d.ri), s.vsub(i, nh), d.ni.scale(d.ni.dot(nh), uw), nh.vsub(uw, d.rj), -nh.dot(d.ni) <= t.radius) {
      if (m)
        return !0;
      const f = d.ri, p = d.rj;
      f.vadd(s, f), f.vsub(a.position, f), p.vadd(i, p), p.vsub(l.position, p), this.result.push(d), this.createFrictionEquationsFromContact(d, this.frictionResult);
    }
  }
  boxBox(t, e, s, i, o, r, a, l, c, u, m) {
    return t.convexPolyhedronRepresentation.material = t.material, e.convexPolyhedronRepresentation.material = e.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexConvex(t.convexPolyhedronRepresentation, e.convexPolyhedronRepresentation, s, i, o, r, a, l, t, e, m);
  }
  sphereBox(t, e, s, i, o, r, a, l, c, u, m) {
    const d = this.v3pool, f = B6;
    s.vsub(i, ih), e.getSideNormals(f, r);
    const p = t.radius;
    let v = !1;
    const _ = R6, g = D6, w = V6;
    let S = null, x = 0, A = 0, C = 0, M = null;
    for (let V = 0, G = f.length; V !== G && v === !1; V++) {
      const U = E6;
      U.copy(f[V]);
      const j = U.length();
      U.normalize();
      const tt = ih.dot(U);
      if (tt < j + p && tt > 0) {
        const K = T6, $ = I6;
        K.copy(f[(V + 1) % 3]), $.copy(f[(V + 2) % 3]);
        const lt = K.length(), gt = $.length();
        K.normalize(), $.normalize();
        const _t = ih.dot(K), Y = ih.dot($);
        if (_t < lt && _t > -lt && Y < gt && Y > -gt) {
          const it = Math.abs(tt - j - p);
          if ((M === null || it < M) && (M = it, A = _t, C = Y, S = j, _.copy(U), g.copy(K), w.copy($), x++, m))
            return !0;
        }
      }
    }
    if (x) {
      v = !0;
      const V = this.createContactEquation(a, l, t, e, c, u);
      _.scale(-p, V.ri), V.ni.copy(_), V.ni.negate(V.ni), _.scale(S, _), g.scale(A, g), _.vadd(g, _), w.scale(C, w), _.vadd(w, V.rj), V.ri.vadd(s, V.ri), V.ri.vsub(a.position, V.ri), V.rj.vadd(i, V.rj), V.rj.vsub(l.position, V.rj), this.result.push(V), this.createFrictionEquationsFromContact(V, this.frictionResult);
    }
    let T = d.get();
    const b = P6;
    for (let V = 0; V !== 2 && !v; V++)
      for (let G = 0; G !== 2 && !v; G++)
        for (let U = 0; U !== 2 && !v; U++)
          if (T.set(0, 0, 0), V ? T.vadd(f[0], T) : T.vsub(f[0], T), G ? T.vadd(f[1], T) : T.vsub(f[1], T), U ? T.vadd(f[2], T) : T.vsub(f[2], T), i.vadd(T, b), b.vsub(s, b), b.lengthSquared() < p * p) {
            if (m)
              return !0;
            v = !0;
            const j = this.createContactEquation(a, l, t, e, c, u);
            j.ri.copy(b), j.ri.normalize(), j.ni.copy(j.ri), j.ri.scale(p, j.ri), j.rj.copy(T), j.ri.vadd(s, j.ri), j.ri.vsub(a.position, j.ri), j.rj.vadd(i, j.rj), j.rj.vsub(l.position, j.rj), this.result.push(j), this.createFrictionEquationsFromContact(j, this.frictionResult);
          }
    d.release(T), T = null;
    const y = d.get(), E = d.get(), I = d.get(), B = d.get(), D = d.get(), N = f.length;
    for (let V = 0; V !== N && !v; V++)
      for (let G = 0; G !== N && !v; G++)
        if (V % 3 !== G % 3) {
          f[G].cross(f[V], y), y.normalize(), f[V].vadd(f[G], E), I.copy(s), I.vsub(E, I), I.vsub(i, I);
          const U = I.dot(y);
          y.scale(U, B);
          let j = 0;
          for (; j === V % 3 || j === G % 3; )
            j++;
          D.copy(s), D.vsub(B, D), D.vsub(E, D), D.vsub(i, D);
          const tt = Math.abs(U), K = D.length();
          if (tt < f[j].length() && K < p) {
            if (m)
              return !0;
            v = !0;
            const $ = this.createContactEquation(a, l, t, e, c, u);
            E.vadd(B, $.rj), $.rj.copy($.rj), D.negate($.ni), $.ni.normalize(), $.ri.copy($.rj), $.ri.vadd(i, $.ri), $.ri.vsub(s, $.ri), $.ri.normalize(), $.ri.scale(p, $.ri), $.ri.vadd(s, $.ri), $.ri.vsub(a.position, $.ri), $.rj.vadd(i, $.rj), $.rj.vsub(l.position, $.rj), this.result.push($), this.createFrictionEquationsFromContact($, this.frictionResult);
          }
        }
    d.release(y, E, I, B, D);
  }
  planeBox(t, e, s, i, o, r, a, l, c, u, m) {
    return e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, e.convexPolyhedronRepresentation.id = e.id, this.planeConvex(t, e.convexPolyhedronRepresentation, s, i, o, r, a, l, t, e, m);
  }
  convexConvex(t, e, s, i, o, r, a, l, c, u, m, d, f) {
    const p = Z6;
    if (!(s.distanceTo(i) > t.boundingSphereRadius + e.boundingSphereRadius) && t.findSeparatingAxis(e, s, o, i, r, p, d, f)) {
      const v = [], _ = Y6;
      t.clipAgainstHull(s, o, e, i, r, p, -100, 100, v);
      let g = 0;
      for (let w = 0; w !== v.length; w++) {
        if (m)
          return !0;
        const S = this.createContactEquation(a, l, t, e, c, u), x = S.ri, A = S.rj;
        p.negate(S.ni), v[w].normal.negate(_), _.scale(v[w].depth, _), v[w].point.vadd(_, x), A.copy(v[w].point), x.vsub(s, x), A.vsub(i, A), x.vadd(s, x), x.vsub(a.position, x), A.vadd(i, A), A.vsub(l.position, A), this.result.push(S), g++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(S, this.frictionResult);
      }
      this.enableFrictionReduction && g && this.createFrictionFromAverage(g);
    }
  }
  sphereConvex(t, e, s, i, o, r, a, l, c, u, m) {
    const d = this.v3pool;
    s.vsub(i, L6);
    const f = e.faceNormals, p = e.faces, v = e.vertices, _ = t.radius;
    let g = !1;
    for (let w = 0; w !== v.length; w++) {
      const S = v[w], x = U6;
      r.vmult(S, x), i.vadd(x, x);
      const A = k6;
      if (x.vsub(s, A), A.lengthSquared() < _ * _) {
        if (m)
          return !0;
        g = !0;
        const C = this.createContactEquation(a, l, t, e, c, u);
        C.ri.copy(A), C.ri.normalize(), C.ni.copy(C.ri), C.ri.scale(_, C.ri), x.vsub(i, C.rj), C.ri.vadd(s, C.ri), C.ri.vsub(a.position, C.ri), C.rj.vadd(i, C.rj), C.rj.vsub(l.position, C.rj), this.result.push(C), this.createFrictionEquationsFromContact(C, this.frictionResult);
        return;
      }
    }
    for (let w = 0, S = p.length; w !== S && g === !1; w++) {
      const x = f[w], A = p[w], C = O6;
      r.vmult(x, C);
      const M = $6;
      r.vmult(v[A[0]], M), M.vadd(i, M);
      const T = F6;
      C.scale(-_, T), s.vadd(T, T);
      const b = G6;
      T.vsub(M, b);
      const y = b.dot(C), E = H6;
      if (s.vsub(M, E), y < 0 && E.dot(C) > 0) {
        const I = [];
        for (let B = 0, D = A.length; B !== D; B++) {
          const N = d.get();
          r.vmult(v[A[B]], N), i.vadd(N, N), I.push(N);
        }
        if (C6(I, C, s)) {
          if (m)
            return !0;
          g = !0;
          const B = this.createContactEquation(a, l, t, e, c, u);
          C.scale(-_, B.ri), C.negate(B.ni);
          const D = d.get();
          C.scale(-y, D);
          const N = d.get();
          C.scale(-_, N), s.vsub(i, B.rj), B.rj.vadd(N, B.rj), B.rj.vadd(D, B.rj), B.rj.vadd(i, B.rj), B.rj.vsub(l.position, B.rj), B.ri.vadd(s, B.ri), B.ri.vsub(a.position, B.ri), d.release(D), d.release(N), this.result.push(B), this.createFrictionEquationsFromContact(B, this.frictionResult);
          for (let V = 0, G = I.length; V !== G; V++)
            d.release(I[V]);
          return;
        } else
          for (let B = 0; B !== A.length; B++) {
            const D = d.get(), N = d.get();
            r.vmult(v[A[(B + 1) % A.length]], D), r.vmult(v[A[(B + 2) % A.length]], N), i.vadd(D, D), i.vadd(N, N);
            const V = N6;
            N.vsub(D, V);
            const G = z6;
            V.unit(G);
            const U = d.get(), j = d.get();
            s.vsub(D, j);
            const tt = j.dot(G);
            G.scale(tt, U), U.vadd(D, U);
            const K = d.get();
            if (U.vsub(s, K), tt > 0 && tt * tt < V.lengthSquared() && K.lengthSquared() < _ * _) {
              if (m)
                return !0;
              const $ = this.createContactEquation(a, l, t, e, c, u);
              U.vsub(i, $.rj), U.vsub(s, $.ni), $.ni.normalize(), $.ni.scale(_, $.ri), $.rj.vadd(i, $.rj), $.rj.vsub(l.position, $.rj), $.ri.vadd(s, $.ri), $.ri.vsub(a.position, $.ri), this.result.push($), this.createFrictionEquationsFromContact($, this.frictionResult);
              for (let lt = 0, gt = I.length; lt !== gt; lt++)
                d.release(I[lt]);
              d.release(D), d.release(N), d.release(U), d.release(K), d.release(j);
              return;
            }
            d.release(D), d.release(N), d.release(U), d.release(K), d.release(j);
          }
        for (let B = 0, D = I.length; B !== D; B++)
          d.release(I[B]);
      }
    }
  }
  planeConvex(t, e, s, i, o, r, a, l, c, u, m) {
    const d = j6, f = W6;
    f.set(0, 0, 1), o.vmult(f, f);
    let p = 0;
    const v = q6;
    for (let _ = 0; _ !== e.vertices.length; _++)
      if (d.copy(e.vertices[_]), r.vmult(d, d), i.vadd(d, d), d.vsub(s, v), f.dot(v) <= 0) {
        if (m)
          return !0;
        const w = this.createContactEquation(a, l, t, e, c, u), S = X6;
        f.scale(f.dot(v), S), d.vsub(S, S), S.vsub(s, w.ri), w.ni.copy(f), d.vsub(i, w.rj), w.ri.vadd(s, w.ri), w.ri.vsub(a.position, w.ri), w.rj.vadd(i, w.rj), w.rj.vsub(l.position, w.rj), this.result.push(w), p++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(w, this.frictionResult);
      }
    this.enableFrictionReduction && p && this.createFrictionFromAverage(p);
  }
  boxConvex(t, e, s, i, o, r, a, l, c, u, m) {
    return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.convexConvex(t.convexPolyhedronRepresentation, e, s, i, o, r, a, l, t, e, m);
  }
  sphereHeightfield(t, e, s, i, o, r, a, l, c, u, m) {
    const d = e.data, f = t.radius, p = e.elementSize, v = cN, _ = aN;
    on.pointToLocalFrame(i, r, s, _);
    let g = Math.floor((_.x - f) / p) - 1, w = Math.ceil((_.x + f) / p) + 1, S = Math.floor((_.y - f) / p) - 1, x = Math.ceil((_.y + f) / p) + 1;
    if (w < 0 || x < 0 || g > d.length || S > d[0].length)
      return;
    g < 0 && (g = 0), w < 0 && (w = 0), S < 0 && (S = 0), x < 0 && (x = 0), g >= d.length && (g = d.length - 1), w >= d.length && (w = d.length - 1), x >= d[0].length && (x = d[0].length - 1), S >= d[0].length && (S = d[0].length - 1);
    const A = [];
    e.getRectMinMax(g, S, w, x, A);
    const C = A[0], M = A[1];
    if (_.z - f > M || _.z + f < C)
      return;
    const T = this.result;
    for (let b = g; b < w; b++)
      for (let y = S; y < x; y++) {
        const E = T.length;
        let I = !1;
        if (e.getConvexTrianglePillar(b, y, !1), on.pointToWorldFrame(i, r, e.pillarOffset, v), s.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (I = this.sphereConvex(t, e.pillarConvex, s, v, o, r, a, l, t, e, m)), m && I || (e.getConvexTrianglePillar(b, y, !0), on.pointToWorldFrame(i, r, e.pillarOffset, v), s.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (I = this.sphereConvex(t, e.pillarConvex, s, v, o, r, a, l, t, e, m)), m && I))
          return !0;
        if (T.length - E > 2)
          return;
      }
  }
  boxHeightfield(t, e, s, i, o, r, a, l, c, u, m) {
    return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.convexHeightfield(t.convexPolyhedronRepresentation, e, s, i, o, r, a, l, t, e, m);
  }
  convexHeightfield(t, e, s, i, o, r, a, l, c, u, m) {
    const d = e.data, f = e.elementSize, p = t.boundingSphereRadius, v = oN, _ = rN, g = sN;
    on.pointToLocalFrame(i, r, s, g);
    let w = Math.floor((g.x - p) / f) - 1, S = Math.ceil((g.x + p) / f) + 1, x = Math.floor((g.y - p) / f) - 1, A = Math.ceil((g.y + p) / f) + 1;
    if (S < 0 || A < 0 || w > d.length || x > d[0].length)
      return;
    w < 0 && (w = 0), S < 0 && (S = 0), x < 0 && (x = 0), A < 0 && (A = 0), w >= d.length && (w = d.length - 1), S >= d.length && (S = d.length - 1), A >= d[0].length && (A = d[0].length - 1), x >= d[0].length && (x = d[0].length - 1);
    const C = [];
    e.getRectMinMax(w, x, S, A, C);
    const M = C[0], T = C[1];
    if (!(g.z - p > T || g.z + p < M))
      for (let b = w; b < S; b++)
        for (let y = x; y < A; y++) {
          let E = !1;
          if (e.getConvexTrianglePillar(b, y, !1), on.pointToWorldFrame(i, r, e.pillarOffset, v), s.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (E = this.convexConvex(t, e.pillarConvex, s, v, o, r, a, l, null, null, m, _, null)), m && E || (e.getConvexTrianglePillar(b, y, !0), on.pointToWorldFrame(i, r, e.pillarOffset, v), s.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (E = this.convexConvex(t, e.pillarConvex, s, v, o, r, a, l, null, null, m, _, null)), m && E))
            return !0;
        }
  }
  sphereParticle(t, e, s, i, o, r, a, l, c, u, m) {
    const d = tN;
    if (d.set(0, 0, 1), i.vsub(s, d), d.lengthSquared() <= t.radius * t.radius) {
      if (m)
        return !0;
      const p = this.createContactEquation(l, a, e, t, c, u);
      d.normalize(), p.rj.copy(d), p.rj.scale(t.radius, p.rj), p.ni.copy(d), p.ni.negate(p.ni), p.ri.set(0, 0, 0), this.result.push(p), this.createFrictionEquationsFromContact(p, this.frictionResult);
    }
  }
  planeParticle(t, e, s, i, o, r, a, l, c, u, m) {
    const d = J6;
    d.set(0, 0, 1), a.quaternion.vmult(d, d);
    const f = K6;
    if (i.vsub(a.position, f), d.dot(f) <= 0) {
      if (m)
        return !0;
      const v = this.createContactEquation(l, a, e, t, c, u);
      v.ni.copy(d), v.ni.negate(v.ni), v.ri.set(0, 0, 0);
      const _ = Q6;
      d.scale(d.dot(i), _), i.vsub(_, _), v.rj.copy(_), this.result.push(v), this.createFrictionEquationsFromContact(v, this.frictionResult);
    }
  }
  boxParticle(t, e, s, i, o, r, a, l, c, u, m) {
    return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.convexParticle(t.convexPolyhedronRepresentation, e, s, i, o, r, a, l, t, e, m);
  }
  convexParticle(t, e, s, i, o, r, a, l, c, u, m) {
    let d = -1;
    const f = nN, p = iN;
    let v = null;
    const _ = eN;
    if (_.copy(i), _.vsub(s, _), o.conjugate(hw), hw.vmult(_, _), t.pointIsInside(_)) {
      t.worldVerticesNeedsUpdate && t.computeWorldVertices(s, o), t.worldFaceNormalsNeedsUpdate && t.computeWorldFaceNormals(o);
      for (let g = 0, w = t.faces.length; g !== w; g++) {
        const S = [t.worldVertices[t.faces[g][0]]], x = t.worldFaceNormals[g];
        i.vsub(S[0], dw);
        const A = -x.dot(dw);
        if (v === null || Math.abs(A) < Math.abs(v)) {
          if (m)
            return !0;
          v = A, d = g, f.copy(x);
        }
      }
      if (d !== -1) {
        const g = this.createContactEquation(l, a, e, t, c, u);
        f.scale(v, p), p.vadd(i, p), p.vsub(s, p), g.rj.copy(p), f.negate(g.ni), g.ri.set(0, 0, 0);
        const w = g.ri, S = g.rj;
        w.vadd(i, w), w.vsub(l.position, w), S.vadd(s, S), S.vsub(a.position, S), this.result.push(g), this.createFrictionEquationsFromContact(g, this.frictionResult);
      } else
        console.warn("Point found inside convex, but did not find penetrating face!");
    }
  }
  heightfieldCylinder(t, e, s, i, o, r, a, l, c, u, m) {
    return this.convexHeightfield(e, t, i, s, r, o, l, a, c, u, m);
  }
  particleCylinder(t, e, s, i, o, r, a, l, c, u, m) {
    return this.convexParticle(e, t, i, s, r, o, l, a, c, u, m);
  }
  sphereTrimesh(t, e, s, i, o, r, a, l, c, u, m) {
    const d = d6, f = m6, p = f6, v = p6, _ = _6, g = g6, w = x6, S = h6, x = l6, A = w6;
    on.pointToLocalFrame(i, r, s, _);
    const C = t.radius;
    w.lowerBound.set(_.x - C, _.y - C, _.z - C), w.upperBound.set(_.x + C, _.y + C, _.z + C), e.getTrianglesInAABB(w, A);
    const M = u6, T = t.radius * t.radius;
    for (let B = 0; B < A.length; B++)
      for (let D = 0; D < 3; D++)
        if (e.getVertex(e.indices[A[B] * 3 + D], M), M.vsub(_, x), x.lengthSquared() <= T) {
          if (S.copy(M), on.pointToWorldFrame(i, r, S, M), M.vsub(s, x), m)
            return !0;
          let N = this.createContactEquation(a, l, t, e, c, u);
          N.ni.copy(x), N.ni.normalize(), N.ri.copy(N.ni), N.ri.scale(t.radius, N.ri), N.ri.vadd(s, N.ri), N.ri.vsub(a.position, N.ri), N.rj.copy(M), N.rj.vsub(l.position, N.rj), this.result.push(N), this.createFrictionEquationsFromContact(N, this.frictionResult);
        }
    for (let B = 0; B < A.length; B++)
      for (let D = 0; D < 3; D++) {
        e.getVertex(e.indices[A[B] * 3 + D], d), e.getVertex(e.indices[A[B] * 3 + (D + 1) % 3], f), f.vsub(d, p), _.vsub(f, g);
        const N = g.dot(p);
        _.vsub(d, g);
        let V = g.dot(p);
        if (V > 0 && N < 0 && (_.vsub(d, g), v.copy(p), v.normalize(), V = g.dot(v), v.scale(V, g), g.vadd(d, g), g.distanceTo(_) < t.radius)) {
          if (m)
            return !0;
          const U = this.createContactEquation(a, l, t, e, c, u);
          g.vsub(_, U.ni), U.ni.normalize(), U.ni.scale(t.radius, U.ri), U.ri.vadd(s, U.ri), U.ri.vsub(a.position, U.ri), on.pointToWorldFrame(i, r, g, g), g.vsub(l.position, U.rj), on.vectorToWorldFrame(r, U.ni, U.ni), on.vectorToWorldFrame(r, U.ri, U.ri), this.result.push(U), this.createFrictionEquationsFromContact(U, this.frictionResult);
        }
      }
    const b = v6, y = b6, E = y6, I = c6;
    for (let B = 0, D = A.length; B !== D; B++) {
      e.getTriangleVertices(A[B], b, y, E), e.getNormal(A[B], I), _.vsub(b, g);
      let N = g.dot(I);
      if (I.scale(N, g), _.vsub(g, g), N = g.distanceTo(_), Ws.pointInTriangle(g, b, y, E) && N < t.radius) {
        if (m)
          return !0;
        let V = this.createContactEquation(a, l, t, e, c, u);
        g.vsub(_, V.ni), V.ni.normalize(), V.ni.scale(t.radius, V.ri), V.ri.vadd(s, V.ri), V.ri.vsub(a.position, V.ri), on.pointToWorldFrame(i, r, g, g), g.vsub(l.position, V.rj), on.vectorToWorldFrame(r, V.ni, V.ni), on.vectorToWorldFrame(r, V.ri, V.ri), this.result.push(V), this.createFrictionEquationsFromContact(V, this.frictionResult);
      }
    }
    A.length = 0;
  }
  planeTrimesh(t, e, s, i, o, r, a, l, c, u, m) {
    const d = new R(), f = o6;
    f.set(0, 0, 1), o.vmult(f, f);
    for (let p = 0; p < e.vertices.length / 3; p++) {
      e.getVertex(p, d);
      const v = new R();
      v.copy(d), on.pointToWorldFrame(i, r, v, d);
      const _ = r6;
      if (d.vsub(s, _), f.dot(_) <= 0) {
        if (m)
          return !0;
        const w = this.createContactEquation(a, l, t, e, c, u);
        w.ni.copy(f);
        const S = a6;
        f.scale(_.dot(f), S), d.vsub(S, S), w.ri.copy(S), w.ri.vsub(a.position, w.ri), w.rj.copy(d), w.rj.vsub(l.position, w.rj), this.result.push(w), this.createFrictionEquationsFromContact(w, this.frictionResult);
      }
    }
  }
};
h(xb, "Narrowphase");
let Lp = xb;
const Pr = new R(), Ha = new R(), ja = new R(), e6 = new R(), n6 = new R(), i6 = new Wi(), s6 = new Wi(), o6 = new R(), r6 = new R(), a6 = new R(), c6 = new R(), l6 = new R();
new R();
const u6 = new R(), h6 = new R(), d6 = new R(), m6 = new R(), f6 = new R(), p6 = new R(), _6 = new R(), g6 = new R(), v6 = new R(), b6 = new R(), y6 = new R(), x6 = new Yi(), w6 = [], nh = new R(), uw = new R(), S6 = new R(), A6 = new R(), M6 = new R();
function C6(n, t, e) {
  let s = null;
  const i = n.length;
  for (let o = 0; o !== i; o++) {
    const r = n[o], a = S6;
    n[(o + 1) % i].vsub(r, a);
    const l = A6;
    a.cross(t, l);
    const c = M6;
    e.vsub(r, c);
    const u = l.dot(c);
    if (s === null || u > 0 && s === !0 || u <= 0 && s === !1) {
      s === null && (s = u > 0);
      continue;
    } else
      return !1;
  }
  return !0;
}
h(C6, "pointInPolygon");
const ih = new R(), E6 = new R(), T6 = new R(), I6 = new R(), B6 = [new R(), new R(), new R(), new R(), new R(), new R()], P6 = new R(), R6 = new R(), D6 = new R(), V6 = new R(), L6 = new R(), N6 = new R(), z6 = new R(), k6 = new R(), U6 = new R(), O6 = new R(), $6 = new R(), F6 = new R(), G6 = new R(), H6 = new R();
new R();
new R();
const j6 = new R(), W6 = new R(), q6 = new R(), X6 = new R(), Z6 = new R(), Y6 = new R(), J6 = new R(), K6 = new R(), Q6 = new R(), tN = new R(), hw = new Wi(), eN = new R();
new R();
const nN = new R(), dw = new R(), iN = new R(), sN = new R(), oN = new R(), rN = [0], aN = new R(), cN = new R(), wb = class wb {
  constructor() {
    this.current = [], this.previous = [];
  }
  getKey(t, e) {
    if (e < t) {
      const s = e;
      e = t, t = s;
    }
    return t << 16 | e;
  }
  set(t, e) {
    const s = this.getKey(t, e), i = this.current;
    let o = 0;
    for (; s > i[o]; )
      o++;
    if (s !== i[o]) {
      for (let r = i.length - 1; r >= o; r--)
        i[r + 1] = i[r];
      i[o] = s;
    }
  }
  tick() {
    const t = this.current;
    this.current = this.previous, this.previous = t, this.current.length = 0;
  }
  getDiff(t, e) {
    const s = this.current, i = this.previous, o = s.length, r = i.length;
    let a = 0;
    for (let l = 0; l < o; l++) {
      let c = !1;
      const u = s[l];
      for (; u > i[a]; )
        a++;
      c = u === i[a], c || mw(t, u);
    }
    a = 0;
    for (let l = 0; l < r; l++) {
      let c = !1;
      const u = i[l];
      for (; u > s[a]; )
        a++;
      c = s[a] === u, c || mw(e, u);
    }
  }
};
h(wb, "OverlapKeeper");
let ad = wb;
function mw(n, t) {
  n.push((t & 4294901760) >> 16, t & 65535);
}
h(mw, "unpackAndPush");
const yf = /* @__PURE__ */ h((n, t) => n < t ? `${n}-${t}` : `${t}-${n}`, "getKey"), Sb = class Sb {
  constructor() {
    this.data = {
      keys: []
    };
  }
  get(t, e) {
    const s = yf(t, e);
    return this.data[s];
  }
  set(t, e, s) {
    const i = yf(t, e);
    this.get(t, e) || this.data.keys.push(i), this.data[i] = s;
  }
  delete(t, e) {
    const s = yf(t, e), i = this.data.keys.indexOf(s);
    i !== -1 && this.data.keys.splice(i, 1), delete this.data[s];
  }
  reset() {
    const t = this.data, e = t.keys;
    for (; e.length > 0; ) {
      const s = e.pop();
      delete t[s];
    }
  }
};
h(Sb, "TupleDictionary");
let Np = Sb;
const Ab = class Ab extends td {
  constructor(t) {
    t === void 0 && (t = {}), super(), this.dt = -1, this.allowSleep = !!t.allowSleep, this.contacts = [], this.frictionEquations = [], this.quatNormalizeSkip = t.quatNormalizeSkip !== void 0 ? t.quatNormalizeSkip : 0, this.quatNormalizeFast = t.quatNormalizeFast !== void 0 ? t.quatNormalizeFast : !1, this.time = 0, this.stepnumber = 0, this.default_dt = 1 / 60, this.nextId = 0, this.gravity = new R(), t.gravity && this.gravity.copy(t.gravity), t.frictionGravity && (this.frictionGravity = new R(), this.frictionGravity.copy(t.frictionGravity)), this.broadphase = t.broadphase !== void 0 ? t.broadphase : new id(), this.bodies = [], this.hasActiveBodies = !1, this.solver = t.solver !== void 0 ? t.solver : new Rp(), this.constraints = [], this.narrowphase = new Lp(this), this.collisionMatrix = new Qh(), this.collisionMatrixPrevious = new Qh(), this.bodyOverlapKeeper = new ad(), this.shapeOverlapKeeper = new ad(), this.contactmaterials = [], this.contactMaterialTable = new Np(), this.defaultMaterial = new R2("default"), this.defaultContactMaterial = new rd(this.defaultMaterial, this.defaultMaterial, {
      friction: 0.3,
      restitution: 0
    }), this.doProfiling = !1, this.profile = {
      solve: 0,
      makeContactConstraints: 0,
      broadphase: 0,
      integrate: 0,
      narrowphase: 0
    }, this.accumulator = 0, this.subsystems = [], this.addBodyEvent = {
      type: "addBody",
      body: null
    }, this.removeBodyEvent = {
      type: "removeBody",
      body: null
    }, this.idToBodyMap = {}, this.broadphase.setWorld(this);
  }
  getContactMaterial(t, e) {
    return this.contactMaterialTable.get(t.id, e.id);
  }
  collisionMatrixTick() {
    const t = this.collisionMatrixPrevious;
    this.collisionMatrixPrevious = this.collisionMatrix, this.collisionMatrix = t, this.collisionMatrix.reset(), this.bodyOverlapKeeper.tick(), this.shapeOverlapKeeper.tick();
  }
  addConstraint(t) {
    this.constraints.push(t);
  }
  removeConstraint(t) {
    const e = this.constraints.indexOf(t);
    e !== -1 && this.constraints.splice(e, 1);
  }
  rayTest(t, e, s) {
    s instanceof _a ? this.raycastClosest(t, e, {
      skipBackfaces: !0
    }, s) : this.raycastAll(t, e, {
      skipBackfaces: !0
    }, s);
  }
  raycastAll(t, e, s, i) {
    return s === void 0 && (s = {}), s.mode = Ws.ALL, s.from = t, s.to = e, s.callback = i, xf.intersectWorld(this, s);
  }
  raycastAny(t, e, s, i) {
    return s === void 0 && (s = {}), s.mode = Ws.ANY, s.from = t, s.to = e, s.result = i, xf.intersectWorld(this, s);
  }
  raycastClosest(t, e, s, i) {
    return s === void 0 && (s = {}), s.mode = Ws.CLOSEST, s.from = t, s.to = e, s.result = i, xf.intersectWorld(this, s);
  }
  addBody(t) {
    this.bodies.includes(t) || (t.index = this.bodies.length, this.bodies.push(t), t.world = this, t.initPosition.copy(t.position), t.initVelocity.copy(t.velocity), t.timeLastSleepy = this.time, t instanceof Me && (t.initAngularVelocity.copy(t.angularVelocity), t.initQuaternion.copy(t.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = t, this.idToBodyMap[t.id] = t, this.dispatchEvent(this.addBodyEvent));
  }
  removeBody(t) {
    t.world = null;
    const e = this.bodies.length - 1, s = this.bodies, i = s.indexOf(t);
    if (i !== -1) {
      s.splice(i, 1);
      for (let o = 0; o !== s.length; o++)
        s[o].index = o;
      this.collisionMatrix.setNumObjects(e), this.removeBodyEvent.body = t, delete this.idToBodyMap[t.id], this.dispatchEvent(this.removeBodyEvent);
    }
  }
  getBodyById(t) {
    return this.idToBodyMap[t];
  }
  getShapeById(t) {
    const e = this.bodies;
    for (let s = 0; s < e.length; s++) {
      const i = e[s].shapes;
      for (let o = 0; o < i.length; o++) {
        const r = i[o];
        if (r.id === t)
          return r;
      }
    }
    return null;
  }
  addContactMaterial(t) {
    this.contactmaterials.push(t), this.contactMaterialTable.set(t.materials[0].id, t.materials[1].id, t);
  }
  removeContactMaterial(t) {
    const e = this.contactmaterials.indexOf(t);
    e !== -1 && (this.contactmaterials.splice(e, 1), this.contactMaterialTable.delete(t.materials[0].id, t.materials[1].id));
  }
  fixedStep(t, e) {
    t === void 0 && (t = 1 / 60), e === void 0 && (e = 10);
    const s = Xn.now() / 1e3;
    if (!this.lastCallTime)
      this.step(t, void 0, e);
    else {
      const i = s - this.lastCallTime;
      this.step(t, i, e);
    }
    this.lastCallTime = s;
  }
  step(t, e, s) {
    if (s === void 0 && (s = 10), e === void 0)
      this.internalStep(t), this.time += t;
    else {
      this.accumulator += e;
      const i = Xn.now();
      let o = 0;
      for (; this.accumulator >= t && o < s && (this.internalStep(t), this.accumulator -= t, o++, !(Xn.now() - i > t * 1e3)); )
        ;
      this.accumulator = this.accumulator % t;
      const r = this.accumulator / t;
      for (let a = 0; a !== this.bodies.length; a++) {
        const l = this.bodies[a];
        l.previousPosition.lerp(l.position, r, l.interpolatedPosition), l.previousQuaternion.slerp(l.quaternion, r, l.interpolatedQuaternion), l.previousQuaternion.normalize();
      }
      this.time += e;
    }
  }
  internalStep(t) {
    this.dt = t;
    const e = this.contacts, s = mN, i = fN, o = this.bodies.length, r = this.bodies, a = this.solver, l = this.gravity, c = this.doProfiling, u = this.profile, m = Me.DYNAMIC;
    let d = -1 / 0;
    const f = this.constraints, p = dN;
    l.length();
    const v = l.x, _ = l.y, g = l.z;
    let w = 0;
    for (c && (d = Xn.now()), w = 0; w !== o; w++) {
      const B = r[w];
      if (B.type === m) {
        const D = B.force, N = B.mass;
        D.x += N * v, D.y += N * _, D.z += N * g;
      }
    }
    for (let B = 0, D = this.subsystems.length; B !== D; B++)
      this.subsystems[B].update();
    c && (d = Xn.now()), s.length = 0, i.length = 0, this.broadphase.collisionPairs(this, s, i), c && (u.broadphase = Xn.now() - d);
    let S = f.length;
    for (w = 0; w !== S; w++) {
      const B = f[w];
      if (!B.collideConnected)
        for (let D = s.length - 1; D >= 0; D -= 1)
          (B.bodyA === s[D] && B.bodyB === i[D] || B.bodyB === s[D] && B.bodyA === i[D]) && (s.splice(D, 1), i.splice(D, 1));
    }
    this.collisionMatrixTick(), c && (d = Xn.now());
    const x = hN, A = e.length;
    for (w = 0; w !== A; w++)
      x.push(e[w]);
    e.length = 0;
    const C = this.frictionEquations.length;
    for (w = 0; w !== C; w++)
      p.push(this.frictionEquations[w]);
    for (this.frictionEquations.length = 0, this.narrowphase.getContacts(
      s,
      i,
      this,
      e,
      x,
      this.frictionEquations,
      p
    ), c && (u.narrowphase = Xn.now() - d), c && (d = Xn.now()), w = 0; w < this.frictionEquations.length; w++)
      a.addEquation(this.frictionEquations[w]);
    const M = e.length;
    for (let B = 0; B !== M; B++) {
      const D = e[B], N = D.bi, V = D.bj, G = D.si, U = D.sj;
      let j;
      if (N.material && V.material ? j = this.getContactMaterial(N.material, V.material) || this.defaultContactMaterial : j = this.defaultContactMaterial, j.friction, N.material && V.material && (N.material.friction >= 0 && V.material.friction >= 0 && N.material.friction * V.material.friction, N.material.restitution >= 0 && V.material.restitution >= 0 && (D.restitution = N.material.restitution * V.material.restitution)), a.addEquation(D), N.allowSleep && N.type === Me.DYNAMIC && N.sleepState === Me.SLEEPING && V.sleepState === Me.AWAKE && V.type !== Me.STATIC) {
        const tt = V.velocity.lengthSquared() + V.angularVelocity.lengthSquared(), K = V.sleepSpeedLimit ** 2;
        tt >= K * 2 && (N.wakeUpAfterNarrowphase = !0);
      }
      if (V.allowSleep && V.type === Me.DYNAMIC && V.sleepState === Me.SLEEPING && N.sleepState === Me.AWAKE && N.type !== Me.STATIC) {
        const tt = N.velocity.lengthSquared() + N.angularVelocity.lengthSquared(), K = N.sleepSpeedLimit ** 2;
        tt >= K * 2 && (V.wakeUpAfterNarrowphase = !0);
      }
      this.collisionMatrix.set(N, V, !0), this.collisionMatrixPrevious.get(N, V) || (al.body = V, al.contact = D, N.dispatchEvent(al), al.body = N, V.dispatchEvent(al)), this.bodyOverlapKeeper.set(N.id, V.id), this.shapeOverlapKeeper.set(G.id, U.id);
    }
    for (this.emitContactEvents(), c && (u.makeContactConstraints = Xn.now() - d, d = Xn.now()), w = 0; w !== o; w++) {
      const B = r[w];
      B.wakeUpAfterNarrowphase && (B.wakeUp(), B.wakeUpAfterNarrowphase = !1);
    }
    for (S = f.length, w = 0; w !== S; w++) {
      const B = f[w];
      B.update();
      for (let D = 0, N = B.equations.length; D !== N; D++) {
        const V = B.equations[D];
        a.addEquation(V);
      }
    }
    a.solve(t, this), c && (u.solve = Xn.now() - d), a.removeAllEquations();
    const T = Math.pow;
    for (w = 0; w !== o; w++) {
      const B = r[w];
      if (B.type & m) {
        const D = T(1 - B.linearDamping, t), N = B.velocity;
        N.scale(D, N);
        const V = B.angularVelocity;
        if (V) {
          const G = T(1 - B.angularDamping, t);
          V.scale(G, V);
        }
      }
    }
    this.dispatchEvent(uN), c && (d = Xn.now());
    const y = this.stepnumber % (this.quatNormalizeSkip + 1) === 0, E = this.quatNormalizeFast;
    for (w = 0; w !== o; w++)
      r[w].integrate(t, y, E);
    this.clearForces(), this.broadphase.dirty = !0, c && (u.integrate = Xn.now() - d), this.stepnumber += 1, this.dispatchEvent(lN);
    let I = !0;
    if (this.allowSleep)
      for (I = !1, w = 0; w !== o; w++) {
        const B = r[w];
        B.sleepTick(this.time), B.sleepState !== Me.SLEEPING && (I = !0);
      }
    this.hasActiveBodies = I;
  }
  emitContactEvents() {
    const t = this.hasAnyEventListener("beginContact"), e = this.hasAnyEventListener("endContact");
    if ((t || e) && this.bodyOverlapKeeper.getDiff(ao, co), t) {
      for (let o = 0, r = ao.length; o < r; o += 2)
        cl.bodyA = this.getBodyById(ao[o]), cl.bodyB = this.getBodyById(ao[o + 1]), this.dispatchEvent(cl);
      cl.bodyA = cl.bodyB = null;
    }
    if (e) {
      for (let o = 0, r = co.length; o < r; o += 2)
        ll.bodyA = this.getBodyById(co[o]), ll.bodyB = this.getBodyById(co[o + 1]), this.dispatchEvent(ll);
      ll.bodyA = ll.bodyB = null;
    }
    ao.length = co.length = 0;
    const s = this.hasAnyEventListener("beginShapeContact"), i = this.hasAnyEventListener("endShapeContact");
    if ((s || i) && this.shapeOverlapKeeper.getDiff(ao, co), s) {
      for (let o = 0, r = ao.length; o < r; o += 2) {
        const a = this.getShapeById(ao[o]), l = this.getShapeById(ao[o + 1]);
        lo.shapeA = a, lo.shapeB = l, a && (lo.bodyA = a.body), l && (lo.bodyB = l.body), this.dispatchEvent(lo);
      }
      lo.bodyA = lo.bodyB = lo.shapeA = lo.shapeB = null;
    }
    if (i) {
      for (let o = 0, r = co.length; o < r; o += 2) {
        const a = this.getShapeById(co[o]), l = this.getShapeById(co[o + 1]);
        uo.shapeA = a, uo.shapeB = l, a && (uo.bodyA = a.body), l && (uo.bodyB = l.body), this.dispatchEvent(uo);
      }
      uo.bodyA = uo.bodyB = uo.shapeA = uo.shapeB = null;
    }
  }
  clearForces() {
    const t = this.bodies, e = t.length;
    for (let s = 0; s !== e; s++) {
      const i = t[s];
      i.force, i.torque, i.force.set(0, 0, 0), i.torque.set(0, 0, 0);
    }
  }
};
h(Ab, "World");
let zp = Ab;
new Yi();
const xf = new Ws(), Xn = globalThis.performance || {};
if (!Xn.now) {
  let n = Date.now();
  Xn.timing && Xn.timing.navigationStart && (n = Xn.timing.navigationStart), Xn.now = () => Date.now() - n;
}
new R();
const lN = {
  type: "postStep"
}, uN = {
  type: "preStep"
}, al = {
  type: Me.COLLIDE_EVENT_NAME,
  body: null,
  contact: null
}, hN = [], dN = [], mN = [], fN = [], ao = [], co = [], cl = {
  type: "beginContact",
  bodyA: null,
  bodyB: null
}, ll = {
  type: "endContact",
  bodyA: null,
  bodyB: null
}, lo = {
  type: "beginShapeContact",
  bodyA: null,
  bodyB: null,
  shapeA: null,
  shapeB: null
}, uo = {
  type: "endShapeContact",
  bodyA: null,
  bodyB: null,
  shapeA: null,
  shapeB: null
}, Mb = class Mb {
  constructor(t = {}) {
    var e, s, i, o, r, a, l, c;
    this.bodies = /* @__PURE__ */ new Map(), this.nextBodyId = 1, this._stepCount = 0, this.world = new zp({
      gravity: new R(
        (s = (e = t.gravity) == null ? void 0 : e.x) != null ? s : 0,
        (o = (i = t.gravity) == null ? void 0 : i.y) != null ? o : -19.62,
        (a = (r = t.gravity) == null ? void 0 : r.z) != null ? a : 0
      )
    }), this.world.solver.iterations = (l = t.iterations) != null ? l : 5, this.world.solver.tolerance = (c = t.tolerance) != null ? c : 0.01, this.world.broadphase = new id(), this.world.allowSleep = !1, console.log("✅ Physics3D engine initialized");
  }
  step(t) {
    const e = Math.min(t / 1e3, 0.1);
    this._stepCount || (this._stepCount = 0), this._stepCount++, this.world.step(1 / 60, e, 3);
  }
  createBody(t) {
    var o, r;
    const e = this.nextBodyId++, s = new Me({
      mass: t.bodyType === "static" ? 0 : t.mass,
      position: new R(t.position.x, t.position.y, t.position.z),
      linearDamping: (o = t.linearDamping) != null ? o : 0.01,
      angularDamping: (r = t.angularDamping) != null ? r : 0.01,
      type: this.getBodyType(t.bodyType),
      collisionFilterGroup: t.collisionGroup,
      collisionFilterMask: t.collisionMask
    }), i = new R2();
    return t.friction !== void 0 && (i.friction = t.friction), t.restitution !== void 0 && (i.restitution = t.restitution), t.shape.material = i, s.addShape(t.shape), t.rotation && s.quaternion.set(
      t.rotation.x,
      t.rotation.y,
      t.rotation.z,
      t.rotation.w
    ), t.fixedRotation && (s.fixedRotation = !0, s.updateMassProperties()), this.world.addBody(s), this.bodies.set(e, s), e;
  }
  removeBody(t) {
    const e = this.bodies.get(t);
    e && (this.world.removeBody(e), this.bodies.delete(t));
  }
  getBody(t) {
    return this.bodies.get(t);
  }
  getVelocity(t) {
    const e = this.bodies.get(t);
    return e ? {
      x: e.velocity.x,
      y: e.velocity.y,
      z: e.velocity.z
    } : null;
  }
  applyForce(t, e, s) {
    const i = this.bodies.get(t);
    if (!i) return;
    const o = new R(e.x, e.y, e.z), r = s ? new R(s.x, s.y, s.z) : i.position;
    i.applyForce(o, r);
  }
  applyImpulse(t, e, s) {
    const i = this.bodies.get(t);
    if (!i) return;
    const o = new R(e.x, e.y, e.z), r = s ? new R(s.x, s.y, s.z) : i.position;
    i.applyImpulse(o, r);
  }
  setVelocity(t, e) {
    const s = this.bodies.get(t);
    s && (s.sleepState === Me.SLEEPING && console.warn("💤 Setting velocity on SLEEPING body", t, "velocity:", e), s.velocity.set(e.x, e.y, e.z), s.wakeUp(), s.sleepState === Me.SLEEPING && console.error("❌ Body still sleeping after wakeUp()!", t));
  }
  setAngularVelocity(t, e) {
    const s = this.bodies.get(t);
    s && s.angularVelocity.set(e.x, e.y, e.z);
  }
  setPosition(t, e) {
    const s = this.bodies.get(t);
    s && s.position.set(e.x, e.y, e.z);
  }
  setRotation(t, e) {
    const s = this.bodies.get(t);
    s && s.quaternion.set(e.x, e.y, e.z, e.w);
  }
  raycast(t, e) {
    const s = new R(t.x, t.y, t.z), i = new R(e.x, e.y, e.z), o = new _a();
    return this.world.raycastClosest(s, i, {}, o) ? o : null;
  }
  getBodyType(t) {
    switch (t) {
      case "static":
        return Me.STATIC;
      case "kinematic":
        return Me.KINEMATIC;
      case "dynamic":
      default:
        return Me.DYNAMIC;
    }
  }
  getAllBodies() {
    return Array.from(this.bodies.values());
  }
  clear() {
    for (const t of this.bodies.values())
      this.world.removeBody(t);
    this.bodies.clear();
  }
};
h(Mb, "PhysicsEngine3D");
let kp = Mb;
const Cb = class Cb {
  static createBox(t, e, s) {
    return new nd(new R(t / 2, e / 2, s / 2));
  }
  static createSphere(t) {
    return new YL(t);
  }
  static createCylinder(t, e, s = 16) {
    return new Bp(t, t, e, s);
  }
  static createPlane() {
    return new JL();
  }
};
h(Cb, "PhysicsShapes");
let Fi = Cb;
const os = oi({
  bodyId: Q.ui32,
  bodyType: Q.ui8,
  mass: Q.f32,
  linearDamping: Q.f32,
  angularDamping: Q.f32,
  fixedRotation: Q.ui8,
  collisionGroup: Q.ui32,
  collisionMask: Q.ui32
}), pN = he({
  bodyType: Ri(["dynamic", "static", "kinematic"]).default("dynamic"),
  mass: ct().default(1),
  linearDamping: ct().default(0.01),
  angularDamping: ct().default(0.01),
  fixedRotation: je().default(!1),
  material: Ri(["default", "bouncy", "ice", "rubber", "metal", "wood", "stone"]).optional(),
  friction: ct().optional(),
  restitution: ct().optional(),
  shape: Ri(["box", "sphere", "cylinder", "plane"]).optional(),
  size: ct().optional(),
  radius: ct().optional(),
  width: ct().optional(),
  height: ct().optional(),
  depth: ct().optional(),
  collisionGroup: ct().int().optional(),
  collisionMask: ct().int().optional()
});
function _N(n, t, e) {
  var g, w, S, x, A, C, M, T, b, y, E, I, B, D, N, V, G, U, j, tt, K, $, lt, gt, _t, Y, it, J, dt, vt, Nt, _e, k;
  wn(n.world, os, t);
  const s = (g = ne.component.x[t]) != null ? g : 0, i = (w = ne.component.y[t]) != null ? w : 0, o = (S = ne.component.z[t]) != null ? S : 0, r = (A = (x = ne.component.rotationX) == null ? void 0 : x[t]) != null ? A : 0, a = (M = (C = ne.component.rotationY) == null ? void 0 : C[t]) != null ? M : 0, l = (b = (T = ne.component.rotationZ) == null ? void 0 : T[t]) != null ? b : 0, c = Math.sin(r / 2) * Math.cos(a / 2) * Math.cos(l / 2) - Math.cos(r / 2) * Math.sin(a / 2) * Math.sin(l / 2), u = Math.cos(r / 2) * Math.sin(a / 2) * Math.cos(l / 2) + Math.sin(r / 2) * Math.cos(a / 2) * Math.sin(l / 2), m = Math.cos(r / 2) * Math.cos(a / 2) * Math.sin(l / 2) - Math.sin(r / 2) * Math.sin(a / 2) * Math.cos(l / 2), d = Math.cos(r / 2) * Math.cos(a / 2) * Math.cos(l / 2) + Math.sin(r / 2) * Math.sin(a / 2) * Math.sin(l / 2);
  let f;
  if (Zi(n.world, xo.component, t)) {
    const te = xo.component.shapeType[t];
    if (te === 0) {
      const It = (y = xo.component.halfExtentX[t]) != null ? y : 0.5, ut = (E = xo.component.halfExtentY[t]) != null ? E : 0.5, bt = (I = xo.component.halfExtentZ[t]) != null ? I : 0.5;
      f = Fi.createBox(It * 2, ut * 2, bt * 2);
    } else if (te === 1) {
      const It = (B = xo.component.radius[t]) != null ? B : 0.5;
      f = Fi.createSphere(It);
    } else if (te === 2) {
      const It = (D = xo.component.radius[t]) != null ? D : 0.5, ut = (N = xo.component.height[t]) != null ? N : 1;
      f = Fi.createCylinder(It, ut);
    } else te === 4 ? f = Fi.createPlane() : f = Fi.createBox(1, 1, 1);
  } else {
    const te = e.shape || "box";
    if (te === "box") {
      const It = (G = (V = e.width) != null ? V : e.size) != null ? G : 1, ut = (j = (U = e.height) != null ? U : e.size) != null ? j : 1, bt = (K = (tt = e.depth) != null ? tt : e.size) != null ? K : 1;
      f = Fi.createBox(It, ut, bt);
    } else if (te === "sphere") {
      const It = (lt = ($ = e.radius) != null ? $ : e.size) != null ? lt : 0.5;
      f = Fi.createSphere(It);
    } else if (te === "cylinder") {
      const It = (_t = (gt = e.radius) != null ? gt : e.size) != null ? _t : 0.5, ut = (Y = e.height) != null ? Y : 1;
      f = Fi.createCylinder(It, ut);
    } else te === "plane" ? f = Fi.createPlane() : f = Fi.createBox(1, 1, 1);
  }
  const p = e.bodyType === "static" ? "static" : e.bodyType === "kinematic" ? "kinematic" : "dynamic", v = f3({
    material: e.material,
    friction: e.friction,
    restitution: e.restitution
  }), _ = n.physicsEngine.createBody({
    position: { x: s, y: i, z: o },
    rotation: { x: c, y: u, z: m, w: d },
    mass: (it = e.mass) != null ? it : 1,
    shape: f,
    bodyType: p,
    linearDamping: (J = e.linearDamping) != null ? J : 0.01,
    angularDamping: (dt = e.angularDamping) != null ? dt : 0.01,
    fixedRotation: (vt = e.fixedRotation) != null ? vt : !1,
    friction: v.friction,
    restitution: v.restitution
  });
  n.addPhysicsBody(t, _), os.bodyId[t] = _, os.bodyType[t] = p === "static" ? 1 : p === "kinematic" ? 2 : 0, os.mass[t] = (Nt = e.mass) != null ? Nt : 1, os.linearDamping[t] = (_e = e.linearDamping) != null ? _e : 0.01, os.angularDamping[t] = (k = e.angularDamping) != null ? k : 0.01, os.fixedRotation[t] = e.fixedRotation ? 1 : 0;
}
h(_N, "addRigidBody3D");
const Ue = oi({
  bodyId: Q.ui32,
  moveSpeed: Q.f32,
  jumpForce: Q.f32,
  airControl: Q.f32,
  isGrounded: Q.ui8,
  groundDistance: Q.f32,
  groundCheckRadius: Q.f32,
  radius: Q.f32,
  height: Q.f32,
  jumpRequested: Q.ui8,
  wasGrounded: Q.ui8
}), gN = he({
  radius: ct().default(0.5),
  height: ct().default(2),
  mass: ct().default(1),
  material: Ri(["default", "bouncy", "ice", "rubber", "metal", "wood", "stone"]).optional(),
  moveSpeed: ct().default(5),
  jumpForce: ct().default(10),
  airControl: ct().min(0).max(1).default(0.3),
  groundDistance: ct().default(0.05),
  groundCheckRadius: ct().optional(),
  stepHeight: ct().default(0.5),
  slopeLimit: ct().default(45)
});
function vN(n, t, e) {
  var l, c, u, m;
  wn(n.world, Ue, t);
  const s = (l = ne.component.x[t]) != null ? l : 0, i = (c = ne.component.y[t]) != null ? c : 0, o = (u = ne.component.z[t]) != null ? u : 0, r = Fi.createCylinder(e.radius, e.height, 16), a = n.physicsEngine.createBody({
    position: { x: s, y: i, z: o },
    rotation: { x: 0, y: 0, z: 0, w: 1 },
    mass: e.mass,
    shape: r,
    bodyType: "dynamic",
    linearDamping: 0.01,
    angularDamping: 0.99,
    fixedRotation: !0,
    friction: 0,
    restitution: 0
  });
  n.addPhysicsBody(t, a), Ue.bodyId[t] = a, Ue.moveSpeed[t] = e.moveSpeed, Ue.jumpForce[t] = e.jumpForce, Ue.airControl[t] = e.airControl, Ue.isGrounded[t] = 0, Ue.groundDistance[t] = e.groundDistance, Ue.groundCheckRadius[t] = (m = e.groundCheckRadius) != null ? m : e.radius * 0.8, Ue.radius[t] = e.radius, Ue.height[t] = e.height, Ue.jumpRequested[t] = 0, Ue.wasGrounded[t] = 0, console.log(`✅ CharacterController3D created for eid=${t}:`, {
    position: { x: s, y: i, z: o },
    dimensions: { radius: e.radius, height: e.height },
    moveSpeed: e.moveSpeed,
    jumpForce: e.jumpForce
  });
}
h(vN, "addCharacterController3D");
const gn = oi({
  targetEid: Q.ui32,
  distance: Q.f32,
  height: Q.f32,
  yawOffset: Q.f32,
  pitchOffset: Q.f32,
  followRotation: Q.ui8,
  mouseControl: Q.ui8,
  isDragging: Q.ui8,
  mode: Q.ui8
}), bN = he({
  targetName: $t(),
  distance: ct().default(10),
  height: ct().default(5),
  followRotation: je().default(!0),
  mouseControl: je().default(!0),
  mouseSensitivity: ct().default(5e-3),
  mode: Ri(["back", "front", "firstPerson"]).default("back")
});
function yN(n, t, e) {
  var o;
  wn(n.world, gn, t);
  const s = n.nameToEid.get(e.targetName);
  s === void 0 ? (console.warn(`CameraFollow3D: Target entity "${e.targetName}" not found`), gn.targetEid[t] = 0) : gn.targetEid[t] = s, gn.distance[t] = e.distance, gn.height[t] = e.height, gn.yawOffset[t] = 0, gn.pitchOffset[t] = 0, gn.followRotation[t] = e.followRotation ? 1 : 0, gn.mouseControl[t] = e.mouseControl ? 1 : 0, gn.isDragging[t] = 0;
  const i = {
    back: 0,
    front: 1,
    firstPerson: 2
  };
  gn.mode[t] = (o = i[e.mode]) != null ? o : 0, console.log(`✅ CameraFollow3D created: following "${e.targetName}" (eid=${s})`, {
    distance: e.distance,
    height: e.height,
    mode: e.mode,
    followRotation: e.followRotation
  });
}
h(yN, "addCameraFollow3D");
const na = oi({
  turnSpeed: Q.f32,
  moveAxisId: Q.ui32,
  jumpActionId: Q.ui32
}), xN = he({
  turnSpeed: ct().default(2.5),
  moveAxis: $t().default("Move"),
  jumpAction: $t().default("Jump")
});
function wN(n, t, e) {
  wn(n.world, na, t), na.turnSpeed[t] = e.turnSpeed, na.moveAxisId[t] = 0, na.jumpActionId[t] = 0, console.log(`✅ TankController created for eid=${t}`, {
    turnSpeed: e.turnSpeed,
    moveAxis: e.moveAxis,
    jumpAction: e.jumpAction
  });
}
h(wN, "addTankController");
const SN = he({
  speed: jt().default(5)
}), D2 = Vi("PlayerController", SN), AN = he({
  current: jt().default(0),
  max: jt().default(100),
  isInvulnerable: Ii().default(!1),
  invulnerableTimer: jt().default(0),
  isDead: Ii().default(!1)
}), zs = Vi("Health", AN), fc = oi({
  boneId: Q.ui16,
  skeletonEid: Q.ui32,
  length: Q.f32,
  inverseBindMatrix: [Q.f32, 16]
});
he({
  boneId: ls(),
  skeletonEid: ls(),
  length: ls().default(1)
});
function MN(n) {
  const t = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ];
  fc.inverseBindMatrix[n].set(t);
}
h(MN, "initializeBoneMatrix");
function CN(n, t, e, s, i) {
  const o = Math.cos(i), r = Math.sin(i);
  return new Float32Array([
    o,
    -r,
    0,
    t,
    r,
    o,
    0,
    e,
    0,
    0,
    1,
    s,
    0,
    0,
    0,
    1
  ]);
}
h(CN, "getBoneMatrix");
function EN(n, t, e, s, i) {
  const o = CN(n, t, e, s, i), r = fc.inverseBindMatrix[n];
  return TN(o, r);
}
h(EN, "getSkinningMatrix");
function TN(n, t) {
  const e = new Float32Array(16);
  for (let s = 0; s < 4; s++)
    for (let i = 0; i < 4; i++) {
      let o = 0;
      for (let r = 0; r < 4; r++)
        o += n[s * 4 + r] * t[r * 4 + i];
      e[s * 4 + i] = o;
    }
  return e;
}
h(TN, "multiplyMatrices");
function IN(n, t, e, s = 0) {
  const i = n[0] * t + n[1] * e + n[2] * s + n[3], o = n[4] * t + n[5] * e + n[6] * s + n[7], r = n[8] * t + n[9] * e + n[10] * s + n[11];
  return [i, o, r];
}
h(IN, "transformPoint");
const BN = he({
  viewportX: jt().default(0),
  viewportY: jt().default(0),
  viewportWidth: jt().default(1),
  viewportHeight: jt().default(1),
  zOrder: Wh().default(0),
  isActive: Ii().default(!0)
}), Zn = Vi("Camera", BN);
function PN(n) {
  Zn.assign(n, {
    viewportX: 0,
    viewportY: 0,
    viewportWidth: 1,
    viewportHeight: 1,
    zOrder: 0,
    isActive: !0
  });
}
h(PN, "setCameraFullscreenViewport");
const RN = he({
  isActive: Ii().default(!0),
  viewportX: jt().default(0),
  viewportY: jt().default(0),
  viewportWidth: jt().default(1),
  viewportHeight: jt().default(1),
  zOrder: Wh().default(0),
  projectionType: Ri(["perspective", "orthographic"]).default("perspective"),
  fov: jt().default(1.0472),
  near: jt().default(0.1),
  far: jt().default(1e3),
  orthoWidth: jt().default(20),
  orthoHeight: jt().default(15),
  followSpeed: jt().default(5),
  offsetX: jt().default(0),
  offsetY: jt().default(0),
  offsetZ: jt().default(0),
  targetEid: Wh().default(0)
}), ia = Vi("Camera3D", RN), DN = he({
  radius: jt().default(1),
  color: $t().describe("color").default("#ffffff"),
  isVisible: Ii().default(!0)
}), Ln = Vi("Circle", DN);
function VN(n, t, e) {
  if (!Ln.component.radius[n]) return !1;
  const { x: s, y: i } = ue.read(n), o = Ln.component.radius[n], r = t - s, a = e - i;
  return r * r + a * a <= o * o;
}
h(VN, "isPointInCircle");
const rn = oi({
  lightType: Q.ui8,
  isActive: Q.ui8,
  colorR: Q.f32,
  colorG: Q.f32,
  colorB: Q.f32,
  intensity: Q.f32,
  directionX: Q.f32,
  directionY: Q.f32,
  directionZ: Q.f32,
  range: Q.f32,
  attenuation: Q.f32,
  angle: Q.f32,
  penumbra: Q.f32,
  castsShadows: Q.ui8
}), LN = he({
  lightType: Ri(["ambient", "directional", "point", "spot"]).default("directional"),
  isActive: je().default(!0),
  color: $t().describe("color").default("#ffffff"),
  intensity: ct().default(1),
  directionX: ct().default(0),
  directionY: ct().default(-1),
  directionZ: ct().default(0),
  range: ct().default(100),
  attenuation: ct().default(1),
  angle: ct().default(0.785),
  penumbra: ct().default(0.1),
  castsShadows: je().default(!1)
});
function NN(n, t, e) {
  var a;
  wn(n.world, rn, t);
  const s = {
    ambient: 0,
    directional: 1,
    point: 2,
    spot: 3
  };
  rn.lightType[t] = (a = s[e.lightType]) != null ? a : 1;
  const [i, o, r] = Ie(e.color).rgb();
  rn.colorR[t] = i / 255, rn.colorG[t] = o / 255, rn.colorB[t] = r / 255, rn.intensity[t] = e.intensity, rn.directionX[t] = e.directionX, rn.directionY[t] = e.directionY, rn.directionZ[t] = e.directionZ, rn.range[t] = e.range, rn.attenuation[t] = e.attenuation, rn.angle[t] = e.angle, rn.penumbra[t] = e.penumbra, rn.isActive[t] = e.isActive ? 1 : 0, rn.castsShadows[t] = e.castsShadows ? 1 : 0;
}
h(NN, "addLight");
const ke = oi({
  colorR: Q.f32,
  colorG: Q.f32,
  colorB: Q.f32,
  alpha: Q.f32,
  roughness: Q.f32,
  metallic: Q.f32,
  emissiveR: Q.f32,
  emissiveG: Q.f32,
  emissiveB: Q.f32,
  emissiveIntensity: Q.f32,
  isVisible: Q.ui8,
  castsShadows: Q.ui8,
  receivesShadows: Q.ui8
}), zN = he({
  color: $t().describe("color").default("#ffffff"),
  alpha: ct().default(1),
  roughness: ct().default(0.5),
  metallic: ct().default(0),
  emissiveColor: $t().describe("color").default("#000000"),
  emissiveIntensity: ct().default(0),
  isVisible: je().default(!0),
  castsShadows: je().default(!0),
  receivesShadows: je().default(!0)
});
function kN(n, t, e) {
  wn(n.world, ke, t);
  const [s, i, o] = Ie(e.color).rgb();
  ke.colorR[t] = s / 255, ke.colorG[t] = i / 255, ke.colorB[t] = o / 255;
  const [r, a, l] = Ie(e.emissiveColor).rgb();
  ke.emissiveR[t] = r / 255, ke.emissiveG[t] = a / 255, ke.emissiveB[t] = l / 255, ke.alpha[t] = e.alpha, ke.roughness[t] = e.roughness, ke.metallic[t] = e.metallic, ke.emissiveIntensity[t] = e.emissiveIntensity, ke.isVisible[t] = e.isVisible ? 1 : 0, ke.castsShadows[t] = e.castsShadows ? 1 : 0, ke.receivesShadows[t] = e.receivesShadows ? 1 : 0;
}
h(kN, "addMaterial");
const qn = oi({
  meshId: Q.ui32,
  primitiveType: Q.ui8,
  boundingRadius: Q.f32,
  boundingCenterX: Q.f32,
  boundingCenterY: Q.f32,
  boundingCenterZ: Q.f32,
  vertexCount: Q.ui32,
  triangleCount: Q.ui32
}), UN = he({
  meshId: ct().optional(),
  primitive: Ri(["cube", "sphere", "cylinder", "plane", "torus", "cone"]).optional(),
  size: ct().optional(),
  width: ct().optional(),
  height: ct().optional(),
  depth: ct().optional(),
  radius: ct().optional(),
  segments: ct().int().optional(),
  vertices: We(ls()).optional(),
  normals: We(ls()).optional(),
  indices: We(ls().int()).optional(),
  uvs: We(ls()).optional()
});
function ON(n, t, e) {
  var s, i;
  if (wn(n.world, qn, t), e.primitive) {
    switch (e.primitive) {
      case "cube":
        qn.primitiveType[t] = 1;
        break;
      case "sphere":
        qn.primitiveType[t] = 2;
        break;
      case "cylinder":
        qn.primitiveType[t] = 3;
        break;
      case "plane":
        qn.primitiveType[t] = 4;
        break;
      case "torus":
        qn.primitiveType[t] = 5;
        break;
      case "cone":
        qn.primitiveType[t] = 6;
        break;
      default:
        qn.primitiveType[t] = 1;
    }
    qn.meshId[t] = qn.primitiveType[t];
  } else
    qn.primitiveType[t] = 0, qn.meshId[t] = e.meshId && parseInt(e.meshId) || 0;
  qn.boundingRadius[t] = (i = (s = e.size) != null ? s : e.radius) != null ? i : 0.5, qn.boundingCenterX[t] = 0, qn.boundingCenterY[t] = 0, qn.boundingCenterZ[t] = 0;
}
h(ON, "addMesh3D");
const $N = he({
  meshId: la().default(0),
  materialId: la().default(0),
  isVisible: Ii().default(!0),
  castsShadows: Ii().default(!0),
  receivesShadows: Ii().default(!0),
  animationId: la().default(0),
  animationSpeed: jt().default(1),
  animationTime: jt().default(0),
  animationLoop: Ii().default(!0)
}), Bl = Vi("Model3D", $N), Tn = oi({
  isAlive: Q.ui8,
  lifetime: Q.f32,
  age: Q.f32,
  vx: Q.f32,
  vy: Q.f32,
  gravity: Q.f32,
  size: Q.f32,
  fadeOut: Q.ui8,
  emitterEid: Q.ui32
}), He = oi({
  isActive: Q.ui8,
  presetId: Q.ui8,
  elapsed: Q.f32,
  duration: Q.f32,
  rate: Q.f32,
  timeSinceLastEmit: Q.f32,
  colorR: Q.ui8,
  colorG: Q.ui8,
  colorB: Q.ui8,
  hasCustomColor: Q.ui8
}), V2 = [
  {
    name: "explosion",
    color: "#ff6600",
    size: 0.15,
    sizeVariation: 0.5,
    lifetime: 0.8,
    speed: 8,
    speedVariation: 0.4,
    spread: 360,
    gravity: 0.3,
    fadeOut: !0,
    count: 20
  },
  {
    name: "sparkle",
    color: "#ffee00",
    size: 0.08,
    sizeVariation: 0.3,
    lifetime: 0.5,
    speed: 3,
    speedVariation: 0.5,
    spread: 360,
    gravity: 0,
    fadeOut: !0,
    count: 10
  },
  {
    name: "smoke",
    color: "#888888",
    size: 0.3,
    sizeVariation: 0.4,
    lifetime: 2,
    speed: 1.5,
    speedVariation: 0.3,
    spread: 45,
    gravity: -0.2,
    fadeOut: !0,
    count: 1
  },
  {
    name: "fire",
    color: "#ff4400",
    size: 0.2,
    sizeVariation: 0.5,
    lifetime: 0.6,
    speed: 2,
    speedVariation: 0.4,
    spread: 30,
    gravity: -0.5,
    fadeOut: !0,
    count: 2
  },
  {
    name: "magic",
    color: "#aa00ff",
    size: 0.12,
    sizeVariation: 0.3,
    lifetime: 1,
    speed: 4,
    speedVariation: 0.6,
    spread: 360,
    gravity: 0,
    fadeOut: !0,
    count: 5
  },
  {
    name: "dust",
    color: "#ccaa88",
    size: 0.05,
    sizeVariation: 0.4,
    lifetime: 1.5,
    speed: 0.5,
    speedVariation: 0.5,
    spread: 180,
    gravity: 0.1,
    fadeOut: !0,
    count: 3
  },
  {
    name: "stars",
    color: "#ffffff",
    size: 0.1,
    sizeVariation: 0.3,
    lifetime: 1,
    speed: 2,
    speedVariation: 0.4,
    spread: 360,
    gravity: 0,
    fadeOut: !0,
    count: 8
  },
  {
    name: "bubbles",
    color: "#88ddff",
    size: 0.15,
    sizeVariation: 0.4,
    lifetime: 2,
    speed: 1,
    speedVariation: 0.3,
    spread: 60,
    gravity: -0.3,
    fadeOut: !1,
    count: 1
  },
  {
    name: "rain",
    color: "#6699cc",
    size: 0.08,
    sizeVariation: 0.2,
    lifetime: 1.5,
    speed: 10,
    speedVariation: 0.2,
    spread: 5,
    gravity: 1.5,
    fadeOut: !1,
    count: 5
  },
  {
    name: "snow",
    color: "#ffffff",
    size: 0.1,
    sizeVariation: 0.3,
    lifetime: 3,
    speed: 0.5,
    speedVariation: 0.5,
    spread: 20,
    gravity: 0.1,
    fadeOut: !1,
    count: 2
  },
  {
    name: "hearts",
    color: "#ff69b4",
    size: 0.15,
    sizeVariation: 0.2,
    lifetime: 1.5,
    speed: 2,
    speedVariation: 0.3,
    spread: 45,
    gravity: -0.2,
    fadeOut: !0,
    count: 3
  },
  {
    name: "coins",
    color: "#ffd700",
    size: 0.12,
    sizeVariation: 0.2,
    lifetime: 0.8,
    speed: 5,
    speedVariation: 0.4,
    spread: 90,
    gravity: 0.5,
    fadeOut: !0,
    count: 8
  }
];
function FN(n) {
  return V2.find((t) => t.name === n);
}
h(FN, "getPresetByName");
const GN = he({
  preset: $t(),
  color: $t().optional(),
  rate: ct().optional(),
  duration: ct().default(-1),
  autoStart: je().default(!0)
});
function HN(n, t, e) {
  var o, r;
  wn(n.world, He, t);
  const s = FN(e.preset);
  if (!s) {
    console.warn(`Unknown particle preset: "${e.preset}"`), He.isActive[t] = 0;
    return;
  }
  const i = V2.findIndex((a) => a.name === e.preset);
  if (e.color) {
    const a = Na(e.color);
    He.colorR[t] = a.rgb[0], He.colorG[t] = a.rgb[1], He.colorB[t] = a.rgb[2], He.hasCustomColor[t] = 1;
  } else
    He.hasCustomColor[t] = 0;
  He.presetId[t] = i, He.isActive[t] = e.autoStart ? 1 : 0, He.elapsed[t] = 0, He.duration[t] = e.duration, He.rate[t] = (o = e.rate) != null ? o : s.count, He.timeSinceLastEmit[t] = 0, console.log(`Added ParticleEmitter to entity ${t}:`, {
    preset: e.preset,
    color: (r = e.color) != null ? r : s.color,
    rate: He.rate[t],
    duration: e.duration
  });
}
h(HN, "addParticleEmitter");
function LH(n) {
  He.isActive[n] = 1, He.elapsed[n] = 0;
}
h(LH, "startEmitter");
function NH(n) {
  He.isActive[n] = 0;
}
h(NH, "stopEmitter");
function zH(n) {
  He.timeSinceLastEmit[n] = 999;
}
h(zH, "burstParticles");
const jN = he({
  width: jt().default(1),
  height: jt().default(1),
  color: $t().describe("color").default("#ffffff"),
  isVisible: Ii().default(!0)
}), qs = Vi("Rect", jN);
function WN(n, t, e) {
  if (!qs.component.width[n]) return !1;
  const { x: s, y: i } = ue.read(n), o = qs.component.width[n], r = qs.component.height[n];
  if (o === 0 || r === 0) return !1;
  const [a, l] = [o / 2, r / 2], [c, u] = [s - a, s + a], [m, d] = [i - l, i + l];
  return t >= c && t <= u && e >= m && e <= d;
}
h(WN, "isPointInRect");
const Gt = oi({
  animationSetId: Q.ui32,
  currentAnimationId: Q.ui16,
  animationTime: Q.f32,
  previousFrameIndex: Q.ui16,
  speedMultiplier: Q.f32,
  isPlaying: Q.ui8,
  isLooping: Q.ui8,
  blendTime: Q.f32,
  blendProgress: Q.f32,
  previousAnimationId: Q.ui16,
  isBlending: Q.ui8,
  hasAnimations: Q.ui8
}), fw = he({
  "@time": ct(),
  "@x": ct().optional(),
  "@y": ct().optional(),
  "@z": ct().optional(),
  "@rotation": ct().optional(),
  "@sx": ct().optional(),
  "@sy": ct().optional(),
  "@rotationX": ct().optional(),
  "@rotationY": ct().optional(),
  "@rotationZ": ct().optional(),
  "@easing": $t().optional()
}).transform((n) => ({
  time: n["@time"],
  x: n["@x"],
  y: n["@y"],
  z: n["@z"],
  rotation: n["@rotation"],
  sx: n["@sx"],
  sy: n["@sy"],
  rotationX: n["@rotationX"],
  rotationY: n["@rotationY"],
  rotationZ: n["@rotationZ"],
  easing: n["@easing"]
})), pw = he({
  "@bone": $t(),
  keyframe: cn([fw, We(fw)]).transform((n) => Array.isArray(n) ? n : [n])
}).transform((n) => ({
  boneName: n["@bone"],
  keyframes: n.keyframe
})), _w = he({
  "@time": ct(),
  "@action": $t(),
  "@value": $t().optional()
}).transform((n) => ({
  time: n["@time"],
  action: n["@action"],
  value: n["@value"]
})), gw = he({
  "@name": $t(),
  "@duration": ct(),
  "@fps": ct().default(30),
  "@loop": je().default(!0),
  track: cn([pw, We(pw)]).transform((n) => Array.isArray(n) ? n : [n]),
  event: cn([_w, We(_w)]).optional().transform((n) => n ? Array.isArray(n) ? n : [n] : void 0)
}).transform((n) => ({
  name: n["@name"],
  duration: n["@duration"],
  fps: n["@fps"],
  loop: n["@loop"],
  tracks: n.track,
  events: n.event
})), qN = he({
  defaultAnimation: $t().optional(),
  "@defaultAnimation": $t().optional(),
  blendTime: ct().default(0.15),
  "@blendTime": ct().optional(),
  animation: cn([gw, We(gw)]).optional().transform((n) => n ? Array.isArray(n) ? n : [n] : void 0)
}).transform((n) => {
  var i, o;
  const t = (i = n["@defaultAnimation"]) != null ? i : n.defaultAnimation, e = (o = n["@blendTime"]) != null ? o : n.blendTime, s = n.animation;
  return { defaultAnimation: t, blendTime: e, animations: s };
});
function S3(n, t, e) {
  if (n.addComponentToEntity(Gt, t), !e.animations || e.animations.length === 0) {
    console.warn(`SkeletalAnimation on entity ${t} has no animations defined`), Gt.hasAnimations[t] = 0, Gt.animationSetId[t] = 0, Gt.currentAnimationId[t] = 0, Gt.animationTime[t] = 0, Gt.previousFrameIndex[t] = 0, Gt.speedMultiplier[t] = 1, Gt.isPlaying[t] = 0, Gt.isLooping[t] = 1, Gt.blendTime[t] = e.blendTime, Gt.blendProgress[t] = 0, Gt.previousAnimationId[t] = 0, Gt.isBlending[t] = 0;
    return;
  }
  const s = {
    animations: /* @__PURE__ */ new Map(),
    animationList: []
  };
  for (let o = 0; o < e.animations.length; o++) {
    const r = e.animations[o], a = {
      name: r.name,
      duration: r.duration,
      fps: r.fps,
      loop: r.loop,
      tracks: r.tracks,
      events: r.events
    };
    s.animations.set(r.name, o), s.animationList.push(a);
  }
  const i = n.skeletalAnimationSets.length;
  if (n.skeletalAnimationSets.push(s), Gt.hasAnimations[t] = 1, Gt.animationSetId[t] = i, Gt.currentAnimationId[t] = 0, Gt.animationTime[t] = 0, Gt.previousFrameIndex[t] = 0, Gt.speedMultiplier[t] = 1, Gt.isPlaying[t] = 1, Gt.isLooping[t] = 1, Gt.blendTime[t] = e.blendTime, Gt.blendProgress[t] = 0, Gt.previousAnimationId[t] = 0, Gt.isBlending[t] = 0, e.defaultAnimation) {
    const o = s.animations.get(e.defaultAnimation);
    o !== void 0 ? Gt.currentAnimationId[t] = o : console.warn(`Default animation "${e.defaultAnimation}" not found for entity ${t}`);
  }
  console.log(`Added SkeletalAnimation to entity ${t}:`, {
    setId: i,
    animationCount: s.animationList.length,
    names: s.animationList.map((o) => o.name),
    defaultAnimation: e.defaultAnimation
  });
}
h(S3, "addSkeletalAnimation");
function kH(n, t, e, s) {
  const i = Gt.animationSetId[t];
  if (i >= n.skeletalAnimationSets.length)
    return console.warn(`No animation set found for entity ${t}`), !1;
  const r = n.skeletalAnimationSets[i].animations.get(e);
  if (r === void 0)
    return console.warn(`Animation "${e}" not found on entity ${t}`), !1;
  const a = Gt.currentAnimationId[t];
  if (a !== r) {
    const l = s != null ? s : Gt.blendTime[t];
    l > 0 && (Gt.hasAnimations[t] | 0) === 1 && (Gt.previousAnimationId[t] = a, Gt.blendTime[t] = l, Gt.blendProgress[t] = 0, Gt.isBlending[t] = 1), Gt.currentAnimationId[t] = r, Gt.animationTime[t] = 0;
  }
  return Gt.isPlaying[t] = 1, !0;
}
h(kH, "playSkeletalAnimation");
function UH(n) {
  Gt.isPlaying[n] = 0;
}
h(UH, "stopSkeletalAnimation");
function OH(n) {
  Gt.isPlaying[n] = 0;
}
h(OH, "pauseSkeletalAnimation");
function $H(n) {
  Gt.isPlaying[n] = 1;
}
h($H, "resumeSkeletalAnimation");
function FH(n, t) {
  Gt.speedMultiplier[n] = Math.max(0, t);
}
h(FH, "setSkeletalAnimationSpeed");
function XN(n, t) {
  if (!(Gt.hasAnimations[t] | 0)) return null;
  const e = Gt.animationSetId[t];
  if (e >= n.skeletalAnimationSets.length) return null;
  const s = n.skeletalAnimationSets[e], i = Gt.currentAnimationId[t];
  return i >= s.animationList.length ? null : s.animationList[i];
}
h(XN, "getCurrentSkeletalAnimation");
function GH(n, t) {
  if (!(Gt.hasAnimations[t] | 0)) return [];
  const e = Gt.animationSetId[t];
  return e >= n.skeletalAnimationSets.length ? [] : n.skeletalAnimationSets[e].animationList.map((i) => i.name);
}
h(GH, "getSkeletalAnimationNames");
function ZN(n, t, e) {
  const s = { time: e };
  return n.x !== void 0 && t.x !== void 0 ? s.x = n.x + (t.x - n.x) * e : n.x !== void 0 ? s.x = n.x : t.x !== void 0 && (s.x = t.x), n.y !== void 0 && t.y !== void 0 ? s.y = n.y + (t.y - n.y) * e : n.y !== void 0 ? s.y = n.y : t.y !== void 0 && (s.y = t.y), n.z !== void 0 && t.z !== void 0 ? s.z = n.z + (t.z - n.z) * e : n.z !== void 0 ? s.z = n.z : t.z !== void 0 && (s.z = t.z), n.rotation !== void 0 && t.rotation !== void 0 ? s.rotation = n.rotation + (t.rotation - n.rotation) * e : n.rotation !== void 0 ? s.rotation = n.rotation : t.rotation !== void 0 && (s.rotation = t.rotation), n.sx !== void 0 && t.sx !== void 0 ? s.sx = n.sx + (t.sx - n.sx) * e : n.sx !== void 0 ? s.sx = n.sx : t.sx !== void 0 && (s.sx = t.sx), n.sy !== void 0 && t.sy !== void 0 ? s.sy = n.sy + (t.sy - n.sy) * e : n.sy !== void 0 ? s.sy = n.sy : t.sy !== void 0 && (s.sy = t.sy), s;
}
h(ZN, "interpolateKeyframes");
function Up(n, t) {
  if (n.keyframes.length === 0) return null;
  if (n.keyframes.length === 1) return n.keyframes[0];
  let e = n.keyframes[0], s = n.keyframes[0];
  for (let r = 0; r < n.keyframes.length - 1; r++)
    if (t >= n.keyframes[r].time && t <= n.keyframes[r + 1].time) {
      e = n.keyframes[r], s = n.keyframes[r + 1];
      break;
    }
  if (t >= n.keyframes[n.keyframes.length - 1].time)
    return n.keyframes[n.keyframes.length - 1];
  const i = s.time - e.time;
  if (i === 0) return e;
  const o = (t - e.time) / i;
  return ZN(e, s, o);
}
h(Up, "getBoneTransformAtTime");
const Gi = oi({
  skeletonId: Q.ui32,
  rootBoneEid: Q.ui32,
  renderMode: Q.ui8,
  is3D: Q.ui8
}), vw = he({
  "@name": $t(),
  "@parent": $t().optional(),
  "@length": ct(),
  "@rotation": ct().default(0),
  "@x": ct().optional(),
  "@y": ct().optional(),
  "@z": ct().optional(),
  "@sx": ct().optional(),
  "@sy": ct().optional(),
  "@rotationX": ct().optional(),
  "@rotationY": ct().optional(),
  "@rotationZ": ct().optional(),
  "@color": $t().optional()
}).transform((n) => ({
  name: n["@name"],
  parentName: n["@parent"],
  length: n["@length"],
  rotation: n["@rotation"],
  x: n["@x"],
  y: n["@y"],
  z: n["@z"],
  sx: n["@sx"],
  sy: n["@sy"],
  rotationX: n["@rotationX"],
  rotationY: n["@rotationY"],
  rotationZ: n["@rotationZ"],
  color: n["@color"]
})), YN = he({
  name: $t().optional(),
  "@name": $t().optional(),
  renderMode: Ri(["attached", "skinned"]).default("attached"),
  "@renderMode": Ri(["attached", "skinned"]).optional(),
  is3D: je().default(!1),
  "@is3D": je().optional(),
  bone: cn([vw, We(vw)]).optional().transform((n) => n ? Array.isArray(n) ? n : [n] : void 0)
}).transform((n) => {
  var o, r, a;
  const t = (o = n["@name"]) != null ? o : n.name, e = (r = n["@renderMode"]) != null ? r : n.renderMode, s = (a = n["@is3D"]) != null ? a : n.is3D, i = n.bone;
  return { name: t, renderMode: e, is3D: s, bones: i };
});
function A3(n, t, e) {
  var a, l;
  if (n.addComponentToEntity(Gi, t), !e.bones || e.bones.length === 0) {
    console.warn(`Skeleton on entity ${t} has no bones defined`), Gi.skeletonId[t] = 0, Gi.rootBoneEid[t] = 0, Gi.renderMode[t] = e.renderMode === "skinned" ? 1 : 0, Gi.is3D[t] = e.is3D ? 1 : 0;
    return;
  }
  const s = {
    name: (a = e.name) != null ? a : `skeleton_${t}`,
    renderMode: e.renderMode,
    is3D: e.is3D,
    bones: e.bones,
    boneEntities: /* @__PURE__ */ new Map()
  }, i = n.skeletonRegistry.length;
  n.skeletonRegistry.push(s);
  const o = JN(n, t, s);
  let r = 0;
  for (const c of s.bones)
    if (!c.parentName) {
      r = (l = o.get(c.name)) != null ? l : 0;
      break;
    }
  Gi.skeletonId[t] = i, Gi.rootBoneEid[t] = r, Gi.renderMode[t] = e.renderMode === "skinned" ? 1 : 0, Gi.is3D[t] = e.is3D ? 1 : 0, console.log(`Added Skeleton to entity ${t}:`, {
    name: s.name,
    boneCount: s.bones.length,
    renderMode: e.renderMode,
    is3D: e.is3D,
    rootBoneEid: r
  });
}
h(A3, "addSkeleton");
function JN(n, t, e, s) {
  const i = /* @__PURE__ */ new Map();
  n.world;
  const o = /* @__PURE__ */ new Set();
  function r(a) {
    var f, p, v, _, g;
    if (o.has(a.name)) return;
    if (a.parentName) {
      const w = e.bones.find((S) => S.name === a.parentName);
      w && !o.has(w.name) && r(w);
    }
    const l = n.addEntity();
    i.set(a.name, l), "nameToEid" in n && n.nameToEid instanceof Map && n.nameToEid.set(a.name, l);
    let c = (f = a.x) != null ? f : 0, u = (p = a.y) != null ? p : 0, m = (v = a.z) != null ? v : 0;
    if (a.parentName && a.x === void 0 && a.y === void 0) {
      const w = e.bones.find((S) => S.name === a.parentName);
      w && (c = w.length, u = 0);
    }
    n.addComponentToEntity(ue, l), ue.assign(l, {
      x: c,
      y: u,
      z: m,
      rotation: a.rotation,
      sx: (_ = a.sx) != null ? _ : 1,
      sy: (g = a.sy) != null ? g : 1
    }), n.addComponentToEntity(Pt, l), Pt.component.x[l] = 0, Pt.component.y[l] = 0, Pt.component.z[l] = 0, Pt.component.rotation[l] = 0, Pt.component.sx[l] = 1, Pt.component.sy[l] = 1;
    const d = e.bones.indexOf(a);
    n.addComponentToEntity(fc, l), fc.boneId[l] = d, fc.skeletonEid[l] = t, fc.length[l] = a.length, MN(l), o.add(a.name);
  }
  h(r, "processBone");
  for (const a of e.bones)
    r(a);
  for (const a of e.bones) {
    const l = i.get(a.name);
    if (a.parentName) {
      const c = i.get(a.parentName);
      c !== void 0 ? (n.addComponentToEntity(ti, l), ti.assign(l, { parentEid: c })) : console.warn(`Parent bone "${a.parentName}" not found for bone "${a.name}"`);
    } else
      n.addComponentToEntity(ti, l), ti.assign(l, { parentEid: t });
  }
  return e.boneEntities = i, i;
}
h(JN, "createBoneEntities");
function KN(n, t, e) {
  var o;
  const s = Gi.skeletonId[t];
  return s >= n.skeletonRegistry.length || (o = n.skeletonRegistry[s].boneEntities) == null ? void 0 : o.get(e);
}
h(KN, "getBoneEntity");
function M3(n, t) {
  const e = Gi.skeletonId[t];
  if (!(e >= n.skeletonRegistry.length))
    return n.skeletonRegistry[e];
}
h(M3, "getSkeletonDef");
function HH(n, t) {
  const e = M3(n, t);
  return e ? e.bones.map((s) => s.name) : [];
}
h(HH, "getBoneNames");
const sa = oi({
  skinnedMeshId: Q.ui32,
  vertexCount: Q.ui16,
  triangleCount: Q.ui16
}), bw = he({
  "@bone": $t(),
  "@weight": ct()
}).transform((n) => ({
  boneName: n["@bone"],
  weight: n["@weight"]
})), yw = he({
  "@x": ct(),
  "@y": ct(),
  "@z": ct().default(0),
  "@u": ct().default(0),
  "@v": ct().default(0),
  influence: cn([bw, We(bw)]).transform((n) => Array.isArray(n) ? n : [n])
}).transform((n) => ({
  x: n["@x"],
  y: n["@y"],
  z: n["@z"],
  u: n["@u"],
  v: n["@v"],
  influences: n.influence
})), xw = he({
  "@v0": ct(),
  "@v1": ct(),
  "@v2": ct()
}).transform((n) => ({
  v0: n["@v0"],
  v1: n["@v1"],
  v2: n["@v2"]
})), QN = he({
  name: $t().optional(),
  "@name": $t().optional(),
  spriteType: $t().optional(),
  "@spriteType": $t().optional(),
  assetKey: $t().optional(),
  "@assetKey": $t().optional(),
  width: ct().default(1),
  "@width": ct().optional(),
  height: ct().default(1),
  "@height": ct().optional(),
  primaryColor: $t().optional(),
  "@primaryColor": $t().optional(),
  secondaryColor: $t().optional(),
  "@secondaryColor": $t().optional(),
  accentColor: $t().optional(),
  "@accentColor": $t().optional(),
  vertex: cn([yw, We(yw)]).optional().transform((n) => n ? Array.isArray(n) ? n : [n] : void 0),
  triangle: cn([xw, We(xw)]).optional().transform((n) => n ? Array.isArray(n) ? n : [n] : void 0)
}).transform((n) => {
  var m, d, f, p, v, _, g, w;
  const t = (m = n["@name"]) != null ? m : n.name, e = (d = n["@spriteType"]) != null ? d : n.spriteType, s = (f = n["@assetKey"]) != null ? f : n.assetKey, i = (p = n["@width"]) != null ? p : n.width, o = (v = n["@height"]) != null ? v : n.height, r = (_ = n["@primaryColor"]) != null ? _ : n.primaryColor, a = (g = n["@secondaryColor"]) != null ? g : n.secondaryColor, l = (w = n["@accentColor"]) != null ? w : n.accentColor, c = n.vertex, u = n.triangle;
  return {
    name: t,
    spriteType: e,
    assetKey: s,
    width: i,
    height: o,
    primaryColor: r,
    secondaryColor: a,
    accentColor: l,
    vertices: c,
    triangles: u
  };
});
function t5(n, t, e) {
  var a, l, c;
  n.addComponentToEntity(sa, t);
  const s = (a = e.vertices) != null ? a : e5(e.width, e.height), i = (l = e.triangles) != null ? l : [
    { v0: 0, v1: 1, v2: 2 },
    { v0: 2, v1: 3, v2: 0 }
  ], o = {
    name: (c = e.name) != null ? c : `mesh_${t}`,
    vertices: s,
    triangles: i,
    spriteType: e.spriteType,
    assetKey: e.assetKey,
    width: e.width,
    height: e.height,
    primaryColor: e.primaryColor,
    secondaryColor: e.secondaryColor,
    accentColor: e.accentColor
  }, r = n.skinnedMeshRegistry.length;
  n.skinnedMeshRegistry.push(o), sa.skinnedMeshId[t] = r, sa.vertexCount[t] = s.length, sa.triangleCount[t] = i.length, console.log(`Added SkinnedSprite to entity ${t}:`, {
    name: o.name,
    vertexCount: s.length,
    triangleCount: i.length
  });
}
h(t5, "addSkinnedSprite");
function e5(n, t) {
  const e = n / 2, s = t / 2;
  return [
    { x: -e, y: -s, z: 0, u: 0, v: 0, influences: [] },
    { x: e, y: -s, z: 0, u: 1, v: 0, influences: [] },
    { x: e, y: s, z: 0, u: 1, v: 1, influences: [] },
    { x: -e, y: s, z: 0, u: 0, v: 1, influences: [] }
  ];
}
h(e5, "createDefaultQuadMesh");
function n5(n, t) {
  const e = sa.skinnedMeshId[t];
  if (!(e >= n.skinnedMeshRegistry.length))
    return n.skinnedMeshRegistry[e];
}
h(n5, "getSkinnedMeshDef");
const Zt = oi({
  animationSetId: Q.ui32,
  currentAnimationId: Q.ui16,
  animationTime: Q.f32,
  previousFrameIndex: Q.ui16,
  speedMultiplier: Q.f32,
  blendTime: Q.f32,
  blendProgress: Q.f32,
  previousAnimationId: Q.ui16,
  previousFrameIndexBlend: Q.ui16,
  hasAnimations: Q.ui8,
  isBlending: Q.ui8
}), ww = he({
  "@frame": ct(),
  "@action": $t(),
  "@value": $t().optional()
}).transform((n) => ({
  frame: n["@frame"],
  action: n["@action"],
  value: n["@value"]
})), i5 = he({
  frame: ls(),
  action: $t(),
  value: $t().optional()
}), Sw = he({
  "@name": $t(),
  "@frames": $t().transform((n) => n.split(",").map((t) => parseInt(t.trim(), 10))),
  "@fps": ct().default(10),
  "@loop": je().default(!0),
  event: cn([ww, We(ww)]).optional().transform((n) => n ? Array.isArray(n) ? n : [n] : void 0)
}).transform((n) => ({
  name: n["@name"],
  frames: n["@frames"],
  fps: n["@fps"],
  loop: n["@loop"],
  events: n.event
})), s5 = he({
  name: $t(),
  frames: cn([
    $t().transform((n) => n.split(",").map((t) => parseInt(t.trim(), 10))),
    We(ls())
  ]),
  fps: ct().default(10),
  loop: je().default(!0),
  events: We(i5).optional()
}), o5 = he({
  animations: We(s5).optional(),
  animation: cn([Sw, We(Sw)]).optional().transform((n) => n ? Array.isArray(n) ? n : [n] : void 0),
  defaultAnimation: $t().optional(),
  "@defaultAnimation": $t().optional()
}).transform((n) => {
  var s, i;
  const t = (s = n.animation) != null ? s : n.animations, e = (i = n["@defaultAnimation"]) != null ? i : n.defaultAnimation;
  return { animations: t, defaultAnimation: e };
});
function r5(n, t, e) {
  if (wn(n.world, Zt, t), !e.animations || e.animations.length === 0) {
    Zt.hasAnimations[t] = 0, Zt.animationSetId[t] = 0, Zt.currentAnimationId[t] = 0, Zt.animationTime[t] = 0, Zt.previousFrameIndex[t] = 0, Zt.speedMultiplier[t] = 1, Zt.blendTime[t] = 0, Zt.blendProgress[t] = 0, Zt.previousAnimationId[t] = 0, Zt.previousFrameIndexBlend[t] = 0, Zt.isBlending[t] = 0;
    return;
  }
  const s = {
    animations: /* @__PURE__ */ new Map(),
    animationList: []
  };
  for (let r = 0; r < e.animations.length; r++) {
    const a = e.animations[r], l = a.frames.length / a.fps, c = {
      name: a.name,
      frames: a.frames,
      fps: a.fps,
      loop: a.loop,
      duration: l,
      events: a.events
    };
    s.animations.set(a.name, r), s.animationList.push(c);
  }
  const i = n.spriteAnimationSets.length;
  n.spriteAnimationSets.push(s), Zt.hasAnimations[t] = 1, Zt.animationSetId[t] = i, Zt.animationTime[t] = 0, Zt.previousFrameIndex[t] = 0, Zt.speedMultiplier[t] = 1, Zt.blendTime[t] = 0, Zt.blendProgress[t] = 0, Zt.previousAnimationId[t] = 0, Zt.previousFrameIndexBlend[t] = 0, Zt.isBlending[t] = 0;
  let o = 0;
  e.defaultAnimation && s.animations.has(e.defaultAnimation) && (o = s.animations.get(e.defaultAnimation)), Zt.currentAnimationId[t] = o, console.log(`Added SpriteAnimations to entity ${t}:`, {
    setId: i,
    animationCount: s.animationList.length,
    names: s.animationList.map((r) => r.name),
    defaultAnimation: e.defaultAnimation,
    defaultAnimId: o
  });
}
h(r5, "addSpriteAnimations");
function jH(n, t, e, s = 0.15) {
  const i = Zt.animationSetId[t];
  if (i >= n.spriteAnimationSets.length)
    return console.warn(`No animation set found for entity ${t}`), !1;
  const r = n.spriteAnimationSets[i].animations.get(e);
  if (r === void 0)
    return console.warn(`Animation "${e}" not found on entity ${t}`), !1;
  const a = Zt.currentAnimationId[t];
  return a !== r && (s > 0 && (Zt.hasAnimations[t] | 0) === 1 && (Zt.previousAnimationId[t] = a, Zt.previousFrameIndexBlend[t] = Zt.previousFrameIndex[t], Zt.blendTime[t] = s, Zt.blendProgress[t] = 0, Zt.isBlending[t] = 1), Zt.currentAnimationId[t] = r, Zt.animationTime[t] = 0), !0;
}
h(jH, "playSpriteAnimation");
function a5(n, t) {
  if (!(Zt.hasAnimations[t] | 0)) return null;
  const e = Zt.animationSetId[t];
  if (e >= n.spriteAnimationSets.length) return null;
  const s = n.spriteAnimationSets[e], i = Zt.currentAnimationId[t];
  return i >= s.animationList.length ? null : s.animationList[i];
}
h(a5, "getCurrentSpriteAnimation");
function WH(n, t) {
  Zt.speedMultiplier[n] = Math.max(0, t);
}
h(WH, "setAnimationSpeed");
function qH(n) {
  Zt.speedMultiplier[n] = 0;
}
h(qH, "pauseAnimation");
function XH(n, t = 1) {
  Zt.speedMultiplier[n] = Math.max(0, t);
}
h(XH, "resumeAnimation");
function ZH(n) {
  return Zt.speedMultiplier[n];
}
h(ZH, "getAnimationSpeed");
const ht = oi({
  assetId: Q.ui32,
  frameWidth: Q.ui16,
  frameHeight: Q.ui16,
  currentFrame: Q.ui16,
  totalFrames: Q.ui16,
  width: Q.f32,
  height: Q.f32,
  fps: Q.f32,
  frameTimer: Q.f32,
  isLooping: Q.ui8,
  isPlaying: Q.ui8,
  alpha: Q.f32,
  isVisible: Q.ui8,
  flipX: Q.ui8,
  flipY: Q.ui8,
  tintR: Q.ui8,
  tintG: Q.ui8,
  tintB: Q.ui8,
  tintStrength: Q.f32,
  frameOffsetX: Q.ui16,
  frameOffsetY: Q.ui16,
  anchorX: Q.f32,
  anchorY: Q.f32
});
function YH(n, t) {
  ht.flipX[n] = t ? 1 : 0;
}
h(YH, "setSpriteFlipX");
function JH(n, t) {
  ht.flipY[n] = t ? 1 : 0;
}
h(JH, "setSpriteFlipY");
function KH(n, t, e) {
  ht.flipX[n] = t ? 1 : 0, ht.flipY[n] = e ? 1 : 0;
}
h(KH, "setSpriteFlip");
function QH(n) {
  return (ht.flipX[n] | 0) === 1;
}
h(QH, "getSpriteFlipX");
function tj(n) {
  return (ht.flipY[n] | 0) === 1;
}
h(tj, "getSpriteFlipY");
function ej(n, t, e = 1) {
  const s = Na(t);
  ht.tintR[n] = s.rgb[0], ht.tintG[n] = s.rgb[1], ht.tintB[n] = s.rgb[2], ht.tintStrength[n] = Math.max(0, Math.min(1, e));
}
h(ej, "setSpriteColor");
function nj(n, t, e, s, i = 1) {
  ht.tintR[n] = Math.max(0, Math.min(255, t)), ht.tintG[n] = Math.max(0, Math.min(255, e)), ht.tintB[n] = Math.max(0, Math.min(255, s)), ht.tintStrength[n] = Math.max(0, Math.min(1, i));
}
h(nj, "setSpriteTint");
function ij(n) {
  ht.tintR[n] = 255, ht.tintG[n] = 255, ht.tintB[n] = 255, ht.tintStrength[n] = 0;
}
h(ij, "resetSpriteColor");
function sj(n) {
  return {
    r: ht.tintR[n],
    g: ht.tintG[n],
    b: ht.tintB[n],
    strength: ht.tintStrength[n]
  };
}
h(sj, "getSpriteColor");
const c5 = he({
  assetKey: $t().optional(),
  spriteType: $t().optional(),
  size: ct().optional(),
  primaryColor: $t().optional(),
  secondaryColor: $t().optional(),
  accentColor: $t().optional(),
  frameWidth: ct().optional(),
  frameHeight: ct().optional(),
  width: ct().optional(),
  height: ct().optional(),
  totalFrames: ct().default(1),
  fps: ct().default(10),
  isLooping: je().default(!0),
  isPlaying: je().default(!0),
  alpha: ct().min(0).max(1).default(1),
  isVisible: je().default(!0),
  flipX: je().default(!1),
  flipY: je().default(!1),
  tintColor: $t().optional(),
  tintStrength: ct().min(0).max(1).default(0),
  frameOffsetX: ct().default(0),
  frameOffsetY: ct().default(0),
  anchorX: ct().min(0).max(1).default(0.5),
  anchorY: ct().min(0).max(1).default(0.5)
}).refine((n) => n.assetKey || n.spriteType, {
  message: "Either assetKey or spriteType must be provided"
});
function C3(n, t, e) {
  var u, m, d, f, p, v, _;
  console.log(`🎨 addSprite called: eid=${t}, spriteType="${e.spriteType}", assetKey="${e.assetKey}", size=${e.size}`), wn(n.world, ht, t);
  const s = n.assetManager;
  let i = e.assetKey, o = null;
  if (e.spriteType && !i) {
    const g = (u = e.size) != null ? u : 1, w = `procedural_${e.spriteType}_${g}_${e.primaryColor}_${e.secondaryColor}_${e.accentColor}`;
    o = s.getAssetId(w), o === null ? (console.log(`🎨 Generating built-in sprite: ${e.spriteType}, size=${g} world units, key="${w}"`), o = l5(
      s,
      e.spriteType,
      g,
      w,
      e.primaryColor,
      e.secondaryColor,
      e.accentColor
    ), console.log(`  ✅ Generated asset ID: ${o}`)) : console.log(`♻️ Using cached sprite: ${e.spriteType}, assetId=${o}, key="${w}"`), i = w;
  } else i && (o = s.getAssetId(i));
  o === null && (console.warn(`Asset "${i}" not found, sprite will not render until asset is loaded`), o = 0), console.log(`📍 Asset lookup result: assetKey="${i}", assetId=${o}`);
  let r = (m = e.frameWidth) != null ? m : 32, a = (d = e.frameHeight) != null ? d : 32;
  if (!e.frameWidth || !e.frameHeight) {
    const g = s.getSpriteResolution(i != null ? i : "");
    g && (r = g.frameWidth, a = g.frameHeight, console.log(`📏 Got resolution from asset: ${r}x${a}`));
  }
  const l = (p = (f = e.size) != null ? f : e.width) != null ? p : 1, c = (_ = (v = e.size) != null ? v : e.height) != null ? _ : 1;
  if (console.log(`🎨 Setting Sprite data: assetId=${o}, size=${l}x${c}, frames=${e.totalFrames}, visible=${e.isVisible}, alpha=${e.alpha}`), ht.assetId[t] = o, ht.frameWidth[t] = r, ht.frameHeight[t] = a, ht.width[t] = l, ht.height[t] = c, ht.currentFrame[t] = 0, ht.totalFrames[t] = e.totalFrames, ht.fps[t] = e.fps, ht.frameTimer[t] = 0, ht.isLooping[t] = e.isLooping ? 1 : 0, ht.isPlaying[t] = e.isPlaying ? 1 : 0, ht.alpha[t] = e.alpha, ht.isVisible[t] = e.isVisible ? 1 : 0, ht.flipX[t] = e.flipX ? 1 : 0, ht.flipY[t] = e.flipY ? 1 : 0, e.tintColor) {
    const g = Na(e.tintColor);
    ht.tintR[t] = g.rgb[0], ht.tintG[t] = g.rgb[1], ht.tintB[t] = g.rgb[2], ht.tintStrength[t] = e.tintStrength;
  } else
    ht.tintR[t] = 255, ht.tintG[t] = 255, ht.tintB[t] = 255, ht.tintStrength[t] = 0;
  ht.frameOffsetX[t] = e.frameOffsetX, ht.frameOffsetY[t] = e.frameOffsetY, ht.anchorX[t] = e.anchorX, ht.anchorY[t] = e.anchorY, console.log(`✅ Sprite component initialized for eid=${t}`), console.log(`   Verify: assetId=${ht.assetId[t]}, width=${ht.width[t]}, height=${ht.height[t]}, visible=${ht.isVisible[t]}`);
}
h(C3, "addSprite");
function l5(n, t, e, s, i, o, r) {
  const a = /* @__PURE__ */ h((l, c, u) => {
    const m = i != null ? i : "#888888", d = o != null ? o : "#666666", f = r != null ? r : "#aaaaaa";
    switch (t) {
      case "crate":
        u5(l, c, u, m, d, f);
        break;
      case "gem":
        h5(l, c, u, m, d, f);
        break;
      case "platform":
        d5(l, c, u, m, d);
        break;
      case "character":
        m5(l, c, u, m, d, f);
        break;
      case "coin":
        f5(l, c, u, m, d, f);
        break;
      default:
        l.fillStyle = m, l.fillRect(-c * 0.5, -u * 0.5, c, u);
    }
  }, "drawFn");
  return n.generateProceduralSprite(s, a, e, e);
}
h(l5, "generateProceduralSprite");
function u5(n, t, e, s, i, o) {
  n.fillStyle = s, n.fillRect(-t * 0.5, -e * 0.5, t, e), n.strokeStyle = i, n.lineWidth = Math.max(0.02, t / 16), n.strokeRect(-t * 0.5, -e * 0.5, t, e), n.strokeStyle = o;
  const r = t / 4;
  for (let a = 1; a < 4; a++) {
    const l = -t * 0.5 + a * r;
    n.beginPath(), n.moveTo(l, -e * 0.5), n.lineTo(l, e * 0.5), n.stroke();
  }
}
h(u5, "drawCrate");
function h5(n, t, e, s, i, o) {
  n.fillStyle = s, n.beginPath(), n.moveTo(0, e * 0.4), n.lineTo(t * 0.3, 0), n.lineTo(0, -e * 0.4), n.lineTo(-t * 0.3, 0), n.closePath(), n.fill(), n.strokeStyle = o, n.lineWidth = Math.max(0.02, t / 20), n.stroke(), n.fillStyle = o, n.beginPath(), n.arc(-t * 0.1, e * 0.1, t * 0.08, 0, Math.PI * 2), n.fill();
}
h(h5, "drawGem");
function d5(n, t, e, s, i) {
  n.fillStyle = s, n.fillRect(-t * 0.5, -e * 0.5, t, e), n.fillStyle = i;
  const o = Math.max(0.05, e / 4);
  n.fillRect(-t * 0.5, e * 0.5 - o, t, o);
}
h(d5, "drawPlatform");
function m5(n, t, e, s, i, o) {
  n.fillStyle = s, n.fillRect(-t * 0.3, -e * 0.2, t * 0.6, e * 0.6), n.fillStyle = i, n.beginPath(), n.arc(0, e * 0.25, t * 0.25, 0, Math.PI * 2), n.fill(), n.fillStyle = o, n.beginPath(), n.arc(-t * 0.1, e * 0.28, t * 0.05, 0, Math.PI * 2), n.arc(t * 0.1, e * 0.28, t * 0.05, 0, Math.PI * 2), n.fill();
}
h(m5, "drawCharacter");
function f5(n, t, e, s, i, o) {
  const r = Math.min(t, e) / 2 * 0.9;
  n.fillStyle = s, n.beginPath(), n.arc(0, 0, r, 0, Math.PI * 2), n.fill(), n.strokeStyle = i, n.lineWidth = Math.max(0.02, t / 16), n.stroke(), n.strokeStyle = o, n.lineWidth = Math.max(0.02, t / 20), n.beginPath(), n.arc(0, 0, r * 0.7, 0, Math.PI * 2), n.stroke();
}
h(f5, "drawCoin");
const $e = {
  linear: /* @__PURE__ */ h((n) => n, "linear"),
  easeInQuad: /* @__PURE__ */ h((n) => n * n, "easeInQuad"),
  easeOutQuad: /* @__PURE__ */ h((n) => n * (2 - n), "easeOutQuad"),
  easeInOutQuad: /* @__PURE__ */ h((n) => n < 0.5 ? 2 * n * n : -1 + (4 - 2 * n) * n, "easeInOutQuad"),
  easeInCubic: /* @__PURE__ */ h((n) => n * n * n, "easeInCubic"),
  easeOutCubic: /* @__PURE__ */ h((n) => --n * n * n + 1, "easeOutCubic"),
  easeInOutCubic: /* @__PURE__ */ h((n) => n < 0.5 ? 4 * n * n * n : (n - 1) * (2 * n - 2) * (2 * n - 2) + 1, "easeInOutCubic"),
  easeInQuart: /* @__PURE__ */ h((n) => n * n * n * n, "easeInQuart"),
  easeOutQuart: /* @__PURE__ */ h((n) => 1 - --n * n * n * n, "easeOutQuart"),
  easeInOutQuart: /* @__PURE__ */ h((n) => n < 0.5 ? 8 * n * n * n * n : 1 - 8 * --n * n * n * n, "easeInOutQuart"),
  easeInQuint: /* @__PURE__ */ h((n) => n * n * n * n * n, "easeInQuint"),
  easeOutQuint: /* @__PURE__ */ h((n) => 1 + --n * n * n * n * n, "easeOutQuint"),
  easeInOutQuint: /* @__PURE__ */ h((n) => n < 0.5 ? 16 * n * n * n * n * n : 1 + 16 * --n * n * n * n * n, "easeInOutQuint"),
  easeInSine: /* @__PURE__ */ h((n) => 1 - Math.cos(n * Math.PI / 2), "easeInSine"),
  easeOutSine: /* @__PURE__ */ h((n) => Math.sin(n * Math.PI / 2), "easeOutSine"),
  easeInOutSine: /* @__PURE__ */ h((n) => -(Math.cos(Math.PI * n) - 1) / 2, "easeInOutSine"),
  easeInExpo: /* @__PURE__ */ h((n) => n === 0 ? 0 : Math.pow(2, 10 * n - 10), "easeInExpo"),
  easeOutExpo: /* @__PURE__ */ h((n) => n === 1 ? 1 : 1 - Math.pow(2, -10 * n), "easeOutExpo"),
  easeInOutExpo: /* @__PURE__ */ h((n) => n === 0 ? 0 : n === 1 ? 1 : n < 0.5 ? Math.pow(2, 20 * n - 10) / 2 : (2 - Math.pow(2, -20 * n + 10)) / 2, "easeInOutExpo"),
  easeInCirc: /* @__PURE__ */ h((n) => 1 - Math.sqrt(1 - n * n), "easeInCirc"),
  easeOutCirc: /* @__PURE__ */ h((n) => Math.sqrt(1 - (n - 1) * (n - 1)), "easeOutCirc"),
  easeInOutCirc: /* @__PURE__ */ h((n) => n < 0.5 ? (1 - Math.sqrt(1 - 4 * n * n)) / 2 : (Math.sqrt(1 - (-2 * n + 2) * (-2 * n + 2)) + 1) / 2, "easeInOutCirc"),
  easeInBack: /* @__PURE__ */ h((n) => 2.70158 * n * n * n - 1.70158 * n * n, "easeInBack"),
  easeOutBack: /* @__PURE__ */ h((n) => 1 + 2.70158 * Math.pow(n - 1, 3) + 1.70158 * Math.pow(n - 1, 2), "easeOutBack"),
  easeInOutBack: /* @__PURE__ */ h((n) => {
    const e = 2.5949095;
    return n < 0.5 ? Math.pow(2 * n, 2) * ((e + 1) * 2 * n - e) / 2 : (Math.pow(2 * n - 2, 2) * ((e + 1) * (n * 2 - 2) + e) + 2) / 2;
  }, "easeInOutBack"),
  easeInElastic: /* @__PURE__ */ h((n) => {
    if (n === 0) return 0;
    if (n === 1) return 1;
    const t = 2 * Math.PI / 3;
    return -Math.pow(2, 10 * n - 10) * Math.sin((n * 10 - 10.75) * t);
  }, "easeInElastic"),
  easeOutElastic: /* @__PURE__ */ h((n) => {
    if (n === 0) return 0;
    if (n === 1) return 1;
    const t = 2 * Math.PI / 3;
    return Math.pow(2, -10 * n) * Math.sin((n * 10 - 0.75) * t) + 1;
  }, "easeOutElastic"),
  easeInOutElastic: /* @__PURE__ */ h((n) => {
    if (n === 0) return 0;
    if (n === 1) return 1;
    const t = 2 * Math.PI / 4.5;
    return n < 0.5 ? -(Math.pow(2, 20 * n - 10) * Math.sin((20 * n - 11.125) * t)) / 2 : Math.pow(2, -20 * n + 10) * Math.sin((20 * n - 11.125) * t) / 2 + 1;
  }, "easeInOutElastic"),
  easeInBounce: /* @__PURE__ */ h((n) => 1 - $e.easeOutBounce(1 - n), "easeInBounce"),
  easeOutBounce: /* @__PURE__ */ h((n) => n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375, "easeOutBounce"),
  easeInOutBounce: /* @__PURE__ */ h((n) => n < 0.5 ? (1 - $e.easeOutBounce(1 - 2 * n)) / 2 : (1 + $e.easeOutBounce(2 * n - 1)) / 2, "easeInOutBounce")
}, p5 = {
  linear: $e.linear,
  easeInQuad: $e.easeInQuad,
  easeOutQuad: $e.easeOutQuad,
  easeInOutQuad: $e.easeInOutQuad,
  easeInCubic: $e.easeInCubic,
  easeOutCubic: $e.easeOutCubic,
  easeInOutCubic: $e.easeInOutCubic,
  easeInQuart: $e.easeInQuart,
  easeOutQuart: $e.easeOutQuart,
  easeInOutQuart: $e.easeInOutQuart,
  easeInQuint: $e.easeInQuint,
  easeOutQuint: $e.easeOutQuint,
  easeInOutQuint: $e.easeInOutQuint,
  easeInSine: $e.easeInSine,
  easeOutSine: $e.easeOutSine,
  easeInOutSine: $e.easeInOutSine,
  easeInExpo: $e.easeInExpo,
  easeOutExpo: $e.easeOutExpo,
  easeInOutExpo: $e.easeInOutExpo,
  easeInCirc: $e.easeInCirc,
  easeOutCirc: $e.easeOutCirc,
  easeInOutCirc: $e.easeInOutCirc,
  easeInBack: $e.easeInBack,
  easeOutBack: $e.easeOutBack,
  easeInOutBack: $e.easeInOutBack,
  easeInElastic: $e.easeInElastic,
  easeOutElastic: $e.easeOutElastic,
  easeInOutElastic: $e.easeInOutElastic,
  easeInBounce: $e.easeInBounce,
  easeOutBounce: $e.easeOutBounce,
  easeInOutBounce: $e.easeInOutBounce
};
function Op(n) {
  var t;
  return (t = p5[n]) != null ? t : $e.linear;
}
h(Op, "getEasingFunction");
const _5 = he({
  isActive: Ii().default(!1),
  elapsed: jt().default(0),
  duration: jt().default(0),
  delay: jt().default(0),
  delayElapsed: jt().default(0),
  tweenId: la().default(0)
}), Be = Vi("Tween", _5), g5 = he({
  target: $t(),
  from: ct().optional(),
  to: ct(),
  duration: ct(),
  delay: ct().default(0),
  easing: $t().default("linear"),
  loop: je().default(!1),
  yoyo: je().default(!1),
  autoStart: je().default(!0)
}).transform((n) => (n.yoyo && !n.loop && (n.loop = !0), n));
function v5(n, t, e) {
  var o;
  wn(n.world, Be.component, t);
  const s = {
    target: e.target,
    from: (o = e.from) != null ? o : 0,
    to: e.to,
    duration: e.duration,
    delay: e.delay,
    easing: Op(e.easing),
    loop: e.loop,
    yoyo: e.yoyo
  }, i = n.tweenRegistry.length;
  n.tweenRegistry.push(s), Be.component.tweenId[t] = i, Be.component.isActive[t] = e.autoStart ? 1 : 0, Be.component.elapsed[t] = 0, Be.component.duration[t] = e.duration, Be.component.delay[t] = e.delay, Be.component.delayElapsed[t] = 0, console.log(`Added Tween to entity ${t}:`, {
    target: s.target,
    from: s.from,
    to: s.to,
    duration: s.duration,
    easing: e.easing
  });
}
h(v5, "addTween");
function oj(n) {
  Be.component.isActive[n] = 1, Be.component.elapsed[n] = 0, Be.component.delayElapsed[n] = 0;
}
h(oj, "startTween");
function rj(n) {
  Be.component.isActive[n] = 0;
}
h(rj, "stopTween");
function aj(n) {
  Be.component.isActive[n] = 0;
}
h(aj, "pauseTween");
function cj(n) {
  Be.component.isActive[n] = 1;
}
h(cj, "resumeTween");
function lj(n) {
  Be.component.elapsed[n] = 0, Be.component.delayElapsed[n] = 0;
}
h(lj, "resetTween");
function b5(n) {
  n.registerType({
    type: ue,
    onAdd: /* @__PURE__ */ h((t, e, s) => {
      t.addComponentToEntity(ue.component, e), ue.assign(e, s);
    }, "onAdd")
  }), n.registerType({ type: ne }), n.registerType({ type: ti }), n.registerType({ type: Pt }), n.registerType({ type: zs }), n.registerType({ type: D2 }), n.registerType({ type: qs }), n.registerType({ type: Ln }), n.registerType({ type: Zn }), n.registerType({ type: ia }), n.registerType({ type: Be, authoringSchema: g5, onAdd: v5 }), n.registerType({ type: Bl }), n.registerType({ type: xo }), n.registerCustom({
    name: "Sprite",
    component: ht,
    authoringSchema: c5,
    onAdd: C3
  }), n.registerCustom({
    name: "SpriteAnimations",
    component: Zt,
    authoringSchema: o5,
    onAdd: r5
  }), n.registerCustom({
    name: "ParticleEmitter",
    component: He,
    authoringSchema: GN,
    onAdd: HN
  }), n.registerCustom({
    name: "Skeleton",
    component: Gi,
    authoringSchema: YN,
    onAdd: A3
  }), n.registerCustom({
    name: "SkeletalAnimation",
    component: Gt,
    authoringSchema: qN,
    onAdd: S3
  }), n.registerCustom({
    name: "SkinnedSprite",
    component: sa,
    authoringSchema: QN,
    onAdd: t5
  }), n.registerCustom({
    name: "Material",
    component: ke,
    authoringSchema: zN,
    onAdd: kN
  }), n.registerCustom({
    name: "Mesh3D",
    component: qn,
    authoringSchema: UN,
    onAdd: ON
  }), n.registerCustom({
    name: "Light",
    component: rn,
    authoringSchema: LN,
    onAdd: NN
  }), n.registerCustom({
    name: "RigidBody3D",
    component: os,
    authoringSchema: pN,
    onAdd: _N
  }), n.registerCustom({
    name: "CharacterController3D",
    component: Ue,
    authoringSchema: gN,
    onAdd: vN
  }), n.registerCustom({
    name: "CameraFollow3D",
    component: gn,
    authoringSchema: bN,
    onAdd: yN
  }), n.registerCustom({
    name: "TankController",
    component: na,
    authoringSchema: xN,
    onAdd: wN
  });
}
h(b5, "registerBuiltins");
const Ji = /* @__PURE__ */ h((n) => Array.isArray(n) ? n : n ? [n] : [], "ensureArray"), Pl = /* @__PURE__ */ h((n) => n ? typeof n == "string" ? n : Array.isArray(n) ? n.map(Pl).join("") : typeof n["#text"] == "string" ? n["#text"] : "" : "", "extractText"), Aw = he({
  "@type": $t().min(1)
}).catchall(Ql()).transform((n) => ({
  type: n["@type"],
  attributes: Object.fromEntries(
    Object.entries(n).filter(([t]) => t !== "@type").map(([t, e]) => [t.replace(/^@/, ""), e])
  )
})), vr = v2(
  () => he({
    "@name": $t().optional(),
    component: cn([Aw, We(Aw)]).optional(),
    entity: cn([vr, We(vr)]).optional()
  }).transform((n) => {
    var t;
    return {
      name: (t = n["@name"]) != null ? t : null,
      components: Ji(n.component),
      children: Ji(n.entity)
    };
  })
), L2 = he({ "@name": $t().min(1) }), y5 = L2.extend({
  "@type": jo("string"),
  "@default": $t().optional()
}).transform((n) => ({
  name: n["@name"],
  type: "string",
  default: n["@default"]
})), x5 = L2.extend({
  "@type": jo("number"),
  "@default": ct().optional()
}).transform((n) => ({
  name: n["@name"],
  type: "number",
  default: n["@default"]
})), w5 = L2.extend({
  "@type": jo("boolean"),
  "@default": je().optional()
}).transform((n) => ({
  name: n["@name"],
  type: "boolean",
  default: n["@default"]
})), Mw = cn([y5, x5, w5]), br = he({
  "@name": $t().min(1),
  param: cn([Mw, We(Mw)]).optional(),
  entity: cn([vr, We(vr)])
}).transform((n) => {
  const t = Ji(n.param), e = Ji(n.entity);
  return {
    name: n["@name"],
    params: t,
    entities: e,
    paramsSchema: S5(t)
  };
});
function S5(n) {
  const t = {};
  for (const { type: e, name: s, default: i } of n) {
    let o;
    switch (e) {
      case "number":
        o = ct();
        break;
      case "boolean":
        o = je();
        break;
      case "string":
      default:
        o = $t();
        break;
    }
    i !== void 0 && (o = o.default(i)), t[s] = o;
  }
  return he(t);
}
h(S5, "createParamsSchema");
function A5(n, t) {
  return {
    x: n.x + t.worldX,
    y: n.y + t.worldY
  };
}
h(A5, "cameraToWorld");
function M5(n, t, e, s, i, o) {
  const r = e * n.scaleX, a = s * n.scaleY;
  return {
    left: n.worldX - r / 2,
    right: n.worldX + r / 2,
    top: n.worldY + a / 2,
    bottom: n.worldY - a / 2
  };
}
h(M5, "getCameraWorldBounds");
function C5(n, t, e) {
  return {
    x: n.x / t,
    y: 1 - n.y / e
  };
}
h(C5, "canvasToScreen");
function E5(n, t, e, s, i, o, r) {
  const a = C5(n, o, r);
  if (a.x < e.x || a.x > e.x + e.width || a.y < e.y || a.y > e.y + e.height)
    return { x: NaN, y: NaN };
  const l = {
    x: (a.x - e.x) / e.width,
    y: (a.y - e.y) / e.height
  }, c = M5(t, e, s, i), u = c.right - c.left, m = c.top - c.bottom, d = {
    x: c.left + l.x * u - t.worldX,
    y: c.bottom + l.y * m - t.worldY
  };
  return A5(d, t);
}
h(E5, "canvasToWorld");
const Cw = 24, re = class re {
  constructor() {
  }
  static initialize(t, e) {
    if (re._initialized) throw new Error("ScreenManager already initialized");
    re._container = t, re._aspectRatio = e, re._initialized = !0, re.setupResizeListener();
  }
  static assertInit() {
    if (!re._initialized)
      throw new Error("ScreenManager not initialized. Call ScreenManager.initialize() first.");
  }
  static get container() {
    return re.assertInit(), re._container;
  }
  static get aspectRatio() {
    return re.assertInit(), re._aspectRatio;
  }
  static get canvasPixelWidth() {
    return re.assertInit(), re._canvasPixelWidth;
  }
  static get canvasPixelHeight() {
    return re.assertInit(), re._canvasPixelHeight;
  }
  static get isLandscape() {
    return re.assertInit(), re.aspectRatio >= 1;
  }
  static get isPortrait() {
    return re.assertInit(), re.aspectRatio < 1;
  }
  static get worldViewHeight() {
    const t = Cw;
    return re.isLandscape ? t : t * re.aspectRatio;
  }
  static get worldViewWidth() {
    const t = Cw;
    return re.isPortrait ? t : t * re.aspectRatio;
  }
  static setupResizeListener() {
    setTimeout(() => re.handleScreenResize(), 50);
    const t = /* @__PURE__ */ h(() => {
      re._resizeTimeoutId !== null && clearTimeout(re._resizeTimeoutId), re._resizeTimeoutId = window.setTimeout(() => {
        re.handleScreenResize(), re._resizeTimeoutId = null;
      }, 150);
    }, "debouncedResize");
    window.addEventListener("resize", t);
  }
  static handleScreenResize() {
    var s;
    re.assertInit(), re.setAspectAttributes();
    const t = (s = re.container.querySelector("#app > .scene[data-type=composite]")) == null ? void 0 : s.getBoundingClientRect();
    if (!t) throw new Error("Root scene not found");
    const e = window.devicePixelRatio || 1;
    re._canvasPixelWidth = t.width * e, re._canvasPixelHeight = t.height * e, re.container.querySelectorAll(".scene > canvas").forEach(re.sizeCanvas);
  }
  static setAspectAttributes() {
    re.assertInit();
    const { container: t, aspectRatio: e } = re, s = window.innerWidth / window.innerHeight;
    document.body.dataset.editorLayout = s > e ? "horizontal" : "vertical";
    const i = t.getBoundingClientRect(), o = parseFloat(window.getComputedStyle(t).paddingTop), r = i.height - o, a = i.width / r;
    document.body.dataset.fit = a > e ? "height" : "width";
  }
  static sizeCanvas(t) {
    re.assertInit(), t.width = re.canvasPixelWidth, t.height = re.canvasPixelHeight;
  }
  static worldToScreen(t, e) {
    re.assertInit();
    const s = window.devicePixelRatio || 1, i = re.canvasPixelWidth / re.worldViewWidth / s;
    return [t * i, e * i];
  }
  static screenToWorld(t, e) {
    re.assertInit();
    const s = window.devicePixelRatio || 1, i = re.canvasPixelWidth / re.worldViewWidth / s;
    return [t / i, e / i];
  }
};
h(re, "ScreenManager"), re._initialized = !1, re._resizeTimeoutId = null, re._canvasPixelWidth = 0, re._canvasPixelHeight = 0, re._container = null, re._aspectRatio = null;
let Dn = re;
const T5 = new hn().with(Be);
function I5(n, t) {
  for (const e of n.query(T5)) {
    if (!(Be.component.isActive[e] | 0)) continue;
    const s = Be.component.tweenId[e], i = n.tweenRegistry[s];
    if (!i) continue;
    const o = t / 1e3;
    if (Be.component.delay[e] > 0 && (Be.component.delayElapsed[e] += o, Be.component.delayElapsed[e] < Be.component.delay[e]))
      continue;
    Be.component.elapsed[e] += o;
    let r = Math.min(1, Be.component.elapsed[e] / Be.component.duration[e]);
    i.yoyo && i.isYoyoingBack && (r = 1 - r);
    const a = i.easing(r), l = i.from, c = i.to, u = l + (c - l) * a;
    B5(e, i.target, u), i.onUpdate && i.onUpdate(u, e), Be.component.elapsed[e] >= Be.component.duration[e] && (i.yoyo && !i.isYoyoingBack ? (i.isYoyoingBack = !0, Be.component.elapsed[e] = 0) : i.loop ? (Be.component.elapsed[e] = 0, i.yoyo && (i.isYoyoingBack = !i.isYoyoingBack)) : (Be.component.isActive[e] = 0, i.onComplete && i.onComplete(e)));
  }
}
h(I5, "tweenSystem");
function B5(n, t, e) {
  const s = t.split(".");
  if (s.length !== 2) {
    console.warn(`Invalid tween target: ${t}. Expected format: "ComponentName.propertyName"`);
    return;
  }
  const [i, o] = s;
  switch (i) {
    case "Transform":
      o in ue.component && (ue.component[o][n] = e);
      break;
    case "Sprite":
      o in ht && (ht[o][n] = e);
      break;
    default:
      console.warn(`Unsupported tween component: ${i}`);
  }
}
h(B5, "applyTweenValue");
const P5 = new hn().with(ht), R5 = new hn().with(ht).with(Zt);
function D5(n, t) {
  const e = n.query(R5);
  for (const i of e) {
    if (!(ht.isPlaying[i] | 0) || !(Zt.hasAnimations[i] | 0)) continue;
    const o = a5(n, i);
    if (!o) continue;
    if ((Zt.isBlending[i] | 0) === 1) {
      const u = Zt.blendTime[i], m = t / 1e3;
      Zt.blendProgress[i] += m / u, Zt.blendProgress[i] >= 1 && (Zt.isBlending[i] = 0, Zt.blendProgress[i] = 0);
      const d = Math.min(1, Zt.blendProgress[i]);
      Zt.animationTime[i] += m * d * Zt.speedMultiplier[i];
    } else {
      const u = Zt.speedMultiplier[i];
      Zt.animationTime[i] += t / 1e3 * u;
    }
    const a = Zt.previousFrameIndex[i], l = 1 / o.fps, c = Math.floor(Zt.animationTime[i] / l);
    if (c >= o.frames.length)
      if (o.loop) {
        Zt.animationTime[i] = Zt.animationTime[i] % o.duration;
        const u = Math.floor(Zt.animationTime[i] / l);
        ht.currentFrame[i] = o.frames[Math.min(u, o.frames.length - 1)], u !== a && (Ew(n, i, o, u), Zt.previousFrameIndex[i] = u);
      } else
        Zt.animationTime[i] = o.duration - 1e-3, ht.currentFrame[i] = o.frames[o.frames.length - 1], ht.isPlaying[i] = 0;
    else
      ht.currentFrame[i] = o.frames[c], c !== a && (Ew(n, i, o, c), Zt.previousFrameIndex[i] = c);
  }
  const s = n.query(P5);
  for (const i of s) {
    if (n.doesEntityHaveComponent(i, Zt) || !(ht.isPlaying[i] | 0) || ht.totalFrames[i] <= 1) continue;
    ht.frameTimer[i] += t / 1e3;
    const o = 1 / ht.fps[i];
    if (ht.frameTimer[i] >= o) {
      ht.frameTimer[i] = 0;
      let r = ht.currentFrame[i] + 1;
      r >= ht.totalFrames[i] && ((ht.isLooping[i] | 0) === 1 ? r = 0 : (r = ht.totalFrames[i] - 1, ht.isPlaying[i] = 0)), ht.currentFrame[i] = r;
    }
  }
}
h(D5, "animationSystem");
function Ew(n, t, e, s) {
  if (!(!e.events || e.events.length === 0))
    for (const i of e.events)
      i.frame === s && (Hi.emit(`animation:${i.action}`, {
        eid: t,
        animationName: e.name,
        frameIndex: s,
        action: i.action,
        value: i.value,
        scene: n
      }), Hi.emit("animation:event", {
        eid: t,
        animationName: e.name,
        frameIndex: s,
        action: i.action,
        value: i.value,
        scene: n
      }));
}
h(Ew, "fireAnimationEvents");
const V5 = new hn().with(He).with(ue), E3 = new hn().with(Tn).with(ue), cd = [], T3 = 1e3;
function L5(n, t, e) {
  const s = t / 1e3, i = n.query(V5);
  for (const r of i) {
    if (!(He.isActive[r] | 0)) continue;
    const a = V2[He.presetId[r]];
    if (!a) continue;
    He.elapsed[r] += s;
    const l = He.duration[r];
    if (l > 0 && He.elapsed[r] >= l) {
      He.isActive[r] = 0;
      continue;
    }
    const u = 1 / He.rate[r];
    if (He.timeSinceLastEmit[r] += s, He.timeSinceLastEmit[r] >= u) {
      He.timeSinceLastEmit[r] = 0;
      const m = a.count, d = ue.read(r);
      for (let f = 0; f < m; f++)
        N5(n, r, d.x, d.y, a);
    }
  }
  const o = n.query(E3);
  for (const r of o) {
    if (!(Tn.isAlive[r] | 0)) continue;
    if (Tn.age[r] += s, Tn.age[r] >= Tn.lifetime[r]) {
      z5(r);
      continue;
    }
    Tn.vy[r] += Tn.gravity[r] * e * s;
    const a = ue.read(r);
    if (ue.assign(r, {
      x: a.x + Tn.vx[r] * s,
      y: a.y + Tn.vy[r] * s
    }), (Tn.fadeOut[r] | 0) === 1) {
      const l = Tn.age[r] / Tn.lifetime[r], c = Math.max(0, Math.min(255, Math.round((1 - l) * 255)));
      Ln.component.color[r][3] = c;
    }
  }
}
h(L5, "particleSystem");
function N5(n, t, e, s, i) {
  let o;
  if (cd.length > 0)
    o = cd.pop(), Tn.isAlive[o] = 1;
  else {
    if (n.query(E3).length >= T3)
      return;
    o = n.addEntity(), n.addComponentToEntity(Tn, o), n.addComponentToEntity(ue, o), n.addComponentToEntity(Ln, o);
  }
  const r = i.size, a = i.sizeVariation, l = r * (1 + (Math.random() - 0.5) * a * 2), c = i.spread * Math.PI / 180, u = (Math.random() - 0.5) * c, m = i.speed, d = i.speedVariation, f = m * (1 + (Math.random() - 0.5) * d * 2);
  if (Tn.isAlive[o] = 1, Tn.lifetime[o] = i.lifetime, Tn.age[o] = 0, Tn.vx[o] = Math.sin(u + Math.PI / 2) * f, Tn.vy[o] = Math.cos(u + Math.PI / 2) * f, Tn.gravity[o] = i.gravity, Tn.size[o] = l, Tn.fadeOut[o] = i.fadeOut ? 1 : 0, Tn.emitterEid[o] = t, ue.assign(o, { x: e, y: s, rotation: 0, sx: 1, sy: 1 }), Ln.component.radius[o] = l / 2, Ln.component.isVisible[o] = 1, (He.hasCustomColor[t] | 0) === 1)
    Ln.component.color[o][0] = He.colorR[t], Ln.component.color[o][1] = He.colorG[t], Ln.component.color[o][2] = He.colorB[t], Ln.component.color[o][3] = 255;
  else {
    const v = Na(i.color);
    Ln.component.color[o][0] = v.rgb[0], Ln.component.color[o][1] = v.rgb[1], Ln.component.color[o][2] = v.rgb[2], Ln.component.color[o][3] = 255;
  }
}
h(N5, "spawnParticle");
function z5(n) {
  Tn.isAlive[n] = 0, Ln.component.isVisible[n] = 0, cd.length < T3 / 2 && cd.push(n);
}
h(z5, "killParticle");
const k5 = new hn().with(ue).with(Zn), U5 = new hn().with(ue).with(ht), O5 = new hn().with(ue).with(Ln), $5 = new hn().with(ue).with(qs);
function F5(n, t, e, { assetManager: s }, i = !1) {
  t.imageSmoothingEnabled = !1, G5(t, e), n.query(k5).filter((o) => (Zn.component.isActive[o] | 0) === 1).sort((o, r) => (Zn.component.zOrder[o] | 0) - (Zn.component.zOrder[r] | 0)).forEach((o) => H5(n, t, o, s, i));
}
h(F5, "renderSystem2D");
function G5(n, t) {
  n.save(), n.setTransform(1, 0, 0, 1, 0, 0), n.fillStyle = t, n.fillRect(0, 0, n.canvas.width, n.canvas.height), n.restore();
}
h(G5, "clearCanvas");
function H5(n, t, e, s, i) {
  var C, M, T, b, y, E, I, B, D, N, V, G, U, j, tt, K, $, lt, gt, _t, Y, it, J, dt, vt, Nt, _e, k, te, It;
  const { canvas: o } = t, r = window.devicePixelRatio || 1, a = {
    x: (C = Zn.component.viewportX[e]) != null ? C : 0,
    y: (M = Zn.component.viewportY[e]) != null ? M : 0,
    width: (T = Zn.component.viewportWidth[e]) != null ? T : 1,
    height: (b = Zn.component.viewportHeight[e]) != null ? b : 1
  }, l = n.doesEntityHaveComponent(e, Pt.component), c = ue.read(e), u = {
    worldX: l ? (y = Pt.component.x[e]) != null ? y : 0 : (E = c.x) != null ? E : 0,
    worldY: l ? (I = Pt.component.y[e]) != null ? I : 0 : (B = c.y) != null ? B : 0,
    scaleX: l ? (V = (N = (D = Pt.component.sx) == null ? void 0 : D[e]) != null ? N : c.sx) != null ? V : 1 : (G = c.sx) != null ? G : 1,
    scaleY: l ? (tt = (j = (U = Pt.component.sy) == null ? void 0 : U[e]) != null ? j : c.sy) != null ? tt : 1 : (K = c.sy) != null ? K : 1,
    rotation: l ? ($ = Pt.component.rotation[e]) != null ? $ : 0 : (lt = c.rotation) != null ? lt : 0
  }, m = Math.round(a.x * (o.width / r)), d = Math.round((1 - a.y - a.height) * (o.height / r)), f = Math.round(a.width * (o.width / r)), p = Math.round(a.height * (o.height / r));
  t.save(), t.beginPath(), t.rect(
    m * r,
    d * r,
    f * r,
    p * r
  ), t.clip();
  const v = Dn.worldViewWidth * u.scaleX, _ = Dn.worldViewHeight * u.scaleY, g = f / v, w = p / _, S = (m + f / 2) * r, x = (d + p / 2) * r;
  t.setTransform(1, 0, 0, 1, 0, 0), t.translate(S, x), t.scale(g * r, -w * r), t.rotate(-u.rotation), t.translate(-u.worldX, -u.worldY);
  const A = [];
  for (const ut of n.query($5)) {
    if (!(qs.component.isVisible[ut] | 0)) continue;
    const bt = n.doesEntityHaveComponent(ut, Pt.component), Ft = ue.read(ut), wt = bt ? (Y = (_t = (gt = Pt.component.z) == null ? void 0 : gt[ut]) != null ? _t : Ft.z) != null ? Y : 0 : (it = Ft.z) != null ? it : 0;
    A.push({ eid: ut, z: wt, type: "rect" });
  }
  for (const ut of n.query(O5)) {
    if (!(Ln.component.isVisible[ut] | 0)) continue;
    const bt = n.doesEntityHaveComponent(ut, Pt.component), Ft = ue.read(ut), wt = bt ? (vt = (dt = (J = Pt.component.z) == null ? void 0 : J[ut]) != null ? dt : Ft.z) != null ? vt : 0 : (Nt = Ft.z) != null ? Nt : 0;
    A.push({ eid: ut, z: wt, type: "circle" });
  }
  for (const ut of n.query(U5)) {
    if (!(ht.isVisible[ut] | 0)) continue;
    const bt = n.doesEntityHaveComponent(ut, Pt.component), Ft = ue.read(ut), wt = bt ? (te = (k = (_e = Pt.component.z) == null ? void 0 : _e[ut]) != null ? k : Ft.z) != null ? te : 0 : (It = Ft.z) != null ? It : 0;
    A.push({ eid: ut, z: wt, type: "sprite" });
  }
  A.sort((ut, bt) => ut.z - bt.z);
  for (const { eid: ut, type: bt } of A)
    bt === "rect" && j5(n, t, ut), bt === "circle" && W5(n, t, ut), bt === "sprite" && q5(n, t, ut, s);
  i && X5(t, u, a, o, r), t.restore();
}
h(H5, "renderCameraViewport");
function j5(n, t, e) {
  var d, f, p, v, _;
  const s = n.doesEntityHaveComponent(e, Pt.component), i = ue.read(e), o = s ? (d = Pt.component.x[e]) != null ? d : 0 : i.x || 0, r = s ? (f = Pt.component.y[e]) != null ? f : 0 : i.y || 0, a = qs.component.width[e] || 1, l = qs.component.height[e] || 1, c = s ? (p = Pt.component.rotation[e]) != null ? p : 0 : i.rotation || 0, u = s ? (v = Pt.component.sx[e]) != null ? v : 1 : i.sx || 1, m = s ? (_ = Pt.component.sy[e]) != null ? _ : 1 : i.sy || 1;
  t.save(), t.translate(o, r), t.rotate(c), t.scale(u, m), t.fillStyle = I3(qs.component.color[e]), t.fillRect(-a / 2, -l / 2, a, l), t.restore();
}
h(j5, "renderRect");
function I3(n) {
  var o, r, a, l;
  const t = (o = n[0]) != null ? o : 255, e = (r = n[1]) != null ? r : 255, s = (a = n[2]) != null ? a : 255, i = (l = n[3]) != null ? l : 255;
  return i < 255 ? `rgba(${t}, ${e}, ${s}, ${(i / 255).toFixed(3)})` : `rgb(${t}, ${e}, ${s})`;
}
h(I3, "formatComponentColor");
function W5(n, t, e) {
  var m, d, f, p, v;
  const s = n.doesEntityHaveComponent(e, Pt.component), i = ue.read(e), o = s ? (m = Pt.component.x[e]) != null ? m : 0 : i.x || 0, r = s ? (d = Pt.component.y[e]) != null ? d : 0 : i.y || 0, a = Ln.component.radius[e] || 1, l = s ? (f = Pt.component.rotation[e]) != null ? f : 0 : i.rotation || 0, c = s ? (p = Pt.component.sx[e]) != null ? p : 1 : i.sx || 1, u = s ? (v = Pt.component.sy[e]) != null ? v : 1 : i.sy || 1;
  t.save(), t.translate(o, r), t.rotate(l), t.scale(c, u), t.fillStyle = I3(Ln.component.color[e]), t.beginPath(), t.arc(0, 0, a, 0, Math.PI * 2), t.fill(), t.restore();
}
h(W5, "renderCircle");
function q5(n, t, e, s) {
  var y, E, I;
  const i = ht.assetId[e], o = s.getAssetById(i);
  if (!o) return;
  const r = n.doesEntityHaveComponent(e, Pt.component), a = ue.read(e), l = r ? (y = Pt.component.x[e]) != null ? y : 0 : a.x || 0, c = r ? (E = Pt.component.y[e]) != null ? E : 0 : a.y || 0, u = r ? (I = Pt.component.rotation[e]) != null ? I : 0 : a.rotation || 0, m = ht.frameWidth[e], d = ht.frameHeight[e], f = ht.currentFrame[e], p = ht.width[e], v = ht.height[e], _ = ht.alpha[e], g = ht.flipX[e], w = ht.flipY[e], S = ht.anchorX[e], x = ht.anchorY[e], A = f * m + ht.frameOffsetX[e], C = ht.frameOffsetY[e];
  t.save(), t.translate(l, c), t.rotate(u), t.globalAlpha = _;
  const M = g ? -1 : 1, T = w ? -1 : 1;
  (g || w) && t.scale(M, T), t.drawImage(
    o.data,
    A,
    C,
    m,
    d,
    -p * S,
    -v * x,
    p,
    v
  );
  const b = ht.tintStrength[e];
  if (b > 0) {
    const B = ht.tintR[e], D = ht.tintG[e], N = ht.tintB[e];
    t.globalCompositeOperation = "multiply", t.globalAlpha = b * _, t.fillStyle = `rgb(${B}, ${D}, ${N})`, t.fillRect(
      -p * S,
      -v * x,
      p,
      v
    ), t.globalCompositeOperation = "destination-in", t.globalAlpha = 1, t.drawImage(
      o.data,
      A,
      C,
      m,
      d,
      -p * S,
      -v * x,
      p,
      v
    );
  }
  t.restore();
}
h(q5, "renderSprite");
function X5(n, t, e, s, i) {
  const o = Dn.worldViewWidth, r = Dn.worldViewHeight, a = e.width * (s.width / i), l = e.height * (s.height / i), c = o * Math.abs(t.scaleX), u = r * Math.abs(t.scaleY), m = Math.hypot(c, u) / 2, d = t.worldX - m, f = t.worldX + m, p = t.worldY - m, v = t.worldY + m, _ = Math.max(c, u);
  let g = 1;
  for (; _ / g > 25; ) g *= 2;
  const w = a / c, S = l / u;
  n.strokeStyle = "rgba(255, 255, 255, 0.15)", n.lineWidth = 1 / w, n.setLineDash([]);
  const x = Math.floor(d / g) * g;
  for (let M = x; M <= f; M += g)
    n.beginPath(), n.moveTo(M, p), n.lineTo(M, v), n.stroke();
  n.lineWidth = 1 / S;
  const A = Math.floor(p / g) * g;
  for (let M = A; M <= v; M += g)
    n.beginPath(), n.moveTo(d, M), n.lineTo(f, M), n.stroke();
  const C = 1 / w;
  n.save(), n.strokeStyle = "rgba(255, 255, 255, 0.25)", n.lineWidth = C, n.setLineDash([g / 4, g / 4]), n.beginPath(), n.moveTo(d, 0), n.lineTo(f, 0), n.stroke(), n.beginPath(), n.moveTo(0, p), n.lineTo(0, v), n.stroke(), n.restore(), n.strokeStyle = "rgba(255, 0, 0, 0.3)", n.lineWidth = 2 / S, n.beginPath(), n.moveTo(d, t.worldY), n.lineTo(f, t.worldY), n.stroke(), n.strokeStyle = "rgba(0, 255, 0, 0.3)", n.lineWidth = 2 / w, n.beginPath(), n.moveTo(t.worldX, p), n.lineTo(t.worldX, v), n.stroke();
}
h(X5, "drawDebugGrid");
const Z5 = new hn().with(Gi).with(Gt);
function Tw(n, t, e, s, i, o, r) {
  var a, l, c, u, m, d;
  return {
    x: (a = n.x) != null ? a : t,
    y: (l = n.y) != null ? l : e,
    z: (c = n.z) != null ? c : s,
    rotation: (u = n.rotation) != null ? u : i,
    sx: (m = n.sx) != null ? m : o,
    sy: (d = n.sy) != null ? d : r
  };
}
h(Tw, "mergeWithBindPose");
function B3(n, t) {
  var s, i, o, r, a, l, c, u, m, d, f;
  const e = n.query(Z5);
  for (const p of e) {
    if (!(Gt.isPlaying[p] | 0) || !(Gt.hasAnimations[p] | 0)) continue;
    const v = XN(n, p);
    if (!v) continue;
    const _ = M3(n, p);
    if (!_ || !_.boneEntities) continue;
    const g = (Gt.isBlending[p] | 0) === 1;
    if (g) {
      const A = Gt.blendTime[p], C = t / 1e3;
      Gt.blendProgress[p] += C / A, Gt.blendProgress[p] >= 1 && (Gt.isBlending[p] = 0, Gt.blendProgress[p] = 0);
    }
    const w = Gt.speedMultiplier[p];
    Gt.animationTime[p] += t / 1e3 * w;
    const S = Gt.animationTime[p];
    S >= v.duration && (v.loop ? Gt.animationTime[p] = S % v.duration : (Gt.animationTime[p] = v.duration, Gt.isPlaying[p] = 0));
    const x = Gt.animationTime[p];
    for (const A of v.tracks) {
      const C = (s = _.boneEntities) == null ? void 0 : s.get(A.boneName);
      if (C === void 0) {
        console.warn(`[SkeletalAnim] Bone "${A.boneName}" not found in skeleton`);
        continue;
      }
      const M = _.bones.find((y) => y.name === A.boneName);
      if (!M) {
        console.warn(`[SkeletalAnim] Bone definition not found for "${A.boneName}"`);
        continue;
      }
      const T = Up(A, x);
      if (!T) {
        console.warn(`[SkeletalAnim] No transform for bone "${A.boneName}" at time ${x}`);
        continue;
      }
      const b = Tw(
        T,
        (i = M.x) != null ? i : 0,
        (o = M.y) != null ? o : 0,
        (r = M.z) != null ? r : 0,
        M.rotation,
        (a = M.sx) != null ? a : 1,
        (l = M.sy) != null ? l : 1
      );
      if (g) {
        const y = Gt.blendProgress[p], E = Gt.previousAnimationId[p], I = n.skeletalAnimationSets[Gt.animationSetId[p]];
        if (I && E < I.animationList.length) {
          const D = I.animationList[E].tracks.find((N) => N.boneName === A.boneName);
          if (D) {
            const N = Up(D, 0);
            if (N) {
              const V = Tw(
                N,
                (c = M.x) != null ? c : 0,
                (u = M.y) != null ? u : 0,
                (m = M.z) != null ? m : 0,
                M.rotation,
                (d = M.sx) != null ? d : 1,
                (f = M.sy) != null ? f : 1
              );
              ue.assign(C, {
                x: V.x + (b.x - V.x) * y,
                y: V.y + (b.y - V.y) * y,
                z: V.z + (b.z - V.z) * y,
                rotation: V.rotation + (b.rotation - V.rotation) * y,
                sx: V.sx + (b.sx - V.sx) * y,
                sy: V.sy + (b.sy - V.sy) * y
              });
              continue;
            }
          }
        }
      }
      n.doesEntityHaveComponent(C, ue) ? ue.assign(C, {
        x: b.x,
        y: b.y,
        z: b.z,
        rotation: b.rotation,
        sx: b.sx,
        sy: b.sy
      }) : console.warn(`Bone ${C} doesn't have Transform component!`);
    }
    if (v.events && v.events.length > 0)
      for (const A of v.events)
        x - t / 1e3 * w < A.time && x >= A.time && (Hi.emit(`skeletal-animation:${A.action}`, {
          skeletonEid: p,
          animationName: v.name,
          time: A.time,
          action: A.action,
          value: A.value,
          scene: n
        }), Hi.emit("skeletal-animation:event", {
          skeletonEid: p,
          animationName: v.name,
          time: A.time,
          action: A.action,
          value: A.value,
          scene: n
        }));
  }
}
h(B3, "skeletalAnimationSystem");
const Y5 = new hn().with(sa);
function J5(n, t) {
  var s, i, o, r;
  const e = n.query(Y5);
  for (const a of e) {
    const l = n5(n, a);
    if (!l) continue;
    let c = n.deformedMeshes.get(a);
    (!c || c.length !== l.vertices.length) && (c = new Array(l.vertices.length), n.deformedMeshes.set(a, c));
    for (let u = 0; u < l.vertices.length; u++) {
      const m = l.vertices[u];
      if (!m.influences || m.influences.length === 0) {
        c[u] = {
          x: m.x,
          y: m.y,
          z: m.z,
          u: m.u,
          v: m.v
        };
        continue;
      }
      let d = 0, f = 0, p = 0, v = 0;
      for (const _ of m.influences) {
        const g = _.boneEid;
        if (g === void 0 || g === 0) continue;
        const w = (s = Pt.component.x[g]) != null ? s : 0, S = (i = Pt.component.y[g]) != null ? i : 0, x = (o = Pt.component.z[g]) != null ? o : 0, A = (r = Pt.component.rotation[g]) != null ? r : 0, C = EN(g, w, S, x, A), [M, T, b] = IN(C, m.x, m.y, m.z), y = _.weight;
        d += M * y, f += T * y, p += b * y, v += y;
      }
      v > 0 ? (d /= v, f /= v, p /= v) : (d = m.x, f = m.y, p = m.z), c[u] = {
        x: d,
        y: f,
        z: p,
        u: m.u,
        v: m.v
      };
    }
  }
}
h(J5, "skinningSystem");
let wf = null, Sf = 0, Iw = 0, Bw = 0;
const K5 = 500, sh = 1.5;
function Q5(n, { assetManager: t }, e) {
  wf || (wf = new hn().with(ue).with(ht));
  function s(d, f) {
    const p = [
      "default-player",
      "default-enemy",
      "default-collectible",
      "default-powerup",
      "default-explosion"
    ];
    for (const v of p)
      if (d.getAssetId(v) === f)
        return v;
    return null;
  }
  if (h(s, "findAssetKey"), e - Bw < K5) return;
  Bw = e;
  const i = Dn.canvasPixelWidth, o = Dn.canvasPixelHeight;
  if (!(Math.abs(i - Sf) > 10 || Math.abs(o - Iw) > 10) && Sf !== 0) return;
  Sf = i, Iw = o;
  const a = window.devicePixelRatio || 1, l = Dn.worldViewWidth, c = i / l / a, u = wf._compile().base(n), m = /* @__PURE__ */ new Set();
  for (const d of u) {
    const f = ht.assetId[d];
    if (f === 0) continue;
    const p = s(t, f);
    if (!p || !t.isProcedural(p) || m.has(p)) continue;
    m.add(p);
    const v = ht.width[d], _ = ht.height[d], g = Math.ceil(v * c * 1.5), w = Math.ceil(_ * c * 1.5), S = t.getSpriteResolution(p);
    if (!S) continue;
    const x = g / S.frameWidth, A = w / S.frameHeight;
    if (x >= sh || x <= 1 / sh || A >= sh || A <= 1 / sh) {
      console.log(`🎨 Regenerating sprite "${p}" at ${g}x${w} (was ${S.frameWidth}x${S.frameHeight})`), t.regenerateAnimatedSprite(p, g, w);
      for (const M of u)
        ht.assetId[M] === f && (ht.frameWidth[M] = g, ht.frameHeight[M] = w);
    }
  }
}
h(Q5, "spriteResolutionSystem");
const N2 = "180", tz = 0, Pw = 1, ez = 2, P3 = 1, R3 = 2, wo = 3, yr = 0, Di = 1, As = 2, hr = 0, wc = 1, Rw = 2, Dw = 3, Vw = 4, nz = 5, qr = 100, iz = 101, sz = 102, oz = 103, rz = 104, az = 200, cz = 201, lz = 202, uz = 203, $p = 204, Fp = 205, hz = 206, dz = 207, mz = 208, fz = 209, pz = 210, _z = 211, gz = 212, vz = 213, bz = 214, Gp = 0, Hp = 1, jp = 2, zc = 3, Wp = 4, qp = 5, Xp = 6, Zp = 7, D3 = 0, yz = 1, xz = 2, dr = 0, wz = 1, Sz = 2, Az = 3, Mz = 4, Cz = 5, Ez = 6, Tz = 7, V3 = 300, kc = 301, Uc = 302, Yp = 303, Jp = 304, zm = 306, Kp = 1e3, oa = 1001, Qp = 1002, Ts = 1003, Iz = 1004, oh = 1005, $s = 1006, Af = 1007, ra = 1008, Xs = 1009, L3 = 1010, N3 = 1011, su = 1012, z2 = 1013, ga = 1014, Ro = 1015, Nu = 1016, k2 = 1017, U2 = 1018, ou = 1020, z3 = 35902, k3 = 35899, U3 = 1021, O3 = 1022, Ms = 1023, ru = 1026, au = 1027, $3 = 1028, O2 = 1029, F3 = 1030, $2 = 1031, F2 = 1033, Vh = 33776, Lh = 33777, Nh = 33778, zh = 33779, t_ = 35840, e_ = 35841, n_ = 35842, i_ = 35843, s_ = 36196, o_ = 37492, r_ = 37496, a_ = 37808, c_ = 37809, l_ = 37810, u_ = 37811, h_ = 37812, d_ = 37813, m_ = 37814, f_ = 37815, p_ = 37816, __ = 37817, g_ = 37818, v_ = 37819, b_ = 37820, y_ = 37821, x_ = 36492, w_ = 36494, S_ = 36495, A_ = 36283, M_ = 36284, C_ = 36285, E_ = 36286, Bz = 3200, Pz = 3201, G3 = 0, Rz = 1, rr = "", rs = "srgb", Oc = "srgb-linear", ld = "linear", pn = "srgb", Wa = 7680, Lw = 519, Dz = 512, Vz = 513, Lz = 514, H3 = 515, Nz = 516, zz = 517, kz = 518, Uz = 519, Nw = 35044, zw = "300 es", Fs = 2e3, ud = 2001, Eb = class Eb {
  addEventListener(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const s = this._listeners;
    s[t] === void 0 && (s[t] = []), s[t].indexOf(e) === -1 && s[t].push(e);
  }
  hasEventListener(t, e) {
    const s = this._listeners;
    return s === void 0 ? !1 : s[t] !== void 0 && s[t].indexOf(e) !== -1;
  }
  removeEventListener(t, e) {
    const s = this._listeners;
    if (s === void 0) return;
    const i = s[t];
    if (i !== void 0) {
      const o = i.indexOf(e);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(t) {
    const e = this._listeners;
    if (e === void 0) return;
    const s = e[t.type];
    if (s !== void 0) {
      t.target = this;
      const i = s.slice(0);
      for (let o = 0, r = i.length; o < r; o++)
        i[o].call(this, t);
      t.target = null;
    }
  }
};
h(Eb, "EventDispatcher");
let xr = Eb;
const ri = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let kw = 1234567;
const Rl = Math.PI / 180, $c = 180 / Math.PI;
function il() {
  const n = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0;
  return (ri[n & 255] + ri[n >> 8 & 255] + ri[n >> 16 & 255] + ri[n >> 24 & 255] + "-" + ri[t & 255] + ri[t >> 8 & 255] + "-" + ri[t >> 16 & 15 | 64] + ri[t >> 24 & 255] + "-" + ri[e & 63 | 128] + ri[e >> 8 & 255] + "-" + ri[e >> 16 & 255] + ri[e >> 24 & 255] + ri[s & 255] + ri[s >> 8 & 255] + ri[s >> 16 & 255] + ri[s >> 24 & 255]).toLowerCase();
}
h(il, "generateUUID");
function Oe(n, t, e) {
  return Math.max(t, Math.min(e, n));
}
h(Oe, "clamp");
function G2(n, t) {
  return (n % t + t) % t;
}
h(G2, "euclideanModulo");
function Oz(n, t, e, s, i) {
  return s + (n - t) * (i - s) / (e - t);
}
h(Oz, "mapLinear");
function $z(n, t, e) {
  return n !== t ? (e - n) / (t - n) : 0;
}
h($z, "inverseLerp");
function Dl(n, t, e) {
  return (1 - e) * n + e * t;
}
h(Dl, "lerp$1");
function Fz(n, t, e, s) {
  return Dl(n, t, 1 - Math.exp(-e * s));
}
h(Fz, "damp");
function Gz(n, t = 1) {
  return t - Math.abs(G2(n, t * 2) - t);
}
h(Gz, "pingpong");
function Hz(n, t, e) {
  return n <= t ? 0 : n >= e ? 1 : (n = (n - t) / (e - t), n * n * (3 - 2 * n));
}
h(Hz, "smoothstep");
function jz(n, t, e) {
  return n <= t ? 0 : n >= e ? 1 : (n = (n - t) / (e - t), n * n * n * (n * (n * 6 - 15) + 10));
}
h(jz, "smootherstep");
function Wz(n, t) {
  return n + Math.floor(Math.random() * (t - n + 1));
}
h(Wz, "randInt");
function qz(n, t) {
  return n + Math.random() * (t - n);
}
h(qz, "randFloat");
function Xz(n) {
  return n * (0.5 - Math.random());
}
h(Xz, "randFloatSpread");
function Zz(n) {
  n !== void 0 && (kw = n);
  let t = kw += 1831565813;
  return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
}
h(Zz, "seededRandom");
function Yz(n) {
  return n * Rl;
}
h(Yz, "degToRad");
function Jz(n) {
  return n * $c;
}
h(Jz, "radToDeg");
function Kz(n) {
  return (n & n - 1) === 0 && n !== 0;
}
h(Kz, "isPowerOfTwo");
function Qz(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
h(Qz, "ceilPowerOfTwo");
function tk(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
h(tk, "floorPowerOfTwo");
function ek(n, t, e, s, i) {
  const o = Math.cos, r = Math.sin, a = o(e / 2), l = r(e / 2), c = o((t + s) / 2), u = r((t + s) / 2), m = o((t - s) / 2), d = r((t - s) / 2), f = o((s - t) / 2), p = r((s - t) / 2);
  switch (i) {
    case "XYX":
      n.set(a * u, l * m, l * d, a * c);
      break;
    case "YZY":
      n.set(l * d, a * u, l * m, a * c);
      break;
    case "ZXZ":
      n.set(l * m, l * d, a * u, a * c);
      break;
    case "XZX":
      n.set(a * u, l * p, l * f, a * c);
      break;
    case "YXY":
      n.set(l * f, a * u, l * p, a * c);
      break;
    case "ZYZ":
      n.set(l * p, l * f, a * u, a * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
h(ek, "setQuaternionFromProperEuler");
function hc(n, t) {
  switch (t.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
h(hc, "denormalize");
function gi(n, t) {
  switch (t.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
h(gi, "normalize");
const nk = {
  DEG2RAD: Rl,
  RAD2DEG: $c,
  generateUUID: il,
  clamp: Oe,
  euclideanModulo: G2,
  mapLinear: Oz,
  inverseLerp: $z,
  lerp: Dl,
  damp: Fz,
  pingpong: Gz,
  smoothstep: Hz,
  smootherstep: jz,
  randInt: Wz,
  randFloat: qz,
  randFloatSpread: Xz,
  seededRandom: Zz,
  degToRad: Yz,
  radToDeg: Jz,
  isPowerOfTwo: Kz,
  ceilPowerOfTwo: Qz,
  floorPowerOfTwo: tk,
  setQuaternionFromProperEuler: ek,
  normalize: gi,
  denormalize: hc
}, Yd = class Yd {
  constructor(t = 0, e = 0) {
    Yd.prototype.isVector2 = !0, this.x = t, this.y = e;
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x, s = this.y, i = t.elements;
    return this.x = i[0] * e + i[3] * s + i[6], this.y = i[1] * e + i[4] * s + i[7], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  }
  clamp(t, e) {
    return this.x = Oe(this.x, t.x, e.x), this.y = Oe(this.y, t.y, e.y), this;
  }
  clampScalar(t, e) {
    return this.x = Oe(this.x, t, e), this.y = Oe(this.y, t, e), this;
  }
  clampLength(t, e) {
    const s = this.length();
    return this.divideScalar(s || 1).multiplyScalar(Oe(s, t, e));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0) return Math.PI / 2;
    const s = this.dot(t) / e;
    return Math.acos(Oe(s, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, s = this.y - t.y;
    return e * e + s * s;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
  }
  lerpVectors(t, e, s) {
    return this.x = t.x + (e.x - t.x) * s, this.y = t.y + (e.y - t.y) * s, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this;
  }
  rotateAround(t, e) {
    const s = Math.cos(e), i = Math.sin(e), o = this.x - t.x, r = this.y - t.y;
    return this.x = o * s - r * i + t.x, this.y = o * i + r * s + t.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
};
h(Yd, "Vector2");
let Pe = Yd;
const Tb = class Tb {
  constructor(t = 0, e = 0, s = 0, i = 1) {
    this.isQuaternion = !0, this._x = t, this._y = e, this._z = s, this._w = i;
  }
  static slerpFlat(t, e, s, i, o, r, a) {
    let l = s[i + 0], c = s[i + 1], u = s[i + 2], m = s[i + 3];
    const d = o[r + 0], f = o[r + 1], p = o[r + 2], v = o[r + 3];
    if (a === 0) {
      t[e + 0] = l, t[e + 1] = c, t[e + 2] = u, t[e + 3] = m;
      return;
    }
    if (a === 1) {
      t[e + 0] = d, t[e + 1] = f, t[e + 2] = p, t[e + 3] = v;
      return;
    }
    if (m !== v || l !== d || c !== f || u !== p) {
      let _ = 1 - a;
      const g = l * d + c * f + u * p + m * v, w = g >= 0 ? 1 : -1, S = 1 - g * g;
      if (S > Number.EPSILON) {
        const A = Math.sqrt(S), C = Math.atan2(A, g * w);
        _ = Math.sin(_ * C) / A, a = Math.sin(a * C) / A;
      }
      const x = a * w;
      if (l = l * _ + d * x, c = c * _ + f * x, u = u * _ + p * x, m = m * _ + v * x, _ === 1 - a) {
        const A = 1 / Math.sqrt(l * l + c * c + u * u + m * m);
        l *= A, c *= A, u *= A, m *= A;
      }
    }
    t[e] = l, t[e + 1] = c, t[e + 2] = u, t[e + 3] = m;
  }
  static multiplyQuaternionsFlat(t, e, s, i, o, r) {
    const a = s[i], l = s[i + 1], c = s[i + 2], u = s[i + 3], m = o[r], d = o[r + 1], f = o[r + 2], p = o[r + 3];
    return t[e] = a * p + u * m + l * f - c * d, t[e + 1] = l * p + u * d + c * m - a * f, t[e + 2] = c * p + u * f + a * d - l * m, t[e + 3] = u * p - a * m - l * d - c * f, t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    this._w = t, this._onChangeCallback();
  }
  set(t, e, s, i) {
    return this._x = t, this._y = e, this._z = s, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  }
  setFromEuler(t, e = !0) {
    const s = t._x, i = t._y, o = t._z, r = t._order, a = Math.cos, l = Math.sin, c = a(s / 2), u = a(i / 2), m = a(o / 2), d = l(s / 2), f = l(i / 2), p = l(o / 2);
    switch (r) {
      case "XYZ":
        this._x = d * u * m + c * f * p, this._y = c * f * m - d * u * p, this._z = c * u * p + d * f * m, this._w = c * u * m - d * f * p;
        break;
      case "YXZ":
        this._x = d * u * m + c * f * p, this._y = c * f * m - d * u * p, this._z = c * u * p - d * f * m, this._w = c * u * m + d * f * p;
        break;
      case "ZXY":
        this._x = d * u * m - c * f * p, this._y = c * f * m + d * u * p, this._z = c * u * p + d * f * m, this._w = c * u * m - d * f * p;
        break;
      case "ZYX":
        this._x = d * u * m - c * f * p, this._y = c * f * m + d * u * p, this._z = c * u * p - d * f * m, this._w = c * u * m + d * f * p;
        break;
      case "YZX":
        this._x = d * u * m + c * f * p, this._y = c * f * m + d * u * p, this._z = c * u * p - d * f * m, this._w = c * u * m - d * f * p;
        break;
      case "XZY":
        this._x = d * u * m - c * f * p, this._y = c * f * m - d * u * p, this._z = c * u * p + d * f * m, this._w = c * u * m + d * f * p;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const s = e / 2, i = Math.sin(s);
    return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(s), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t) {
    const e = t.elements, s = e[0], i = e[4], o = e[8], r = e[1], a = e[5], l = e[9], c = e[2], u = e[6], m = e[10], d = s + a + m;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / f, this._x = (u - l) * f, this._y = (o - c) * f, this._z = (r - i) * f;
    } else if (s > a && s > m) {
      const f = 2 * Math.sqrt(1 + s - a - m);
      this._w = (u - l) / f, this._x = 0.25 * f, this._y = (i + r) / f, this._z = (o + c) / f;
    } else if (a > m) {
      const f = 2 * Math.sqrt(1 + a - s - m);
      this._w = (o - c) / f, this._x = (i + r) / f, this._y = 0.25 * f, this._z = (l + u) / f;
    } else {
      const f = 2 * Math.sqrt(1 + m - s - a);
      this._w = (r - i) / f, this._x = (o + c) / f, this._y = (l + u) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let s = t.dot(e) + 1;
    return s < 1e-8 ? (s = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = s) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = s)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = s), this.normalize();
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(Oe(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const s = this.angleTo(t);
    if (s === 0) return this;
    const i = Math.min(1, e / s);
    return this.slerp(t, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t = this.length();
    return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const s = t._x, i = t._y, o = t._z, r = t._w, a = e._x, l = e._y, c = e._z, u = e._w;
    return this._x = s * u + r * a + i * c - o * l, this._y = i * u + r * l + o * a - s * c, this._z = o * u + r * c + s * l - i * a, this._w = r * u - s * a - i * l - o * c, this._onChangeCallback(), this;
  }
  slerp(t, e) {
    if (e === 0) return this;
    if (e === 1) return this.copy(t);
    const s = this._x, i = this._y, o = this._z, r = this._w;
    let a = r * t._w + s * t._x + i * t._y + o * t._z;
    if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1)
      return this._w = r, this._x = s, this._y = i, this._z = o, this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const f = 1 - e;
      return this._w = f * r + e * this._w, this._x = f * s + e * this._x, this._y = f * i + e * this._y, this._z = f * o + e * this._z, this.normalize(), this;
    }
    const c = Math.sqrt(l), u = Math.atan2(c, a), m = Math.sin((1 - e) * u) / c, d = Math.sin(e * u) / c;
    return this._w = r * m + this._w * d, this._x = s * m + this._x * d, this._y = i * m + this._y * d, this._z = o * m + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(t, e, s) {
    return this.copy(t).slerp(e, s);
  }
  random() {
    const t = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), s = Math.random(), i = Math.sqrt(1 - s), o = Math.sqrt(s);
    return this.set(
      i * Math.sin(t),
      i * Math.cos(t),
      o * Math.sin(e),
      o * Math.cos(e)
    );
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  }
  fromArray(t, e = 0) {
    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
  }
  fromBufferAttribute(t, e) {
    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
};
h(Tb, "Quaternion");
let va = Tb;
const Jd = class Jd {
  constructor(t = 0, e = 0, s = 0) {
    Jd.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = s;
  }
  set(t, e, s) {
    return s === void 0 && (s = this.z), this.x = t, this.y = e, this.z = s, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  multiplyVectors(t, e) {
    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
  }
  applyEuler(t) {
    return this.applyQuaternion(Uw.setFromEuler(t));
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(Uw.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x, s = this.y, i = this.z, o = t.elements;
    return this.x = o[0] * e + o[3] * s + o[6] * i, this.y = o[1] * e + o[4] * s + o[7] * i, this.z = o[2] * e + o[5] * s + o[8] * i, this;
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x, s = this.y, i = this.z, o = t.elements, r = 1 / (o[3] * e + o[7] * s + o[11] * i + o[15]);
    return this.x = (o[0] * e + o[4] * s + o[8] * i + o[12]) * r, this.y = (o[1] * e + o[5] * s + o[9] * i + o[13]) * r, this.z = (o[2] * e + o[6] * s + o[10] * i + o[14]) * r, this;
  }
  applyQuaternion(t) {
    const e = this.x, s = this.y, i = this.z, o = t.x, r = t.y, a = t.z, l = t.w, c = 2 * (r * i - a * s), u = 2 * (a * e - o * i), m = 2 * (o * s - r * e);
    return this.x = e + l * c + r * m - a * u, this.y = s + l * u + a * c - o * m, this.z = i + l * m + o * u - r * c, this;
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
  }
  transformDirection(t) {
    const e = this.x, s = this.y, i = this.z, o = t.elements;
    return this.x = o[0] * e + o[4] * s + o[8] * i, this.y = o[1] * e + o[5] * s + o[9] * i, this.z = o[2] * e + o[6] * s + o[10] * i, this.normalize();
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  }
  clamp(t, e) {
    return this.x = Oe(this.x, t.x, e.x), this.y = Oe(this.y, t.y, e.y), this.z = Oe(this.z, t.z, e.z), this;
  }
  clampScalar(t, e) {
    return this.x = Oe(this.x, t, e), this.y = Oe(this.y, t, e), this.z = Oe(this.z, t, e), this;
  }
  clampLength(t, e) {
    const s = this.length();
    return this.divideScalar(s || 1).multiplyScalar(Oe(s, t, e));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
  }
  lerpVectors(t, e, s) {
    return this.x = t.x + (e.x - t.x) * s, this.y = t.y + (e.y - t.y) * s, this.z = t.z + (e.z - t.z) * s, this;
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const s = t.x, i = t.y, o = t.z, r = e.x, a = e.y, l = e.z;
    return this.x = i * l - o * a, this.y = o * r - s * l, this.z = s * a - i * r, this;
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (e === 0) return this.set(0, 0, 0);
    const s = t.dot(this) / e;
    return this.copy(t).multiplyScalar(s);
  }
  projectOnPlane(t) {
    return Mf.copy(this).projectOnVector(t), this.sub(Mf);
  }
  reflect(t) {
    return this.sub(Mf.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0) return Math.PI / 2;
    const s = this.dot(t) / e;
    return Math.acos(Oe(s, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, s = this.y - t.y, i = this.z - t.z;
    return e * e + s * s + i * i;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, s) {
    const i = Math.sin(e) * t;
    return this.x = i * Math.sin(s), this.y = Math.cos(e) * t, this.z = i * Math.cos(s), this;
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, s) {
    return this.x = t * Math.sin(e), this.y = s, this.z = t * Math.cos(e), this;
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(), s = this.setFromMatrixColumn(t, 1).length(), i = this.setFromMatrixColumn(t, 2).length();
    return this.x = e, this.y = s, this.z = i, this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3);
  }
  setFromEuler(t) {
    return this.x = t._x, this.y = t._y, this.z = t._z, this;
  }
  setFromColor(t) {
    return this.x = t.r, this.y = t.g, this.z = t.b, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const t = Math.random() * Math.PI * 2, e = Math.random() * 2 - 1, s = Math.sqrt(1 - e * e);
    return this.x = s * Math.cos(t), this.y = e, this.z = s * Math.sin(t), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
};
h(Jd, "Vector3");
let O = Jd;
const Mf = new O(), Uw = new va(), Kd = class Kd {
  constructor(t, e, s, i, o, r, a, l, c) {
    Kd.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], t !== void 0 && this.set(t, e, s, i, o, r, a, l, c);
  }
  set(t, e, s, i, o, r, a, l, c) {
    const u = this.elements;
    return u[0] = t, u[1] = i, u[2] = a, u[3] = e, u[4] = o, u[5] = l, u[6] = s, u[7] = r, u[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(t) {
    const e = this.elements, s = t.elements;
    return e[0] = s[0], e[1] = s[1], e[2] = s[2], e[3] = s[3], e[4] = s[4], e[5] = s[5], e[6] = s[6], e[7] = s[7], e[8] = s[8], this;
  }
  extractBasis(t, e, s) {
    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), s.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return this.set(
      e[0],
      e[4],
      e[8],
      e[1],
      e[5],
      e[9],
      e[2],
      e[6],
      e[10]
    ), this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const s = t.elements, i = e.elements, o = this.elements, r = s[0], a = s[3], l = s[6], c = s[1], u = s[4], m = s[7], d = s[2], f = s[5], p = s[8], v = i[0], _ = i[3], g = i[6], w = i[1], S = i[4], x = i[7], A = i[2], C = i[5], M = i[8];
    return o[0] = r * v + a * w + l * A, o[3] = r * _ + a * S + l * C, o[6] = r * g + a * x + l * M, o[1] = c * v + u * w + m * A, o[4] = c * _ + u * S + m * C, o[7] = c * g + u * x + m * M, o[2] = d * v + f * w + p * A, o[5] = d * _ + f * S + p * C, o[8] = d * g + f * x + p * M, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], s = t[1], i = t[2], o = t[3], r = t[4], a = t[5], l = t[6], c = t[7], u = t[8];
    return e * r * u - e * a * c - s * o * u + s * a * l + i * o * c - i * r * l;
  }
  invert() {
    const t = this.elements, e = t[0], s = t[1], i = t[2], o = t[3], r = t[4], a = t[5], l = t[6], c = t[7], u = t[8], m = u * r - a * c, d = a * l - u * o, f = c * o - r * l, p = e * m + s * d + i * f;
    if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / p;
    return t[0] = m * v, t[1] = (i * c - u * s) * v, t[2] = (a * s - i * r) * v, t[3] = d * v, t[4] = (u * e - i * l) * v, t[5] = (i * o - a * e) * v, t[6] = f * v, t[7] = (s * l - c * e) * v, t[8] = (r * e - s * o) * v, this;
  }
  transpose() {
    let t;
    const e = this.elements;
    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
  }
  setUvTransform(t, e, s, i, o, r, a) {
    const l = Math.cos(o), c = Math.sin(o);
    return this.set(
      s * l,
      s * c,
      -s * (l * r + c * a) + r + t,
      -i * c,
      i * l,
      -i * (-c * r + l * a) + a + e,
      0,
      0,
      1
    ), this;
  }
  scale(t, e) {
    return this.premultiply(Cf.makeScale(t, e)), this;
  }
  rotate(t) {
    return this.premultiply(Cf.makeRotation(-t)), this;
  }
  translate(t, e) {
    return this.premultiply(Cf.makeTranslation(t, e)), this;
  }
  makeTranslation(t, e) {
    return t.isVector2 ? this.set(
      1,
      0,
      t.x,
      0,
      1,
      t.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      t,
      0,
      1,
      e,
      0,
      0,
      1
    ), this;
  }
  makeRotation(t) {
    const e = Math.cos(t), s = Math.sin(t);
    return this.set(
      e,
      -s,
      0,
      s,
      e,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(t, e) {
    return this.set(
      t,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      1
    ), this;
  }
  equals(t) {
    const e = this.elements, s = t.elements;
    for (let i = 0; i < 9; i++)
      if (e[i] !== s[i]) return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let s = 0; s < 9; s++)
      this.elements[s] = t[s + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const s = this.elements;
    return t[e] = s[0], t[e + 1] = s[1], t[e + 2] = s[2], t[e + 3] = s[3], t[e + 4] = s[4], t[e + 5] = s[5], t[e + 6] = s[6], t[e + 7] = s[7], t[e + 8] = s[8], t;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
h(Kd, "Matrix3");
let Ae = Kd;
const Cf = new Ae();
function j3(n) {
  for (let t = n.length - 1; t >= 0; --t)
    if (n[t] >= 65535) return !0;
  return !1;
}
h(j3, "arrayNeedsUint32");
function hd(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
h(hd, "createElementNS");
function ik() {
  const n = hd("canvas");
  return n.style.display = "block", n;
}
h(ik, "createCanvasElement");
const Ow = {};
function cu(n) {
  n in Ow || (Ow[n] = !0, console.warn(n));
}
h(cu, "warnOnce");
function sk(n, t, e) {
  return new Promise(function(s, i) {
    function o() {
      switch (n.clientWaitSync(t, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          i();
          break;
        case n.TIMEOUT_EXPIRED:
          setTimeout(o, e);
          break;
        default:
          s();
      }
    }
    h(o, "probe"), setTimeout(o, e);
  });
}
h(sk, "probeAsync");
const $w = new Ae().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), Fw = new Ae().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function ok() {
  const n = {
    enabled: !0,
    workingColorSpace: Oc,
    spaces: {},
    convert: /* @__PURE__ */ h(function(i, o, r) {
      return this.enabled === !1 || o === r || !o || !r || (this.spaces[o].transfer === pn && (i.r = Lo(i.r), i.g = Lo(i.g), i.b = Lo(i.b)), this.spaces[o].primaries !== this.spaces[r].primaries && (i.applyMatrix3(this.spaces[o].toXYZ), i.applyMatrix3(this.spaces[r].fromXYZ)), this.spaces[r].transfer === pn && (i.r = Sc(i.r), i.g = Sc(i.g), i.b = Sc(i.b))), i;
    }, "convert"),
    workingToColorSpace: /* @__PURE__ */ h(function(i, o) {
      return this.convert(i, this.workingColorSpace, o);
    }, "workingToColorSpace"),
    colorSpaceToWorking: /* @__PURE__ */ h(function(i, o) {
      return this.convert(i, o, this.workingColorSpace);
    }, "colorSpaceToWorking"),
    getPrimaries: /* @__PURE__ */ h(function(i) {
      return this.spaces[i].primaries;
    }, "getPrimaries"),
    getTransfer: /* @__PURE__ */ h(function(i) {
      return i === rr ? ld : this.spaces[i].transfer;
    }, "getTransfer"),
    getToneMappingMode: /* @__PURE__ */ h(function(i) {
      return this.spaces[i].outputColorSpaceConfig.toneMappingMode || "standard";
    }, "getToneMappingMode"),
    getLuminanceCoefficients: /* @__PURE__ */ h(function(i, o = this.workingColorSpace) {
      return i.fromArray(this.spaces[o].luminanceCoefficients);
    }, "getLuminanceCoefficients"),
    define: /* @__PURE__ */ h(function(i) {
      Object.assign(this.spaces, i);
    }, "define"),
    _getMatrix: /* @__PURE__ */ h(function(i, o, r) {
      return i.copy(this.spaces[o].toXYZ).multiply(this.spaces[r].fromXYZ);
    }, "_getMatrix"),
    _getDrawingBufferColorSpace: /* @__PURE__ */ h(function(i) {
      return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace;
    }, "_getDrawingBufferColorSpace"),
    _getUnpackColorSpace: /* @__PURE__ */ h(function(i = this.workingColorSpace) {
      return this.spaces[i].workingColorSpaceConfig.unpackColorSpace;
    }, "_getUnpackColorSpace"),
    fromWorkingColorSpace: /* @__PURE__ */ h(function(i, o) {
      return cu("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), n.workingToColorSpace(i, o);
    }, "fromWorkingColorSpace"),
    toWorkingColorSpace: /* @__PURE__ */ h(function(i, o) {
      return cu("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), n.colorSpaceToWorking(i, o);
    }, "toWorkingColorSpace")
  }, t = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], e = [0.2126, 0.7152, 0.0722], s = [0.3127, 0.329];
  return n.define({
    [Oc]: {
      primaries: t,
      whitePoint: s,
      transfer: ld,
      toXYZ: $w,
      fromXYZ: Fw,
      luminanceCoefficients: e,
      workingColorSpaceConfig: { unpackColorSpace: rs },
      outputColorSpaceConfig: { drawingBufferColorSpace: rs }
    },
    [rs]: {
      primaries: t,
      whitePoint: s,
      transfer: pn,
      toXYZ: $w,
      fromXYZ: Fw,
      luminanceCoefficients: e,
      outputColorSpaceConfig: { drawingBufferColorSpace: rs }
    }
  }), n;
}
h(ok, "createColorManagement");
const Qe = ok();
function Lo(n) {
  return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
h(Lo, "SRGBToLinear");
function Sc(n) {
  return n < 31308e-7 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
h(Sc, "LinearToSRGB");
let qa;
const Ib = class Ib {
  static getDataURL(t, e = "image/png") {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement == "undefined")
      return t.src;
    let s;
    if (t instanceof HTMLCanvasElement)
      s = t;
    else {
      qa === void 0 && (qa = hd("canvas")), qa.width = t.width, qa.height = t.height;
      const i = qa.getContext("2d");
      t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), s = qa;
    }
    return s.toDataURL(e);
  }
  static sRGBToLinear(t) {
    if (typeof HTMLImageElement != "undefined" && t instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && t instanceof ImageBitmap) {
      const e = hd("canvas");
      e.width = t.width, e.height = t.height;
      const s = e.getContext("2d");
      s.drawImage(t, 0, 0, t.width, t.height);
      const i = s.getImageData(0, 0, t.width, t.height), o = i.data;
      for (let r = 0; r < o.length; r++)
        o[r] = Lo(o[r] / 255) * 255;
      return s.putImageData(i, 0, 0), e;
    } else if (t.data) {
      const e = t.data.slice(0);
      for (let s = 0; s < e.length; s++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[s] = Math.floor(Lo(e[s] / 255) * 255) : e[s] = Lo(e[s]);
      return {
        data: e,
        width: t.width,
        height: t.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
  }
};
h(Ib, "ImageUtils");
let T_ = Ib, rk = 0;
const Bb = class Bb {
  constructor(t = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: rk++ }), this.uuid = il(), this.data = t, this.dataReady = !0, this.version = 0;
  }
  getSize(t) {
    const e = this.data;
    return typeof HTMLVideoElement != "undefined" && e instanceof HTMLVideoElement ? t.set(e.videoWidth, e.videoHeight, 0) : e instanceof VideoFrame ? t.set(e.displayHeight, e.displayWidth, 0) : e !== null ? t.set(e.width, e.height, e.depth || 0) : t.set(0, 0, 0), t;
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.images[this.uuid] !== void 0)
      return t.images[this.uuid];
    const s = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let r = 0, a = i.length; r < a; r++)
          i[r].isDataTexture ? o.push(Ef(i[r].image)) : o.push(Ef(i[r]));
      } else
        o = Ef(i);
      s.url = o;
    }
    return e || (t.images[this.uuid] = s), s;
  }
};
h(Bb, "Source");
let lu = Bb;
function Ef(n) {
  return typeof HTMLImageElement != "undefined" && n instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && n instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && n instanceof ImageBitmap ? T_.getDataURL(n) : n.data ? {
    data: Array.from(n.data),
    width: n.width,
    height: n.height,
    type: n.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
h(Ef, "serializeImage");
let ak = 0;
const Tf = new O(), bc = class bc extends xr {
  constructor(t = bc.DEFAULT_IMAGE, e = bc.DEFAULT_MAPPING, s = oa, i = oa, o = $s, r = ra, a = Ms, l = Xs, c = bc.DEFAULT_ANISOTROPY, u = rr) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: ak++ }), this.uuid = il(), this.name = "", this.source = new lu(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = s, this.wrapT = i, this.magFilter = o, this.minFilter = r, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Pe(0, 0), this.repeat = new Pe(1, 1), this.center = new Pe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ae(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!(t && t.depth && t.depth > 1), this.pmremVersion = 0;
  }
  get width() {
    return this.source.getSize(Tf).x;
  }
  get height() {
    return this.source.getSize(Tf).y;
  }
  get depth() {
    return this.source.getSize(Tf).z;
  }
  get image() {
    return this.source.data;
  }
  set image(t = null) {
    this.source.data = t;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.renderTarget = t.renderTarget, this.isRenderTargetTexture = t.isRenderTargetTexture, this.isArrayTexture = t.isArrayTexture, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this;
  }
  setValues(t) {
    for (const e in t) {
      const s = t[e];
      if (s === void 0) {
        console.warn(`THREE.Texture.setValues(): parameter '${e}' has value of undefined.`);
        continue;
      }
      const i = this[e];
      if (i === void 0) {
        console.warn(`THREE.Texture.setValues(): property '${e}' does not exist.`);
        continue;
      }
      i && s && i.isVector2 && s.isVector2 || i && s && i.isVector3 && s.isVector3 || i && s && i.isMatrix3 && s.isMatrix3 ? i.copy(s) : this[e] = s;
    }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0)
      return t.textures[this.uuid];
    const s = {
      metadata: {
        version: 4.7,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(t).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (s.userData = this.userData), e || (t.textures[this.uuid] = s), s;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(t) {
    if (this.mapping !== V3) return t;
    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1)
      switch (this.wrapS) {
        case Kp:
          t.x = t.x - Math.floor(t.x);
          break;
        case oa:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case Qp:
          Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case Kp:
          t.y = t.y - Math.floor(t.y);
          break;
        case oa:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case Qp:
          Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
  set needsUpdate(t) {
    t === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(t) {
    t === !0 && this.pmremVersion++;
  }
};
h(bc, "Texture");
let fs = bc;
fs.DEFAULT_IMAGE = null;
fs.DEFAULT_MAPPING = V3;
fs.DEFAULT_ANISOTROPY = 1;
const Qd = class Qd {
  constructor(t = 0, e = 0, s = 0, i = 1) {
    Qd.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = s, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, s, i) {
    return this.x = t, this.y = e, this.z = s, this.w = i, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this.w = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setW(t) {
    return this.w = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this.w += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  applyMatrix4(t) {
    const e = this.x, s = this.y, i = this.z, o = this.w, r = t.elements;
    return this.x = r[0] * e + r[4] * s + r[8] * i + r[12] * o, this.y = r[1] * e + r[5] * s + r[9] * i + r[13] * o, this.z = r[2] * e + r[6] * s + r[10] * i + r[14] * o, this.w = r[3] * e + r[7] * s + r[11] * i + r[15] * o, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this.w /= t.w, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, s, i, o;
    const l = t.elements, c = l[0], u = l[4], m = l[8], d = l[1], f = l[5], p = l[9], v = l[2], _ = l[6], g = l[10];
    if (Math.abs(u - d) < 0.01 && Math.abs(m - v) < 0.01 && Math.abs(p - _) < 0.01) {
      if (Math.abs(u + d) < 0.1 && Math.abs(m + v) < 0.1 && Math.abs(p + _) < 0.1 && Math.abs(c + f + g - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const S = (c + 1) / 2, x = (f + 1) / 2, A = (g + 1) / 2, C = (u + d) / 4, M = (m + v) / 4, T = (p + _) / 4;
      return S > x && S > A ? S < 0.01 ? (s = 0, i = 0.707106781, o = 0.707106781) : (s = Math.sqrt(S), i = C / s, o = M / s) : x > A ? x < 0.01 ? (s = 0.707106781, i = 0, o = 0.707106781) : (i = Math.sqrt(x), s = C / i, o = T / i) : A < 0.01 ? (s = 0.707106781, i = 0.707106781, o = 0) : (o = Math.sqrt(A), s = M / o, i = T / o), this.set(s, i, o, e), this;
    }
    let w = Math.sqrt((_ - p) * (_ - p) + (m - v) * (m - v) + (d - u) * (d - u));
    return Math.abs(w) < 1e-3 && (w = 1), this.x = (_ - p) / w, this.y = (m - v) / w, this.z = (d - u) / w, this.w = Math.acos((c + f + g - 1) / 2), this;
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this.w = e[15], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
  }
  clamp(t, e) {
    return this.x = Oe(this.x, t.x, e.x), this.y = Oe(this.y, t.y, e.y), this.z = Oe(this.z, t.z, e.z), this.w = Oe(this.w, t.w, e.w), this;
  }
  clampScalar(t, e) {
    return this.x = Oe(this.x, t, e), this.y = Oe(this.y, t, e), this.z = Oe(this.z, t, e), this.w = Oe(this.w, t, e), this;
  }
  clampLength(t, e) {
    const s = this.length();
    return this.divideScalar(s || 1).multiplyScalar(Oe(s, t, e));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
  }
  lerpVectors(t, e, s) {
    return this.x = t.x + (e.x - t.x) * s, this.y = t.y + (e.y - t.y) * s, this.z = t.z + (e.z - t.z) * s, this.w = t.w + (e.w - t.w) * s, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
};
h(Qd, "Vector4");
let an = Qd;
const Pb = class Pb extends xr {
  constructor(t = 1, e = 1, s = {}) {
    super(), s = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: $s,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1,
      depth: 1,
      multiview: !1
    }, s), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = s.depth, this.scissor = new an(0, 0, t, e), this.scissorTest = !1, this.viewport = new an(0, 0, t, e);
    const i = { width: t, height: e, depth: s.depth }, o = new fs(i);
    this.textures = [];
    const r = s.count;
    for (let a = 0; a < r; a++)
      this.textures[a] = o.clone(), this.textures[a].isRenderTargetTexture = !0, this.textures[a].renderTarget = this;
    this._setTextureOptions(s), this.depthBuffer = s.depthBuffer, this.stencilBuffer = s.stencilBuffer, this.resolveDepthBuffer = s.resolveDepthBuffer, this.resolveStencilBuffer = s.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = s.depthTexture, this.samples = s.samples, this.multiview = s.multiview;
  }
  _setTextureOptions(t = {}) {
    const e = {
      minFilter: $s,
      generateMipmaps: !1,
      flipY: !1,
      internalFormat: null
    };
    t.mapping !== void 0 && (e.mapping = t.mapping), t.wrapS !== void 0 && (e.wrapS = t.wrapS), t.wrapT !== void 0 && (e.wrapT = t.wrapT), t.wrapR !== void 0 && (e.wrapR = t.wrapR), t.magFilter !== void 0 && (e.magFilter = t.magFilter), t.minFilter !== void 0 && (e.minFilter = t.minFilter), t.format !== void 0 && (e.format = t.format), t.type !== void 0 && (e.type = t.type), t.anisotropy !== void 0 && (e.anisotropy = t.anisotropy), t.colorSpace !== void 0 && (e.colorSpace = t.colorSpace), t.flipY !== void 0 && (e.flipY = t.flipY), t.generateMipmaps !== void 0 && (e.generateMipmaps = t.generateMipmaps), t.internalFormat !== void 0 && (e.internalFormat = t.internalFormat);
    for (let s = 0; s < this.textures.length; s++)
      this.textures[s].setValues(e);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(t) {
    this.textures[0] = t;
  }
  set depthTexture(t) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null), t !== null && (t.renderTarget = this), this._depthTexture = t;
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(t, e, s = 1) {
    if (this.width !== t || this.height !== e || this.depth !== s) {
      this.width = t, this.height = e, this.depth = s;
      for (let i = 0, o = this.textures.length; i < o; i++)
        this.textures[i].image.width = t, this.textures[i].image.height = e, this.textures[i].image.depth = s, this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
      this.dispose();
    }
    this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
    for (let e = 0, s = t.textures.length; e < s; e++) {
      this.textures[e] = t.textures[e].clone(), this.textures[e].isRenderTargetTexture = !0, this.textures[e].renderTarget = this;
      const i = Object.assign({}, t.textures[e].image);
      this.textures[e].source = new lu(i);
    }
    return this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
h(Pb, "RenderTarget");
let I_ = Pb;
const Rb = class Rb extends I_ {
  constructor(t = 1, e = 1, s = {}) {
    super(t, e, s), this.isWebGLRenderTarget = !0;
  }
};
h(Rb, "WebGLRenderTarget");
let Oo = Rb;
const Db = class Db extends fs {
  constructor(t = null, e = 1, s = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: t, width: e, height: s, depth: i }, this.magFilter = Ts, this.minFilter = Ts, this.wrapR = oa, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(t) {
    this.layerUpdates.add(t);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
};
h(Db, "DataArrayTexture");
let dd = Db;
const Vb = class Vb extends fs {
  constructor(t = null, e = 1, s = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: t, width: e, height: s, depth: i }, this.magFilter = Ts, this.minFilter = Ts, this.wrapR = oa, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
};
h(Vb, "Data3DTexture");
let B_ = Vb;
const Lb = class Lb {
  constructor(t = new O(1 / 0, 1 / 0, 1 / 0), e = new O(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = t, this.max = e;
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromArray(t) {
    this.makeEmpty();
    for (let e = 0, s = t.length; e < s; e += 3)
      this.expandByPoint(gs.fromArray(t, e));
    return this;
  }
  setFromBufferAttribute(t) {
    this.makeEmpty();
    for (let e = 0, s = t.count; e < s; e++)
      this.expandByPoint(gs.fromBufferAttribute(t, e));
    return this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, s = t.length; e < s; e++)
      this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const s = gs.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(s), this.max.copy(t).add(s), this;
  }
  setFromObject(t, e = !1) {
    return this.makeEmpty(), this.expandByObject(t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t, e = !1) {
    t.updateWorldMatrix(!1, !1);
    const s = t.geometry;
    if (s !== void 0) {
      const o = s.getAttribute("position");
      if (e === !0 && o !== void 0 && t.isInstancedMesh !== !0)
        for (let r = 0, a = o.count; r < a; r++)
          t.isMesh === !0 ? t.getVertexPosition(r, gs) : gs.fromBufferAttribute(o, r), gs.applyMatrix4(t.matrixWorld), this.expandByPoint(gs);
      else
        t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), rh.copy(t.boundingBox)) : (s.boundingBox === null && s.computeBoundingBox(), rh.copy(s.boundingBox)), rh.applyMatrix4(t.matrixWorld), this.union(rh);
    }
    const i = t.children;
    for (let o = 0, r = i.length; o < r; o++)
      this.expandByObject(i[o], e);
    return this;
  }
  containsPoint(t) {
    return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z;
  }
  containsBox(t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(t) {
    return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z;
  }
  intersectsSphere(t) {
    return this.clampPoint(t.center, gs), gs.distanceToSquared(t.center) <= t.radius * t.radius;
  }
  intersectsPlane(t) {
    let e, s;
    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, s = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, s = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, s += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, s += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, s += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, s += t.normal.z * this.min.z), e <= -t.constant && s >= -t.constant;
  }
  intersectsTriangle(t) {
    if (this.isEmpty())
      return !1;
    this.getCenter(ul), ah.subVectors(this.max, ul), Xa.subVectors(t.a, ul), Za.subVectors(t.b, ul), Ya.subVectors(t.c, ul), qo.subVectors(Za, Xa), Xo.subVectors(Ya, Za), Rr.subVectors(Xa, Ya);
    let e = [
      0,
      -qo.z,
      qo.y,
      0,
      -Xo.z,
      Xo.y,
      0,
      -Rr.z,
      Rr.y,
      qo.z,
      0,
      -qo.x,
      Xo.z,
      0,
      -Xo.x,
      Rr.z,
      0,
      -Rr.x,
      -qo.y,
      qo.x,
      0,
      -Xo.y,
      Xo.x,
      0,
      -Rr.y,
      Rr.x,
      0
    ];
    return !If(e, Xa, Za, Ya, ah) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !If(e, Xa, Za, Ya, ah)) ? !1 : (ch.crossVectors(qo, Xo), e = [ch.x, ch.y, ch.z], If(e, Xa, Za, Ya, ah));
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return this.clampPoint(t, gs).distanceTo(t);
  }
  getBoundingSphere(t) {
    return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(gs).length() * 0.5), t;
  }
  intersect(t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return this.isEmpty() ? this : (ho[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), ho[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), ho[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), ho[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), ho[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), ho[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), ho[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), ho[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(ho), this);
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
  toJSON() {
    return {
      min: this.min.toArray(),
      max: this.max.toArray()
    };
  }
  fromJSON(t) {
    return this.min.fromArray(t.min), this.max.fromArray(t.max), this;
  }
};
h(Lb, "Box3");
let Zs = Lb;
const ho = [
  new O(),
  new O(),
  new O(),
  new O(),
  new O(),
  new O(),
  new O(),
  new O()
], gs = new O(), rh = new Zs(), Xa = new O(), Za = new O(), Ya = new O(), qo = new O(), Xo = new O(), Rr = new O(), ul = new O(), ah = new O(), ch = new O(), Dr = new O();
function If(n, t, e, s, i) {
  for (let o = 0, r = n.length - 3; o <= r; o += 3) {
    Dr.fromArray(n, o);
    const a = i.x * Math.abs(Dr.x) + i.y * Math.abs(Dr.y) + i.z * Math.abs(Dr.z), l = t.dot(Dr), c = e.dot(Dr), u = s.dot(Dr);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a)
      return !1;
  }
  return !0;
}
h(If, "satForAxes");
const ck = new Zs(), hl = new O(), Bf = new O(), Nb = class Nb {
  constructor(t = new O(), e = -1) {
    this.isSphere = !0, this.center = t, this.radius = e;
  }
  set(t, e) {
    return this.center.copy(t), this.radius = e, this;
  }
  setFromPoints(t, e) {
    const s = this.center;
    e !== void 0 ? s.copy(e) : ck.setFromPoints(t).getCenter(s);
    let i = 0;
    for (let o = 0, r = t.length; o < r; o++)
      i = Math.max(i, s.distanceToSquared(t[o]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(t) {
    return this.center.copy(t.center), this.radius = t.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, e) {
    const s = this.center.distanceToSquared(t);
    return e.copy(t), s > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  }
  getBoundingBox(t) {
    return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  }
  applyMatrix4(t) {
    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
  }
  translate(t) {
    return this.center.add(t), this;
  }
  expandByPoint(t) {
    if (this.isEmpty())
      return this.center.copy(t), this.radius = 0, this;
    hl.subVectors(t, this.center);
    const e = hl.lengthSq();
    if (e > this.radius * this.radius) {
      const s = Math.sqrt(e), i = (s - this.radius) * 0.5;
      this.center.addScaledVector(hl, i / s), this.radius += i;
    }
    return this;
  }
  union(t) {
    return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (Bf.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(hl.copy(t.center).add(Bf)), this.expandByPoint(hl.copy(t.center).sub(Bf))), this);
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    return {
      radius: this.radius,
      center: this.center.toArray()
    };
  }
  fromJSON(t) {
    return this.radius = t.radius, this.center.fromArray(t.center), this;
  }
};
h(Nb, "Sphere");
let Ys = Nb;
const mo = new O(), Pf = new O(), lh = new O(), Zo = new O(), Rf = new O(), uh = new O(), Df = new O(), zb = class zb {
  constructor(t = new O(), e = new O(0, 0, -1)) {
    this.origin = t, this.direction = e;
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, e) {
    return e.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, mo)), this;
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin);
    const s = e.dot(this.direction);
    return s < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, s);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    const e = mo.subVectors(t, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(t) : (mo.copy(this.origin).addScaledVector(this.direction, e), mo.distanceToSquared(t));
  }
  distanceSqToSegment(t, e, s, i) {
    Pf.copy(t).add(e).multiplyScalar(0.5), lh.copy(e).sub(t).normalize(), Zo.copy(this.origin).sub(Pf);
    const o = t.distanceTo(e) * 0.5, r = -this.direction.dot(lh), a = Zo.dot(this.direction), l = -Zo.dot(lh), c = Zo.lengthSq(), u = Math.abs(1 - r * r);
    let m, d, f, p;
    if (u > 0)
      if (m = r * l - a, d = r * a - l, p = o * u, m >= 0)
        if (d >= -p)
          if (d <= p) {
            const v = 1 / u;
            m *= v, d *= v, f = m * (m + r * d + 2 * a) + d * (r * m + d + 2 * l) + c;
          } else
            d = o, m = Math.max(0, -(r * d + a)), f = -m * m + d * (d + 2 * l) + c;
        else
          d = -o, m = Math.max(0, -(r * d + a)), f = -m * m + d * (d + 2 * l) + c;
      else
        d <= -p ? (m = Math.max(0, -(-r * o + a)), d = m > 0 ? -o : Math.min(Math.max(-o, -l), o), f = -m * m + d * (d + 2 * l) + c) : d <= p ? (m = 0, d = Math.min(Math.max(-o, -l), o), f = d * (d + 2 * l) + c) : (m = Math.max(0, -(r * o + a)), d = m > 0 ? o : Math.min(Math.max(-o, -l), o), f = -m * m + d * (d + 2 * l) + c);
    else
      d = r > 0 ? -o : o, m = Math.max(0, -(r * d + a)), f = -m * m + d * (d + 2 * l) + c;
    return s && s.copy(this.origin).addScaledVector(this.direction, m), i && i.copy(Pf).addScaledVector(lh, d), f;
  }
  intersectSphere(t, e) {
    mo.subVectors(t.center, this.origin);
    const s = mo.dot(this.direction), i = mo.dot(mo) - s * s, o = t.radius * t.radius;
    if (i > o) return null;
    const r = Math.sqrt(o - i), a = s - r, l = s + r;
    return l < 0 ? null : a < 0 ? this.at(l, e) : this.at(a, e);
  }
  intersectsSphere(t) {
    return t.radius < 0 ? !1 : this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction);
    if (e === 0)
      return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    const s = -(this.origin.dot(t.normal) + t.constant) / e;
    return s >= 0 ? s : null;
  }
  intersectPlane(t, e) {
    const s = this.distanceToPlane(t);
    return s === null ? null : this.at(s, e);
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin);
    return e === 0 || t.normal.dot(this.direction) * e < 0;
  }
  intersectBox(t, e) {
    let s, i, o, r, a, l;
    const c = 1 / this.direction.x, u = 1 / this.direction.y, m = 1 / this.direction.z, d = this.origin;
    return c >= 0 ? (s = (t.min.x - d.x) * c, i = (t.max.x - d.x) * c) : (s = (t.max.x - d.x) * c, i = (t.min.x - d.x) * c), u >= 0 ? (o = (t.min.y - d.y) * u, r = (t.max.y - d.y) * u) : (o = (t.max.y - d.y) * u, r = (t.min.y - d.y) * u), s > r || o > i || ((o > s || isNaN(s)) && (s = o), (r < i || isNaN(i)) && (i = r), m >= 0 ? (a = (t.min.z - d.z) * m, l = (t.max.z - d.z) * m) : (a = (t.max.z - d.z) * m, l = (t.min.z - d.z) * m), s > l || a > i) || ((a > s || s !== s) && (s = a), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(s >= 0 ? s : i, e);
  }
  intersectsBox(t) {
    return this.intersectBox(t, mo) !== null;
  }
  intersectTriangle(t, e, s, i, o) {
    Rf.subVectors(e, t), uh.subVectors(s, t), Df.crossVectors(Rf, uh);
    let r = this.direction.dot(Df), a;
    if (r > 0) {
      if (i) return null;
      a = 1;
    } else if (r < 0)
      a = -1, r = -r;
    else
      return null;
    Zo.subVectors(this.origin, t);
    const l = a * this.direction.dot(uh.crossVectors(Zo, uh));
    if (l < 0)
      return null;
    const c = a * this.direction.dot(Rf.cross(Zo));
    if (c < 0 || l + c > r)
      return null;
    const u = -a * Zo.dot(Df);
    return u < 0 ? null : this.at(u / r, o);
  }
  applyMatrix4(t) {
    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
h(zb, "Ray");
let Fc = zb;
const Gl = class Gl {
  constructor(t, e, s, i, o, r, a, l, c, u, m, d, f, p, v, _) {
    Gl.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], t !== void 0 && this.set(t, e, s, i, o, r, a, l, c, u, m, d, f, p, v, _);
  }
  set(t, e, s, i, o, r, a, l, c, u, m, d, f, p, v, _) {
    const g = this.elements;
    return g[0] = t, g[4] = e, g[8] = s, g[12] = i, g[1] = o, g[5] = r, g[9] = a, g[13] = l, g[2] = c, g[6] = u, g[10] = m, g[14] = d, g[3] = f, g[7] = p, g[11] = v, g[15] = _, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Gl().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements, s = t.elements;
    return e[0] = s[0], e[1] = s[1], e[2] = s[2], e[3] = s[3], e[4] = s[4], e[5] = s[5], e[6] = s[6], e[7] = s[7], e[8] = s[8], e[9] = s[9], e[10] = s[10], e[11] = s[11], e[12] = s[12], e[13] = s[13], e[14] = s[14], e[15] = s[15], this;
  }
  copyPosition(t) {
    const e = this.elements, s = t.elements;
    return e[12] = s[12], e[13] = s[13], e[14] = s[14], this;
  }
  setFromMatrix3(t) {
    const e = t.elements;
    return this.set(
      e[0],
      e[3],
      e[6],
      0,
      e[1],
      e[4],
      e[7],
      0,
      e[2],
      e[5],
      e[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(t, e, s) {
    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), s.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(t, e, s) {
    return this.set(
      t.x,
      e.x,
      s.x,
      0,
      t.y,
      e.y,
      s.y,
      0,
      t.z,
      e.z,
      s.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(t) {
    const e = this.elements, s = t.elements, i = 1 / Ja.setFromMatrixColumn(t, 0).length(), o = 1 / Ja.setFromMatrixColumn(t, 1).length(), r = 1 / Ja.setFromMatrixColumn(t, 2).length();
    return e[0] = s[0] * i, e[1] = s[1] * i, e[2] = s[2] * i, e[3] = 0, e[4] = s[4] * o, e[5] = s[5] * o, e[6] = s[6] * o, e[7] = 0, e[8] = s[8] * r, e[9] = s[9] * r, e[10] = s[10] * r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromEuler(t) {
    const e = this.elements, s = t.x, i = t.y, o = t.z, r = Math.cos(s), a = Math.sin(s), l = Math.cos(i), c = Math.sin(i), u = Math.cos(o), m = Math.sin(o);
    if (t.order === "XYZ") {
      const d = r * u, f = r * m, p = a * u, v = a * m;
      e[0] = l * u, e[4] = -l * m, e[8] = c, e[1] = f + p * c, e[5] = d - v * c, e[9] = -a * l, e[2] = v - d * c, e[6] = p + f * c, e[10] = r * l;
    } else if (t.order === "YXZ") {
      const d = l * u, f = l * m, p = c * u, v = c * m;
      e[0] = d + v * a, e[4] = p * a - f, e[8] = r * c, e[1] = r * m, e[5] = r * u, e[9] = -a, e[2] = f * a - p, e[6] = v + d * a, e[10] = r * l;
    } else if (t.order === "ZXY") {
      const d = l * u, f = l * m, p = c * u, v = c * m;
      e[0] = d - v * a, e[4] = -r * m, e[8] = p + f * a, e[1] = f + p * a, e[5] = r * u, e[9] = v - d * a, e[2] = -r * c, e[6] = a, e[10] = r * l;
    } else if (t.order === "ZYX") {
      const d = r * u, f = r * m, p = a * u, v = a * m;
      e[0] = l * u, e[4] = p * c - f, e[8] = d * c + v, e[1] = l * m, e[5] = v * c + d, e[9] = f * c - p, e[2] = -c, e[6] = a * l, e[10] = r * l;
    } else if (t.order === "YZX") {
      const d = r * l, f = r * c, p = a * l, v = a * c;
      e[0] = l * u, e[4] = v - d * m, e[8] = p * m + f, e[1] = m, e[5] = r * u, e[9] = -a * u, e[2] = -c * u, e[6] = f * m + p, e[10] = d - v * m;
    } else if (t.order === "XZY") {
      const d = r * l, f = r * c, p = a * l, v = a * c;
      e[0] = l * u, e[4] = -m, e[8] = c * u, e[1] = d * m + v, e[5] = r * u, e[9] = f * m - p, e[2] = p * m - f, e[6] = a * u, e[10] = v * m + d;
    }
    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromQuaternion(t) {
    return this.compose(lk, t, uk);
  }
  lookAt(t, e, s) {
    const i = this.elements;
    return zi.subVectors(t, e), zi.lengthSq() === 0 && (zi.z = 1), zi.normalize(), Yo.crossVectors(s, zi), Yo.lengthSq() === 0 && (Math.abs(s.z) === 1 ? zi.x += 1e-4 : zi.z += 1e-4, zi.normalize(), Yo.crossVectors(s, zi)), Yo.normalize(), hh.crossVectors(zi, Yo), i[0] = Yo.x, i[4] = hh.x, i[8] = zi.x, i[1] = Yo.y, i[5] = hh.y, i[9] = zi.y, i[2] = Yo.z, i[6] = hh.z, i[10] = zi.z, this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const s = t.elements, i = e.elements, o = this.elements, r = s[0], a = s[4], l = s[8], c = s[12], u = s[1], m = s[5], d = s[9], f = s[13], p = s[2], v = s[6], _ = s[10], g = s[14], w = s[3], S = s[7], x = s[11], A = s[15], C = i[0], M = i[4], T = i[8], b = i[12], y = i[1], E = i[5], I = i[9], B = i[13], D = i[2], N = i[6], V = i[10], G = i[14], U = i[3], j = i[7], tt = i[11], K = i[15];
    return o[0] = r * C + a * y + l * D + c * U, o[4] = r * M + a * E + l * N + c * j, o[8] = r * T + a * I + l * V + c * tt, o[12] = r * b + a * B + l * G + c * K, o[1] = u * C + m * y + d * D + f * U, o[5] = u * M + m * E + d * N + f * j, o[9] = u * T + m * I + d * V + f * tt, o[13] = u * b + m * B + d * G + f * K, o[2] = p * C + v * y + _ * D + g * U, o[6] = p * M + v * E + _ * N + g * j, o[10] = p * T + v * I + _ * V + g * tt, o[14] = p * b + v * B + _ * G + g * K, o[3] = w * C + S * y + x * D + A * U, o[7] = w * M + S * E + x * N + A * j, o[11] = w * T + S * I + x * V + A * tt, o[15] = w * b + S * B + x * G + A * K, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], s = t[4], i = t[8], o = t[12], r = t[1], a = t[5], l = t[9], c = t[13], u = t[2], m = t[6], d = t[10], f = t[14], p = t[3], v = t[7], _ = t[11], g = t[15];
    return p * (+o * l * m - i * c * m - o * a * d + s * c * d + i * a * f - s * l * f) + v * (+e * l * f - e * c * d + o * r * d - i * r * f + i * c * u - o * l * u) + _ * (+e * c * m - e * a * f - o * r * m + s * r * f + o * a * u - s * c * u) + g * (-i * a * u - e * l * m + e * a * d + i * r * m - s * r * d + s * l * u);
  }
  transpose() {
    const t = this.elements;
    let e;
    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
  }
  setPosition(t, e, s) {
    const i = this.elements;
    return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = s), this;
  }
  invert() {
    const t = this.elements, e = t[0], s = t[1], i = t[2], o = t[3], r = t[4], a = t[5], l = t[6], c = t[7], u = t[8], m = t[9], d = t[10], f = t[11], p = t[12], v = t[13], _ = t[14], g = t[15], w = m * _ * c - v * d * c + v * l * f - a * _ * f - m * l * g + a * d * g, S = p * d * c - u * _ * c - p * l * f + r * _ * f + u * l * g - r * d * g, x = u * v * c - p * m * c + p * a * f - r * v * f - u * a * g + r * m * g, A = p * m * l - u * v * l - p * a * d + r * v * d + u * a * _ - r * m * _, C = e * w + s * S + i * x + o * A;
    if (C === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const M = 1 / C;
    return t[0] = w * M, t[1] = (v * d * o - m * _ * o - v * i * f + s * _ * f + m * i * g - s * d * g) * M, t[2] = (a * _ * o - v * l * o + v * i * c - s * _ * c - a * i * g + s * l * g) * M, t[3] = (m * l * o - a * d * o - m * i * c + s * d * c + a * i * f - s * l * f) * M, t[4] = S * M, t[5] = (u * _ * o - p * d * o + p * i * f - e * _ * f - u * i * g + e * d * g) * M, t[6] = (p * l * o - r * _ * o - p * i * c + e * _ * c + r * i * g - e * l * g) * M, t[7] = (r * d * o - u * l * o + u * i * c - e * d * c - r * i * f + e * l * f) * M, t[8] = x * M, t[9] = (p * m * o - u * v * o - p * s * f + e * v * f + u * s * g - e * m * g) * M, t[10] = (r * v * o - p * a * o + p * s * c - e * v * c - r * s * g + e * a * g) * M, t[11] = (u * a * o - r * m * o - u * s * c + e * m * c + r * s * f - e * a * f) * M, t[12] = A * M, t[13] = (u * v * i - p * m * i + p * s * d - e * v * d - u * s * _ + e * m * _) * M, t[14] = (p * a * i - r * v * i - p * s * l + e * v * l + r * s * _ - e * a * _) * M, t[15] = (r * m * i - u * a * i + u * s * l - e * m * l - r * s * d + e * a * d) * M, this;
  }
  scale(t) {
    const e = this.elements, s = t.x, i = t.y, o = t.z;
    return e[0] *= s, e[4] *= i, e[8] *= o, e[1] *= s, e[5] *= i, e[9] *= o, e[2] *= s, e[6] *= i, e[10] *= o, e[3] *= s, e[7] *= i, e[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], s = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, s, i));
  }
  makeTranslation(t, e, s) {
    return t.isVector3 ? this.set(
      1,
      0,
      0,
      t.x,
      0,
      1,
      0,
      t.y,
      0,
      0,
      1,
      t.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      t,
      0,
      1,
      0,
      e,
      0,
      0,
      1,
      s,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(t) {
    const e = Math.cos(t), s = Math.sin(t);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      e,
      -s,
      0,
      0,
      s,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t), s = Math.sin(t);
    return this.set(
      e,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t), s = Math.sin(t);
    return this.set(
      e,
      -s,
      0,
      0,
      s,
      e,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(t, e) {
    const s = Math.cos(e), i = Math.sin(e), o = 1 - s, r = t.x, a = t.y, l = t.z, c = o * r, u = o * a;
    return this.set(
      c * r + s,
      c * a - i * l,
      c * l + i * a,
      0,
      c * a + i * l,
      u * a + s,
      u * l - i * r,
      0,
      c * l - i * a,
      u * l + i * r,
      o * l * l + s,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(t, e, s) {
    return this.set(
      t,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      s,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(t, e, s, i, o, r) {
    return this.set(
      1,
      s,
      o,
      0,
      t,
      1,
      r,
      0,
      e,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(t, e, s) {
    const i = this.elements, o = e._x, r = e._y, a = e._z, l = e._w, c = o + o, u = r + r, m = a + a, d = o * c, f = o * u, p = o * m, v = r * u, _ = r * m, g = a * m, w = l * c, S = l * u, x = l * m, A = s.x, C = s.y, M = s.z;
    return i[0] = (1 - (v + g)) * A, i[1] = (f + x) * A, i[2] = (p - S) * A, i[3] = 0, i[4] = (f - x) * C, i[5] = (1 - (d + g)) * C, i[6] = (_ + w) * C, i[7] = 0, i[8] = (p + S) * M, i[9] = (_ - w) * M, i[10] = (1 - (d + v)) * M, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this;
  }
  decompose(t, e, s) {
    const i = this.elements;
    let o = Ja.set(i[0], i[1], i[2]).length();
    const r = Ja.set(i[4], i[5], i[6]).length(), a = Ja.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o), t.x = i[12], t.y = i[13], t.z = i[14], vs.copy(this);
    const c = 1 / o, u = 1 / r, m = 1 / a;
    return vs.elements[0] *= c, vs.elements[1] *= c, vs.elements[2] *= c, vs.elements[4] *= u, vs.elements[5] *= u, vs.elements[6] *= u, vs.elements[8] *= m, vs.elements[9] *= m, vs.elements[10] *= m, e.setFromRotationMatrix(vs), s.x = o, s.y = r, s.z = a, this;
  }
  makePerspective(t, e, s, i, o, r, a = Fs, l = !1) {
    const c = this.elements, u = 2 * o / (e - t), m = 2 * o / (s - i), d = (e + t) / (e - t), f = (s + i) / (s - i);
    let p, v;
    if (l)
      p = o / (r - o), v = r * o / (r - o);
    else if (a === Fs)
      p = -(r + o) / (r - o), v = -2 * r * o / (r - o);
    else if (a === ud)
      p = -r / (r - o), v = -r * o / (r - o);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
    return c[0] = u, c[4] = 0, c[8] = d, c[12] = 0, c[1] = 0, c[5] = m, c[9] = f, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = p, c[14] = v, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  makeOrthographic(t, e, s, i, o, r, a = Fs, l = !1) {
    const c = this.elements, u = 2 / (e - t), m = 2 / (s - i), d = -(e + t) / (e - t), f = -(s + i) / (s - i);
    let p, v;
    if (l)
      p = 1 / (r - o), v = r / (r - o);
    else if (a === Fs)
      p = -2 / (r - o), v = -(r + o) / (r - o);
    else if (a === ud)
      p = -1 / (r - o), v = -o / (r - o);
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
    return c[0] = u, c[4] = 0, c[8] = 0, c[12] = d, c[1] = 0, c[5] = m, c[9] = 0, c[13] = f, c[2] = 0, c[6] = 0, c[10] = p, c[14] = v, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  equals(t) {
    const e = this.elements, s = t.elements;
    for (let i = 0; i < 16; i++)
      if (e[i] !== s[i]) return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let s = 0; s < 16; s++)
      this.elements[s] = t[s + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const s = this.elements;
    return t[e] = s[0], t[e + 1] = s[1], t[e + 2] = s[2], t[e + 3] = s[3], t[e + 4] = s[4], t[e + 5] = s[5], t[e + 6] = s[6], t[e + 7] = s[7], t[e + 8] = s[8], t[e + 9] = s[9], t[e + 10] = s[10], t[e + 11] = s[11], t[e + 12] = s[12], t[e + 13] = s[13], t[e + 14] = s[14], t[e + 15] = s[15], t;
  }
};
h(Gl, "Matrix4");
let Re = Gl;
const Ja = new O(), vs = new Re(), lk = new O(0, 0, 0), uk = new O(1, 1, 1), Yo = new O(), hh = new O(), zi = new O(), Gw = new Re(), Hw = new va(), tm = class tm {
  constructor(t = 0, e = 0, s = 0, i = tm.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = t, this._y = e, this._z = s, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    this._order = t, this._onChangeCallback();
  }
  set(t, e, s, i = this._order) {
    return this._x = t, this._y = e, this._z = s, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t, e = this._order, s = !0) {
    const i = t.elements, o = i[0], r = i[4], a = i[8], l = i[1], c = i[5], u = i[9], m = i[2], d = i[6], f = i[10];
    switch (e) {
      case "XYZ":
        this._y = Math.asin(Oe(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-r, o)) : (this._x = Math.atan2(d, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Oe(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-m, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Oe(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-m, f), this._z = Math.atan2(-r, c)) : (this._y = 0, this._z = Math.atan2(l, o));
        break;
      case "ZYX":
        this._y = Math.asin(-Oe(m, -1, 1)), Math.abs(m) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, o)) : (this._x = 0, this._z = Math.atan2(-r, c));
        break;
      case "YZX":
        this._z = Math.asin(Oe(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-m, o)) : (this._x = 0, this._y = Math.atan2(a, f));
        break;
      case "XZY":
        this._z = Math.asin(-Oe(r, -1, 1)), Math.abs(r) < 0.9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, o)) : (this._x = Math.atan2(-u, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
    }
    return this._order = e, s === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, s) {
    return Gw.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Gw, e, s);
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return Hw.setFromEuler(this), this.setFromQuaternion(Hw, t);
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  }
  fromArray(t) {
    return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
};
h(tm, "Euler");
let Js = tm;
Js.DEFAULT_ORDER = "XYZ";
const kb = class kb {
  constructor() {
    this.mask = 1;
  }
  set(t) {
    this.mask = (1 << t | 0) >>> 0;
  }
  enable(t) {
    this.mask |= 1 << t | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t) {
    this.mask ^= 1 << t | 0;
  }
  disable(t) {
    this.mask &= ~(1 << t | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return (this.mask & t.mask) !== 0;
  }
  isEnabled(t) {
    return (this.mask & (1 << t | 0)) !== 0;
  }
};
h(kb, "Layers");
let md = kb, hk = 0;
const jw = new O(), Ka = new va(), fo = new Re(), dh = new O(), dl = new O(), dk = new O(), mk = new va(), Ww = new O(1, 0, 0), qw = new O(0, 1, 0), Xw = new O(0, 0, 1), Zw = { type: "added" }, fk = { type: "removed" }, Qa = { type: "childadded", child: null }, Vf = { type: "childremoved", child: null }, yc = class yc extends xr {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: hk++ }), this.uuid = il(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = yc.DEFAULT_UP.clone();
    const t = new O(), e = new Js(), s = new va(), i = new O(1, 1, 1);
    function o() {
      s.setFromEuler(e, !1);
    }
    h(o, "onRotationChange");
    function r() {
      e.setFromQuaternion(s, void 0, !1);
    }
    h(r, "onQuaternionChange"), e._onChange(o), s._onChange(r), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new Re()
      },
      normalMatrix: {
        value: new Ae()
      }
    }), this.matrix = new Re(), this.matrixWorld = new Re(), this.matrixAutoUpdate = yc.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = yc.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new md(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this;
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0);
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t);
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t);
  }
  rotateOnAxis(t, e) {
    return Ka.setFromAxisAngle(t, e), this.quaternion.multiply(Ka), this;
  }
  rotateOnWorldAxis(t, e) {
    return Ka.setFromAxisAngle(t, e), this.quaternion.premultiply(Ka), this;
  }
  rotateX(t) {
    return this.rotateOnAxis(Ww, t);
  }
  rotateY(t) {
    return this.rotateOnAxis(qw, t);
  }
  rotateZ(t) {
    return this.rotateOnAxis(Xw, t);
  }
  translateOnAxis(t, e) {
    return jw.copy(t).applyQuaternion(this.quaternion), this.position.add(jw.multiplyScalar(e)), this;
  }
  translateX(t) {
    return this.translateOnAxis(Ww, t);
  }
  translateY(t) {
    return this.translateOnAxis(qw, t);
  }
  translateZ(t) {
    return this.translateOnAxis(Xw, t);
  }
  localToWorld(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(fo.copy(this.matrixWorld).invert());
  }
  lookAt(t, e, s) {
    t.isVector3 ? dh.copy(t) : dh.set(t, e, s);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), dl.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? fo.lookAt(dl, dh, this.up) : fo.lookAt(dh, dl, this.up), this.quaternion.setFromRotationMatrix(fo), i && (fo.extractRotation(i.matrixWorld), Ka.setFromRotationMatrix(fo), this.quaternion.premultiply(Ka.invert()));
  }
  add(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++)
        this.add(arguments[e]);
      return this;
    }
    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(Zw), Qa.child = t, this.dispatchEvent(Qa), Qa.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let s = 0; s < arguments.length; s++)
        this.remove(arguments[s]);
      return this;
    }
    const e = this.children.indexOf(t);
    return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(fk), Vf.child = t, this.dispatchEvent(Vf), Vf.child = null), this;
  }
  removeFromParent() {
    const t = this.parent;
    return t !== null && t.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(t) {
    return this.updateWorldMatrix(!0, !1), fo.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), fo.multiply(t.parent.matrixWorld)), t.applyMatrix4(fo), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(!1, !0), t.dispatchEvent(Zw), Qa.child = t, this.dispatchEvent(Qa), Qa.child = null, this;
  }
  getObjectById(t) {
    return this.getObjectByProperty("id", t);
  }
  getObjectByName(t) {
    return this.getObjectByProperty("name", t);
  }
  getObjectByProperty(t, e) {
    if (this[t] === e) return this;
    for (let s = 0, i = this.children.length; s < i; s++) {
      const r = this.children[s].getObjectByProperty(t, e);
      if (r !== void 0)
        return r;
    }
  }
  getObjectsByProperty(t, e, s = []) {
    this[t] === e && s.push(this);
    const i = this.children;
    for (let o = 0, r = i.length; o < r; o++)
      i[o].getObjectsByProperty(t, e, s);
    return s;
  }
  getWorldPosition(t) {
    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(dl, t, dk), t;
  }
  getWorldScale(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(dl, mk, t), t;
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(t) {
    t(this);
    const e = this.children;
    for (let s = 0, i = e.length; s < i; s++)
      e[s].traverse(t);
  }
  traverseVisible(t) {
    if (this.visible === !1) return;
    t(this);
    const e = this.children;
    for (let s = 0, i = e.length; s < i; s++)
      e[s].traverseVisible(t);
  }
  traverseAncestors(t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, t = !0);
    const e = this.children;
    for (let s = 0, i = e.length; s < i; s++)
      e[s].updateMatrixWorld(t);
  }
  updateWorldMatrix(t, e) {
    const s = this.parent;
    if (t === !0 && s !== null && s.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), e === !0) {
      const i = this.children;
      for (let o = 0, r = i.length; o < r; o++)
        i[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string", s = {};
    e && (t = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, s.metadata = {
      version: 4.7,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.geometryInfo = this._geometryInfo.map((a) => ({
      ...a,
      boundingBox: a.boundingBox ? a.boundingBox.toJSON() : void 0,
      boundingSphere: a.boundingSphere ? a.boundingSphere.toJSON() : void 0
    })), i.instanceInfo = this._instanceInfo.map((a) => ({ ...a })), i.availableInstanceIds = this._availableInstanceIds.slice(), i.availableGeometryIds = this._availableGeometryIds.slice(), i.nextIndexStart = this._nextIndexStart, i.nextVertexStart = this._nextVertexStart, i.geometryCount = this._geometryCount, i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.matricesTexture = this._matricesTexture.toJSON(t), i.indirectTexture = this._indirectTexture.toJSON(t), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(t)), this.boundingSphere !== null && (i.boundingSphere = this.boundingSphere.toJSON()), this.boundingBox !== null && (i.boundingBox = this.boundingBox.toJSON()));
    function o(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(t)), l.uuid;
    }
    if (h(o, "serialize"), this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(t).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(t.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const m = l[c];
            o(t.shapes, m);
          }
        else
          o(t.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(o(t.materials, this.material[l]));
        i.material = a;
      } else
        i.material = o(t.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let a = 0; a < this.children.length; a++)
        i.children.push(this.children[a].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        i.animations.push(o(t.animations, l));
      }
    }
    if (e) {
      const a = r(t.geometries), l = r(t.materials), c = r(t.textures), u = r(t.images), m = r(t.shapes), d = r(t.skeletons), f = r(t.animations), p = r(t.nodes);
      a.length > 0 && (s.geometries = a), l.length > 0 && (s.materials = l), c.length > 0 && (s.textures = c), u.length > 0 && (s.images = u), m.length > 0 && (s.shapes = m), d.length > 0 && (s.skeletons = d), f.length > 0 && (s.animations = f), p.length > 0 && (s.nodes = p);
    }
    return s.object = i, s;
    function r(a) {
      const l = [];
      for (const c in a) {
        const u = a[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
    h(r, "extractFromCache");
  }
  clone(t) {
    return new this.constructor().copy(this, t);
  }
  copy(t, e = !0) {
    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
      for (let s = 0; s < t.children.length; s++) {
        const i = t.children[s];
        this.add(i.clone());
      }
    return this;
  }
};
h(yc, "Object3D");
let mi = yc;
mi.DEFAULT_UP = new O(0, 1, 0);
mi.DEFAULT_MATRIX_AUTO_UPDATE = !0;
mi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const bs = new O(), po = new O(), Lf = new O(), _o = new O(), tc = new O(), ec = new O(), Yw = new O(), Nf = new O(), zf = new O(), kf = new O(), Uf = new an(), Of = new an(), $f = new an(), sr = class sr {
  constructor(t = new O(), e = new O(), s = new O()) {
    this.a = t, this.b = e, this.c = s;
  }
  static getNormal(t, e, s, i) {
    i.subVectors(s, e), bs.subVectors(t, e), i.cross(bs);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  static getBarycoord(t, e, s, i, o) {
    bs.subVectors(i, e), po.subVectors(s, e), Lf.subVectors(t, e);
    const r = bs.dot(bs), a = bs.dot(po), l = bs.dot(Lf), c = po.dot(po), u = po.dot(Lf), m = r * c - a * a;
    if (m === 0)
      return o.set(0, 0, 0), null;
    const d = 1 / m, f = (c * l - a * u) * d, p = (r * u - a * l) * d;
    return o.set(1 - f - p, p, f);
  }
  static containsPoint(t, e, s, i) {
    return this.getBarycoord(t, e, s, i, _o) === null ? !1 : _o.x >= 0 && _o.y >= 0 && _o.x + _o.y <= 1;
  }
  static getInterpolation(t, e, s, i, o, r, a, l) {
    return this.getBarycoord(t, e, s, i, _o) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(o, _o.x), l.addScaledVector(r, _o.y), l.addScaledVector(a, _o.z), l);
  }
  static getInterpolatedAttribute(t, e, s, i, o, r) {
    return Uf.setScalar(0), Of.setScalar(0), $f.setScalar(0), Uf.fromBufferAttribute(t, e), Of.fromBufferAttribute(t, s), $f.fromBufferAttribute(t, i), r.setScalar(0), r.addScaledVector(Uf, o.x), r.addScaledVector(Of, o.y), r.addScaledVector($f, o.z), r;
  }
  static isFrontFacing(t, e, s, i) {
    return bs.subVectors(s, e), po.subVectors(t, e), bs.cross(po).dot(i) < 0;
  }
  set(t, e, s) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(s), this;
  }
  setFromPointsAndIndices(t, e, s, i) {
    return this.a.copy(t[e]), this.b.copy(t[s]), this.c.copy(t[i]), this;
  }
  setFromAttributeAndIndices(t, e, s, i) {
    return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, s), this.c.fromBufferAttribute(t, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return bs.subVectors(this.c, this.b), po.subVectors(this.a, this.b), bs.cross(po).length() * 0.5;
  }
  getMidpoint(t) {
    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(t) {
    return sr.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t, e) {
    return sr.getBarycoord(t, this.a, this.b, this.c, e);
  }
  getInterpolation(t, e, s, i, o) {
    return sr.getInterpolation(t, this.a, this.b, this.c, e, s, i, o);
  }
  containsPoint(t) {
    return sr.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return sr.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, e) {
    const s = this.a, i = this.b, o = this.c;
    let r, a;
    tc.subVectors(i, s), ec.subVectors(o, s), Nf.subVectors(t, s);
    const l = tc.dot(Nf), c = ec.dot(Nf);
    if (l <= 0 && c <= 0)
      return e.copy(s);
    zf.subVectors(t, i);
    const u = tc.dot(zf), m = ec.dot(zf);
    if (u >= 0 && m <= u)
      return e.copy(i);
    const d = l * m - u * c;
    if (d <= 0 && l >= 0 && u <= 0)
      return r = l / (l - u), e.copy(s).addScaledVector(tc, r);
    kf.subVectors(t, o);
    const f = tc.dot(kf), p = ec.dot(kf);
    if (p >= 0 && f <= p)
      return e.copy(o);
    const v = f * c - l * p;
    if (v <= 0 && c >= 0 && p <= 0)
      return a = c / (c - p), e.copy(s).addScaledVector(ec, a);
    const _ = u * p - f * m;
    if (_ <= 0 && m - u >= 0 && f - p >= 0)
      return Yw.subVectors(o, i), a = (m - u) / (m - u + (f - p)), e.copy(i).addScaledVector(Yw, a);
    const g = 1 / (_ + v + d);
    return r = v * g, a = d * g, e.copy(s).addScaledVector(tc, r).addScaledVector(ec, a);
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
};
h(sr, "Triangle");
let ar = sr;
const W3 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Jo = { h: 0, s: 0, l: 0 }, mh = { h: 0, s: 0, l: 0 };
function Ff(n, t, e) {
  return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? n + (t - n) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? n + (t - n) * 6 * (2 / 3 - e) : n;
}
h(Ff, "hue2rgb");
const Ub = class Ub {
  constructor(t, e, s) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, s);
  }
  set(t, e, s) {
    if (e === void 0 && s === void 0) {
      const i = t;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(t, e, s);
    return this;
  }
  setScalar(t) {
    return this.r = t, this.g = t, this.b = t, this;
  }
  setHex(t, e = rs) {
    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, Qe.colorSpaceToWorking(this, e), this;
  }
  setRGB(t, e, s, i = Qe.workingColorSpace) {
    return this.r = t, this.g = e, this.b = s, Qe.colorSpaceToWorking(this, i), this;
  }
  setHSL(t, e, s, i = Qe.workingColorSpace) {
    if (t = G2(t, 1), e = Oe(e, 0, 1), s = Oe(s, 0, 1), e === 0)
      this.r = this.g = this.b = s;
    else {
      const o = s <= 0.5 ? s * (1 + e) : s + e - s * e, r = 2 * s - o;
      this.r = Ff(r, o, t + 1 / 3), this.g = Ff(r, o, t), this.b = Ff(r, o, t - 1 / 3);
    }
    return Qe.colorSpaceToWorking(this, i), this;
  }
  setStyle(t, e = rs) {
    function s(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
    }
    h(s, "handleAlpha");
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
      let o;
      const r = i[1], a = i[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return s(o[4]), this.setRGB(
              Math.min(255, parseInt(o[1], 10)) / 255,
              Math.min(255, parseInt(o[2], 10)) / 255,
              Math.min(255, parseInt(o[3], 10)) / 255,
              e
            );
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return s(o[4]), this.setRGB(
              Math.min(100, parseInt(o[1], 10)) / 100,
              Math.min(100, parseInt(o[2], 10)) / 100,
              Math.min(100, parseInt(o[3], 10)) / 100,
              e
            );
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return s(o[4]), this.setHSL(
              parseFloat(o[1]) / 360,
              parseFloat(o[2]) / 100,
              parseFloat(o[3]) / 100,
              e
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + t);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
      const o = i[1], r = o.length;
      if (r === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          e
        );
      if (r === 6)
        return this.setHex(parseInt(o, 16), e);
      console.warn("THREE.Color: Invalid hex color " + t);
    } else if (t && t.length > 0)
      return this.setColorName(t, e);
    return this;
  }
  setColorName(t, e = rs) {
    const s = W3[t.toLowerCase()];
    return s !== void 0 ? this.setHex(s, e) : console.warn("THREE.Color: Unknown color " + t), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t) {
    return this.r = t.r, this.g = t.g, this.b = t.b, this;
  }
  copySRGBToLinear(t) {
    return this.r = Lo(t.r), this.g = Lo(t.g), this.b = Lo(t.b), this;
  }
  copyLinearToSRGB(t) {
    return this.r = Sc(t.r), this.g = Sc(t.g), this.b = Sc(t.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(t = rs) {
    return Qe.workingToColorSpace(ai.copy(this), t), Math.round(Oe(ai.r * 255, 0, 255)) * 65536 + Math.round(Oe(ai.g * 255, 0, 255)) * 256 + Math.round(Oe(ai.b * 255, 0, 255));
  }
  getHexString(t = rs) {
    return ("000000" + this.getHex(t).toString(16)).slice(-6);
  }
  getHSL(t, e = Qe.workingColorSpace) {
    Qe.workingToColorSpace(ai.copy(this), e);
    const s = ai.r, i = ai.g, o = ai.b, r = Math.max(s, i, o), a = Math.min(s, i, o);
    let l, c;
    const u = (a + r) / 2;
    if (a === r)
      l = 0, c = 0;
    else {
      const m = r - a;
      switch (c = u <= 0.5 ? m / (r + a) : m / (2 - r - a), r) {
        case s:
          l = (i - o) / m + (i < o ? 6 : 0);
          break;
        case i:
          l = (o - s) / m + 2;
          break;
        case o:
          l = (s - i) / m + 4;
          break;
      }
      l /= 6;
    }
    return t.h = l, t.s = c, t.l = u, t;
  }
  getRGB(t, e = Qe.workingColorSpace) {
    return Qe.workingToColorSpace(ai.copy(this), e), t.r = ai.r, t.g = ai.g, t.b = ai.b, t;
  }
  getStyle(t = rs) {
    Qe.workingToColorSpace(ai.copy(this), t);
    const e = ai.r, s = ai.g, i = ai.b;
    return t !== rs ? `color(${t} ${e.toFixed(3)} ${s.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(s * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(t, e, s) {
    return this.getHSL(Jo), this.setHSL(Jo.h + t, Jo.s + e, Jo.l + s);
  }
  add(t) {
    return this.r += t.r, this.g += t.g, this.b += t.b, this;
  }
  addColors(t, e) {
    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
  }
  addScalar(t) {
    return this.r += t, this.g += t, this.b += t, this;
  }
  sub(t) {
    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
  }
  multiply(t) {
    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
  }
  multiplyScalar(t) {
    return this.r *= t, this.g *= t, this.b *= t, this;
  }
  lerp(t, e) {
    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
  }
  lerpColors(t, e, s) {
    return this.r = t.r + (e.r - t.r) * s, this.g = t.g + (e.g - t.g) * s, this.b = t.b + (e.b - t.b) * s, this;
  }
  lerpHSL(t, e) {
    this.getHSL(Jo), t.getHSL(mh);
    const s = Dl(Jo.h, mh.h, e), i = Dl(Jo.s, mh.s, e), o = Dl(Jo.l, mh.l, e);
    return this.setHSL(s, i, o), this;
  }
  setFromVector3(t) {
    return this.r = t.x, this.g = t.y, this.b = t.z, this;
  }
  applyMatrix3(t) {
    const e = this.r, s = this.g, i = this.b, o = t.elements;
    return this.r = o[0] * e + o[3] * s + o[6] * i, this.g = o[1] * e + o[4] * s + o[7] * i, this.b = o[2] * e + o[5] * s + o[8] * i, this;
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e = 0) {
    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
  }
  fromBufferAttribute(t, e) {
    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
h(Ub, "Color");
let Ce = Ub;
const ai = new Ce();
Ce.NAMES = W3;
let pk = 0;
const Ob = class Ob extends xr {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: pk++ }), this.uuid = il(), this.name = "", this.type = "Material", this.blending = wc, this.side = yr, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = $p, this.blendDst = Fp, this.blendEquation = qr, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ce(0, 0, 0), this.blendAlpha = 0, this.depthFunc = zc, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Lw, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Wa, this.stencilZFail = Wa, this.stencilZPass = Wa, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t) {
    if (t !== void 0)
      for (const e in t) {
        const s = t[e];
        if (s === void 0) {
          console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
          continue;
        }
        const i = this[e];
        if (i === void 0) {
          console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(s) : i && i.isVector3 && s && s.isVector3 ? i.copy(s) : this[e] = s;
      }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = {
      textures: {},
      images: {}
    });
    const s = {
      metadata: {
        version: 4.7,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.color && this.color.isColor && (s.color = this.color.getHex()), this.roughness !== void 0 && (s.roughness = this.roughness), this.metalness !== void 0 && (s.metalness = this.metalness), this.sheen !== void 0 && (s.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (s.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (s.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (s.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (s.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (s.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (s.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (s.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (s.shininess = this.shininess), this.clearcoat !== void 0 && (s.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (s.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (s.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (s.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (s.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, s.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.sheenColorMap && this.sheenColorMap.isTexture && (s.sheenColorMap = this.sheenColorMap.toJSON(t).uuid), this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (s.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(t).uuid), this.dispersion !== void 0 && (s.dispersion = this.dispersion), this.iridescence !== void 0 && (s.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (s.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (s.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (s.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (s.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (s.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (s.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (s.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (s.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (s.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (s.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (s.lightMap = this.lightMap.toJSON(t).uuid, s.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (s.aoMap = this.aoMap.toJSON(t).uuid, s.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (s.bumpMap = this.bumpMap.toJSON(t).uuid, s.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (s.normalMap = this.normalMap.toJSON(t).uuid, s.normalMapType = this.normalMapType, s.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (s.displacementMap = this.displacementMap.toJSON(t).uuid, s.displacementScale = this.displacementScale, s.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (s.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (s.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (s.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (s.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (s.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (s.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (s.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (s.combine = this.combine)), this.envMapRotation !== void 0 && (s.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (s.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (s.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (s.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (s.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (s.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (s.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (s.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (s.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (s.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (s.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (s.size = this.size), this.shadowSide !== null && (s.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (s.sizeAttenuation = this.sizeAttenuation), this.blending !== wc && (s.blending = this.blending), this.side !== yr && (s.side = this.side), this.vertexColors === !0 && (s.vertexColors = !0), this.opacity < 1 && (s.opacity = this.opacity), this.transparent === !0 && (s.transparent = !0), this.blendSrc !== $p && (s.blendSrc = this.blendSrc), this.blendDst !== Fp && (s.blendDst = this.blendDst), this.blendEquation !== qr && (s.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (s.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (s.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (s.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (s.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (s.blendAlpha = this.blendAlpha), this.depthFunc !== zc && (s.depthFunc = this.depthFunc), this.depthTest === !1 && (s.depthTest = this.depthTest), this.depthWrite === !1 && (s.depthWrite = this.depthWrite), this.colorWrite === !1 && (s.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (s.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Lw && (s.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (s.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (s.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Wa && (s.stencilFail = this.stencilFail), this.stencilZFail !== Wa && (s.stencilZFail = this.stencilZFail), this.stencilZPass !== Wa && (s.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (s.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (s.rotation = this.rotation), this.polygonOffset === !0 && (s.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (s.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (s.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (s.linewidth = this.linewidth), this.dashSize !== void 0 && (s.dashSize = this.dashSize), this.gapSize !== void 0 && (s.gapSize = this.gapSize), this.scale !== void 0 && (s.scale = this.scale), this.dithering === !0 && (s.dithering = !0), this.alphaTest > 0 && (s.alphaTest = this.alphaTest), this.alphaHash === !0 && (s.alphaHash = !0), this.alphaToCoverage === !0 && (s.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (s.premultipliedAlpha = !0), this.forceSinglePass === !0 && (s.forceSinglePass = !0), this.wireframe === !0 && (s.wireframe = !0), this.wireframeLinewidth > 1 && (s.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (s.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (s.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (s.flatShading = !0), this.visible === !1 && (s.visible = !1), this.toneMapped === !1 && (s.toneMapped = !1), this.fog === !1 && (s.fog = !1), Object.keys(this.userData).length > 0 && (s.userData = this.userData);
    function i(o) {
      const r = [];
      for (const a in o) {
        const l = o[a];
        delete l.metadata, r.push(l);
      }
      return r;
    }
    if (h(i, "extractFromCache"), e) {
      const o = i(t.textures), r = i(t.images);
      o.length > 0 && (s.textures = o), r.length > 0 && (s.images = r);
    }
    return s;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    const e = t.clippingPlanes;
    let s = null;
    if (e !== null) {
      const i = e.length;
      s = new Array(i);
      for (let o = 0; o !== i; ++o)
        s[o] = e[o].clone();
    }
    return this.clippingPlanes = s, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
};
h(Ob, "Material");
let $o = Ob;
const $b = class $b extends $o {
  constructor(t) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Ce(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Js(), this.combine = D3, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
  }
};
h($b, "MeshBasicMaterial");
let fd = $b;
_k();
function _k() {
  const n = new ArrayBuffer(4), t = new Float32Array(n), e = new Uint32Array(n), s = new Uint32Array(512), i = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27 ? (s[l] = 0, s[l | 256] = 32768, i[l] = 24, i[l | 256] = 24) : c < -14 ? (s[l] = 1024 >> -c - 14, s[l | 256] = 1024 >> -c - 14 | 32768, i[l] = -c - 1, i[l | 256] = -c - 1) : c <= 15 ? (s[l] = c + 15 << 10, s[l | 256] = c + 15 << 10 | 32768, i[l] = 13, i[l | 256] = 13) : c < 128 ? (s[l] = 31744, s[l | 256] = 64512, i[l] = 24, i[l | 256] = 24) : (s[l] = 31744, s[l | 256] = 64512, i[l] = 13, i[l | 256] = 13);
  }
  const o = new Uint32Array(2048), r = new Uint32Array(64), a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13, u = 0;
    for (; !(c & 8388608); )
      c <<= 1, u -= 8388608;
    c &= -8388609, u += 947912704, o[l] = c | u;
  }
  for (let l = 1024; l < 2048; ++l)
    o[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l)
    r[l] = l << 23;
  r[31] = 1199570944, r[32] = 2147483648;
  for (let l = 33; l < 63; ++l)
    r[l] = 2147483648 + (l - 32 << 23);
  r[63] = 3347054592;
  for (let l = 1; l < 64; ++l)
    l !== 32 && (a[l] = 1024);
  return {
    floatView: t,
    uint32View: e,
    baseTable: s,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: r,
    offsetTable: a
  };
}
h(_k, "_generateTables");
const $n = new O(), fh = new Pe();
let gk = 0;
const Fb = class Fb {
  constructor(t, e, s = !1) {
    if (Array.isArray(t))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: gk++ }), this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = s, this.usage = Nw, this.updateRanges = [], this.gpuType = Ro, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  setUsage(t) {
    return this.usage = t, this;
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(t) {
    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
  }
  copyAt(t, e, s) {
    t *= this.itemSize, s *= e.itemSize;
    for (let i = 0, o = this.itemSize; i < o; i++)
      this.array[t + i] = e.array[s + i];
    return this;
  }
  copyArray(t) {
    return this.array.set(t), this;
  }
  applyMatrix3(t) {
    if (this.itemSize === 2)
      for (let e = 0, s = this.count; e < s; e++)
        fh.fromBufferAttribute(this, e), fh.applyMatrix3(t), this.setXY(e, fh.x, fh.y);
    else if (this.itemSize === 3)
      for (let e = 0, s = this.count; e < s; e++)
        $n.fromBufferAttribute(this, e), $n.applyMatrix3(t), this.setXYZ(e, $n.x, $n.y, $n.z);
    return this;
  }
  applyMatrix4(t) {
    for (let e = 0, s = this.count; e < s; e++)
      $n.fromBufferAttribute(this, e), $n.applyMatrix4(t), this.setXYZ(e, $n.x, $n.y, $n.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, s = this.count; e < s; e++)
      $n.fromBufferAttribute(this, e), $n.applyNormalMatrix(t), this.setXYZ(e, $n.x, $n.y, $n.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, s = this.count; e < s; e++)
      $n.fromBufferAttribute(this, e), $n.transformDirection(t), this.setXYZ(e, $n.x, $n.y, $n.z);
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  getComponent(t, e) {
    let s = this.array[t * this.itemSize + e];
    return this.normalized && (s = hc(s, this.array)), s;
  }
  setComponent(t, e, s) {
    return this.normalized && (s = gi(s, this.array)), this.array[t * this.itemSize + e] = s, this;
  }
  getX(t) {
    let e = this.array[t * this.itemSize];
    return this.normalized && (e = hc(e, this.array)), e;
  }
  setX(t, e) {
    return this.normalized && (e = gi(e, this.array)), this.array[t * this.itemSize] = e, this;
  }
  getY(t) {
    let e = this.array[t * this.itemSize + 1];
    return this.normalized && (e = hc(e, this.array)), e;
  }
  setY(t, e) {
    return this.normalized && (e = gi(e, this.array)), this.array[t * this.itemSize + 1] = e, this;
  }
  getZ(t) {
    let e = this.array[t * this.itemSize + 2];
    return this.normalized && (e = hc(e, this.array)), e;
  }
  setZ(t, e) {
    return this.normalized && (e = gi(e, this.array)), this.array[t * this.itemSize + 2] = e, this;
  }
  getW(t) {
    let e = this.array[t * this.itemSize + 3];
    return this.normalized && (e = hc(e, this.array)), e;
  }
  setW(t, e) {
    return this.normalized && (e = gi(e, this.array)), this.array[t * this.itemSize + 3] = e, this;
  }
  setXY(t, e, s) {
    return t *= this.itemSize, this.normalized && (e = gi(e, this.array), s = gi(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = s, this;
  }
  setXYZ(t, e, s, i) {
    return t *= this.itemSize, this.normalized && (e = gi(e, this.array), s = gi(s, this.array), i = gi(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = s, this.array[t + 2] = i, this;
  }
  setXYZW(t, e, s, i, o) {
    return t *= this.itemSize, this.normalized && (e = gi(e, this.array), s = gi(s, this.array), i = gi(i, this.array), o = gi(o, this.array)), this.array[t + 0] = e, this.array[t + 1] = s, this.array[t + 2] = i, this.array[t + 3] = o, this;
  }
  onUpload(t) {
    return this.onUploadCallback = t, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (t.name = this.name), this.usage !== Nw && (t.usage = this.usage), t;
  }
};
h(Fb, "BufferAttribute");
let ds = Fb;
const Gb = class Gb extends ds {
  constructor(t, e, s) {
    super(new Uint16Array(t), e, s);
  }
};
h(Gb, "Uint16BufferAttribute");
let pd = Gb;
const Hb = class Hb extends ds {
  constructor(t, e, s) {
    super(new Uint32Array(t), e, s);
  }
};
h(Hb, "Uint32BufferAttribute");
let _d = Hb;
const jb = class jb extends ds {
  constructor(t, e, s) {
    super(new Float32Array(t), e, s);
  }
};
h(jb, "Float32BufferAttribute");
let ei = jb, vk = 0;
const ts = new Re(), Gf = new mi(), nc = new O(), ki = new Zs(), ml = new Zs(), Qn = new O(), em = class em extends xr {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: vk++ }), this.uuid = il(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(t) {
    return Array.isArray(t) ? this.index = new (j3(t) ? _d : pd)(t, 1) : this.index = t, this;
  }
  setIndirect(t) {
    return this.indirect = t, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(t) {
    return this.attributes[t];
  }
  setAttribute(t, e) {
    return this.attributes[t] = e, this;
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this;
  }
  hasAttribute(t) {
    return this.attributes[t] !== void 0;
  }
  addGroup(t, e, s = 0) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: s
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t, e) {
    this.drawRange.start = t, this.drawRange.count = e;
  }
  applyMatrix4(t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
    const s = this.attributes.normal;
    if (s !== void 0) {
      const o = new Ae().getNormalMatrix(t);
      s.applyNormalMatrix(o), s.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(t), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(t) {
    return ts.makeRotationFromQuaternion(t), this.applyMatrix4(ts), this;
  }
  rotateX(t) {
    return ts.makeRotationX(t), this.applyMatrix4(ts), this;
  }
  rotateY(t) {
    return ts.makeRotationY(t), this.applyMatrix4(ts), this;
  }
  rotateZ(t) {
    return ts.makeRotationZ(t), this.applyMatrix4(ts), this;
  }
  translate(t, e, s) {
    return ts.makeTranslation(t, e, s), this.applyMatrix4(ts), this;
  }
  scale(t, e, s) {
    return ts.makeScale(t, e, s), this.applyMatrix4(ts), this;
  }
  lookAt(t) {
    return Gf.lookAt(t), Gf.updateMatrix(), this.applyMatrix4(Gf.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(nc).negate(), this.translate(nc.x, nc.y, nc.z), this;
  }
  setFromPoints(t) {
    const e = this.getAttribute("position");
    if (e === void 0) {
      const s = [];
      for (let i = 0, o = t.length; i < o; i++) {
        const r = t[i];
        s.push(r.x, r.y, r.z || 0);
      }
      this.setAttribute("position", new ei(s, 3));
    } else {
      const s = Math.min(t.length, e.count);
      for (let i = 0; i < s; i++) {
        const o = t[i];
        e.setXYZ(i, o.x, o.y, o.z || 0);
      }
      t.length > e.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), e.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Zs());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new O(-1 / 0, -1 / 0, -1 / 0),
        new O(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (t !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(t), e)
        for (let s = 0, i = e.length; s < i; s++) {
          const o = e[s];
          ki.setFromBufferAttribute(o), this.morphTargetsRelative ? (Qn.addVectors(this.boundingBox.min, ki.min), this.boundingBox.expandByPoint(Qn), Qn.addVectors(this.boundingBox.max, ki.max), this.boundingBox.expandByPoint(Qn)) : (this.boundingBox.expandByPoint(ki.min), this.boundingBox.expandByPoint(ki.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ys());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new O(), 1 / 0);
      return;
    }
    if (t) {
      const s = this.boundingSphere.center;
      if (ki.setFromBufferAttribute(t), e)
        for (let o = 0, r = e.length; o < r; o++) {
          const a = e[o];
          ml.setFromBufferAttribute(a), this.morphTargetsRelative ? (Qn.addVectors(ki.min, ml.min), ki.expandByPoint(Qn), Qn.addVectors(ki.max, ml.max), ki.expandByPoint(Qn)) : (ki.expandByPoint(ml.min), ki.expandByPoint(ml.max));
        }
      ki.getCenter(s);
      let i = 0;
      for (let o = 0, r = t.count; o < r; o++)
        Qn.fromBufferAttribute(t, o), i = Math.max(i, s.distanceToSquared(Qn));
      if (e)
        for (let o = 0, r = e.length; o < r; o++) {
          const a = e[o], l = this.morphTargetsRelative;
          for (let c = 0, u = a.count; c < u; c++)
            Qn.fromBufferAttribute(a, c), l && (nc.fromBufferAttribute(t, c), Qn.add(nc)), i = Math.max(i, s.distanceToSquared(Qn));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const t = this.index, e = this.attributes;
    if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const s = e.position, i = e.normal, o = e.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ds(new Float32Array(4 * s.count), 4));
    const r = this.getAttribute("tangent"), a = [], l = [];
    for (let T = 0; T < s.count; T++)
      a[T] = new O(), l[T] = new O();
    const c = new O(), u = new O(), m = new O(), d = new Pe(), f = new Pe(), p = new Pe(), v = new O(), _ = new O();
    function g(T, b, y) {
      c.fromBufferAttribute(s, T), u.fromBufferAttribute(s, b), m.fromBufferAttribute(s, y), d.fromBufferAttribute(o, T), f.fromBufferAttribute(o, b), p.fromBufferAttribute(o, y), u.sub(c), m.sub(c), f.sub(d), p.sub(d);
      const E = 1 / (f.x * p.y - p.x * f.y);
      isFinite(E) && (v.copy(u).multiplyScalar(p.y).addScaledVector(m, -f.y).multiplyScalar(E), _.copy(m).multiplyScalar(f.x).addScaledVector(u, -p.x).multiplyScalar(E), a[T].add(v), a[b].add(v), a[y].add(v), l[T].add(_), l[b].add(_), l[y].add(_));
    }
    h(g, "handleTriangle");
    let w = this.groups;
    w.length === 0 && (w = [{
      start: 0,
      count: t.count
    }]);
    for (let T = 0, b = w.length; T < b; ++T) {
      const y = w[T], E = y.start, I = y.count;
      for (let B = E, D = E + I; B < D; B += 3)
        g(
          t.getX(B + 0),
          t.getX(B + 1),
          t.getX(B + 2)
        );
    }
    const S = new O(), x = new O(), A = new O(), C = new O();
    function M(T) {
      A.fromBufferAttribute(i, T), C.copy(A);
      const b = a[T];
      S.copy(b), S.sub(A.multiplyScalar(A.dot(b))).normalize(), x.crossVectors(C, b);
      const E = x.dot(l[T]) < 0 ? -1 : 1;
      r.setXYZW(T, S.x, S.y, S.z, E);
    }
    h(M, "handleVertex");
    for (let T = 0, b = w.length; T < b; ++T) {
      const y = w[T], E = y.start, I = y.count;
      for (let B = E, D = E + I; B < D; B += 3)
        M(t.getX(B + 0)), M(t.getX(B + 1)), M(t.getX(B + 2));
    }
  }
  computeVertexNormals() {
    const t = this.index, e = this.getAttribute("position");
    if (e !== void 0) {
      let s = this.getAttribute("normal");
      if (s === void 0)
        s = new ds(new Float32Array(e.count * 3), 3), this.setAttribute("normal", s);
      else
        for (let d = 0, f = s.count; d < f; d++)
          s.setXYZ(d, 0, 0, 0);
      const i = new O(), o = new O(), r = new O(), a = new O(), l = new O(), c = new O(), u = new O(), m = new O();
      if (t)
        for (let d = 0, f = t.count; d < f; d += 3) {
          const p = t.getX(d + 0), v = t.getX(d + 1), _ = t.getX(d + 2);
          i.fromBufferAttribute(e, p), o.fromBufferAttribute(e, v), r.fromBufferAttribute(e, _), u.subVectors(r, o), m.subVectors(i, o), u.cross(m), a.fromBufferAttribute(s, p), l.fromBufferAttribute(s, v), c.fromBufferAttribute(s, _), a.add(u), l.add(u), c.add(u), s.setXYZ(p, a.x, a.y, a.z), s.setXYZ(v, l.x, l.y, l.z), s.setXYZ(_, c.x, c.y, c.z);
        }
      else
        for (let d = 0, f = e.count; d < f; d += 3)
          i.fromBufferAttribute(e, d + 0), o.fromBufferAttribute(e, d + 1), r.fromBufferAttribute(e, d + 2), u.subVectors(r, o), m.subVectors(i, o), u.cross(m), s.setXYZ(d + 0, u.x, u.y, u.z), s.setXYZ(d + 1, u.x, u.y, u.z), s.setXYZ(d + 2, u.x, u.y, u.z);
      this.normalizeNormals(), s.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const t = this.attributes.normal;
    for (let e = 0, s = t.count; e < s; e++)
      Qn.fromBufferAttribute(t, e), Qn.normalize(), t.setXYZ(e, Qn.x, Qn.y, Qn.z);
  }
  toNonIndexed() {
    function t(a, l) {
      const c = a.array, u = a.itemSize, m = a.normalized, d = new c.constructor(l.length * u);
      let f = 0, p = 0;
      for (let v = 0, _ = l.length; v < _; v++) {
        a.isInterleavedBufferAttribute ? f = l[v] * a.data.stride + a.offset : f = l[v] * u;
        for (let g = 0; g < u; g++)
          d[p++] = c[f++];
      }
      return new ds(d, u, m);
    }
    if (h(t, "convertBufferAttribute"), this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const e = new em(), s = this.index.array, i = this.attributes;
    for (const a in i) {
      const l = i[a], c = t(l, s);
      e.setAttribute(a, c);
    }
    const o = this.morphAttributes;
    for (const a in o) {
      const l = [], c = o[a];
      for (let u = 0, m = c.length; u < m; u++) {
        const d = c[u], f = t(d, s);
        l.push(f);
      }
      e.morphAttributes[a] = l;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const r = this.groups;
    for (let a = 0, l = r.length; a < l; a++) {
      const c = r[a];
      e.addGroup(c.start, c.count, c.materialIndex);
    }
    return e;
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.7,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (t[c] = l[c]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null && (t.data.index = {
      type: e.array.constructor.name,
      array: Array.prototype.slice.call(e.array)
    });
    const s = this.attributes;
    for (const l in s) {
      const c = s[l];
      t.data.attributes[l] = c.toJSON(t.data);
    }
    const i = {};
    let o = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], u = [];
      for (let m = 0, d = c.length; m < d; m++) {
        const f = c[m];
        u.push(f.toJSON(t.data));
      }
      u.length > 0 && (i[l] = u, o = !0);
    }
    o && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
    const r = this.groups;
    r.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(r)));
    const a = this.boundingSphere;
    return a !== null && (t.data.boundingSphere = a.toJSON()), t;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e = {};
    this.name = t.name;
    const s = t.index;
    s !== null && this.setIndex(s.clone());
    const i = t.attributes;
    for (const c in i) {
      const u = i[c];
      this.setAttribute(c, u.clone(e));
    }
    const o = t.morphAttributes;
    for (const c in o) {
      const u = [], m = o[c];
      for (let d = 0, f = m.length; d < f; d++)
        u.push(m[d].clone(e));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const r = t.groups;
    for (let c = 0, u = r.length; c < u; c++) {
      const m = r[c];
      this.addGroup(m.start, m.count, m.materialIndex);
    }
    const a = t.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = t.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
h(em, "BufferGeometry");
let Ks = em;
const Jw = new Re(), Vr = new Fc(), ph = new Ys(), Kw = new O(), _h = new O(), gh = new O(), vh = new O(), Hf = new O(), bh = new O(), Qw = new O(), yh = new O(), Wb = class Wb extends mi {
  constructor(t = new Ks(), e = new fd()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.count = 1, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, s = Object.keys(e);
    if (s.length > 0) {
      const i = e[s[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, r = i.length; o < r; o++) {
          const a = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = o;
        }
      }
    }
  }
  getVertexPosition(t, e) {
    const s = this.geometry, i = s.attributes.position, o = s.morphAttributes.position, r = s.morphTargetsRelative;
    e.fromBufferAttribute(i, t);
    const a = this.morphTargetInfluences;
    if (o && a) {
      bh.set(0, 0, 0);
      for (let l = 0, c = o.length; l < c; l++) {
        const u = a[l], m = o[l];
        u !== 0 && (Hf.fromBufferAttribute(m, t), r ? bh.addScaledVector(Hf, u) : bh.addScaledVector(Hf.sub(e), u));
      }
      e.add(bh);
    }
    return e;
  }
  raycast(t, e) {
    const s = this.geometry, i = this.material, o = this.matrixWorld;
    i !== void 0 && (s.boundingSphere === null && s.computeBoundingSphere(), ph.copy(s.boundingSphere), ph.applyMatrix4(o), Vr.copy(t.ray).recast(t.near), !(ph.containsPoint(Vr.origin) === !1 && (Vr.intersectSphere(ph, Kw) === null || Vr.origin.distanceToSquared(Kw) > (t.far - t.near) ** 2)) && (Jw.copy(o).invert(), Vr.copy(t.ray).applyMatrix4(Jw), !(s.boundingBox !== null && Vr.intersectsBox(s.boundingBox) === !1) && this._computeIntersections(t, e, Vr)));
  }
  _computeIntersections(t, e, s) {
    let i;
    const o = this.geometry, r = this.material, a = o.index, l = o.attributes.position, c = o.attributes.uv, u = o.attributes.uv1, m = o.attributes.normal, d = o.groups, f = o.drawRange;
    if (a !== null)
      if (Array.isArray(r))
        for (let p = 0, v = d.length; p < v; p++) {
          const _ = d[p], g = r[_.materialIndex], w = Math.max(_.start, f.start), S = Math.min(a.count, Math.min(_.start + _.count, f.start + f.count));
          for (let x = w, A = S; x < A; x += 3) {
            const C = a.getX(x), M = a.getX(x + 1), T = a.getX(x + 2);
            i = xh(this, g, t, s, c, u, m, C, M, T), i && (i.faceIndex = Math.floor(x / 3), i.face.materialIndex = _.materialIndex, e.push(i));
          }
        }
      else {
        const p = Math.max(0, f.start), v = Math.min(a.count, f.start + f.count);
        for (let _ = p, g = v; _ < g; _ += 3) {
          const w = a.getX(_), S = a.getX(_ + 1), x = a.getX(_ + 2);
          i = xh(this, r, t, s, c, u, m, w, S, x), i && (i.faceIndex = Math.floor(_ / 3), e.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(r))
        for (let p = 0, v = d.length; p < v; p++) {
          const _ = d[p], g = r[_.materialIndex], w = Math.max(_.start, f.start), S = Math.min(l.count, Math.min(_.start + _.count, f.start + f.count));
          for (let x = w, A = S; x < A; x += 3) {
            const C = x, M = x + 1, T = x + 2;
            i = xh(this, g, t, s, c, u, m, C, M, T), i && (i.faceIndex = Math.floor(x / 3), i.face.materialIndex = _.materialIndex, e.push(i));
          }
        }
      else {
        const p = Math.max(0, f.start), v = Math.min(l.count, f.start + f.count);
        for (let _ = p, g = v; _ < g; _ += 3) {
          const w = _, S = _ + 1, x = _ + 2;
          i = xh(this, r, t, s, c, u, m, w, S, x), i && (i.faceIndex = Math.floor(_ / 3), e.push(i));
        }
      }
  }
};
h(Wb, "Mesh");
let Bi = Wb;
function bk(n, t, e, s, i, o, r, a) {
  let l;
  if (t.side === Di ? l = s.intersectTriangle(r, o, i, !0, a) : l = s.intersectTriangle(i, o, r, t.side === yr, a), l === null) return null;
  yh.copy(a), yh.applyMatrix4(n.matrixWorld);
  const c = e.ray.origin.distanceTo(yh);
  return c < e.near || c > e.far ? null : {
    distance: c,
    point: yh.clone(),
    object: n
  };
}
h(bk, "checkIntersection$1");
function xh(n, t, e, s, i, o, r, a, l, c) {
  n.getVertexPosition(a, _h), n.getVertexPosition(l, gh), n.getVertexPosition(c, vh);
  const u = bk(n, t, e, s, _h, gh, vh, Qw);
  if (u) {
    const m = new O();
    ar.getBarycoord(Qw, _h, gh, vh, m), i && (u.uv = ar.getInterpolatedAttribute(i, a, l, c, m, new Pe())), o && (u.uv1 = ar.getInterpolatedAttribute(o, a, l, c, m, new Pe())), r && (u.normal = ar.getInterpolatedAttribute(r, a, l, c, m, new O()), u.normal.dot(s.direction) > 0 && u.normal.multiplyScalar(-1));
    const d = {
      a,
      b: l,
      c,
      normal: new O(),
      materialIndex: 0
    };
    ar.getNormal(_h, gh, vh, d.normal), u.face = d, u.barycoord = m;
  }
  return u;
}
h(xh, "checkGeometryIntersection");
const nm = class nm extends Ks {
  constructor(t = 1, e = 1, s = 1, i = 1, o = 1, r = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: t,
      height: e,
      depth: s,
      widthSegments: i,
      heightSegments: o,
      depthSegments: r
    };
    const a = this;
    i = Math.floor(i), o = Math.floor(o), r = Math.floor(r);
    const l = [], c = [], u = [], m = [];
    let d = 0, f = 0;
    p("z", "y", "x", -1, -1, s, e, t, r, o, 0), p("z", "y", "x", 1, -1, s, e, -t, r, o, 1), p("x", "z", "y", 1, 1, t, s, e, i, r, 2), p("x", "z", "y", 1, -1, t, s, -e, i, r, 3), p("x", "y", "z", 1, -1, t, e, s, i, o, 4), p("x", "y", "z", -1, -1, t, e, -s, i, o, 5), this.setIndex(l), this.setAttribute("position", new ei(c, 3)), this.setAttribute("normal", new ei(u, 3)), this.setAttribute("uv", new ei(m, 2));
    function p(v, _, g, w, S, x, A, C, M, T, b) {
      const y = x / M, E = A / T, I = x / 2, B = A / 2, D = C / 2, N = M + 1, V = T + 1;
      let G = 0, U = 0;
      const j = new O();
      for (let tt = 0; tt < V; tt++) {
        const K = tt * E - B;
        for (let $ = 0; $ < N; $++) {
          const lt = $ * y - I;
          j[v] = lt * w, j[_] = K * S, j[g] = D, c.push(j.x, j.y, j.z), j[v] = 0, j[_] = 0, j[g] = C > 0 ? 1 : -1, u.push(j.x, j.y, j.z), m.push($ / M), m.push(1 - tt / T), G += 1;
        }
      }
      for (let tt = 0; tt < T; tt++)
        for (let K = 0; K < M; K++) {
          const $ = d + K + N * tt, lt = d + K + N * (tt + 1), gt = d + (K + 1) + N * (tt + 1), _t = d + (K + 1) + N * tt;
          l.push($, lt, _t), l.push(lt, gt, _t), U += 6;
        }
      a.addGroup(f, U, b), f += U, d += G;
    }
    h(p, "buildPlane");
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new nm(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
  }
};
h(nm, "BoxGeometry");
let ba = nm;
function Gc(n) {
  const t = {};
  for (const e in n) {
    t[e] = {};
    for (const s in n[e]) {
      const i = n[e][s];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[e][s] = null) : t[e][s] = i.clone() : Array.isArray(i) ? t[e][s] = i.slice() : t[e][s] = i;
    }
  }
  return t;
}
h(Gc, "cloneUniforms");
function vi(n) {
  const t = {};
  for (let e = 0; e < n.length; e++) {
    const s = Gc(n[e]);
    for (const i in s)
      t[i] = s[i];
  }
  return t;
}
h(vi, "mergeUniforms");
function yk(n) {
  const t = [];
  for (let e = 0; e < n.length; e++)
    t.push(n[e].clone());
  return t;
}
h(yk, "cloneUniformsGroups");
function q3(n) {
  const t = n.getRenderTarget();
  return t === null ? n.outputColorSpace : t.isXRRenderTarget === !0 ? t.texture.colorSpace : Qe.workingColorSpace;
}
h(q3, "getUnlitUniformColorSpace");
const xk = { clone: Gc, merge: vi };
var wk = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Sk = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
const qb = class qb extends $o {
  constructor(t) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = wk, this.fragmentShader = Sk, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      multiDraw: !1
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Gc(t.uniforms), this.uniformsGroups = yk(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    e.glslVersion = this.glslVersion, e.uniforms = {};
    for (const i in this.uniforms) {
      const r = this.uniforms[i].value;
      r && r.isTexture ? e.uniforms[i] = {
        type: "t",
        value: r.toJSON(t).uuid
      } : r && r.isColor ? e.uniforms[i] = {
        type: "c",
        value: r.getHex()
      } : r && r.isVector2 ? e.uniforms[i] = {
        type: "v2",
        value: r.toArray()
      } : r && r.isVector3 ? e.uniforms[i] = {
        type: "v3",
        value: r.toArray()
      } : r && r.isVector4 ? e.uniforms[i] = {
        type: "v4",
        value: r.toArray()
      } : r && r.isMatrix3 ? e.uniforms[i] = {
        type: "m3",
        value: r.toArray()
      } : r && r.isMatrix4 ? e.uniforms[i] = {
        type: "m4",
        value: r.toArray()
      } : e.uniforms[i] = {
        value: r
      };
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
    const s = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (s[i] = !0);
    return Object.keys(s).length > 0 && (e.extensions = s), e;
  }
};
h(qb, "ShaderMaterial");
let Qs = qb;
const Xb = class Xb extends mi {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Re(), this.projectionMatrix = new Re(), this.projectionMatrixInverse = new Re(), this.coordinateSystem = Fs, this._reversedDepth = !1;
  }
  get reversedDepth() {
    return this._reversedDepth;
  }
  copy(t, e) {
    return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this;
  }
  getWorldDirection(t) {
    return super.getWorldDirection(t).negate();
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
h(Xb, "Camera");
let uu = Xb;
const Ko = new O(), tS = new Pe(), eS = new Pe(), Zb = class Zb extends uu {
  constructor(t = 50, e = 1, s = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = s, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
  }
  setFocalLength(t) {
    const e = 0.5 * this.getFilmHeight() / t;
    this.fov = $c * 2 * Math.atan(e), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const t = Math.tan(Rl * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / t;
  }
  getEffectiveFOV() {
    return $c * 2 * Math.atan(
      Math.tan(Rl * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(t, e, s) {
    Ko.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), e.set(Ko.x, Ko.y).multiplyScalar(-t / Ko.z), Ko.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), s.set(Ko.x, Ko.y).multiplyScalar(-t / Ko.z);
  }
  getViewSize(t, e) {
    return this.getViewBounds(t, tS, eS), e.subVectors(eS, tS);
  }
  setViewOffset(t, e, s, i, o, r) {
    this.aspect = t / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = s, this.view.offsetY = i, this.view.width = o, this.view.height = r, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = this.near;
    let e = t * Math.tan(Rl * 0.5 * this.fov) / this.zoom, s = 2 * e, i = this.aspect * s, o = -0.5 * i;
    const r = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = r.fullWidth, c = r.fullHeight;
      o += r.offsetX * i / l, e -= r.offsetY * s / c, i *= r.width / l, s *= r.height / c;
    }
    const a = this.filmOffset;
    a !== 0 && (o += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + i, e, e - s, t, this.far, this.coordinateSystem, this.reversedDepth), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
};
h(Zb, "PerspectiveCamera");
let si = Zb;
const ic = -90, sc = 1, Yb = class Yb extends mi {
  constructor(t, e, s) {
    super(), this.type = "CubeCamera", this.renderTarget = s, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const i = new si(ic, sc, t, e);
    i.layers = this.layers, this.add(i);
    const o = new si(ic, sc, t, e);
    o.layers = this.layers, this.add(o);
    const r = new si(ic, sc, t, e);
    r.layers = this.layers, this.add(r);
    const a = new si(ic, sc, t, e);
    a.layers = this.layers, this.add(a);
    const l = new si(ic, sc, t, e);
    l.layers = this.layers, this.add(l);
    const c = new si(ic, sc, t, e);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    const t = this.coordinateSystem, e = this.children.concat(), [s, i, o, r, a, l] = e;
    for (const c of e) this.remove(c);
    if (t === Fs)
      s.up.set(0, 1, 0), s.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), r.up.set(0, 0, 1), r.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (t === ud)
      s.up.set(0, -1, 0), s.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), r.up.set(0, 0, -1), r.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
    for (const c of e)
      this.add(c), c.updateMatrixWorld();
  }
  update(t, e) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: s, activeMipmapLevel: i } = this;
    this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
    const [o, r, a, l, c, u] = this.children, m = t.getRenderTarget(), d = t.getActiveCubeFace(), f = t.getActiveMipmapLevel(), p = t.xr.enabled;
    t.xr.enabled = !1;
    const v = s.texture.generateMipmaps;
    s.texture.generateMipmaps = !1, t.setRenderTarget(s, 0, i), t.render(e, o), t.setRenderTarget(s, 1, i), t.render(e, r), t.setRenderTarget(s, 2, i), t.render(e, a), t.setRenderTarget(s, 3, i), t.render(e, l), t.setRenderTarget(s, 4, i), t.render(e, c), s.texture.generateMipmaps = v, t.setRenderTarget(s, 5, i), t.render(e, u), t.setRenderTarget(m, d, f), t.xr.enabled = p, s.texture.needsPMREMUpdate = !0;
  }
};
h(Yb, "CubeCamera");
let P_ = Yb;
const Jb = class Jb extends fs {
  constructor(t = [], e = kc, s, i, o, r, a, l, c, u) {
    super(t, e, s, i, o, r, a, l, c, u), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(t) {
    this.image = t;
  }
};
h(Jb, "CubeTexture");
let gd = Jb;
const Kb = class Kb extends Oo {
  constructor(t = 1, e = {}) {
    super(t, t, e), this.isWebGLCubeRenderTarget = !0;
    const s = { width: t, height: t, depth: 1 }, i = [s, s, s, s, s, s];
    this.texture = new gd(i), this._setTextureOptions(e), this.texture.isRenderTargetTexture = !0;
  }
  fromEquirectangularTexture(t, e) {
    this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    const s = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    }, i = new ba(5, 5, 5), o = new Qs({
      name: "CubemapFromEquirect",
      uniforms: Gc(s.uniforms),
      vertexShader: s.vertexShader,
      fragmentShader: s.fragmentShader,
      side: Di,
      blending: hr
    });
    o.uniforms.tEquirect.value = e;
    const r = new Bi(i, o), a = e.minFilter;
    return e.minFilter === ra && (e.minFilter = $s), new P_(1, 10, this).update(t, r), e.minFilter = a, r.geometry.dispose(), r.material.dispose(), this;
  }
  clear(t, e = !0, s = !0, i = !0) {
    const o = t.getRenderTarget();
    for (let r = 0; r < 6; r++)
      t.setRenderTarget(this, r), t.clear(e, s, i);
    t.setRenderTarget(o);
  }
};
h(Kb, "WebGLCubeRenderTarget");
let R_ = Kb;
const Qb = class Qb extends mi {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
};
h(Qb, "Group");
let pc = Qb;
const Ak = { type: "move" }, ty = class ty {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new pc(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new pc(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new O(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new O()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new pc(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new O(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new O()), this._grip;
  }
  dispatchEvent(t) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
  }
  connect(t) {
    if (t && t.hand) {
      const e = this._hand;
      if (e)
        for (const s of t.hand.values())
          this._getHandJoint(e, s);
    }
    return this.dispatchEvent({ type: "connected", data: t }), this;
  }
  disconnect(t) {
    return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(t, e, s) {
    let i = null, o = null, r = null;
    const a = this._targetRay, l = this._grip, c = this._hand;
    if (t && e.session.visibilityState !== "visible-blurred") {
      if (c && t.hand) {
        r = !0;
        for (const v of t.hand.values()) {
          const _ = e.getJointPose(v, s), g = this._getHandJoint(c, v);
          _ !== null && (g.matrix.fromArray(_.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, g.jointRadius = _.radius), g.visible = _ !== null;
        }
        const u = c.joints["index-finger-tip"], m = c.joints["thumb-tip"], d = u.position.distanceTo(m.position), f = 0.02, p = 5e-3;
        c.inputState.pinching && d > f + p ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: t.handedness,
          target: this
        })) : !c.inputState.pinching && d <= f - p && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: t.handedness,
          target: this
        }));
      } else
        l !== null && t.gripSpace && (o = e.getPose(t.gripSpace, s), o !== null && (l.matrix.fromArray(o.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(o.linearVelocity)) : l.hasLinearVelocity = !1, o.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(o.angularVelocity)) : l.hasAngularVelocity = !1));
      a !== null && (i = e.getPose(t.targetRaySpace, s), i === null && o !== null && (i = o), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Ak)));
    }
    return a !== null && (a.visible = i !== null), l !== null && (l.visible = o !== null), c !== null && (c.visible = r !== null), this;
  }
  _getHandJoint(t, e) {
    if (t.joints[e.jointName] === void 0) {
      const s = new pc();
      s.matrixAutoUpdate = !1, s.visible = !1, t.joints[e.jointName] = s, t.add(s);
    }
    return t.joints[e.jointName];
  }
};
h(ty, "WebXRController");
let Vl = ty;
var Ic;
let Mk = (Ic = class extends mi {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Js(), this.environmentIntensity = 1, this.environmentRotation = new Js(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(t, e) {
    return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
  }
}, h(Ic, "Scene"), Ic);
new O();
new O();
new O();
new O();
new Pe();
new Pe();
new Re();
new O();
new O();
new O();
new Pe();
new Pe();
new Pe();
new O();
new O();
new O();
new an();
new an();
new O();
new Re();
new O();
new Ys();
new Re();
new Fc();
new Re();
new Re();
new Re();
new Re();
new Zs();
new Re();
new Bi();
new Ys();
const jf = new O(), Ck = new O(), Ek = new Ae(), ey = class ey {
  constructor(t = new O(1, 0, 0), e = 0) {
    this.isPlane = !0, this.normal = t, this.constant = e;
  }
  set(t, e) {
    return this.normal.copy(t), this.constant = e, this;
  }
  setComponents(t, e, s, i) {
    return this.normal.set(t, e, s), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
  }
  setFromCoplanarPoints(t, e, s) {
    const i = jf.subVectors(s, e).cross(Ck.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, t), this;
  }
  copy(t) {
    return this.normal.copy(t.normal), this.constant = t.constant, this;
  }
  normalize() {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), this.constant *= t, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant;
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius;
  }
  projectPoint(t, e) {
    return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
  }
  intersectLine(t, e) {
    const s = t.delta(jf), i = this.normal.dot(s);
    if (i === 0)
      return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
    const o = -(t.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : e.copy(t.start).addScaledVector(s, o);
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start), s = this.distanceToPoint(t.end);
    return e < 0 && s > 0 || s < 0 && e > 0;
  }
  intersectsBox(t) {
    return t.intersectsPlane(this);
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this);
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t, e) {
    const s = e || Ek.getNormalMatrix(t), i = this.coplanarPoint(jf).applyMatrix4(t), o = this.normal.applyMatrix3(s).normalize();
    return this.constant = -i.dot(o), this;
  }
  translate(t) {
    return this.constant -= t.dot(this.normal), this;
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
h(ey, "Plane");
let Co = ey;
const Lr = new Ys(), Tk = new Pe(0.5, 0.5), wh = new O(), ny = class ny {
  constructor(t = new Co(), e = new Co(), s = new Co(), i = new Co(), o = new Co(), r = new Co()) {
    this.planes = [t, e, s, i, o, r];
  }
  set(t, e, s, i, o, r) {
    const a = this.planes;
    return a[0].copy(t), a[1].copy(e), a[2].copy(s), a[3].copy(i), a[4].copy(o), a[5].copy(r), this;
  }
  copy(t) {
    const e = this.planes;
    for (let s = 0; s < 6; s++)
      e[s].copy(t.planes[s]);
    return this;
  }
  setFromProjectionMatrix(t, e = Fs, s = !1) {
    const i = this.planes, o = t.elements, r = o[0], a = o[1], l = o[2], c = o[3], u = o[4], m = o[5], d = o[6], f = o[7], p = o[8], v = o[9], _ = o[10], g = o[11], w = o[12], S = o[13], x = o[14], A = o[15];
    if (i[0].setComponents(c - r, f - u, g - p, A - w).normalize(), i[1].setComponents(c + r, f + u, g + p, A + w).normalize(), i[2].setComponents(c + a, f + m, g + v, A + S).normalize(), i[3].setComponents(c - a, f - m, g - v, A - S).normalize(), s)
      i[4].setComponents(l, d, _, x).normalize(), i[5].setComponents(c - l, f - d, g - _, A - x).normalize();
    else if (i[4].setComponents(c - l, f - d, g - _, A - x).normalize(), e === Fs)
      i[5].setComponents(c + l, f + d, g + _, A + x).normalize();
    else if (e === ud)
      i[5].setComponents(l, d, _, x).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
    return this;
  }
  intersectsObject(t) {
    if (t.boundingSphere !== void 0)
      t.boundingSphere === null && t.computeBoundingSphere(), Lr.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
    else {
      const e = t.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(), Lr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
    }
    return this.intersectsSphere(Lr);
  }
  intersectsSprite(t) {
    Lr.center.set(0, 0, 0);
    const e = Tk.distanceTo(t.center);
    return Lr.radius = 0.7071067811865476 + e, Lr.applyMatrix4(t.matrixWorld), this.intersectsSphere(Lr);
  }
  intersectsSphere(t) {
    const e = this.planes, s = t.center, i = -t.radius;
    for (let o = 0; o < 6; o++)
      if (e[o].distanceToPoint(s) < i)
        return !1;
    return !0;
  }
  intersectsBox(t) {
    const e = this.planes;
    for (let s = 0; s < 6; s++) {
      const i = e[s];
      if (wh.x = i.normal.x > 0 ? t.max.x : t.min.x, wh.y = i.normal.y > 0 ? t.max.y : t.min.y, wh.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(wh) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(t) {
    const e = this.planes;
    for (let s = 0; s < 6; s++)
      if (e[s].distanceToPoint(t) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
h(ny, "Frustum");
let ya = ny;
new Re();
new ya();
new Re();
new Ce(1, 1, 1);
new ya();
new Zs();
new Ys();
new O();
new O();
new O();
new Bi();
new O();
new O();
new Re();
new Fc();
new Ys();
new O();
new O();
new O();
new O();
new Re();
new Fc();
new Ys();
new O();
const iy = class iy extends fs {
  constructor(t, e, s = ga, i, o, r, a = Ts, l = Ts, c, u = ru, m = 1) {
    if (u !== ru && u !== au)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    const d = { width: t, height: e, depth: m };
    super(d, i, o, r, a, l, u, s, c), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(t) {
    return super.copy(t), this.source = new lu(Object.assign({}, t.image)), this.compareFunction = t.compareFunction, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
  }
};
h(iy, "DepthTexture");
let vd = iy;
const sy = class sy extends fs {
  constructor(t = null) {
    super(), this.sourceTexture = t, this.isExternalTexture = !0;
  }
  copy(t) {
    return super.copy(t), this.sourceTexture = t.sourceTexture, this;
  }
};
h(sy, "ExternalTexture");
let bd = sy;
const im = class im extends Ks {
  constructor(t = 1, e = 1, s = 1, i = 32, o = 1, r = !1, a = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: s,
      radialSegments: i,
      heightSegments: o,
      openEnded: r,
      thetaStart: a,
      thetaLength: l
    };
    const c = this;
    i = Math.floor(i), o = Math.floor(o);
    const u = [], m = [], d = [], f = [];
    let p = 0;
    const v = [], _ = s / 2;
    let g = 0;
    w(), r === !1 && (t > 0 && S(!0), e > 0 && S(!1)), this.setIndex(u), this.setAttribute("position", new ei(m, 3)), this.setAttribute("normal", new ei(d, 3)), this.setAttribute("uv", new ei(f, 2));
    function w() {
      const x = new O(), A = new O();
      let C = 0;
      const M = (e - t) / s;
      for (let T = 0; T <= o; T++) {
        const b = [], y = T / o, E = y * (e - t) + t;
        for (let I = 0; I <= i; I++) {
          const B = I / i, D = B * l + a, N = Math.sin(D), V = Math.cos(D);
          A.x = E * N, A.y = -y * s + _, A.z = E * V, m.push(A.x, A.y, A.z), x.set(N, M, V).normalize(), d.push(x.x, x.y, x.z), f.push(B, 1 - y), b.push(p++);
        }
        v.push(b);
      }
      for (let T = 0; T < i; T++)
        for (let b = 0; b < o; b++) {
          const y = v[b][T], E = v[b + 1][T], I = v[b + 1][T + 1], B = v[b][T + 1];
          (t > 0 || b !== 0) && (u.push(y, E, B), C += 3), (e > 0 || b !== o - 1) && (u.push(E, I, B), C += 3);
        }
      c.addGroup(g, C, 0), g += C;
    }
    h(w, "generateTorso");
    function S(x) {
      const A = p, C = new Pe(), M = new O();
      let T = 0;
      const b = x === !0 ? t : e, y = x === !0 ? 1 : -1;
      for (let I = 1; I <= i; I++)
        m.push(0, _ * y, 0), d.push(0, y, 0), f.push(0.5, 0.5), p++;
      const E = p;
      for (let I = 0; I <= i; I++) {
        const D = I / i * l + a, N = Math.cos(D), V = Math.sin(D);
        M.x = b * V, M.y = _ * y, M.z = b * N, m.push(M.x, M.y, M.z), d.push(0, y, 0), C.x = N * 0.5 + 0.5, C.y = V * 0.5 * y + 0.5, f.push(C.x, C.y), p++;
      }
      for (let I = 0; I < i; I++) {
        const B = A + I, D = E + I;
        x === !0 ? u.push(D, D + 1, B) : u.push(D + 1, D, B), T += 3;
      }
      c.addGroup(g, T, x === !0 ? 1 : 2), g += T;
    }
    h(S, "generateCap");
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new im(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength);
  }
};
h(im, "CylinderGeometry");
let yd = im;
const sm = class sm extends yd {
  constructor(t = 1, e = 1, s = 32, i = 1, o = !1, r = 0, a = Math.PI * 2) {
    super(0, t, e, s, i, o, r, a), this.type = "ConeGeometry", this.parameters = {
      radius: t,
      height: e,
      radialSegments: s,
      heightSegments: i,
      openEnded: o,
      thetaStart: r,
      thetaLength: a
    };
  }
  static fromJSON(t) {
    return new sm(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength);
  }
};
h(sm, "ConeGeometry");
let D_ = sm;
new O();
new O();
new O();
new ar();
new O();
const om = class om extends Ks {
  constructor(t = 1, e = 1, s = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: s,
      heightSegments: i
    };
    const o = t / 2, r = e / 2, a = Math.floor(s), l = Math.floor(i), c = a + 1, u = l + 1, m = t / a, d = e / l, f = [], p = [], v = [], _ = [];
    for (let g = 0; g < u; g++) {
      const w = g * d - r;
      for (let S = 0; S < c; S++) {
        const x = S * m - o;
        p.push(x, -w, 0), v.push(0, 0, 1), _.push(S / a), _.push(1 - g / l);
      }
    }
    for (let g = 0; g < l; g++)
      for (let w = 0; w < a; w++) {
        const S = w + c * g, x = w + c * (g + 1), A = w + 1 + c * (g + 1), C = w + 1 + c * g;
        f.push(S, x, C), f.push(x, A, C);
      }
    this.setIndex(f), this.setAttribute("position", new ei(p, 3)), this.setAttribute("normal", new ei(v, 3)), this.setAttribute("uv", new ei(_, 2));
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new om(t.width, t.height, t.widthSegments, t.heightSegments);
  }
};
h(om, "PlaneGeometry");
let hu = om;
const rm = class rm extends Ks {
  constructor(t = 1, e = 32, s = 16, i = 0, o = Math.PI * 2, r = 0, a = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: s,
      phiStart: i,
      phiLength: o,
      thetaStart: r,
      thetaLength: a
    }, e = Math.max(3, Math.floor(e)), s = Math.max(2, Math.floor(s));
    const l = Math.min(r + a, Math.PI);
    let c = 0;
    const u = [], m = new O(), d = new O(), f = [], p = [], v = [], _ = [];
    for (let g = 0; g <= s; g++) {
      const w = [], S = g / s;
      let x = 0;
      g === 0 && r === 0 ? x = 0.5 / e : g === s && l === Math.PI && (x = -0.5 / e);
      for (let A = 0; A <= e; A++) {
        const C = A / e;
        m.x = -t * Math.cos(i + C * o) * Math.sin(r + S * a), m.y = t * Math.cos(r + S * a), m.z = t * Math.sin(i + C * o) * Math.sin(r + S * a), p.push(m.x, m.y, m.z), d.copy(m).normalize(), v.push(d.x, d.y, d.z), _.push(C + x, 1 - S), w.push(c++);
      }
      u.push(w);
    }
    for (let g = 0; g < s; g++)
      for (let w = 0; w < e; w++) {
        const S = u[g][w + 1], x = u[g][w], A = u[g + 1][w], C = u[g + 1][w + 1];
        (g !== 0 || r > 0) && f.push(S, x, C), (g !== s - 1 || l < Math.PI) && f.push(x, A, C);
      }
    this.setIndex(f), this.setAttribute("position", new ei(p, 3)), this.setAttribute("normal", new ei(v, 3)), this.setAttribute("uv", new ei(_, 2));
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new rm(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength);
  }
};
h(rm, "SphereGeometry");
let V_ = rm;
const am = class am extends Ks {
  constructor(t = 1, e = 0.4, s = 12, i = 48, o = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: t,
      tube: e,
      radialSegments: s,
      tubularSegments: i,
      arc: o
    }, s = Math.floor(s), i = Math.floor(i);
    const r = [], a = [], l = [], c = [], u = new O(), m = new O(), d = new O();
    for (let f = 0; f <= s; f++)
      for (let p = 0; p <= i; p++) {
        const v = p / i * o, _ = f / s * Math.PI * 2;
        m.x = (t + e * Math.cos(_)) * Math.cos(v), m.y = (t + e * Math.cos(_)) * Math.sin(v), m.z = e * Math.sin(_), a.push(m.x, m.y, m.z), u.x = t * Math.cos(v), u.y = t * Math.sin(v), d.subVectors(m, u).normalize(), l.push(d.x, d.y, d.z), c.push(p / i), c.push(f / s);
      }
    for (let f = 1; f <= s; f++)
      for (let p = 1; p <= i; p++) {
        const v = (i + 1) * f + p - 1, _ = (i + 1) * (f - 1) + p - 1, g = (i + 1) * (f - 1) + p, w = (i + 1) * f + p;
        r.push(v, _, w), r.push(_, g, w);
      }
    this.setIndex(r), this.setAttribute("position", new ei(a, 3)), this.setAttribute("normal", new ei(l, 3)), this.setAttribute("uv", new ei(c, 2));
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new am(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc);
  }
};
h(am, "TorusGeometry");
let L_ = am;
const oy = class oy extends $o {
  constructor(t) {
    super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new Ce(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ce(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = G3, this.normalScale = new Pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Js(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
  }
};
h(oy, "MeshStandardMaterial");
let du = oy;
const ry = class ry extends $o {
  constructor(t) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Bz, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
  }
};
h(ry, "MeshDepthMaterial");
let N_ = ry;
const ay = class ay extends $o {
  constructor(t) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
  }
};
h(ay, "MeshDistanceMaterial");
let z_ = ay;
const cy = class cy {
  constructor(t, e, s) {
    const i = this;
    let o = !1, r = 0, a = 0, l;
    const c = [];
    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = s, this.abortController = new AbortController(), this.itemStart = function(u) {
      a++, o === !1 && i.onStart !== void 0 && i.onStart(u, r, a), o = !0;
    }, this.itemEnd = function(u) {
      r++, i.onProgress !== void 0 && i.onProgress(u, r, a), r === a && (o = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(u) {
      i.onError !== void 0 && i.onError(u);
    }, this.resolveURL = function(u) {
      return l ? l(u) : u;
    }, this.setURLModifier = function(u) {
      return l = u, this;
    }, this.addHandler = function(u, m) {
      return c.push(u, m), this;
    }, this.removeHandler = function(u) {
      const m = c.indexOf(u);
      return m !== -1 && c.splice(m, 2), this;
    }, this.getHandler = function(u) {
      for (let m = 0, d = c.length; m < d; m += 2) {
        const f = c[m], p = c[m + 1];
        if (f.global && (f.lastIndex = 0), f.test(u))
          return p;
      }
      return null;
    }, this.abort = function() {
      return this.abortController.abort(), this.abortController = new AbortController(), this;
    };
  }
};
h(cy, "LoadingManager");
let k_ = cy;
new k_();
const ly = class ly extends mi {
  constructor(t, e = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Ce(t), this.intensity = e;
  }
  dispose() {
  }
  copy(t, e) {
    return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (e.object.target = this.target.uuid), e;
  }
};
h(ly, "Light");
let Hc = ly;
const Wf = new Re(), nS = new O(), iS = new O(), uy = class uy {
  constructor(t) {
    this.camera = t, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Pe(512, 512), this.mapType = Xs, this.map = null, this.mapPass = null, this.matrix = new Re(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new ya(), this._frameExtents = new Pe(1, 1), this._viewportCount = 1, this._viewports = [
      new an(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(t) {
    const e = this.camera, s = this.matrix;
    nS.setFromMatrixPosition(t.matrixWorld), e.position.copy(nS), iS.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(iS), e.updateMatrixWorld(), Wf.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Wf, e.coordinateSystem, e.reversedDepth), e.reversedDepth ? s.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ) : s.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), s.multiply(Wf);
  }
  getViewport(t) {
    return this._viewports[t];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(t) {
    return this.camera = t.camera.clone(), this.intensity = t.intensity, this.bias = t.bias, this.radius = t.radius, this.autoUpdate = t.autoUpdate, this.needsUpdate = t.needsUpdate, this.normalBias = t.normalBias, this.blurSamples = t.blurSamples, this.mapSize.copy(t.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t = {};
    return this.intensity !== 1 && (t.intensity = this.intensity), this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
  }
};
h(uy, "LightShadow");
let mu = uy;
const hy = class hy extends mu {
  constructor() {
    super(new si(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1, this.aspect = 1;
  }
  updateMatrices(t) {
    const e = this.camera, s = $c * 2 * t.angle * this.focus, i = this.mapSize.width / this.mapSize.height * this.aspect, o = t.distance || e.far;
    (s !== e.fov || i !== e.aspect || o !== e.far) && (e.fov = s, e.aspect = i, e.far = o, e.updateProjectionMatrix()), super.updateMatrices(t);
  }
  copy(t) {
    return super.copy(t), this.focus = t.focus, this;
  }
};
h(hy, "SpotLightShadow");
let U_ = hy;
const dy = class dy extends Hc {
  constructor(t, e, s = 0, i = Math.PI / 3, o = 0, r = 2) {
    super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(mi.DEFAULT_UP), this.updateMatrix(), this.target = new mi(), this.distance = s, this.angle = i, this.penumbra = o, this.decay = r, this.map = null, this.shadow = new U_();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(t) {
    this.intensity = t / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t, e) {
    return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
};
h(dy, "SpotLight");
let xd = dy;
const sS = new Re(), fl = new O(), qf = new O(), my = class my extends mu {
  constructor() {
    super(new si(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Pe(4, 2), this._viewportCount = 6, this._viewports = [
      new an(2, 1, 1, 1),
      new an(0, 1, 1, 1),
      new an(3, 1, 1, 1),
      new an(1, 1, 1, 1),
      new an(3, 0, 1, 1),
      new an(1, 0, 1, 1)
    ], this._cubeDirections = [
      new O(1, 0, 0),
      new O(-1, 0, 0),
      new O(0, 0, 1),
      new O(0, 0, -1),
      new O(0, 1, 0),
      new O(0, -1, 0)
    ], this._cubeUps = [
      new O(0, 1, 0),
      new O(0, 1, 0),
      new O(0, 1, 0),
      new O(0, 1, 0),
      new O(0, 0, 1),
      new O(0, 0, -1)
    ];
  }
  updateMatrices(t, e = 0) {
    const s = this.camera, i = this.matrix, o = t.distance || s.far;
    o !== s.far && (s.far = o, s.updateProjectionMatrix()), fl.setFromMatrixPosition(t.matrixWorld), s.position.copy(fl), qf.copy(s.position), qf.add(this._cubeDirections[e]), s.up.copy(this._cubeUps[e]), s.lookAt(qf), s.updateMatrixWorld(), i.makeTranslation(-fl.x, -fl.y, -fl.z), sS.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse), this._frustum.setFromProjectionMatrix(sS, s.coordinateSystem, s.reversedDepth);
  }
};
h(my, "PointLightShadow");
let O_ = my;
const fy = class fy extends Hc {
  constructor(t, e, s = 0, i = 2) {
    super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = s, this.decay = i, this.shadow = new O_();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(t) {
    this.intensity = t / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t, e) {
    return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
  }
};
h(fy, "PointLight");
let wd = fy;
const py = class py extends uu {
  constructor(t = -1, e = 1, s = 1, i = -1, o = 0.1, r = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = s, this.bottom = i, this.near = o, this.far = r, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
  }
  setViewOffset(t, e, s, i, o, r) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = s, this.view.offsetY = i, this.view.width = o, this.view.height = r, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), s = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let o = s - t, r = s + t, a = i + e, l = i - e;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += c * this.view.offsetX, r = o + c * this.view.width, a -= u * this.view.offsetY, l = a - u * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, r, a, l, this.near, this.far, this.coordinateSystem, this.reversedDepth), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
};
h(py, "OrthographicCamera");
let Sd = py;
const _y = class _y extends mu {
  constructor() {
    super(new Sd(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
};
h(_y, "DirectionalLightShadow");
let $_ = _y;
const gy = class gy extends Hc {
  constructor(t, e) {
    super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(mi.DEFAULT_UP), this.updateMatrix(), this.target = new mi(), this.shadow = new $_();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t) {
    return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
};
h(gy, "DirectionalLight");
let Ll = gy;
const vy = class vy extends Hc {
  constructor(t, e) {
    super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
};
h(vy, "AmbientLight");
let Ad = vy;
new Re();
new Re();
new Re();
const by = class by extends si {
  constructor(t = []) {
    super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = t;
  }
};
h(by, "ArrayCamera");
let F_ = by;
new O();
new O();
new O();
new O();
new O();
new O();
new O();
const X3 = "\\[\\]\\.:\\/", H2 = "[^" + X3 + "]", Ik = "[^" + X3.replace("\\.", "") + "]";
/((?:WC+[\/:])*)/.source.replace("WC", H2);
/(WCOD+)?/.source.replace("WCOD", Ik);
/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", H2);
/\.(WC+)(?:\[(.+)\])?/.source.replace("WC", H2);
new Re();
new Pe();
new O();
new O();
new O();
new O();
new O();
new O();
new O();
new O();
new O();
new Re();
new Re();
new O();
new Ce();
new Ce();
new O();
new O();
new O();
new O();
new uu();
new Zs();
new O();
function oS(n, t, e, s) {
  const i = Bk(s);
  switch (e) {
    case U3:
      return n * t;
    case $3:
      return n * t / i.components * i.byteLength;
    case O2:
      return n * t / i.components * i.byteLength;
    case F3:
      return n * t * 2 / i.components * i.byteLength;
    case $2:
      return n * t * 2 / i.components * i.byteLength;
    case O3:
      return n * t * 3 / i.components * i.byteLength;
    case Ms:
      return n * t * 4 / i.components * i.byteLength;
    case F2:
      return n * t * 4 / i.components * i.byteLength;
    case Vh:
    case Lh:
      return Math.floor((n + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case Nh:
    case zh:
      return Math.floor((n + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case e_:
    case i_:
      return Math.max(n, 16) * Math.max(t, 8) / 4;
    case t_:
    case n_:
      return Math.max(n, 8) * Math.max(t, 8) / 2;
    case s_:
    case o_:
      return Math.floor((n + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case r_:
      return Math.floor((n + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case a_:
      return Math.floor((n + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case c_:
      return Math.floor((n + 4) / 5) * Math.floor((t + 3) / 4) * 16;
    case l_:
      return Math.floor((n + 4) / 5) * Math.floor((t + 4) / 5) * 16;
    case u_:
      return Math.floor((n + 5) / 6) * Math.floor((t + 4) / 5) * 16;
    case h_:
      return Math.floor((n + 5) / 6) * Math.floor((t + 5) / 6) * 16;
    case d_:
      return Math.floor((n + 7) / 8) * Math.floor((t + 4) / 5) * 16;
    case m_:
      return Math.floor((n + 7) / 8) * Math.floor((t + 5) / 6) * 16;
    case f_:
      return Math.floor((n + 7) / 8) * Math.floor((t + 7) / 8) * 16;
    case p_:
      return Math.floor((n + 9) / 10) * Math.floor((t + 4) / 5) * 16;
    case __:
      return Math.floor((n + 9) / 10) * Math.floor((t + 5) / 6) * 16;
    case g_:
      return Math.floor((n + 9) / 10) * Math.floor((t + 7) / 8) * 16;
    case v_:
      return Math.floor((n + 9) / 10) * Math.floor((t + 9) / 10) * 16;
    case b_:
      return Math.floor((n + 11) / 12) * Math.floor((t + 9) / 10) * 16;
    case y_:
      return Math.floor((n + 11) / 12) * Math.floor((t + 11) / 12) * 16;
    case x_:
    case w_:
    case S_:
      return Math.ceil(n / 4) * Math.ceil(t / 4) * 16;
    case A_:
    case M_:
      return Math.ceil(n / 4) * Math.ceil(t / 4) * 8;
    case C_:
    case E_:
      return Math.ceil(n / 4) * Math.ceil(t / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${e} format.`
  );
}
h(oS, "getByteLength");
function Bk(n) {
  switch (n) {
    case Xs:
    case L3:
      return { byteLength: 1, components: 1 };
    case su:
    case N3:
    case Nu:
      return { byteLength: 2, components: 1 };
    case k2:
    case U2:
      return { byteLength: 2, components: 4 };
    case ga:
    case z2:
    case Ro:
      return { byteLength: 4, components: 1 };
    case z3:
    case k3:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${n}.`);
}
h(Bk, "getTextureTypeByteLength");
typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: N2
} }));
typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = N2);
function Z3() {
  let n = null, t = !1, e = null, s = null;
  function i(o, r) {
    e(o, r), s = n.requestAnimationFrame(i);
  }
  return h(i, "onAnimationFrame"), {
    start: /* @__PURE__ */ h(function() {
      t !== !0 && e !== null && (s = n.requestAnimationFrame(i), t = !0);
    }, "start"),
    stop: /* @__PURE__ */ h(function() {
      n.cancelAnimationFrame(s), t = !1;
    }, "stop"),
    setAnimationLoop: /* @__PURE__ */ h(function(o) {
      e = o;
    }, "setAnimationLoop"),
    setContext: /* @__PURE__ */ h(function(o) {
      n = o;
    }, "setContext")
  };
}
h(Z3, "WebGLAnimation");
function Pk(n) {
  const t = /* @__PURE__ */ new WeakMap();
  function e(a, l) {
    const c = a.array, u = a.usage, m = c.byteLength, d = n.createBuffer();
    n.bindBuffer(l, d), n.bufferData(l, c, u), a.onUploadCallback();
    let f;
    if (c instanceof Float32Array)
      f = n.FLOAT;
    else if (typeof Float16Array != "undefined" && c instanceof Float16Array)
      f = n.HALF_FLOAT;
    else if (c instanceof Uint16Array)
      a.isFloat16BufferAttribute ? f = n.HALF_FLOAT : f = n.UNSIGNED_SHORT;
    else if (c instanceof Int16Array)
      f = n.SHORT;
    else if (c instanceof Uint32Array)
      f = n.UNSIGNED_INT;
    else if (c instanceof Int32Array)
      f = n.INT;
    else if (c instanceof Int8Array)
      f = n.BYTE;
    else if (c instanceof Uint8Array)
      f = n.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray)
      f = n.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
    return {
      buffer: d,
      type: f,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: a.version,
      size: m
    };
  }
  h(e, "createBuffer");
  function s(a, l, c) {
    const u = l.array, m = l.updateRanges;
    if (n.bindBuffer(c, a), m.length === 0)
      n.bufferSubData(c, 0, u);
    else {
      m.sort((f, p) => f.start - p.start);
      let d = 0;
      for (let f = 1; f < m.length; f++) {
        const p = m[d], v = m[f];
        v.start <= p.start + p.count + 1 ? p.count = Math.max(
          p.count,
          v.start + v.count - p.start
        ) : (++d, m[d] = v);
      }
      m.length = d + 1;
      for (let f = 0, p = m.length; f < p; f++) {
        const v = m[f];
        n.bufferSubData(
          c,
          v.start * u.BYTES_PER_ELEMENT,
          u,
          v.start,
          v.count
        );
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  h(s, "updateBuffer");
  function i(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), t.get(a);
  }
  h(i, "get");
  function o(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const l = t.get(a);
    l && (n.deleteBuffer(l.buffer), t.delete(a));
  }
  h(o, "remove");
  function r(a, l) {
    if (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute) {
      const u = t.get(a);
      (!u || u.version < a.version) && t.set(a, {
        buffer: a.buffer,
        type: a.type,
        bytesPerElement: a.elementSize,
        version: a.version
      });
      return;
    }
    const c = t.get(a);
    if (c === void 0)
      t.set(a, e(a, l));
    else if (c.version < a.version) {
      if (c.size !== a.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      s(c.buffer, a, l), c.version = a.version;
    }
  }
  return h(r, "update"), {
    get: i,
    remove: o,
    update: r
  };
}
h(Pk, "WebGLAttributes");
var Rk = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Dk = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, Vk = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Lk = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Nk = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, zk = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, kk = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Uk = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Ok = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, $k = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, Fk = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, Gk = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Hk = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, jk = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Wk = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, qk = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, Xk = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Zk = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Yk = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Jk = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, Kk = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Qk = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, tU = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, eU = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, nU = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, iU = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, sU = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, oU = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, rU = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, aU = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, cU = "gl_FragColor = linearToOutputTexel( gl_FragColor );", lU = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, uU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, hU = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, dU = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, mU = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, fU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, pU = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, _U = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, gU = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, vU = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, bU = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, yU = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, xU = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, wU = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, SU = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, AU = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, MU = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, CU = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, EU = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, TU = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, IU = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, BU = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, PU = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, RU = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, DU = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, VU = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, LU = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, NU = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, zU = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, kU = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, UU = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, OU = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, $U = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, FU = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, GU = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, HU = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, jU = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, WU = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, qU = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, XU = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, ZU = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, YU = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, JU = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, KU = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, QU = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, tO = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, eO = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, nO = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, iO = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, sO = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, oO = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, rO = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, aO = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, cO = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, lO = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, uO = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, hO = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, dO = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, mO = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, fO = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, pO = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, _O = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, gO = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, vO = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, bO = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, yO = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, xO = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, wO = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, SO = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, AO = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, MO = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, CO = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, EO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, TO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, IO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, BO = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const PO = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, RO = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, DO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, VO = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, LO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, NO = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, zO = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, kO = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, UO = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, OO = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, $O = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, FO = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, GO = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, HO = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, jO = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, WO = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, qO = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, XO = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ZO = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, YO = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, JO = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, KO = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, QO = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, t$ = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, e$ = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, n$ = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, i$ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, s$ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, o$ = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, r$ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, a$ = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, c$ = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, l$ = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, u$ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Te = {
  alphahash_fragment: Rk,
  alphahash_pars_fragment: Dk,
  alphamap_fragment: Vk,
  alphamap_pars_fragment: Lk,
  alphatest_fragment: Nk,
  alphatest_pars_fragment: zk,
  aomap_fragment: kk,
  aomap_pars_fragment: Uk,
  batching_pars_vertex: Ok,
  batching_vertex: $k,
  begin_vertex: Fk,
  beginnormal_vertex: Gk,
  bsdfs: Hk,
  iridescence_fragment: jk,
  bumpmap_pars_fragment: Wk,
  clipping_planes_fragment: qk,
  clipping_planes_pars_fragment: Xk,
  clipping_planes_pars_vertex: Zk,
  clipping_planes_vertex: Yk,
  color_fragment: Jk,
  color_pars_fragment: Kk,
  color_pars_vertex: Qk,
  color_vertex: tU,
  common: eU,
  cube_uv_reflection_fragment: nU,
  defaultnormal_vertex: iU,
  displacementmap_pars_vertex: sU,
  displacementmap_vertex: oU,
  emissivemap_fragment: rU,
  emissivemap_pars_fragment: aU,
  colorspace_fragment: cU,
  colorspace_pars_fragment: lU,
  envmap_fragment: uU,
  envmap_common_pars_fragment: hU,
  envmap_pars_fragment: dU,
  envmap_pars_vertex: mU,
  envmap_physical_pars_fragment: AU,
  envmap_vertex: fU,
  fog_vertex: pU,
  fog_pars_vertex: _U,
  fog_fragment: gU,
  fog_pars_fragment: vU,
  gradientmap_pars_fragment: bU,
  lightmap_pars_fragment: yU,
  lights_lambert_fragment: xU,
  lights_lambert_pars_fragment: wU,
  lights_pars_begin: SU,
  lights_toon_fragment: MU,
  lights_toon_pars_fragment: CU,
  lights_phong_fragment: EU,
  lights_phong_pars_fragment: TU,
  lights_physical_fragment: IU,
  lights_physical_pars_fragment: BU,
  lights_fragment_begin: PU,
  lights_fragment_maps: RU,
  lights_fragment_end: DU,
  logdepthbuf_fragment: VU,
  logdepthbuf_pars_fragment: LU,
  logdepthbuf_pars_vertex: NU,
  logdepthbuf_vertex: zU,
  map_fragment: kU,
  map_pars_fragment: UU,
  map_particle_fragment: OU,
  map_particle_pars_fragment: $U,
  metalnessmap_fragment: FU,
  metalnessmap_pars_fragment: GU,
  morphinstance_vertex: HU,
  morphcolor_vertex: jU,
  morphnormal_vertex: WU,
  morphtarget_pars_vertex: qU,
  morphtarget_vertex: XU,
  normal_fragment_begin: ZU,
  normal_fragment_maps: YU,
  normal_pars_fragment: JU,
  normal_pars_vertex: KU,
  normal_vertex: QU,
  normalmap_pars_fragment: tO,
  clearcoat_normal_fragment_begin: eO,
  clearcoat_normal_fragment_maps: nO,
  clearcoat_pars_fragment: iO,
  iridescence_pars_fragment: sO,
  opaque_fragment: oO,
  packing: rO,
  premultiplied_alpha_fragment: aO,
  project_vertex: cO,
  dithering_fragment: lO,
  dithering_pars_fragment: uO,
  roughnessmap_fragment: hO,
  roughnessmap_pars_fragment: dO,
  shadowmap_pars_fragment: mO,
  shadowmap_pars_vertex: fO,
  shadowmap_vertex: pO,
  shadowmask_pars_fragment: _O,
  skinbase_vertex: gO,
  skinning_pars_vertex: vO,
  skinning_vertex: bO,
  skinnormal_vertex: yO,
  specularmap_fragment: xO,
  specularmap_pars_fragment: wO,
  tonemapping_fragment: SO,
  tonemapping_pars_fragment: AO,
  transmission_fragment: MO,
  transmission_pars_fragment: CO,
  uv_pars_fragment: EO,
  uv_pars_vertex: TO,
  uv_vertex: IO,
  worldpos_vertex: BO,
  background_vert: PO,
  background_frag: RO,
  backgroundCube_vert: DO,
  backgroundCube_frag: VO,
  cube_vert: LO,
  cube_frag: NO,
  depth_vert: zO,
  depth_frag: kO,
  distanceRGBA_vert: UO,
  distanceRGBA_frag: OO,
  equirect_vert: $O,
  equirect_frag: FO,
  linedashed_vert: GO,
  linedashed_frag: HO,
  meshbasic_vert: jO,
  meshbasic_frag: WO,
  meshlambert_vert: qO,
  meshlambert_frag: XO,
  meshmatcap_vert: ZO,
  meshmatcap_frag: YO,
  meshnormal_vert: JO,
  meshnormal_frag: KO,
  meshphong_vert: QO,
  meshphong_frag: t$,
  meshphysical_vert: e$,
  meshphysical_frag: n$,
  meshtoon_vert: i$,
  meshtoon_frag: s$,
  points_vert: o$,
  points_frag: r$,
  shadow_vert: a$,
  shadow_frag: c$,
  sprite_vert: l$,
  sprite_frag: u$
}, zt = {
  common: {
    diffuse: { value: new Ce(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: new Ae() },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Ae() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: new Ae() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: new Ae() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: new Ae() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: new Ae() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: new Ae() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: new Ae() },
    normalScale: { value: new Pe(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: new Ae() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: new Ae() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: new Ae() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: new Ae() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Ce(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Ce(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Ae() },
    alphaTest: { value: 0 },
    uvTransform: { value: new Ae() }
  },
  sprite: {
    diffuse: { value: new Ce(16777215) },
    opacity: { value: 1 },
    center: { value: new Pe(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: new Ae() },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Ae() },
    alphaTest: { value: 0 }
  }
}, Os = {
  basic: {
    uniforms: vi([
      zt.common,
      zt.specularmap,
      zt.envmap,
      zt.aomap,
      zt.lightmap,
      zt.fog
    ]),
    vertexShader: Te.meshbasic_vert,
    fragmentShader: Te.meshbasic_frag
  },
  lambert: {
    uniforms: vi([
      zt.common,
      zt.specularmap,
      zt.envmap,
      zt.aomap,
      zt.lightmap,
      zt.emissivemap,
      zt.bumpmap,
      zt.normalmap,
      zt.displacementmap,
      zt.fog,
      zt.lights,
      {
        emissive: { value: new Ce(0) }
      }
    ]),
    vertexShader: Te.meshlambert_vert,
    fragmentShader: Te.meshlambert_frag
  },
  phong: {
    uniforms: vi([
      zt.common,
      zt.specularmap,
      zt.envmap,
      zt.aomap,
      zt.lightmap,
      zt.emissivemap,
      zt.bumpmap,
      zt.normalmap,
      zt.displacementmap,
      zt.fog,
      zt.lights,
      {
        emissive: { value: new Ce(0) },
        specular: { value: new Ce(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Te.meshphong_vert,
    fragmentShader: Te.meshphong_frag
  },
  standard: {
    uniforms: vi([
      zt.common,
      zt.envmap,
      zt.aomap,
      zt.lightmap,
      zt.emissivemap,
      zt.bumpmap,
      zt.normalmap,
      zt.displacementmap,
      zt.roughnessmap,
      zt.metalnessmap,
      zt.fog,
      zt.lights,
      {
        emissive: { value: new Ce(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Te.meshphysical_vert,
    fragmentShader: Te.meshphysical_frag
  },
  toon: {
    uniforms: vi([
      zt.common,
      zt.aomap,
      zt.lightmap,
      zt.emissivemap,
      zt.bumpmap,
      zt.normalmap,
      zt.displacementmap,
      zt.gradientmap,
      zt.fog,
      zt.lights,
      {
        emissive: { value: new Ce(0) }
      }
    ]),
    vertexShader: Te.meshtoon_vert,
    fragmentShader: Te.meshtoon_frag
  },
  matcap: {
    uniforms: vi([
      zt.common,
      zt.bumpmap,
      zt.normalmap,
      zt.displacementmap,
      zt.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Te.meshmatcap_vert,
    fragmentShader: Te.meshmatcap_frag
  },
  points: {
    uniforms: vi([
      zt.points,
      zt.fog
    ]),
    vertexShader: Te.points_vert,
    fragmentShader: Te.points_frag
  },
  dashed: {
    uniforms: vi([
      zt.common,
      zt.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Te.linedashed_vert,
    fragmentShader: Te.linedashed_frag
  },
  depth: {
    uniforms: vi([
      zt.common,
      zt.displacementmap
    ]),
    vertexShader: Te.depth_vert,
    fragmentShader: Te.depth_frag
  },
  normal: {
    uniforms: vi([
      zt.common,
      zt.bumpmap,
      zt.normalmap,
      zt.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Te.meshnormal_vert,
    fragmentShader: Te.meshnormal_frag
  },
  sprite: {
    uniforms: vi([
      zt.sprite,
      zt.fog
    ]),
    vertexShader: Te.sprite_vert,
    fragmentShader: Te.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Ae() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Te.background_vert,
    fragmentShader: Te.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: new Ae() }
    },
    vertexShader: Te.backgroundCube_vert,
    fragmentShader: Te.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Te.cube_vert,
    fragmentShader: Te.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Te.equirect_vert,
    fragmentShader: Te.equirect_frag
  },
  distanceRGBA: {
    uniforms: vi([
      zt.common,
      zt.displacementmap,
      {
        referencePosition: { value: new O() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Te.distanceRGBA_vert,
    fragmentShader: Te.distanceRGBA_frag
  },
  shadow: {
    uniforms: vi([
      zt.lights,
      zt.fog,
      {
        color: { value: new Ce(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Te.shadow_vert,
    fragmentShader: Te.shadow_frag
  }
};
Os.physical = {
  uniforms: vi([
    Os.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Ae() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Ae() },
      clearcoatNormalScale: { value: new Pe(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Ae() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Ae() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Ae() },
      sheen: { value: 0 },
      sheenColor: { value: new Ce(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Ae() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Ae() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Ae() },
      transmissionSamplerSize: { value: new Pe() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Ae() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Ce(0) },
      specularColor: { value: new Ce(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Ae() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Ae() },
      anisotropyVector: { value: new Pe() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Ae() }
    }
  ]),
  vertexShader: Te.meshphysical_vert,
  fragmentShader: Te.meshphysical_frag
};
const Sh = { r: 0, b: 0, g: 0 }, Nr = new Js(), h$ = new Re();
function d$(n, t, e, s, i, o, r) {
  const a = new Ce(0);
  let l = o === !0 ? 0 : 1, c, u, m = null, d = 0, f = null;
  function p(S) {
    let x = S.isScene === !0 ? S.background : null;
    return x && x.isTexture && (x = (S.backgroundBlurriness > 0 ? e : t).get(x)), x;
  }
  h(p, "getBackground");
  function v(S) {
    let x = !1;
    const A = p(S);
    A === null ? g(a, l) : A && A.isColor && (g(A, 1), x = !0);
    const C = n.xr.getEnvironmentBlendMode();
    C === "additive" ? s.buffers.color.setClear(0, 0, 0, 1, r) : C === "alpha-blend" && s.buffers.color.setClear(0, 0, 0, 0, r), (n.autoClear || x) && (s.buffers.depth.setTest(!0), s.buffers.depth.setMask(!0), s.buffers.color.setMask(!0), n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
  }
  h(v, "render");
  function _(S, x) {
    const A = p(x);
    A && (A.isCubeTexture || A.mapping === zm) ? (u === void 0 && (u = new Bi(
      new ba(1, 1, 1),
      new Qs({
        name: "BackgroundCubeMaterial",
        uniforms: Gc(Os.backgroundCube.uniforms),
        vertexShader: Os.backgroundCube.vertexShader,
        fragmentShader: Os.backgroundCube.fragmentShader,
        side: Di,
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        allowOverride: !1
      })
    ), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(C, M, T) {
      this.matrixWorld.copyPosition(T.matrixWorld);
    }, Object.defineProperty(u.material, "envMap", {
      get: /* @__PURE__ */ h(function() {
        return this.uniforms.envMap.value;
      }, "get")
    }), i.update(u)), Nr.copy(x.backgroundRotation), Nr.x *= -1, Nr.y *= -1, Nr.z *= -1, A.isCubeTexture && A.isRenderTargetTexture === !1 && (Nr.y *= -1, Nr.z *= -1), u.material.uniforms.envMap.value = A, u.material.uniforms.flipEnvMap.value = A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = x.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(h$.makeRotationFromEuler(Nr)), u.material.toneMapped = Qe.getTransfer(A.colorSpace) !== pn, (m !== A || d !== A.version || f !== n.toneMapping) && (u.material.needsUpdate = !0, m = A, d = A.version, f = n.toneMapping), u.layers.enableAll(), S.unshift(u, u.geometry, u.material, 0, 0, null)) : A && A.isTexture && (c === void 0 && (c = new Bi(
      new hu(2, 2),
      new Qs({
        name: "BackgroundMaterial",
        uniforms: Gc(Os.background.uniforms),
        vertexShader: Os.background.vertexShader,
        fragmentShader: Os.background.fragmentShader,
        side: yr,
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        allowOverride: !1
      })
    ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
      get: /* @__PURE__ */ h(function() {
        return this.uniforms.t2D.value;
      }, "get")
    }), i.update(c)), c.material.uniforms.t2D.value = A, c.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, c.material.toneMapped = Qe.getTransfer(A.colorSpace) !== pn, A.matrixAutoUpdate === !0 && A.updateMatrix(), c.material.uniforms.uvTransform.value.copy(A.matrix), (m !== A || d !== A.version || f !== n.toneMapping) && (c.material.needsUpdate = !0, m = A, d = A.version, f = n.toneMapping), c.layers.enableAll(), S.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  h(_, "addToRenderList");
  function g(S, x) {
    S.getRGB(Sh, q3(n)), s.buffers.color.setClear(Sh.r, Sh.g, Sh.b, x, r);
  }
  h(g, "setClear");
  function w() {
    u !== void 0 && (u.geometry.dispose(), u.material.dispose(), u = void 0), c !== void 0 && (c.geometry.dispose(), c.material.dispose(), c = void 0);
  }
  return h(w, "dispose"), {
    getClearColor: /* @__PURE__ */ h(function() {
      return a;
    }, "getClearColor"),
    setClearColor: /* @__PURE__ */ h(function(S, x = 1) {
      a.set(S), l = x, g(a, l);
    }, "setClearColor"),
    getClearAlpha: /* @__PURE__ */ h(function() {
      return l;
    }, "getClearAlpha"),
    setClearAlpha: /* @__PURE__ */ h(function(S) {
      l = S, g(a, l);
    }, "setClearAlpha"),
    render: v,
    addToRenderList: _,
    dispose: w
  };
}
h(d$, "WebGLBackground");
function m$(n, t) {
  const e = n.getParameter(n.MAX_VERTEX_ATTRIBS), s = {}, i = d(null);
  let o = i, r = !1;
  function a(y, E, I, B, D) {
    let N = !1;
    const V = m(B, I, E);
    o !== V && (o = V, c(o.object)), N = f(y, B, I, D), N && p(y, B, I, D), D !== null && t.update(D, n.ELEMENT_ARRAY_BUFFER), (N || r) && (r = !1, x(y, E, I, B), D !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(D).buffer));
  }
  h(a, "setup");
  function l() {
    return n.createVertexArray();
  }
  h(l, "createVertexArrayObject");
  function c(y) {
    return n.bindVertexArray(y);
  }
  h(c, "bindVertexArrayObject");
  function u(y) {
    return n.deleteVertexArray(y);
  }
  h(u, "deleteVertexArrayObject");
  function m(y, E, I) {
    const B = I.wireframe === !0;
    let D = s[y.id];
    D === void 0 && (D = {}, s[y.id] = D);
    let N = D[E.id];
    N === void 0 && (N = {}, D[E.id] = N);
    let V = N[B];
    return V === void 0 && (V = d(l()), N[B] = V), V;
  }
  h(m, "getBindingState");
  function d(y) {
    const E = [], I = [], B = [];
    for (let D = 0; D < e; D++)
      E[D] = 0, I[D] = 0, B[D] = 0;
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: E,
      enabledAttributes: I,
      attributeDivisors: B,
      object: y,
      attributes: {},
      index: null
    };
  }
  h(d, "createBindingState");
  function f(y, E, I, B) {
    const D = o.attributes, N = E.attributes;
    let V = 0;
    const G = I.getAttributes();
    for (const U in G)
      if (G[U].location >= 0) {
        const tt = D[U];
        let K = N[U];
        if (K === void 0 && (U === "instanceMatrix" && y.instanceMatrix && (K = y.instanceMatrix), U === "instanceColor" && y.instanceColor && (K = y.instanceColor)), tt === void 0 || tt.attribute !== K || K && tt.data !== K.data) return !0;
        V++;
      }
    return o.attributesNum !== V || o.index !== B;
  }
  h(f, "needsUpdate");
  function p(y, E, I, B) {
    const D = {}, N = E.attributes;
    let V = 0;
    const G = I.getAttributes();
    for (const U in G)
      if (G[U].location >= 0) {
        let tt = N[U];
        tt === void 0 && (U === "instanceMatrix" && y.instanceMatrix && (tt = y.instanceMatrix), U === "instanceColor" && y.instanceColor && (tt = y.instanceColor));
        const K = {};
        K.attribute = tt, tt && tt.data && (K.data = tt.data), D[U] = K, V++;
      }
    o.attributes = D, o.attributesNum = V, o.index = B;
  }
  h(p, "saveCache");
  function v() {
    const y = o.newAttributes;
    for (let E = 0, I = y.length; E < I; E++)
      y[E] = 0;
  }
  h(v, "initAttributes");
  function _(y) {
    g(y, 0);
  }
  h(_, "enableAttribute");
  function g(y, E) {
    const I = o.newAttributes, B = o.enabledAttributes, D = o.attributeDivisors;
    I[y] = 1, B[y] === 0 && (n.enableVertexAttribArray(y), B[y] = 1), D[y] !== E && (n.vertexAttribDivisor(y, E), D[y] = E);
  }
  h(g, "enableAttributeAndDivisor");
  function w() {
    const y = o.newAttributes, E = o.enabledAttributes;
    for (let I = 0, B = E.length; I < B; I++)
      E[I] !== y[I] && (n.disableVertexAttribArray(I), E[I] = 0);
  }
  h(w, "disableUnusedAttributes");
  function S(y, E, I, B, D, N, V) {
    V === !0 ? n.vertexAttribIPointer(y, E, I, D, N) : n.vertexAttribPointer(y, E, I, B, D, N);
  }
  h(S, "vertexAttribPointer");
  function x(y, E, I, B) {
    v();
    const D = B.attributes, N = I.getAttributes(), V = E.defaultAttributeValues;
    for (const G in N) {
      const U = N[G];
      if (U.location >= 0) {
        let j = D[G];
        if (j === void 0 && (G === "instanceMatrix" && y.instanceMatrix && (j = y.instanceMatrix), G === "instanceColor" && y.instanceColor && (j = y.instanceColor)), j !== void 0) {
          const tt = j.normalized, K = j.itemSize, $ = t.get(j);
          if ($ === void 0) continue;
          const lt = $.buffer, gt = $.type, _t = $.bytesPerElement, Y = gt === n.INT || gt === n.UNSIGNED_INT || j.gpuType === z2;
          if (j.isInterleavedBufferAttribute) {
            const it = j.data, J = it.stride, dt = j.offset;
            if (it.isInstancedInterleavedBuffer) {
              for (let vt = 0; vt < U.locationSize; vt++)
                g(U.location + vt, it.meshPerAttribute);
              y.isInstancedMesh !== !0 && B._maxInstanceCount === void 0 && (B._maxInstanceCount = it.meshPerAttribute * it.count);
            } else
              for (let vt = 0; vt < U.locationSize; vt++)
                _(U.location + vt);
            n.bindBuffer(n.ARRAY_BUFFER, lt);
            for (let vt = 0; vt < U.locationSize; vt++)
              S(
                U.location + vt,
                K / U.locationSize,
                gt,
                tt,
                J * _t,
                (dt + K / U.locationSize * vt) * _t,
                Y
              );
          } else {
            if (j.isInstancedBufferAttribute) {
              for (let it = 0; it < U.locationSize; it++)
                g(U.location + it, j.meshPerAttribute);
              y.isInstancedMesh !== !0 && B._maxInstanceCount === void 0 && (B._maxInstanceCount = j.meshPerAttribute * j.count);
            } else
              for (let it = 0; it < U.locationSize; it++)
                _(U.location + it);
            n.bindBuffer(n.ARRAY_BUFFER, lt);
            for (let it = 0; it < U.locationSize; it++)
              S(
                U.location + it,
                K / U.locationSize,
                gt,
                tt,
                K * _t,
                K / U.locationSize * it * _t,
                Y
              );
          }
        } else if (V !== void 0) {
          const tt = V[G];
          if (tt !== void 0)
            switch (tt.length) {
              case 2:
                n.vertexAttrib2fv(U.location, tt);
                break;
              case 3:
                n.vertexAttrib3fv(U.location, tt);
                break;
              case 4:
                n.vertexAttrib4fv(U.location, tt);
                break;
              default:
                n.vertexAttrib1fv(U.location, tt);
            }
        }
      }
    }
    w();
  }
  h(x, "setupVertexAttributes");
  function A() {
    T();
    for (const y in s) {
      const E = s[y];
      for (const I in E) {
        const B = E[I];
        for (const D in B)
          u(B[D].object), delete B[D];
        delete E[I];
      }
      delete s[y];
    }
  }
  h(A, "dispose");
  function C(y) {
    if (s[y.id] === void 0) return;
    const E = s[y.id];
    for (const I in E) {
      const B = E[I];
      for (const D in B)
        u(B[D].object), delete B[D];
      delete E[I];
    }
    delete s[y.id];
  }
  h(C, "releaseStatesOfGeometry");
  function M(y) {
    for (const E in s) {
      const I = s[E];
      if (I[y.id] === void 0) continue;
      const B = I[y.id];
      for (const D in B)
        u(B[D].object), delete B[D];
      delete I[y.id];
    }
  }
  h(M, "releaseStatesOfProgram");
  function T() {
    b(), r = !0, o !== i && (o = i, c(o.object));
  }
  h(T, "reset");
  function b() {
    i.geometry = null, i.program = null, i.wireframe = !1;
  }
  return h(b, "resetDefaultState"), {
    setup: a,
    reset: T,
    resetDefaultState: b,
    dispose: A,
    releaseStatesOfGeometry: C,
    releaseStatesOfProgram: M,
    initAttributes: v,
    enableAttribute: _,
    disableUnusedAttributes: w
  };
}
h(m$, "WebGLBindingStates");
function f$(n, t, e) {
  let s;
  function i(c) {
    s = c;
  }
  h(i, "setMode");
  function o(c, u) {
    n.drawArrays(s, c, u), e.update(u, s, 1);
  }
  h(o, "render");
  function r(c, u, m) {
    m !== 0 && (n.drawArraysInstanced(s, c, u, m), e.update(u, s, m));
  }
  h(r, "renderInstances");
  function a(c, u, m) {
    if (m === 0) return;
    t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(s, c, 0, u, 0, m);
    let f = 0;
    for (let p = 0; p < m; p++)
      f += u[p];
    e.update(f, s, 1);
  }
  h(a, "renderMultiDraw");
  function l(c, u, m, d) {
    if (m === 0) return;
    const f = t.get("WEBGL_multi_draw");
    if (f === null)
      for (let p = 0; p < c.length; p++)
        r(c[p], u[p], d[p]);
    else {
      f.multiDrawArraysInstancedWEBGL(s, c, 0, u, 0, d, 0, m);
      let p = 0;
      for (let v = 0; v < m; v++)
        p += u[v] * d[v];
      e.update(p, s, 1);
    }
  }
  h(l, "renderMultiDrawInstances"), this.setMode = i, this.render = o, this.renderInstances = r, this.renderMultiDraw = a, this.renderMultiDrawInstances = l;
}
h(f$, "WebGLBufferRenderer");
function p$(n, t, e, s) {
  let i;
  function o() {
    if (i !== void 0) return i;
    if (t.has("EXT_texture_filter_anisotropic") === !0) {
      const M = t.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(M.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  h(o, "getMaxAnisotropy");
  function r(M) {
    return !(M !== Ms && s.convert(M) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  h(r, "textureFormatReadable");
  function a(M) {
    const T = M === Nu && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
    return !(M !== Xs && s.convert(M) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && M !== Ro && !T);
  }
  h(a, "textureTypeReadable");
  function l(M) {
    if (M === "highp") {
      if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
        return "highp";
      M = "mediump";
    }
    return M === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  h(l, "getMaxPrecision");
  let c = e.precision !== void 0 ? e.precision : "highp";
  const u = l(c);
  u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."), c = u);
  const m = e.logarithmicDepthBuffer === !0, d = e.reversedDepthBuffer === !0 && t.has("EXT_clip_control"), f = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), p = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), v = n.getParameter(n.MAX_TEXTURE_SIZE), _ = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), g = n.getParameter(n.MAX_VERTEX_ATTRIBS), w = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), S = n.getParameter(n.MAX_VARYING_VECTORS), x = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), A = p > 0, C = n.getParameter(n.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: o,
    getMaxPrecision: l,
    textureFormatReadable: r,
    textureTypeReadable: a,
    precision: c,
    logarithmicDepthBuffer: m,
    reversedDepthBuffer: d,
    maxTextures: f,
    maxVertexTextures: p,
    maxTextureSize: v,
    maxCubemapSize: _,
    maxAttributes: g,
    maxVertexUniforms: w,
    maxVaryings: S,
    maxFragmentUniforms: x,
    vertexTextures: A,
    maxSamples: C
  };
}
h(p$, "WebGLCapabilities");
function _$(n) {
  const t = this;
  let e = null, s = 0, i = !1, o = !1;
  const r = new Co(), a = new Ae(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(m, d) {
    const f = m.length !== 0 || d || s !== 0 || i;
    return i = d, s = m.length, f;
  }, this.beginShadows = function() {
    o = !0, u(null);
  }, this.endShadows = function() {
    o = !1;
  }, this.setGlobalState = function(m, d) {
    e = u(m, d, 0);
  }, this.setState = function(m, d, f) {
    const p = m.clippingPlanes, v = m.clipIntersection, _ = m.clipShadows, g = n.get(m);
    if (!i || p === null || p.length === 0 || o && !_)
      o ? u(null) : c();
    else {
      const w = o ? 0 : s, S = w * 4;
      let x = g.clippingState || null;
      l.value = x, x = u(p, d, S, f);
      for (let A = 0; A !== S; ++A)
        x[A] = e[A];
      g.clippingState = x, this.numIntersection = v ? this.numPlanes : 0, this.numPlanes += w;
    }
  };
  function c() {
    l.value !== e && (l.value = e, l.needsUpdate = s > 0), t.numPlanes = s, t.numIntersection = 0;
  }
  h(c, "resetGlobalState");
  function u(m, d, f, p) {
    const v = m !== null ? m.length : 0;
    let _ = null;
    if (v !== 0) {
      if (_ = l.value, p !== !0 || _ === null) {
        const g = f + v * 4, w = d.matrixWorldInverse;
        a.getNormalMatrix(w), (_ === null || _.length < g) && (_ = new Float32Array(g));
        for (let S = 0, x = f; S !== v; ++S, x += 4)
          r.copy(m[S]).applyMatrix4(w, a), r.normal.toArray(_, x), _[x + 3] = r.constant;
      }
      l.value = _, l.needsUpdate = !0;
    }
    return t.numPlanes = v, t.numIntersection = 0, _;
  }
  h(u, "projectPlanes");
}
h(_$, "WebGLClipping");
function g$(n) {
  let t = /* @__PURE__ */ new WeakMap();
  function e(r, a) {
    return a === Yp ? r.mapping = kc : a === Jp && (r.mapping = Uc), r;
  }
  h(e, "mapTextureMapping");
  function s(r) {
    if (r && r.isTexture) {
      const a = r.mapping;
      if (a === Yp || a === Jp)
        if (t.has(r)) {
          const l = t.get(r).texture;
          return e(l, r.mapping);
        } else {
          const l = r.image;
          if (l && l.height > 0) {
            const c = new R_(l.height);
            return c.fromEquirectangularTexture(n, r), t.set(r, c), r.addEventListener("dispose", i), e(c.texture, r.mapping);
          } else
            return null;
        }
    }
    return r;
  }
  h(s, "get");
  function i(r) {
    const a = r.target;
    a.removeEventListener("dispose", i);
    const l = t.get(a);
    l !== void 0 && (t.delete(a), l.dispose());
  }
  h(i, "onTextureDispose");
  function o() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return h(o, "dispose"), {
    get: s,
    dispose: o
  };
}
h(g$, "WebGLCubeMaps");
const _c = 4, rS = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Xr = 20, Xf = new Sd(), aS = new Ce();
let Zf = null, Yf = 0, Jf = 0, Kf = !1;
const Hr = (1 + Math.sqrt(5)) / 2, oc = 1 / Hr, cS = [
  new O(-Hr, oc, 0),
  new O(Hr, oc, 0),
  new O(-oc, 0, Hr),
  new O(oc, 0, Hr),
  new O(0, Hr, -oc),
  new O(0, Hr, oc),
  new O(-1, 1, -1),
  new O(1, 1, -1),
  new O(-1, 1, 1),
  new O(1, 1, 1)
], v$ = new O(), yy = class yy {
  constructor(t) {
    this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(t, e = 0, s = 0.1, i = 100, o = {}) {
    const {
      size: r = 256,
      position: a = v$
    } = o;
    Zf = this._renderer.getRenderTarget(), Yf = this._renderer.getActiveCubeFace(), Jf = this._renderer.getActiveMipmapLevel(), Kf = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(r);
    const l = this._allocateTargets();
    return l.depthBuffer = !0, this._sceneToCubeUV(t, s, i, l, a), e > 0 && this._blur(l, 0, 0, e), this._applyPMREM(l), this._cleanup(l), l;
  }
  fromEquirectangular(t, e = null) {
    return this._fromTexture(t, e);
  }
  fromCubemap(t, e = null) {
    return this._fromTexture(t, e);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = hS(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = uS(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(t) {
    this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let t = 0; t < this._lodPlanes.length; t++)
      this._lodPlanes[t].dispose();
  }
  _cleanup(t) {
    this._renderer.setRenderTarget(Zf, Yf, Jf), this._renderer.xr.enabled = Kf, t.scissorTest = !1, Ah(t, 0, 0, t.width, t.height);
  }
  _fromTexture(t, e) {
    t.mapping === kc || t.mapping === Uc ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), Zf = this._renderer.getRenderTarget(), Yf = this._renderer.getActiveCubeFace(), Jf = this._renderer.getActiveMipmapLevel(), Kf = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const s = e || this._allocateTargets();
    return this._textureToCubeUV(t, s), this._applyPMREM(s), this._cleanup(s), s;
  }
  _allocateTargets() {
    const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, s = {
      magFilter: $s,
      minFilter: $s,
      generateMipmaps: !1,
      type: Nu,
      format: Ms,
      colorSpace: Oc,
      depthBuffer: !1
    }, i = lS(t, e, s);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = lS(t, e, s);
      const { _lodMax: o } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = b$(o)), this._blurMaterial = y$(o, t, e);
    }
    return i;
  }
  _compileMaterial(t) {
    const e = new Bi(this._lodPlanes[0], t);
    this._renderer.compile(e, Xf);
  }
  _sceneToCubeUV(t, e, s, i, o) {
    const l = new si(90, 1, e, s), c = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], m = this._renderer, d = m.autoClear, f = m.toneMapping;
    m.getClearColor(aS), m.toneMapping = dr, m.autoClear = !1, m.state.buffers.depth.getReversed() && (m.setRenderTarget(i), m.clearDepth(), m.setRenderTarget(null));
    const v = new fd({
      name: "PMREM.Background",
      side: Di,
      depthWrite: !1,
      depthTest: !1
    }), _ = new Bi(new ba(), v);
    let g = !1;
    const w = t.background;
    w ? w.isColor && (v.color.copy(w), t.background = null, g = !0) : (v.color.copy(aS), g = !0);
    for (let S = 0; S < 6; S++) {
      const x = S % 3;
      x === 0 ? (l.up.set(0, c[S], 0), l.position.set(o.x, o.y, o.z), l.lookAt(o.x + u[S], o.y, o.z)) : x === 1 ? (l.up.set(0, 0, c[S]), l.position.set(o.x, o.y, o.z), l.lookAt(o.x, o.y + u[S], o.z)) : (l.up.set(0, c[S], 0), l.position.set(o.x, o.y, o.z), l.lookAt(o.x, o.y, o.z + u[S]));
      const A = this._cubeSize;
      Ah(i, x * A, S > 2 ? A : 0, A, A), m.setRenderTarget(i), g && m.render(_, l), m.render(t, l);
    }
    _.geometry.dispose(), _.material.dispose(), m.toneMapping = f, m.autoClear = d, t.background = w;
  }
  _textureToCubeUV(t, e) {
    const s = this._renderer, i = t.mapping === kc || t.mapping === Uc;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = hS()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = uS());
    const o = i ? this._cubemapMaterial : this._equirectMaterial, r = new Bi(this._lodPlanes[0], o), a = o.uniforms;
    a.envMap.value = t;
    const l = this._cubeSize;
    Ah(e, 0, 0, 3 * l, 2 * l), s.setRenderTarget(e), s.render(r, Xf);
  }
  _applyPMREM(t) {
    const e = this._renderer, s = e.autoClear;
    e.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let o = 1; o < i; o++) {
      const r = Math.sqrt(this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1]), a = cS[(i - o - 1) % cS.length];
      this._blur(t, o - 1, o, r, a);
    }
    e.autoClear = s;
  }
  _blur(t, e, s, i, o) {
    const r = this._pingPongRenderTarget;
    this._halfBlur(
      t,
      r,
      e,
      s,
      i,
      "latitudinal",
      o
    ), this._halfBlur(
      r,
      t,
      s,
      s,
      i,
      "longitudinal",
      o
    );
  }
  _halfBlur(t, e, s, i, o, r, a) {
    const l = this._renderer, c = this._blurMaterial;
    r !== "latitudinal" && r !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const u = 3, m = new Bi(this._lodPlanes[i], c), d = c.uniforms, f = this._sizeLods[s] - 1, p = isFinite(o) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * Xr - 1), v = o / p, _ = isFinite(o) ? 1 + Math.floor(u * v) : Xr;
    _ > Xr && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${Xr}`);
    const g = [];
    let w = 0;
    for (let M = 0; M < Xr; ++M) {
      const T = M / v, b = Math.exp(-T * T / 2);
      g.push(b), M === 0 ? w += b : M < _ && (w += 2 * b);
    }
    for (let M = 0; M < g.length; M++)
      g[M] = g[M] / w;
    d.envMap.value = t.texture, d.samples.value = _, d.weights.value = g, d.latitudinal.value = r === "latitudinal", a && (d.poleAxis.value = a);
    const { _lodMax: S } = this;
    d.dTheta.value = p, d.mipInt.value = S - s;
    const x = this._sizeLods[i], A = 3 * x * (i > S - _c ? i - S + _c : 0), C = 4 * (this._cubeSize - x);
    Ah(e, A, C, 3 * x, 2 * x), l.setRenderTarget(e), l.render(m, Xf);
  }
};
h(yy, "PMREMGenerator");
let Md = yy;
function b$(n) {
  const t = [], e = [], s = [];
  let i = n;
  const o = n - _c + 1 + rS.length;
  for (let r = 0; r < o; r++) {
    const a = Math.pow(2, i);
    e.push(a);
    let l = 1 / a;
    r > n - _c ? l = rS[r - n + _c - 1] : r === 0 && (l = 0), s.push(l);
    const c = 1 / (a - 2), u = -c, m = 1 + c, d = [u, u, m, u, m, m, u, u, m, m, u, m], f = 6, p = 6, v = 3, _ = 2, g = 1, w = new Float32Array(v * p * f), S = new Float32Array(_ * p * f), x = new Float32Array(g * p * f);
    for (let C = 0; C < f; C++) {
      const M = C % 3 * 2 / 3 - 1, T = C > 2 ? 0 : -1, b = [
        M,
        T,
        0,
        M + 2 / 3,
        T,
        0,
        M + 2 / 3,
        T + 1,
        0,
        M,
        T,
        0,
        M + 2 / 3,
        T + 1,
        0,
        M,
        T + 1,
        0
      ];
      w.set(b, v * p * C), S.set(d, _ * p * C);
      const y = [C, C, C, C, C, C];
      x.set(y, g * p * C);
    }
    const A = new Ks();
    A.setAttribute("position", new ds(w, v)), A.setAttribute("uv", new ds(S, _)), A.setAttribute("faceIndex", new ds(x, g)), t.push(A), i > _c && i--;
  }
  return { lodPlanes: t, sizeLods: e, sigmas: s };
}
h(b$, "_createPlanes");
function lS(n, t, e) {
  const s = new Oo(n, t, e);
  return s.texture.mapping = zm, s.texture.name = "PMREM.cubeUv", s.scissorTest = !0, s;
}
h(lS, "_createRenderTarget");
function Ah(n, t, e, s, i) {
  n.viewport.set(t, e, s, i), n.scissor.set(t, e, s, i);
}
h(Ah, "_setViewport");
function y$(n, t, e) {
  const s = new Float32Array(Xr), i = new O(0, 1, 0);
  return new Qs({
    name: "SphericalGaussianBlur",
    defines: {
      n: Xr,
      CUBEUV_TEXEL_WIDTH: 1 / t,
      CUBEUV_TEXEL_HEIGHT: 1 / e,
      CUBEUV_MAX_MIP: `${n}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: s },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: j2(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: hr,
    depthTest: !1,
    depthWrite: !1
  });
}
h(y$, "_getBlurShader");
function uS() {
  return new Qs({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: j2(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: hr,
    depthTest: !1,
    depthWrite: !1
  });
}
h(uS, "_getEquirectMaterial");
function hS() {
  return new Qs({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: j2(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: hr,
    depthTest: !1,
    depthWrite: !1
  });
}
h(hS, "_getCubemapMaterial");
function j2() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
h(j2, "_getCommonVertexShader");
function x$(n) {
  let t = /* @__PURE__ */ new WeakMap(), e = null;
  function s(a) {
    if (a && a.isTexture) {
      const l = a.mapping, c = l === Yp || l === Jp, u = l === kc || l === Uc;
      if (c || u) {
        let m = t.get(a);
        const d = m !== void 0 ? m.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== d)
          return e === null && (e = new Md(n)), m = c ? e.fromEquirectangular(a, m) : e.fromCubemap(a, m), m.texture.pmremVersion = a.pmremVersion, t.set(a, m), m.texture;
        if (m !== void 0)
          return m.texture;
        {
          const f = a.image;
          return c && f && f.height > 0 || u && f && i(f) ? (e === null && (e = new Md(n)), m = c ? e.fromEquirectangular(a) : e.fromCubemap(a), m.texture.pmremVersion = a.pmremVersion, t.set(a, m), a.addEventListener("dispose", o), m.texture) : null;
        }
      }
    }
    return a;
  }
  h(s, "get");
  function i(a) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++)
      a[u] !== void 0 && l++;
    return l === c;
  }
  h(i, "isCubeTextureComplete");
  function o(a) {
    const l = a.target;
    l.removeEventListener("dispose", o);
    const c = t.get(l);
    c !== void 0 && (t.delete(l), c.dispose());
  }
  h(o, "onTextureDispose");
  function r() {
    t = /* @__PURE__ */ new WeakMap(), e !== null && (e.dispose(), e = null);
  }
  return h(r, "dispose"), {
    get: s,
    dispose: r
  };
}
h(x$, "WebGLCubeUVMaps");
function w$(n) {
  const t = {};
  function e(s) {
    if (t[s] !== void 0)
      return t[s];
    let i;
    switch (s) {
      case "WEBGL_depth_texture":
        i = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = n.getExtension(s);
    }
    return t[s] = i, i;
  }
  return h(e, "getExtension"), {
    has: /* @__PURE__ */ h(function(s) {
      return e(s) !== null;
    }, "has"),
    init: /* @__PURE__ */ h(function() {
      e("EXT_color_buffer_float"), e("WEBGL_clip_cull_distance"), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture"), e("WEBGL_render_shared_exponent");
    }, "init"),
    get: /* @__PURE__ */ h(function(s) {
      const i = e(s);
      return i === null && cu("THREE.WebGLRenderer: " + s + " extension not supported."), i;
    }, "get")
  };
}
h(w$, "WebGLExtensions");
function S$(n, t, e, s) {
  const i = {}, o = /* @__PURE__ */ new WeakMap();
  function r(m) {
    const d = m.target;
    d.index !== null && t.remove(d.index);
    for (const p in d.attributes)
      t.remove(d.attributes[p]);
    d.removeEventListener("dispose", r), delete i[d.id];
    const f = o.get(d);
    f && (t.remove(f), o.delete(d)), s.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, e.memory.geometries--;
  }
  h(r, "onGeometryDispose");
  function a(m, d) {
    return i[d.id] === !0 || (d.addEventListener("dispose", r), i[d.id] = !0, e.memory.geometries++), d;
  }
  h(a, "get");
  function l(m) {
    const d = m.attributes;
    for (const f in d)
      t.update(d[f], n.ARRAY_BUFFER);
  }
  h(l, "update");
  function c(m) {
    const d = [], f = m.index, p = m.attributes.position;
    let v = 0;
    if (f !== null) {
      const w = f.array;
      v = f.version;
      for (let S = 0, x = w.length; S < x; S += 3) {
        const A = w[S + 0], C = w[S + 1], M = w[S + 2];
        d.push(A, C, C, M, M, A);
      }
    } else if (p !== void 0) {
      const w = p.array;
      v = p.version;
      for (let S = 0, x = w.length / 3 - 1; S < x; S += 3) {
        const A = S + 0, C = S + 1, M = S + 2;
        d.push(A, C, C, M, M, A);
      }
    } else
      return;
    const _ = new (j3(d) ? _d : pd)(d, 1);
    _.version = v;
    const g = o.get(m);
    g && t.remove(g), o.set(m, _);
  }
  h(c, "updateWireframeAttribute");
  function u(m) {
    const d = o.get(m);
    if (d) {
      const f = m.index;
      f !== null && d.version < f.version && c(m);
    } else
      c(m);
    return o.get(m);
  }
  return h(u, "getWireframeAttribute"), {
    get: a,
    update: l,
    getWireframeAttribute: u
  };
}
h(S$, "WebGLGeometries");
function A$(n, t, e) {
  let s;
  function i(d) {
    s = d;
  }
  h(i, "setMode");
  let o, r;
  function a(d) {
    o = d.type, r = d.bytesPerElement;
  }
  h(a, "setIndex");
  function l(d, f) {
    n.drawElements(s, f, o, d * r), e.update(f, s, 1);
  }
  h(l, "render");
  function c(d, f, p) {
    p !== 0 && (n.drawElementsInstanced(s, f, o, d * r, p), e.update(f, s, p));
  }
  h(c, "renderInstances");
  function u(d, f, p) {
    if (p === 0) return;
    t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(s, f, 0, o, d, 0, p);
    let _ = 0;
    for (let g = 0; g < p; g++)
      _ += f[g];
    e.update(_, s, 1);
  }
  h(u, "renderMultiDraw");
  function m(d, f, p, v) {
    if (p === 0) return;
    const _ = t.get("WEBGL_multi_draw");
    if (_ === null)
      for (let g = 0; g < d.length; g++)
        c(d[g] / r, f[g], v[g]);
    else {
      _.multiDrawElementsInstancedWEBGL(s, f, 0, o, d, 0, v, 0, p);
      let g = 0;
      for (let w = 0; w < p; w++)
        g += f[w] * v[w];
      e.update(g, s, 1);
    }
  }
  h(m, "renderMultiDrawInstances"), this.setMode = i, this.setIndex = a, this.render = l, this.renderInstances = c, this.renderMultiDraw = u, this.renderMultiDrawInstances = m;
}
h(A$, "WebGLIndexedBufferRenderer");
function M$(n) {
  const t = {
    geometries: 0,
    textures: 0
  }, e = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function s(o, r, a) {
    switch (e.calls++, r) {
      case n.TRIANGLES:
        e.triangles += a * (o / 3);
        break;
      case n.LINES:
        e.lines += a * (o / 2);
        break;
      case n.LINE_STRIP:
        e.lines += a * (o - 1);
        break;
      case n.LINE_LOOP:
        e.lines += a * o;
        break;
      case n.POINTS:
        e.points += a * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", r);
        break;
    }
  }
  h(s, "update");
  function i() {
    e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
  }
  return h(i, "reset"), {
    memory: t,
    render: e,
    programs: null,
    autoReset: !0,
    reset: i,
    update: s
  };
}
h(M$, "WebGLInfo");
function C$(n, t, e) {
  const s = /* @__PURE__ */ new WeakMap(), i = new an();
  function o(r, a, l) {
    const c = r.morphTargetInfluences, u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color, m = u !== void 0 ? u.length : 0;
    let d = s.get(a);
    if (d === void 0 || d.count !== m) {
      let b = function() {
        M.dispose(), s.delete(a), a.removeEventListener("dispose", b);
      };
      h(b, "disposeTexture"), d !== void 0 && d.texture.dispose();
      const f = a.morphAttributes.position !== void 0, p = a.morphAttributes.normal !== void 0, v = a.morphAttributes.color !== void 0, _ = a.morphAttributes.position || [], g = a.morphAttributes.normal || [], w = a.morphAttributes.color || [];
      let S = 0;
      f === !0 && (S = 1), p === !0 && (S = 2), v === !0 && (S = 3);
      let x = a.attributes.position.count * S, A = 1;
      x > t.maxTextureSize && (A = Math.ceil(x / t.maxTextureSize), x = t.maxTextureSize);
      const C = new Float32Array(x * A * 4 * m), M = new dd(C, x, A, m);
      M.type = Ro, M.needsUpdate = !0;
      const T = S * 4;
      for (let y = 0; y < m; y++) {
        const E = _[y], I = g[y], B = w[y], D = x * A * 4 * y;
        for (let N = 0; N < E.count; N++) {
          const V = N * T;
          f === !0 && (i.fromBufferAttribute(E, N), C[D + V + 0] = i.x, C[D + V + 1] = i.y, C[D + V + 2] = i.z, C[D + V + 3] = 0), p === !0 && (i.fromBufferAttribute(I, N), C[D + V + 4] = i.x, C[D + V + 5] = i.y, C[D + V + 6] = i.z, C[D + V + 7] = 0), v === !0 && (i.fromBufferAttribute(B, N), C[D + V + 8] = i.x, C[D + V + 9] = i.y, C[D + V + 10] = i.z, C[D + V + 11] = B.itemSize === 4 ? i.w : 1);
        }
      }
      d = {
        count: m,
        texture: M,
        size: new Pe(x, A)
      }, s.set(a, d), a.addEventListener("dispose", b);
    }
    if (r.isInstancedMesh === !0 && r.morphTexture !== null)
      l.getUniforms().setValue(n, "morphTexture", r.morphTexture, e);
    else {
      let f = 0;
      for (let v = 0; v < c.length; v++)
        f += c[v];
      const p = a.morphTargetsRelative ? 1 : 1 - f;
      l.getUniforms().setValue(n, "morphTargetBaseInfluence", p), l.getUniforms().setValue(n, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(n, "morphTargetsTexture", d.texture, e), l.getUniforms().setValue(n, "morphTargetsTextureSize", d.size);
  }
  return h(o, "update"), {
    update: o
  };
}
h(C$, "WebGLMorphtargets");
function E$(n, t, e, s) {
  let i = /* @__PURE__ */ new WeakMap();
  function o(l) {
    const c = s.render.frame, u = l.geometry, m = t.get(l, u);
    if (i.get(m) !== c && (t.update(m), i.set(m, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), i.get(l) !== c && (e.update(l.instanceMatrix, n.ARRAY_BUFFER), l.instanceColor !== null && e.update(l.instanceColor, n.ARRAY_BUFFER), i.set(l, c))), l.isSkinnedMesh) {
      const d = l.skeleton;
      i.get(d) !== c && (d.update(), i.set(d, c));
    }
    return m;
  }
  h(o, "update");
  function r() {
    i = /* @__PURE__ */ new WeakMap();
  }
  h(r, "dispose");
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a), e.remove(c.instanceMatrix), c.instanceColor !== null && e.remove(c.instanceColor);
  }
  return h(a, "onInstancedMeshDispose"), {
    update: o,
    dispose: r
  };
}
h(E$, "WebGLObjects");
const Y3 = new fs(), dS = new vd(1, 1), J3 = new dd(), K3 = new B_(), Q3 = new gd(), mS = [], fS = [], pS = new Float32Array(16), _S = new Float32Array(9), gS = new Float32Array(4);
function sl(n, t, e) {
  const s = n[0];
  if (s <= 0 || s > 0) return n;
  const i = t * e;
  let o = mS[i];
  if (o === void 0 && (o = new Float32Array(i), mS[i] = o), t !== 0) {
    s.toArray(o, 0);
    for (let r = 1, a = 0; r !== t; ++r)
      a += e, n[r].toArray(o, a);
  }
  return o;
}
h(sl, "flatten");
function Jn(n, t) {
  if (n.length !== t.length) return !1;
  for (let e = 0, s = n.length; e < s; e++)
    if (n[e] !== t[e]) return !1;
  return !0;
}
h(Jn, "arraysEqual");
function Kn(n, t) {
  for (let e = 0, s = t.length; e < s; e++)
    n[e] = t[e];
}
h(Kn, "copyArray");
function km(n, t) {
  let e = fS[t];
  e === void 0 && (e = new Int32Array(t), fS[t] = e);
  for (let s = 0; s !== t; ++s)
    e[s] = n.allocateTextureUnit();
  return e;
}
h(km, "allocTexUnits");
function T$(n, t) {
  const e = this.cache;
  e[0] !== t && (n.uniform1f(this.addr, t), e[0] = t);
}
h(T$, "setValueV1f");
function I$(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (n.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (Jn(e, t)) return;
    n.uniform2fv(this.addr, t), Kn(e, t);
  }
}
h(I$, "setValueV2f");
function B$(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (n.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else if (t.r !== void 0)
    (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (n.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
  else {
    if (Jn(e, t)) return;
    n.uniform3fv(this.addr, t), Kn(e, t);
  }
}
h(B$, "setValueV3f");
function P$(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (n.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (Jn(e, t)) return;
    n.uniform4fv(this.addr, t), Kn(e, t);
  }
}
h(P$, "setValueV4f");
function R$(n, t) {
  const e = this.cache, s = t.elements;
  if (s === void 0) {
    if (Jn(e, t)) return;
    n.uniformMatrix2fv(this.addr, !1, t), Kn(e, t);
  } else {
    if (Jn(e, s)) return;
    gS.set(s), n.uniformMatrix2fv(this.addr, !1, gS), Kn(e, s);
  }
}
h(R$, "setValueM2");
function D$(n, t) {
  const e = this.cache, s = t.elements;
  if (s === void 0) {
    if (Jn(e, t)) return;
    n.uniformMatrix3fv(this.addr, !1, t), Kn(e, t);
  } else {
    if (Jn(e, s)) return;
    _S.set(s), n.uniformMatrix3fv(this.addr, !1, _S), Kn(e, s);
  }
}
h(D$, "setValueM3");
function V$(n, t) {
  const e = this.cache, s = t.elements;
  if (s === void 0) {
    if (Jn(e, t)) return;
    n.uniformMatrix4fv(this.addr, !1, t), Kn(e, t);
  } else {
    if (Jn(e, s)) return;
    pS.set(s), n.uniformMatrix4fv(this.addr, !1, pS), Kn(e, s);
  }
}
h(V$, "setValueM4");
function L$(n, t) {
  const e = this.cache;
  e[0] !== t && (n.uniform1i(this.addr, t), e[0] = t);
}
h(L$, "setValueV1i");
function N$(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (n.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (Jn(e, t)) return;
    n.uniform2iv(this.addr, t), Kn(e, t);
  }
}
h(N$, "setValueV2i");
function z$(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (n.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (Jn(e, t)) return;
    n.uniform3iv(this.addr, t), Kn(e, t);
  }
}
h(z$, "setValueV3i");
function k$(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (n.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (Jn(e, t)) return;
    n.uniform4iv(this.addr, t), Kn(e, t);
  }
}
h(k$, "setValueV4i");
function U$(n, t) {
  const e = this.cache;
  e[0] !== t && (n.uniform1ui(this.addr, t), e[0] = t);
}
h(U$, "setValueV1ui");
function O$(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (n.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (Jn(e, t)) return;
    n.uniform2uiv(this.addr, t), Kn(e, t);
  }
}
h(O$, "setValueV2ui");
function $$(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (n.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (Jn(e, t)) return;
    n.uniform3uiv(this.addr, t), Kn(e, t);
  }
}
h($$, "setValueV3ui");
function F$(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (n.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (Jn(e, t)) return;
    n.uniform4uiv(this.addr, t), Kn(e, t);
  }
}
h(F$, "setValueV4ui");
function G$(n, t, e) {
  const s = this.cache, i = e.allocateTextureUnit();
  s[0] !== i && (n.uniform1i(this.addr, i), s[0] = i);
  let o;
  this.type === n.SAMPLER_2D_SHADOW ? (dS.compareFunction = H3, o = dS) : o = Y3, e.setTexture2D(t || o, i);
}
h(G$, "setValueT1");
function H$(n, t, e) {
  const s = this.cache, i = e.allocateTextureUnit();
  s[0] !== i && (n.uniform1i(this.addr, i), s[0] = i), e.setTexture3D(t || K3, i);
}
h(H$, "setValueT3D1");
function j$(n, t, e) {
  const s = this.cache, i = e.allocateTextureUnit();
  s[0] !== i && (n.uniform1i(this.addr, i), s[0] = i), e.setTextureCube(t || Q3, i);
}
h(j$, "setValueT6");
function W$(n, t, e) {
  const s = this.cache, i = e.allocateTextureUnit();
  s[0] !== i && (n.uniform1i(this.addr, i), s[0] = i), e.setTexture2DArray(t || J3, i);
}
h(W$, "setValueT2DArray1");
function q$(n) {
  switch (n) {
    case 5126:
      return T$;
    case 35664:
      return I$;
    case 35665:
      return B$;
    case 35666:
      return P$;
    case 35674:
      return R$;
    case 35675:
      return D$;
    case 35676:
      return V$;
    case 5124:
    case 35670:
      return L$;
    case 35667:
    case 35671:
      return N$;
    case 35668:
    case 35672:
      return z$;
    case 35669:
    case 35673:
      return k$;
    case 5125:
      return U$;
    case 36294:
      return O$;
    case 36295:
      return $$;
    case 36296:
      return F$;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return G$;
    case 35679:
    case 36299:
    case 36307:
      return H$;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return j$;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return W$;
  }
}
h(q$, "getSingularSetter");
function X$(n, t) {
  n.uniform1fv(this.addr, t);
}
h(X$, "setValueV1fArray");
function Z$(n, t) {
  const e = sl(t, this.size, 2);
  n.uniform2fv(this.addr, e);
}
h(Z$, "setValueV2fArray");
function Y$(n, t) {
  const e = sl(t, this.size, 3);
  n.uniform3fv(this.addr, e);
}
h(Y$, "setValueV3fArray");
function J$(n, t) {
  const e = sl(t, this.size, 4);
  n.uniform4fv(this.addr, e);
}
h(J$, "setValueV4fArray");
function K$(n, t) {
  const e = sl(t, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, e);
}
h(K$, "setValueM2Array");
function Q$(n, t) {
  const e = sl(t, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, e);
}
h(Q$, "setValueM3Array");
function tF(n, t) {
  const e = sl(t, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, e);
}
h(tF, "setValueM4Array");
function eF(n, t) {
  n.uniform1iv(this.addr, t);
}
h(eF, "setValueV1iArray");
function nF(n, t) {
  n.uniform2iv(this.addr, t);
}
h(nF, "setValueV2iArray");
function iF(n, t) {
  n.uniform3iv(this.addr, t);
}
h(iF, "setValueV3iArray");
function sF(n, t) {
  n.uniform4iv(this.addr, t);
}
h(sF, "setValueV4iArray");
function oF(n, t) {
  n.uniform1uiv(this.addr, t);
}
h(oF, "setValueV1uiArray");
function rF(n, t) {
  n.uniform2uiv(this.addr, t);
}
h(rF, "setValueV2uiArray");
function aF(n, t) {
  n.uniform3uiv(this.addr, t);
}
h(aF, "setValueV3uiArray");
function cF(n, t) {
  n.uniform4uiv(this.addr, t);
}
h(cF, "setValueV4uiArray");
function lF(n, t, e) {
  const s = this.cache, i = t.length, o = km(e, i);
  Jn(s, o) || (n.uniform1iv(this.addr, o), Kn(s, o));
  for (let r = 0; r !== i; ++r)
    e.setTexture2D(t[r] || Y3, o[r]);
}
h(lF, "setValueT1Array");
function uF(n, t, e) {
  const s = this.cache, i = t.length, o = km(e, i);
  Jn(s, o) || (n.uniform1iv(this.addr, o), Kn(s, o));
  for (let r = 0; r !== i; ++r)
    e.setTexture3D(t[r] || K3, o[r]);
}
h(uF, "setValueT3DArray");
function hF(n, t, e) {
  const s = this.cache, i = t.length, o = km(e, i);
  Jn(s, o) || (n.uniform1iv(this.addr, o), Kn(s, o));
  for (let r = 0; r !== i; ++r)
    e.setTextureCube(t[r] || Q3, o[r]);
}
h(hF, "setValueT6Array");
function dF(n, t, e) {
  const s = this.cache, i = t.length, o = km(e, i);
  Jn(s, o) || (n.uniform1iv(this.addr, o), Kn(s, o));
  for (let r = 0; r !== i; ++r)
    e.setTexture2DArray(t[r] || J3, o[r]);
}
h(dF, "setValueT2DArrayArray");
function mF(n) {
  switch (n) {
    case 5126:
      return X$;
    case 35664:
      return Z$;
    case 35665:
      return Y$;
    case 35666:
      return J$;
    case 35674:
      return K$;
    case 35675:
      return Q$;
    case 35676:
      return tF;
    case 5124:
    case 35670:
      return eF;
    case 35667:
    case 35671:
      return nF;
    case 35668:
    case 35672:
      return iF;
    case 35669:
    case 35673:
      return sF;
    case 5125:
      return oF;
    case 36294:
      return rF;
    case 36295:
      return aF;
    case 36296:
      return cF;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return lF;
    case 35679:
    case 36299:
    case 36307:
      return uF;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return hF;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return dF;
  }
}
h(mF, "getPureArraySetter");
const xy = class xy {
  constructor(t, e, s) {
    this.id = t, this.addr = s, this.cache = [], this.type = e.type, this.setValue = q$(e.type);
  }
};
h(xy, "SingleUniform");
let G_ = xy;
const wy = class wy {
  constructor(t, e, s) {
    this.id = t, this.addr = s, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = mF(e.type);
  }
};
h(wy, "PureArrayUniform");
let H_ = wy;
const Sy = class Sy {
  constructor(t) {
    this.id = t, this.seq = [], this.map = {};
  }
  setValue(t, e, s) {
    const i = this.seq;
    for (let o = 0, r = i.length; o !== r; ++o) {
      const a = i[o];
      a.setValue(t, e[a.id], s);
    }
  }
};
h(Sy, "StructuredUniform");
let j_ = Sy;
const Qf = /(\w+)(\])?(\[|\.)?/g;
function vS(n, t) {
  n.seq.push(t), n.map[t.id] = t;
}
h(vS, "addUniform");
function fF(n, t, e) {
  const s = n.name, i = s.length;
  for (Qf.lastIndex = 0; ; ) {
    const o = Qf.exec(s), r = Qf.lastIndex;
    let a = o[1];
    const l = o[2] === "]", c = o[3];
    if (l && (a = a | 0), c === void 0 || c === "[" && r + 2 === i) {
      vS(e, c === void 0 ? new G_(a, n, t) : new H_(a, n, t));
      break;
    } else {
      let m = e.map[a];
      m === void 0 && (m = new j_(a), vS(e, m)), e = m;
    }
  }
}
h(fF, "parseUniform");
const Ay = class Ay {
  constructor(t, e) {
    this.seq = [], this.map = {};
    const s = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let i = 0; i < s; ++i) {
      const o = t.getActiveUniform(e, i), r = t.getUniformLocation(e, o.name);
      fF(o, r, this);
    }
  }
  setValue(t, e, s, i) {
    const o = this.map[e];
    o !== void 0 && o.setValue(t, s, i);
  }
  setOptional(t, e, s) {
    const i = e[s];
    i !== void 0 && this.setValue(t, s, i);
  }
  static upload(t, e, s, i) {
    for (let o = 0, r = e.length; o !== r; ++o) {
      const a = e[o], l = s[a.id];
      l.needsUpdate !== !1 && a.setValue(t, l.value, i);
    }
  }
  static seqWithValue(t, e) {
    const s = [];
    for (let i = 0, o = t.length; i !== o; ++i) {
      const r = t[i];
      r.id in e && s.push(r);
    }
    return s;
  }
};
h(Ay, "WebGLUniforms");
let Ac = Ay;
function bS(n, t, e) {
  const s = n.createShader(t);
  return n.shaderSource(s, e), n.compileShader(s), s;
}
h(bS, "WebGLShader");
const pF = 37297;
let _F = 0;
function gF(n, t) {
  const e = n.split(`
`), s = [], i = Math.max(t - 6, 0), o = Math.min(t + 6, e.length);
  for (let r = i; r < o; r++) {
    const a = r + 1;
    s.push(`${a === t ? ">" : " "} ${a}: ${e[r]}`);
  }
  return s.join(`
`);
}
h(gF, "handleSource");
const yS = new Ae();
function vF(n) {
  Qe._getMatrix(yS, Qe.workingColorSpace, n);
  const t = `mat3( ${yS.elements.map((e) => e.toFixed(4))} )`;
  switch (Qe.getTransfer(n)) {
    case ld:
      return [t, "LinearTransferOETF"];
    case pn:
      return [t, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", n), [t, "LinearTransferOETF"];
  }
}
h(vF, "getEncodingComponents");
function xS(n, t, e) {
  const s = n.getShaderParameter(t, n.COMPILE_STATUS), o = (n.getShaderInfoLog(t) || "").trim();
  if (s && o === "") return "";
  const r = /ERROR: 0:(\d+)/.exec(o);
  if (r) {
    const a = parseInt(r[1]);
    return e.toUpperCase() + `

` + o + `

` + gF(n.getShaderSource(t), a);
  } else
    return o;
}
h(xS, "getShaderErrors");
function bF(n, t) {
  const e = vF(t);
  return [
    `vec4 ${n}( vec4 value ) {`,
    `	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
h(bF, "getTexelEncodingFunction");
function yF(n, t) {
  let e;
  switch (t) {
    case wz:
      e = "Linear";
      break;
    case Sz:
      e = "Reinhard";
      break;
    case Az:
      e = "Cineon";
      break;
    case Mz:
      e = "ACESFilmic";
      break;
    case Ez:
      e = "AgX";
      break;
    case Tz:
      e = "Neutral";
      break;
    case Cz:
      e = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear";
  }
  return "vec3 " + n + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
}
h(yF, "getToneMappingFunction");
const Mh = new O();
function xF() {
  Qe.getLuminanceCoefficients(Mh);
  const n = Mh.x.toFixed(4), t = Mh.y.toFixed(4), e = Mh.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${n}, ${t}, ${e} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
h(xF, "getLuminanceFunction");
function wF(n) {
  return [
    n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(Sl).join(`
`);
}
h(wF, "generateVertexExtensions");
function SF(n) {
  const t = [];
  for (const e in n) {
    const s = n[e];
    s !== !1 && t.push("#define " + e + " " + s);
  }
  return t.join(`
`);
}
h(SF, "generateDefines");
function AF(n, t) {
  const e = {}, s = n.getProgramParameter(t, n.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < s; i++) {
    const o = n.getActiveAttrib(t, i), r = o.name;
    let a = 1;
    o.type === n.FLOAT_MAT2 && (a = 2), o.type === n.FLOAT_MAT3 && (a = 3), o.type === n.FLOAT_MAT4 && (a = 4), e[r] = {
      type: o.type,
      location: n.getAttribLocation(t, r),
      locationSize: a
    };
  }
  return e;
}
h(AF, "fetchAttributeLocations");
function Sl(n) {
  return n !== "";
}
h(Sl, "filterEmptyLine");
function wS(n, t) {
  const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
  return n.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
h(wS, "replaceLightNums");
function SS(n, t) {
  return n.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
h(SS, "replaceClippingPlaneNums");
const MF = /^[ \t]*#include +<([\w\d./]+)>/gm;
function W_(n) {
  return n.replace(MF, EF);
}
h(W_, "resolveIncludes");
const CF = /* @__PURE__ */ new Map();
function EF(n, t) {
  let e = Te[t];
  if (e === void 0) {
    const s = CF.get(t);
    if (s !== void 0)
      e = Te[s], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, s);
    else
      throw new Error("Can not resolve #include <" + t + ">");
  }
  return W_(e);
}
h(EF, "includeReplacer");
const TF = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function AS(n) {
  return n.replace(TF, IF);
}
h(AS, "unrollLoops");
function IF(n, t, e, s) {
  let i = "";
  for (let o = parseInt(t); o < parseInt(e); o++)
    i += s.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return i;
}
h(IF, "loopReplacer");
function MS(n) {
  let t = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return n.precision === "highp" ? t += `
#define HIGH_PRECISION` : n.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
}
h(MS, "generatePrecision");
function BF(n) {
  let t = "SHADOWMAP_TYPE_BASIC";
  return n.shadowMapType === P3 ? t = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === R3 ? t = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === wo && (t = "SHADOWMAP_TYPE_VSM"), t;
}
h(BF, "generateShadowMapTypeDefine");
function PF(n) {
  let t = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case kc:
      case Uc:
        t = "ENVMAP_TYPE_CUBE";
        break;
      case zm:
        t = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return t;
}
h(PF, "generateEnvMapTypeDefine");
function RF(n) {
  let t = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case Uc:
        t = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return t;
}
h(RF, "generateEnvMapModeDefine");
function DF(n) {
  let t = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case D3:
        t = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case yz:
        t = "ENVMAP_BLENDING_MIX";
        break;
      case xz:
        t = "ENVMAP_BLENDING_ADD";
        break;
    }
  return t;
}
h(DF, "generateEnvMapBlendingDefine");
function VF(n) {
  const t = n.envMapCubeUVHeight;
  if (t === null) return null;
  const e = Math.log2(t) - 2, s = 1 / t;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: s, maxMip: e };
}
h(VF, "generateCubeUVSize");
function LF(n, t, e, s) {
  const i = n.getContext(), o = e.defines;
  let r = e.vertexShader, a = e.fragmentShader;
  const l = BF(e), c = PF(e), u = RF(e), m = DF(e), d = VF(e), f = wF(e), p = SF(o), v = i.createProgram();
  let _, g, w = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
  e.isRawShaderMaterial ? (_ = [
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p
  ].filter(Sl).join(`
`), _.length > 0 && (_ += `
`), g = [
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p
  ].filter(Sl).join(`
`), g.length > 0 && (g += `
`)) : (_ = [
    MS(e),
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p,
    e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    e.batching ? "#define USE_BATCHING" : "",
    e.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    e.instancing ? "#define USE_INSTANCING" : "",
    e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    e.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    e.useFog && e.fog ? "#define USE_FOG" : "",
    e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
    e.map ? "#define USE_MAP" : "",
    e.envMap ? "#define USE_ENVMAP" : "",
    e.envMap ? "#define " + u : "",
    e.lightMap ? "#define USE_LIGHTMAP" : "",
    e.aoMap ? "#define USE_AOMAP" : "",
    e.bumpMap ? "#define USE_BUMPMAP" : "",
    e.normalMap ? "#define USE_NORMALMAP" : "",
    e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    e.anisotropy ? "#define USE_ANISOTROPY" : "",
    e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    e.specularMap ? "#define USE_SPECULARMAP" : "",
    e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    e.metalnessMap ? "#define USE_METALNESSMAP" : "",
    e.alphaMap ? "#define USE_ALPHAMAP" : "",
    e.alphaHash ? "#define USE_ALPHAHASH" : "",
    e.transmission ? "#define USE_TRANSMISSION" : "",
    e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    e.mapUv ? "#define MAP_UV " + e.mapUv : "",
    e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "",
    e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "",
    e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "",
    e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "",
    e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "",
    e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "",
    e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "",
    e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "",
    e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "",
    e.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv : "",
    e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "",
    e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "",
    e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "",
    e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "",
    e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "",
    e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "",
    e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "",
    e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "",
    e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "",
    e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "",
    e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "",
    e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "",
    e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
    e.vertexColors ? "#define USE_COLOR" : "",
    e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    e.vertexUv1s ? "#define USE_UV1" : "",
    e.vertexUv2s ? "#define USE_UV2" : "",
    e.vertexUv3s ? "#define USE_UV3" : "",
    e.pointsUvs ? "#define USE_POINTS_UV" : "",
    e.flatShading ? "#define FLAT_SHADED" : "",
    e.skinning ? "#define USE_SKINNING" : "",
    e.morphTargets ? "#define USE_MORPHTARGETS" : "",
    e.morphNormals && e.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    e.morphColors ? "#define USE_MORPHCOLORS" : "",
    e.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "",
    e.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "",
    e.doubleSided ? "#define DOUBLE_SIDED" : "",
    e.flipSided ? "#define FLIP_SIDED" : "",
    e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    e.shadowMapEnabled ? "#define " + l : "",
    e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    e.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "",
    e.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Sl).join(`
`), g = [
    MS(e),
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p,
    e.useFog && e.fog ? "#define USE_FOG" : "",
    e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
    e.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    e.map ? "#define USE_MAP" : "",
    e.matcap ? "#define USE_MATCAP" : "",
    e.envMap ? "#define USE_ENVMAP" : "",
    e.envMap ? "#define " + c : "",
    e.envMap ? "#define " + u : "",
    e.envMap ? "#define " + m : "",
    d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
    d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
    d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
    e.lightMap ? "#define USE_LIGHTMAP" : "",
    e.aoMap ? "#define USE_AOMAP" : "",
    e.bumpMap ? "#define USE_BUMPMAP" : "",
    e.normalMap ? "#define USE_NORMALMAP" : "",
    e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    e.anisotropy ? "#define USE_ANISOTROPY" : "",
    e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    e.clearcoat ? "#define USE_CLEARCOAT" : "",
    e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    e.dispersion ? "#define USE_DISPERSION" : "",
    e.iridescence ? "#define USE_IRIDESCENCE" : "",
    e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    e.specularMap ? "#define USE_SPECULARMAP" : "",
    e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    e.metalnessMap ? "#define USE_METALNESSMAP" : "",
    e.alphaMap ? "#define USE_ALPHAMAP" : "",
    e.alphaTest ? "#define USE_ALPHATEST" : "",
    e.alphaHash ? "#define USE_ALPHAHASH" : "",
    e.sheen ? "#define USE_SHEEN" : "",
    e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    e.transmission ? "#define USE_TRANSMISSION" : "",
    e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
    e.vertexColors || e.instancingColor || e.batchingColor ? "#define USE_COLOR" : "",
    e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    e.vertexUv1s ? "#define USE_UV1" : "",
    e.vertexUv2s ? "#define USE_UV2" : "",
    e.vertexUv3s ? "#define USE_UV3" : "",
    e.pointsUvs ? "#define USE_POINTS_UV" : "",
    e.gradientMap ? "#define USE_GRADIENTMAP" : "",
    e.flatShading ? "#define FLAT_SHADED" : "",
    e.doubleSided ? "#define DOUBLE_SIDED" : "",
    e.flipSided ? "#define FLIP_SIDED" : "",
    e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    e.shadowMapEnabled ? "#define " + l : "",
    e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    e.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    e.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "",
    e.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    e.toneMapping !== dr ? "#define TONE_MAPPING" : "",
    e.toneMapping !== dr ? Te.tonemapping_pars_fragment : "",
    e.toneMapping !== dr ? yF("toneMapping", e.toneMapping) : "",
    e.dithering ? "#define DITHERING" : "",
    e.opaque ? "#define OPAQUE" : "",
    Te.colorspace_pars_fragment,
    bF("linearToOutputTexel", e.outputColorSpace),
    xF(),
    e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
    `
`
  ].filter(Sl).join(`
`)), r = W_(r), r = wS(r, e), r = SS(r, e), a = W_(a), a = wS(a, e), a = SS(a, e), r = AS(r), a = AS(a), e.isRawShaderMaterial !== !0 && (w = `#version 300 es
`, _ = [
    f,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + _, g = [
    "#define varying in",
    e.glslVersion === zw ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    e.glslVersion === zw ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + g);
  const S = w + _ + r, x = w + g + a, A = bS(i, i.VERTEX_SHADER, S), C = bS(i, i.FRAGMENT_SHADER, x);
  i.attachShader(v, A), i.attachShader(v, C), e.index0AttributeName !== void 0 ? i.bindAttribLocation(v, 0, e.index0AttributeName) : e.morphTargets === !0 && i.bindAttribLocation(v, 0, "position"), i.linkProgram(v);
  function M(E) {
    if (n.debug.checkShaderErrors) {
      const I = i.getProgramInfoLog(v) || "", B = i.getShaderInfoLog(A) || "", D = i.getShaderInfoLog(C) || "", N = I.trim(), V = B.trim(), G = D.trim();
      let U = !0, j = !0;
      if (i.getProgramParameter(v, i.LINK_STATUS) === !1)
        if (U = !1, typeof n.debug.onShaderError == "function")
          n.debug.onShaderError(i, v, A, C);
        else {
          const tt = xS(i, A, "vertex"), K = xS(i, C, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(v, i.VALIDATE_STATUS) + `

Material Name: ` + E.name + `
Material Type: ` + E.type + `

Program Info Log: ` + N + `
` + tt + `
` + K
          );
        }
      else N !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", N) : (V === "" || G === "") && (j = !1);
      j && (E.diagnostics = {
        runnable: U,
        programLog: N,
        vertexShader: {
          log: V,
          prefix: _
        },
        fragmentShader: {
          log: G,
          prefix: g
        }
      });
    }
    i.deleteShader(A), i.deleteShader(C), T = new Ac(i, v), b = AF(i, v);
  }
  h(M, "onFirstUse");
  let T;
  this.getUniforms = function() {
    return T === void 0 && M(this), T;
  };
  let b;
  this.getAttributes = function() {
    return b === void 0 && M(this), b;
  };
  let y = e.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return y === !1 && (y = i.getProgramParameter(v, pF)), y;
  }, this.destroy = function() {
    s.releaseStatesOfProgram(this), i.deleteProgram(v), this.program = void 0;
  }, this.type = e.shaderType, this.name = e.shaderName, this.id = _F++, this.cacheKey = t, this.usedTimes = 1, this.program = v, this.vertexShader = A, this.fragmentShader = C, this;
}
h(LF, "WebGLProgram");
let NF = 0;
const My = class My {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(t) {
    const e = t.vertexShader, s = t.fragmentShader, i = this._getShaderStage(e), o = this._getShaderStage(s), r = this._getShaderCacheForMaterial(t);
    return r.has(i) === !1 && (r.add(i), i.usedTimes++), r.has(o) === !1 && (r.add(o), o.usedTimes++), this;
  }
  remove(t) {
    const e = this.materialCache.get(t);
    for (const s of e)
      s.usedTimes--, s.usedTimes === 0 && this.shaderCache.delete(s.code);
    return this.materialCache.delete(t), this;
  }
  getVertexShaderID(t) {
    return this._getShaderStage(t.vertexShader).id;
  }
  getFragmentShaderID(t) {
    return this._getShaderStage(t.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(t) {
    const e = this.materialCache;
    let s = e.get(t);
    return s === void 0 && (s = /* @__PURE__ */ new Set(), e.set(t, s)), s;
  }
  _getShaderStage(t) {
    const e = this.shaderCache;
    let s = e.get(t);
    return s === void 0 && (s = new X_(t), e.set(t, s)), s;
  }
};
h(My, "WebGLShaderCache");
let q_ = My;
const Cy = class Cy {
  constructor(t) {
    this.id = NF++, this.code = t, this.usedTimes = 0;
  }
};
h(Cy, "WebGLShaderStage");
let X_ = Cy;
function zF(n, t, e, s, i, o, r) {
  const a = new md(), l = new q_(), c = /* @__PURE__ */ new Set(), u = [], m = i.logarithmicDepthBuffer, d = i.vertexTextures;
  let f = i.precision;
  const p = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function v(b) {
    return c.add(b), b === 0 ? "uv" : `uv${b}`;
  }
  h(v, "getChannel");
  function _(b, y, E, I, B) {
    const D = I.fog, N = B.geometry, V = b.isMeshStandardMaterial ? I.environment : null, G = (b.isMeshStandardMaterial ? e : t).get(b.envMap || V), U = G && G.mapping === zm ? G.image.height : null, j = p[b.type];
    b.precision !== null && (f = i.getMaxPrecision(b.precision), f !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", f, "instead."));
    const tt = N.morphAttributes.position || N.morphAttributes.normal || N.morphAttributes.color, K = tt !== void 0 ? tt.length : 0;
    let $ = 0;
    N.morphAttributes.position !== void 0 && ($ = 1), N.morphAttributes.normal !== void 0 && ($ = 2), N.morphAttributes.color !== void 0 && ($ = 3);
    let lt, gt, _t, Y;
    if (j) {
      const nn = Os[j];
      lt = nn.vertexShader, gt = nn.fragmentShader;
    } else
      lt = b.vertexShader, gt = b.fragmentShader, l.update(b), _t = l.getVertexShaderID(b), Y = l.getFragmentShaderID(b);
    const it = n.getRenderTarget(), J = n.state.buffers.depth.getReversed(), dt = B.isInstancedMesh === !0, vt = B.isBatchedMesh === !0, Nt = !!b.map, _e = !!b.matcap, k = !!G, te = !!b.aoMap, It = !!b.lightMap, ut = !!b.bumpMap, bt = !!b.normalMap, Ft = !!b.displacementMap, wt = !!b.emissiveMap, le = !!b.metalnessMap, dn = !!b.roughnessMap, Ze = b.anisotropy > 0, z = b.clearcoat > 0, P = b.dispersion > 0, q = b.iridescence > 0, at = b.sheen > 0, mt = b.transmission > 0, ot = Ze && !!b.anisotropyMap, Wt = z && !!b.clearcoatMap, Rt = z && !!b.clearcoatNormalMap, ie = z && !!b.clearcoatRoughnessMap, se = q && !!b.iridescenceMap, Ct = q && !!b.iridescenceThicknessMap, Ot = at && !!b.sheenColorMap, fe = at && !!b.sheenRoughnessMap, oe = !!b.specularMap, kt = !!b.specularColorMap, Se = !!b.specularIntensityMap, F = mt && !!b.transmissionMap, Et = mt && !!b.thicknessMap, Dt = !!b.gradientMap, Yt = !!b.alphaMap, St = b.alphaTest > 0, ft = !!b.alphaHash, ee = !!b.extensions;
    let be = dr;
    b.toneMapped && (it === null || it.isXRRenderTarget === !0) && (be = n.toneMapping);
    const vn = {
      shaderID: j,
      shaderType: b.type,
      shaderName: b.name,
      vertexShader: lt,
      fragmentShader: gt,
      defines: b.defines,
      customVertexShaderID: _t,
      customFragmentShaderID: Y,
      isRawShaderMaterial: b.isRawShaderMaterial === !0,
      glslVersion: b.glslVersion,
      precision: f,
      batching: vt,
      batchingColor: vt && B._colorsTexture !== null,
      instancing: dt,
      instancingColor: dt && B.instanceColor !== null,
      instancingMorph: dt && B.morphTexture !== null,
      supportsVertexTextures: d,
      outputColorSpace: it === null ? n.outputColorSpace : it.isXRRenderTarget === !0 ? it.texture.colorSpace : Oc,
      alphaToCoverage: !!b.alphaToCoverage,
      map: Nt,
      matcap: _e,
      envMap: k,
      envMapMode: k && G.mapping,
      envMapCubeUVHeight: U,
      aoMap: te,
      lightMap: It,
      bumpMap: ut,
      normalMap: bt,
      displacementMap: d && Ft,
      emissiveMap: wt,
      normalMapObjectSpace: bt && b.normalMapType === Rz,
      normalMapTangentSpace: bt && b.normalMapType === G3,
      metalnessMap: le,
      roughnessMap: dn,
      anisotropy: Ze,
      anisotropyMap: ot,
      clearcoat: z,
      clearcoatMap: Wt,
      clearcoatNormalMap: Rt,
      clearcoatRoughnessMap: ie,
      dispersion: P,
      iridescence: q,
      iridescenceMap: se,
      iridescenceThicknessMap: Ct,
      sheen: at,
      sheenColorMap: Ot,
      sheenRoughnessMap: fe,
      specularMap: oe,
      specularColorMap: kt,
      specularIntensityMap: Se,
      transmission: mt,
      transmissionMap: F,
      thicknessMap: Et,
      gradientMap: Dt,
      opaque: b.transparent === !1 && b.blending === wc && b.alphaToCoverage === !1,
      alphaMap: Yt,
      alphaTest: St,
      alphaHash: ft,
      combine: b.combine,
      mapUv: Nt && v(b.map.channel),
      aoMapUv: te && v(b.aoMap.channel),
      lightMapUv: It && v(b.lightMap.channel),
      bumpMapUv: ut && v(b.bumpMap.channel),
      normalMapUv: bt && v(b.normalMap.channel),
      displacementMapUv: Ft && v(b.displacementMap.channel),
      emissiveMapUv: wt && v(b.emissiveMap.channel),
      metalnessMapUv: le && v(b.metalnessMap.channel),
      roughnessMapUv: dn && v(b.roughnessMap.channel),
      anisotropyMapUv: ot && v(b.anisotropyMap.channel),
      clearcoatMapUv: Wt && v(b.clearcoatMap.channel),
      clearcoatNormalMapUv: Rt && v(b.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: ie && v(b.clearcoatRoughnessMap.channel),
      iridescenceMapUv: se && v(b.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ct && v(b.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ot && v(b.sheenColorMap.channel),
      sheenRoughnessMapUv: fe && v(b.sheenRoughnessMap.channel),
      specularMapUv: oe && v(b.specularMap.channel),
      specularColorMapUv: kt && v(b.specularColorMap.channel),
      specularIntensityMapUv: Se && v(b.specularIntensityMap.channel),
      transmissionMapUv: F && v(b.transmissionMap.channel),
      thicknessMapUv: Et && v(b.thicknessMap.channel),
      alphaMapUv: Yt && v(b.alphaMap.channel),
      vertexTangents: !!N.attributes.tangent && (bt || Ze),
      vertexColors: b.vertexColors,
      vertexAlphas: b.vertexColors === !0 && !!N.attributes.color && N.attributes.color.itemSize === 4,
      pointsUvs: B.isPoints === !0 && !!N.attributes.uv && (Nt || Yt),
      fog: !!D,
      useFog: b.fog === !0,
      fogExp2: !!D && D.isFogExp2,
      flatShading: b.flatShading === !0 && b.wireframe === !1,
      sizeAttenuation: b.sizeAttenuation === !0,
      logarithmicDepthBuffer: m,
      reversedDepthBuffer: J,
      skinning: B.isSkinnedMesh === !0,
      morphTargets: N.morphAttributes.position !== void 0,
      morphNormals: N.morphAttributes.normal !== void 0,
      morphColors: N.morphAttributes.color !== void 0,
      morphTargetsCount: K,
      morphTextureStride: $,
      numDirLights: y.directional.length,
      numPointLights: y.point.length,
      numSpotLights: y.spot.length,
      numSpotLightMaps: y.spotLightMap.length,
      numRectAreaLights: y.rectArea.length,
      numHemiLights: y.hemi.length,
      numDirLightShadows: y.directionalShadowMap.length,
      numPointLightShadows: y.pointShadowMap.length,
      numSpotLightShadows: y.spotShadowMap.length,
      numSpotLightShadowsWithMaps: y.numSpotLightShadowsWithMaps,
      numLightProbes: y.numLightProbes,
      numClippingPlanes: r.numPlanes,
      numClipIntersection: r.numIntersection,
      dithering: b.dithering,
      shadowMapEnabled: n.shadowMap.enabled && E.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: be,
      decodeVideoTexture: Nt && b.map.isVideoTexture === !0 && Qe.getTransfer(b.map.colorSpace) === pn,
      decodeVideoTextureEmissive: wt && b.emissiveMap.isVideoTexture === !0 && Qe.getTransfer(b.emissiveMap.colorSpace) === pn,
      premultipliedAlpha: b.premultipliedAlpha,
      doubleSided: b.side === As,
      flipSided: b.side === Di,
      useDepthPacking: b.depthPacking >= 0,
      depthPacking: b.depthPacking || 0,
      index0AttributeName: b.index0AttributeName,
      extensionClipCullDistance: ee && b.extensions.clipCullDistance === !0 && s.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (ee && b.extensions.multiDraw === !0 || vt) && s.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: s.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: b.customProgramCacheKey()
    };
    return vn.vertexUv1s = c.has(1), vn.vertexUv2s = c.has(2), vn.vertexUv3s = c.has(3), c.clear(), vn;
  }
  h(_, "getParameters");
  function g(b) {
    const y = [];
    if (b.shaderID ? y.push(b.shaderID) : (y.push(b.customVertexShaderID), y.push(b.customFragmentShaderID)), b.defines !== void 0)
      for (const E in b.defines)
        y.push(E), y.push(b.defines[E]);
    return b.isRawShaderMaterial === !1 && (w(y, b), S(y, b), y.push(n.outputColorSpace)), y.push(b.customProgramCacheKey), y.join();
  }
  h(g, "getProgramCacheKey");
  function w(b, y) {
    b.push(y.precision), b.push(y.outputColorSpace), b.push(y.envMapMode), b.push(y.envMapCubeUVHeight), b.push(y.mapUv), b.push(y.alphaMapUv), b.push(y.lightMapUv), b.push(y.aoMapUv), b.push(y.bumpMapUv), b.push(y.normalMapUv), b.push(y.displacementMapUv), b.push(y.emissiveMapUv), b.push(y.metalnessMapUv), b.push(y.roughnessMapUv), b.push(y.anisotropyMapUv), b.push(y.clearcoatMapUv), b.push(y.clearcoatNormalMapUv), b.push(y.clearcoatRoughnessMapUv), b.push(y.iridescenceMapUv), b.push(y.iridescenceThicknessMapUv), b.push(y.sheenColorMapUv), b.push(y.sheenRoughnessMapUv), b.push(y.specularMapUv), b.push(y.specularColorMapUv), b.push(y.specularIntensityMapUv), b.push(y.transmissionMapUv), b.push(y.thicknessMapUv), b.push(y.combine), b.push(y.fogExp2), b.push(y.sizeAttenuation), b.push(y.morphTargetsCount), b.push(y.morphAttributeCount), b.push(y.numDirLights), b.push(y.numPointLights), b.push(y.numSpotLights), b.push(y.numSpotLightMaps), b.push(y.numHemiLights), b.push(y.numRectAreaLights), b.push(y.numDirLightShadows), b.push(y.numPointLightShadows), b.push(y.numSpotLightShadows), b.push(y.numSpotLightShadowsWithMaps), b.push(y.numLightProbes), b.push(y.shadowMapType), b.push(y.toneMapping), b.push(y.numClippingPlanes), b.push(y.numClipIntersection), b.push(y.depthPacking);
  }
  h(w, "getProgramCacheKeyParameters");
  function S(b, y) {
    a.disableAll(), y.supportsVertexTextures && a.enable(0), y.instancing && a.enable(1), y.instancingColor && a.enable(2), y.instancingMorph && a.enable(3), y.matcap && a.enable(4), y.envMap && a.enable(5), y.normalMapObjectSpace && a.enable(6), y.normalMapTangentSpace && a.enable(7), y.clearcoat && a.enable(8), y.iridescence && a.enable(9), y.alphaTest && a.enable(10), y.vertexColors && a.enable(11), y.vertexAlphas && a.enable(12), y.vertexUv1s && a.enable(13), y.vertexUv2s && a.enable(14), y.vertexUv3s && a.enable(15), y.vertexTangents && a.enable(16), y.anisotropy && a.enable(17), y.alphaHash && a.enable(18), y.batching && a.enable(19), y.dispersion && a.enable(20), y.batchingColor && a.enable(21), y.gradientMap && a.enable(22), b.push(a.mask), a.disableAll(), y.fog && a.enable(0), y.useFog && a.enable(1), y.flatShading && a.enable(2), y.logarithmicDepthBuffer && a.enable(3), y.reversedDepthBuffer && a.enable(4), y.skinning && a.enable(5), y.morphTargets && a.enable(6), y.morphNormals && a.enable(7), y.morphColors && a.enable(8), y.premultipliedAlpha && a.enable(9), y.shadowMapEnabled && a.enable(10), y.doubleSided && a.enable(11), y.flipSided && a.enable(12), y.useDepthPacking && a.enable(13), y.dithering && a.enable(14), y.transmission && a.enable(15), y.sheen && a.enable(16), y.opaque && a.enable(17), y.pointsUvs && a.enable(18), y.decodeVideoTexture && a.enable(19), y.decodeVideoTextureEmissive && a.enable(20), y.alphaToCoverage && a.enable(21), b.push(a.mask);
  }
  h(S, "getProgramCacheKeyBooleans");
  function x(b) {
    const y = p[b.type];
    let E;
    if (y) {
      const I = Os[y];
      E = xk.clone(I.uniforms);
    } else
      E = b.uniforms;
    return E;
  }
  h(x, "getUniforms");
  function A(b, y) {
    let E;
    for (let I = 0, B = u.length; I < B; I++) {
      const D = u[I];
      if (D.cacheKey === y) {
        E = D, ++E.usedTimes;
        break;
      }
    }
    return E === void 0 && (E = new LF(n, y, b, o), u.push(E)), E;
  }
  h(A, "acquireProgram");
  function C(b) {
    if (--b.usedTimes === 0) {
      const y = u.indexOf(b);
      u[y] = u[u.length - 1], u.pop(), b.destroy();
    }
  }
  h(C, "releaseProgram");
  function M(b) {
    l.remove(b);
  }
  h(M, "releaseShaderCache");
  function T() {
    l.dispose();
  }
  return h(T, "dispose"), {
    getParameters: _,
    getProgramCacheKey: g,
    getUniforms: x,
    acquireProgram: A,
    releaseProgram: C,
    releaseShaderCache: M,
    programs: u,
    dispose: T
  };
}
h(zF, "WebGLPrograms");
function kF() {
  let n = /* @__PURE__ */ new WeakMap();
  function t(r) {
    return n.has(r);
  }
  h(t, "has");
  function e(r) {
    let a = n.get(r);
    return a === void 0 && (a = {}, n.set(r, a)), a;
  }
  h(e, "get");
  function s(r) {
    n.delete(r);
  }
  h(s, "remove");
  function i(r, a, l) {
    n.get(r)[a] = l;
  }
  h(i, "update");
  function o() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return h(o, "dispose"), {
    has: t,
    get: e,
    remove: s,
    update: i,
    dispose: o
  };
}
h(kF, "WebGLProperties");
function UF(n, t) {
  return n.groupOrder !== t.groupOrder ? n.groupOrder - t.groupOrder : n.renderOrder !== t.renderOrder ? n.renderOrder - t.renderOrder : n.material.id !== t.material.id ? n.material.id - t.material.id : n.z !== t.z ? n.z - t.z : n.id - t.id;
}
h(UF, "painterSortStable");
function CS(n, t) {
  return n.groupOrder !== t.groupOrder ? n.groupOrder - t.groupOrder : n.renderOrder !== t.renderOrder ? n.renderOrder - t.renderOrder : n.z !== t.z ? t.z - n.z : n.id - t.id;
}
h(CS, "reversePainterSortStable");
function ES() {
  const n = [];
  let t = 0;
  const e = [], s = [], i = [];
  function o() {
    t = 0, e.length = 0, s.length = 0, i.length = 0;
  }
  h(o, "init");
  function r(m, d, f, p, v, _) {
    let g = n[t];
    return g === void 0 ? (g = {
      id: m.id,
      object: m,
      geometry: d,
      material: f,
      groupOrder: p,
      renderOrder: m.renderOrder,
      z: v,
      group: _
    }, n[t] = g) : (g.id = m.id, g.object = m, g.geometry = d, g.material = f, g.groupOrder = p, g.renderOrder = m.renderOrder, g.z = v, g.group = _), t++, g;
  }
  h(r, "getNextRenderItem");
  function a(m, d, f, p, v, _) {
    const g = r(m, d, f, p, v, _);
    f.transmission > 0 ? s.push(g) : f.transparent === !0 ? i.push(g) : e.push(g);
  }
  h(a, "push");
  function l(m, d, f, p, v, _) {
    const g = r(m, d, f, p, v, _);
    f.transmission > 0 ? s.unshift(g) : f.transparent === !0 ? i.unshift(g) : e.unshift(g);
  }
  h(l, "unshift");
  function c(m, d) {
    e.length > 1 && e.sort(m || UF), s.length > 1 && s.sort(d || CS), i.length > 1 && i.sort(d || CS);
  }
  h(c, "sort");
  function u() {
    for (let m = t, d = n.length; m < d; m++) {
      const f = n[m];
      if (f.id === null) break;
      f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
    }
  }
  return h(u, "finish"), {
    opaque: e,
    transmissive: s,
    transparent: i,
    init: o,
    push: a,
    unshift: l,
    finish: u,
    sort: c
  };
}
h(ES, "WebGLRenderList");
function OF() {
  let n = /* @__PURE__ */ new WeakMap();
  function t(s, i) {
    const o = n.get(s);
    let r;
    return o === void 0 ? (r = new ES(), n.set(s, [r])) : i >= o.length ? (r = new ES(), o.push(r)) : r = o[i], r;
  }
  h(t, "get");
  function e() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return h(e, "dispose"), {
    get: t,
    dispose: e
  };
}
h(OF, "WebGLRenderLists");
function $F() {
  const n = {};
  return {
    get: /* @__PURE__ */ h(function(t) {
      if (n[t.id] !== void 0)
        return n[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = {
            direction: new O(),
            color: new Ce()
          };
          break;
        case "SpotLight":
          e = {
            position: new O(),
            direction: new O(),
            color: new Ce(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          e = {
            position: new O(),
            color: new Ce(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          e = {
            direction: new O(),
            skyColor: new Ce(),
            groundColor: new Ce()
          };
          break;
        case "RectAreaLight":
          e = {
            color: new Ce(),
            position: new O(),
            halfWidth: new O(),
            halfHeight: new O()
          };
          break;
      }
      return n[t.id] = e, e;
    }, "get")
  };
}
h($F, "UniformsCache");
function FF() {
  const n = {};
  return {
    get: /* @__PURE__ */ h(function(t) {
      if (n[t.id] !== void 0)
        return n[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Pe()
          };
          break;
        case "SpotLight":
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Pe()
          };
          break;
        case "PointLight":
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Pe(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return n[t.id] = e, e;
    }, "get")
  };
}
h(FF, "ShadowUniformsCache");
let GF = 0;
function HF(n, t) {
  return (t.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (n.map ? 1 : 0);
}
h(HF, "shadowCastingAndTexturingLightsFirst");
function jF(n) {
  const t = new $F(), e = FF(), s = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let c = 0; c < 9; c++) s.probe.push(new O());
  const i = new O(), o = new Re(), r = new Re();
  function a(c) {
    let u = 0, m = 0, d = 0;
    for (let b = 0; b < 9; b++) s.probe[b].set(0, 0, 0);
    let f = 0, p = 0, v = 0, _ = 0, g = 0, w = 0, S = 0, x = 0, A = 0, C = 0, M = 0;
    c.sort(HF);
    for (let b = 0, y = c.length; b < y; b++) {
      const E = c[b], I = E.color, B = E.intensity, D = E.distance, N = E.shadow && E.shadow.map ? E.shadow.map.texture : null;
      if (E.isAmbientLight)
        u += I.r * B, m += I.g * B, d += I.b * B;
      else if (E.isLightProbe) {
        for (let V = 0; V < 9; V++)
          s.probe[V].addScaledVector(E.sh.coefficients[V], B);
        M++;
      } else if (E.isDirectionalLight) {
        const V = t.get(E);
        if (V.color.copy(E.color).multiplyScalar(E.intensity), E.castShadow) {
          const G = E.shadow, U = e.get(E);
          U.shadowIntensity = G.intensity, U.shadowBias = G.bias, U.shadowNormalBias = G.normalBias, U.shadowRadius = G.radius, U.shadowMapSize = G.mapSize, s.directionalShadow[f] = U, s.directionalShadowMap[f] = N, s.directionalShadowMatrix[f] = E.shadow.matrix, w++;
        }
        s.directional[f] = V, f++;
      } else if (E.isSpotLight) {
        const V = t.get(E);
        V.position.setFromMatrixPosition(E.matrixWorld), V.color.copy(I).multiplyScalar(B), V.distance = D, V.coneCos = Math.cos(E.angle), V.penumbraCos = Math.cos(E.angle * (1 - E.penumbra)), V.decay = E.decay, s.spot[v] = V;
        const G = E.shadow;
        if (E.map && (s.spotLightMap[A] = E.map, A++, G.updateMatrices(E), E.castShadow && C++), s.spotLightMatrix[v] = G.matrix, E.castShadow) {
          const U = e.get(E);
          U.shadowIntensity = G.intensity, U.shadowBias = G.bias, U.shadowNormalBias = G.normalBias, U.shadowRadius = G.radius, U.shadowMapSize = G.mapSize, s.spotShadow[v] = U, s.spotShadowMap[v] = N, x++;
        }
        v++;
      } else if (E.isRectAreaLight) {
        const V = t.get(E);
        V.color.copy(I).multiplyScalar(B), V.halfWidth.set(E.width * 0.5, 0, 0), V.halfHeight.set(0, E.height * 0.5, 0), s.rectArea[_] = V, _++;
      } else if (E.isPointLight) {
        const V = t.get(E);
        if (V.color.copy(E.color).multiplyScalar(E.intensity), V.distance = E.distance, V.decay = E.decay, E.castShadow) {
          const G = E.shadow, U = e.get(E);
          U.shadowIntensity = G.intensity, U.shadowBias = G.bias, U.shadowNormalBias = G.normalBias, U.shadowRadius = G.radius, U.shadowMapSize = G.mapSize, U.shadowCameraNear = G.camera.near, U.shadowCameraFar = G.camera.far, s.pointShadow[p] = U, s.pointShadowMap[p] = N, s.pointShadowMatrix[p] = E.shadow.matrix, S++;
        }
        s.point[p] = V, p++;
      } else if (E.isHemisphereLight) {
        const V = t.get(E);
        V.skyColor.copy(E.color).multiplyScalar(B), V.groundColor.copy(E.groundColor).multiplyScalar(B), s.hemi[g] = V, g++;
      }
    }
    _ > 0 && (n.has("OES_texture_float_linear") === !0 ? (s.rectAreaLTC1 = zt.LTC_FLOAT_1, s.rectAreaLTC2 = zt.LTC_FLOAT_2) : (s.rectAreaLTC1 = zt.LTC_HALF_1, s.rectAreaLTC2 = zt.LTC_HALF_2)), s.ambient[0] = u, s.ambient[1] = m, s.ambient[2] = d;
    const T = s.hash;
    (T.directionalLength !== f || T.pointLength !== p || T.spotLength !== v || T.rectAreaLength !== _ || T.hemiLength !== g || T.numDirectionalShadows !== w || T.numPointShadows !== S || T.numSpotShadows !== x || T.numSpotMaps !== A || T.numLightProbes !== M) && (s.directional.length = f, s.spot.length = v, s.rectArea.length = _, s.point.length = p, s.hemi.length = g, s.directionalShadow.length = w, s.directionalShadowMap.length = w, s.pointShadow.length = S, s.pointShadowMap.length = S, s.spotShadow.length = x, s.spotShadowMap.length = x, s.directionalShadowMatrix.length = w, s.pointShadowMatrix.length = S, s.spotLightMatrix.length = x + A - C, s.spotLightMap.length = A, s.numSpotLightShadowsWithMaps = C, s.numLightProbes = M, T.directionalLength = f, T.pointLength = p, T.spotLength = v, T.rectAreaLength = _, T.hemiLength = g, T.numDirectionalShadows = w, T.numPointShadows = S, T.numSpotShadows = x, T.numSpotMaps = A, T.numLightProbes = M, s.version = GF++);
  }
  h(a, "setup");
  function l(c, u) {
    let m = 0, d = 0, f = 0, p = 0, v = 0;
    const _ = u.matrixWorldInverse;
    for (let g = 0, w = c.length; g < w; g++) {
      const S = c[g];
      if (S.isDirectionalLight) {
        const x = s.directional[m];
        x.direction.setFromMatrixPosition(S.matrixWorld), i.setFromMatrixPosition(S.target.matrixWorld), x.direction.sub(i), x.direction.transformDirection(_), m++;
      } else if (S.isSpotLight) {
        const x = s.spot[f];
        x.position.setFromMatrixPosition(S.matrixWorld), x.position.applyMatrix4(_), x.direction.setFromMatrixPosition(S.matrixWorld), i.setFromMatrixPosition(S.target.matrixWorld), x.direction.sub(i), x.direction.transformDirection(_), f++;
      } else if (S.isRectAreaLight) {
        const x = s.rectArea[p];
        x.position.setFromMatrixPosition(S.matrixWorld), x.position.applyMatrix4(_), r.identity(), o.copy(S.matrixWorld), o.premultiply(_), r.extractRotation(o), x.halfWidth.set(S.width * 0.5, 0, 0), x.halfHeight.set(0, S.height * 0.5, 0), x.halfWidth.applyMatrix4(r), x.halfHeight.applyMatrix4(r), p++;
      } else if (S.isPointLight) {
        const x = s.point[d];
        x.position.setFromMatrixPosition(S.matrixWorld), x.position.applyMatrix4(_), d++;
      } else if (S.isHemisphereLight) {
        const x = s.hemi[v];
        x.direction.setFromMatrixPosition(S.matrixWorld), x.direction.transformDirection(_), v++;
      }
    }
  }
  return h(l, "setupView"), {
    setup: a,
    setupView: l,
    state: s
  };
}
h(jF, "WebGLLights");
function TS(n) {
  const t = new jF(n), e = [], s = [];
  function i(u) {
    c.camera = u, e.length = 0, s.length = 0;
  }
  h(i, "init");
  function o(u) {
    e.push(u);
  }
  h(o, "pushLight");
  function r(u) {
    s.push(u);
  }
  h(r, "pushShadow");
  function a() {
    t.setup(e);
  }
  h(a, "setupLights");
  function l(u) {
    t.setupView(e, u);
  }
  h(l, "setupLightsView");
  const c = {
    lightsArray: e,
    shadowsArray: s,
    camera: null,
    lights: t,
    transmissionRenderTarget: {}
  };
  return {
    init: i,
    state: c,
    setupLights: a,
    setupLightsView: l,
    pushLight: o,
    pushShadow: r
  };
}
h(TS, "WebGLRenderState");
function WF(n) {
  let t = /* @__PURE__ */ new WeakMap();
  function e(i, o = 0) {
    const r = t.get(i);
    let a;
    return r === void 0 ? (a = new TS(n), t.set(i, [a])) : o >= r.length ? (a = new TS(n), r.push(a)) : a = r[o], a;
  }
  h(e, "get");
  function s() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return h(s, "dispose"), {
    get: e,
    dispose: s
  };
}
h(WF, "WebGLRenderStates");
const qF = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, XF = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function ZF(n, t, e) {
  let s = new ya();
  const i = new Pe(), o = new Pe(), r = new an(), a = new N_({ depthPacking: Pz }), l = new z_(), c = {}, u = e.maxTextureSize, m = { [yr]: Di, [Di]: yr, [As]: As }, d = new Qs({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Pe() },
      radius: { value: 4 }
    },
    vertexShader: qF,
    fragmentShader: XF
  }), f = d.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const p = new Ks();
  p.setAttribute(
    "position",
    new ds(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const v = new Bi(p, d), _ = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = P3;
  let g = this.type;
  this.render = function(C, M, T) {
    if (_.enabled === !1 || _.autoUpdate === !1 && _.needsUpdate === !1 || C.length === 0) return;
    const b = n.getRenderTarget(), y = n.getActiveCubeFace(), E = n.getActiveMipmapLevel(), I = n.state;
    I.setBlending(hr), I.buffers.depth.getReversed() === !0 ? I.buffers.color.setClear(0, 0, 0, 0) : I.buffers.color.setClear(1, 1, 1, 1), I.buffers.depth.setTest(!0), I.setScissorTest(!1);
    const B = g !== wo && this.type === wo, D = g === wo && this.type !== wo;
    for (let N = 0, V = C.length; N < V; N++) {
      const G = C[N], U = G.shadow;
      if (U === void 0) {
        console.warn("THREE.WebGLShadowMap:", G, "has no shadow.");
        continue;
      }
      if (U.autoUpdate === !1 && U.needsUpdate === !1) continue;
      i.copy(U.mapSize);
      const j = U.getFrameExtents();
      if (i.multiply(j), o.copy(U.mapSize), (i.x > u || i.y > u) && (i.x > u && (o.x = Math.floor(u / j.x), i.x = o.x * j.x, U.mapSize.x = o.x), i.y > u && (o.y = Math.floor(u / j.y), i.y = o.y * j.y, U.mapSize.y = o.y)), U.map === null || B === !0 || D === !0) {
        const K = this.type !== wo ? { minFilter: Ts, magFilter: Ts } : {};
        U.map !== null && U.map.dispose(), U.map = new Oo(i.x, i.y, K), U.map.texture.name = G.name + ".shadowMap", U.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(U.map), n.clear();
      const tt = U.getViewportCount();
      for (let K = 0; K < tt; K++) {
        const $ = U.getViewport(K);
        r.set(
          o.x * $.x,
          o.y * $.y,
          o.x * $.z,
          o.y * $.w
        ), I.viewport(r), U.updateMatrices(G, K), s = U.getFrustum(), x(M, T, U.camera, G, this.type);
      }
      U.isPointLightShadow !== !0 && this.type === wo && w(U, T), U.needsUpdate = !1;
    }
    g = this.type, _.needsUpdate = !1, n.setRenderTarget(b, y, E);
  };
  function w(C, M) {
    const T = t.update(v);
    d.defines.VSM_SAMPLES !== C.blurSamples && (d.defines.VSM_SAMPLES = C.blurSamples, f.defines.VSM_SAMPLES = C.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), C.mapPass === null && (C.mapPass = new Oo(i.x, i.y)), d.uniforms.shadow_pass.value = C.map.texture, d.uniforms.resolution.value = C.mapSize, d.uniforms.radius.value = C.radius, n.setRenderTarget(C.mapPass), n.clear(), n.renderBufferDirect(M, null, T, d, v, null), f.uniforms.shadow_pass.value = C.mapPass.texture, f.uniforms.resolution.value = C.mapSize, f.uniforms.radius.value = C.radius, n.setRenderTarget(C.map), n.clear(), n.renderBufferDirect(M, null, T, f, v, null);
  }
  h(w, "VSMPass");
  function S(C, M, T, b) {
    let y = null;
    const E = T.isPointLight === !0 ? C.customDistanceMaterial : C.customDepthMaterial;
    if (E !== void 0)
      y = E;
    else if (y = T.isPointLight === !0 ? l : a, n.localClippingEnabled && M.clipShadows === !0 && Array.isArray(M.clippingPlanes) && M.clippingPlanes.length !== 0 || M.displacementMap && M.displacementScale !== 0 || M.alphaMap && M.alphaTest > 0 || M.map && M.alphaTest > 0 || M.alphaToCoverage === !0) {
      const I = y.uuid, B = M.uuid;
      let D = c[I];
      D === void 0 && (D = {}, c[I] = D);
      let N = D[B];
      N === void 0 && (N = y.clone(), D[B] = N, M.addEventListener("dispose", A)), y = N;
    }
    if (y.visible = M.visible, y.wireframe = M.wireframe, b === wo ? y.side = M.shadowSide !== null ? M.shadowSide : M.side : y.side = M.shadowSide !== null ? M.shadowSide : m[M.side], y.alphaMap = M.alphaMap, y.alphaTest = M.alphaToCoverage === !0 ? 0.5 : M.alphaTest, y.map = M.map, y.clipShadows = M.clipShadows, y.clippingPlanes = M.clippingPlanes, y.clipIntersection = M.clipIntersection, y.displacementMap = M.displacementMap, y.displacementScale = M.displacementScale, y.displacementBias = M.displacementBias, y.wireframeLinewidth = M.wireframeLinewidth, y.linewidth = M.linewidth, T.isPointLight === !0 && y.isMeshDistanceMaterial === !0) {
      const I = n.properties.get(y);
      I.light = T;
    }
    return y;
  }
  h(S, "getDepthMaterial");
  function x(C, M, T, b, y) {
    if (C.visible === !1) return;
    if (C.layers.test(M.layers) && (C.isMesh || C.isLine || C.isPoints) && (C.castShadow || C.receiveShadow && y === wo) && (!C.frustumCulled || s.intersectsObject(C))) {
      C.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, C.matrixWorld);
      const B = t.update(C), D = C.material;
      if (Array.isArray(D)) {
        const N = B.groups;
        for (let V = 0, G = N.length; V < G; V++) {
          const U = N[V], j = D[U.materialIndex];
          if (j && j.visible) {
            const tt = S(C, j, b, y);
            C.onBeforeShadow(n, C, M, T, B, tt, U), n.renderBufferDirect(T, null, B, tt, C, U), C.onAfterShadow(n, C, M, T, B, tt, U);
          }
        }
      } else if (D.visible) {
        const N = S(C, D, b, y);
        C.onBeforeShadow(n, C, M, T, B, N, null), n.renderBufferDirect(T, null, B, N, C, null), C.onAfterShadow(n, C, M, T, B, N, null);
      }
    }
    const I = C.children;
    for (let B = 0, D = I.length; B < D; B++)
      x(I[B], M, T, b, y);
  }
  h(x, "renderObject");
  function A(C) {
    C.target.removeEventListener("dispose", A);
    for (const T in c) {
      const b = c[T], y = C.target.uuid;
      y in b && (b[y].dispose(), delete b[y]);
    }
  }
  h(A, "onMaterialDispose");
}
h(ZF, "WebGLShadowMap");
const YF = {
  [Gp]: Hp,
  [jp]: Xp,
  [Wp]: Zp,
  [zc]: qp,
  [Hp]: Gp,
  [Xp]: jp,
  [Zp]: Wp,
  [qp]: zc
};
function JF(n, t) {
  function e() {
    let F = !1;
    const Et = new an();
    let Dt = null;
    const Yt = new an(0, 0, 0, 0);
    return {
      setMask: /* @__PURE__ */ h(function(St) {
        Dt !== St && !F && (n.colorMask(St, St, St, St), Dt = St);
      }, "setMask"),
      setLocked: /* @__PURE__ */ h(function(St) {
        F = St;
      }, "setLocked"),
      setClear: /* @__PURE__ */ h(function(St, ft, ee, be, vn) {
        vn === !0 && (St *= be, ft *= be, ee *= be), Et.set(St, ft, ee, be), Yt.equals(Et) === !1 && (n.clearColor(St, ft, ee, be), Yt.copy(Et));
      }, "setClear"),
      reset: /* @__PURE__ */ h(function() {
        F = !1, Dt = null, Yt.set(-1, 0, 0, 0);
      }, "reset")
    };
  }
  h(e, "ColorBuffer");
  function s() {
    let F = !1, Et = !1, Dt = null, Yt = null, St = null;
    return {
      setReversed: /* @__PURE__ */ h(function(ft) {
        if (Et !== ft) {
          const ee = t.get("EXT_clip_control");
          ft ? ee.clipControlEXT(ee.LOWER_LEFT_EXT, ee.ZERO_TO_ONE_EXT) : ee.clipControlEXT(ee.LOWER_LEFT_EXT, ee.NEGATIVE_ONE_TO_ONE_EXT), Et = ft;
          const be = St;
          St = null, this.setClear(be);
        }
      }, "setReversed"),
      getReversed: /* @__PURE__ */ h(function() {
        return Et;
      }, "getReversed"),
      setTest: /* @__PURE__ */ h(function(ft) {
        ft ? it(n.DEPTH_TEST) : J(n.DEPTH_TEST);
      }, "setTest"),
      setMask: /* @__PURE__ */ h(function(ft) {
        Dt !== ft && !F && (n.depthMask(ft), Dt = ft);
      }, "setMask"),
      setFunc: /* @__PURE__ */ h(function(ft) {
        if (Et && (ft = YF[ft]), Yt !== ft) {
          switch (ft) {
            case Gp:
              n.depthFunc(n.NEVER);
              break;
            case Hp:
              n.depthFunc(n.ALWAYS);
              break;
            case jp:
              n.depthFunc(n.LESS);
              break;
            case zc:
              n.depthFunc(n.LEQUAL);
              break;
            case Wp:
              n.depthFunc(n.EQUAL);
              break;
            case qp:
              n.depthFunc(n.GEQUAL);
              break;
            case Xp:
              n.depthFunc(n.GREATER);
              break;
            case Zp:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          Yt = ft;
        }
      }, "setFunc"),
      setLocked: /* @__PURE__ */ h(function(ft) {
        F = ft;
      }, "setLocked"),
      setClear: /* @__PURE__ */ h(function(ft) {
        St !== ft && (Et && (ft = 1 - ft), n.clearDepth(ft), St = ft);
      }, "setClear"),
      reset: /* @__PURE__ */ h(function() {
        F = !1, Dt = null, Yt = null, St = null, Et = !1;
      }, "reset")
    };
  }
  h(s, "DepthBuffer");
  function i() {
    let F = !1, Et = null, Dt = null, Yt = null, St = null, ft = null, ee = null, be = null, vn = null;
    return {
      setTest: /* @__PURE__ */ h(function(nn) {
        F || (nn ? it(n.STENCIL_TEST) : J(n.STENCIL_TEST));
      }, "setTest"),
      setMask: /* @__PURE__ */ h(function(nn) {
        Et !== nn && !F && (n.stencilMask(nn), Et = nn);
      }, "setMask"),
      setFunc: /* @__PURE__ */ h(function(nn, io, Rs) {
        (Dt !== nn || Yt !== io || St !== Rs) && (n.stencilFunc(nn, io, Rs), Dt = nn, Yt = io, St = Rs);
      }, "setFunc"),
      setOp: /* @__PURE__ */ h(function(nn, io, Rs) {
        (ft !== nn || ee !== io || be !== Rs) && (n.stencilOp(nn, io, Rs), ft = nn, ee = io, be = Rs);
      }, "setOp"),
      setLocked: /* @__PURE__ */ h(function(nn) {
        F = nn;
      }, "setLocked"),
      setClear: /* @__PURE__ */ h(function(nn) {
        vn !== nn && (n.clearStencil(nn), vn = nn);
      }, "setClear"),
      reset: /* @__PURE__ */ h(function() {
        F = !1, Et = null, Dt = null, Yt = null, St = null, ft = null, ee = null, be = null, vn = null;
      }, "reset")
    };
  }
  h(i, "StencilBuffer");
  const o = new e(), r = new s(), a = new i(), l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
  let u = {}, m = {}, d = /* @__PURE__ */ new WeakMap(), f = [], p = null, v = !1, _ = null, g = null, w = null, S = null, x = null, A = null, C = null, M = new Ce(0, 0, 0), T = 0, b = !1, y = null, E = null, I = null, B = null, D = null;
  const N = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let V = !1, G = 0;
  const U = n.getParameter(n.VERSION);
  U.indexOf("WebGL") !== -1 ? (G = parseFloat(/^WebGL (\d)/.exec(U)[1]), V = G >= 1) : U.indexOf("OpenGL ES") !== -1 && (G = parseFloat(/^OpenGL ES (\d)/.exec(U)[1]), V = G >= 2);
  let j = null, tt = {};
  const K = n.getParameter(n.SCISSOR_BOX), $ = n.getParameter(n.VIEWPORT), lt = new an().fromArray(K), gt = new an().fromArray($);
  function _t(F, Et, Dt, Yt) {
    const St = new Uint8Array(4), ft = n.createTexture();
    n.bindTexture(F, ft), n.texParameteri(F, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(F, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let ee = 0; ee < Dt; ee++)
      F === n.TEXTURE_3D || F === n.TEXTURE_2D_ARRAY ? n.texImage3D(Et, 0, n.RGBA, 1, 1, Yt, 0, n.RGBA, n.UNSIGNED_BYTE, St) : n.texImage2D(Et + ee, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, St);
    return ft;
  }
  h(_t, "createTexture");
  const Y = {};
  Y[n.TEXTURE_2D] = _t(n.TEXTURE_2D, n.TEXTURE_2D, 1), Y[n.TEXTURE_CUBE_MAP] = _t(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), Y[n.TEXTURE_2D_ARRAY] = _t(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), Y[n.TEXTURE_3D] = _t(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1), o.setClear(0, 0, 0, 1), r.setClear(1), a.setClear(0), it(n.DEPTH_TEST), r.setFunc(zc), ut(!1), bt(Pw), it(n.CULL_FACE), te(hr);
  function it(F) {
    u[F] !== !0 && (n.enable(F), u[F] = !0);
  }
  h(it, "enable");
  function J(F) {
    u[F] !== !1 && (n.disable(F), u[F] = !1);
  }
  h(J, "disable");
  function dt(F, Et) {
    return m[F] !== Et ? (n.bindFramebuffer(F, Et), m[F] = Et, F === n.DRAW_FRAMEBUFFER && (m[n.FRAMEBUFFER] = Et), F === n.FRAMEBUFFER && (m[n.DRAW_FRAMEBUFFER] = Et), !0) : !1;
  }
  h(dt, "bindFramebuffer");
  function vt(F, Et) {
    let Dt = f, Yt = !1;
    if (F) {
      Dt = d.get(Et), Dt === void 0 && (Dt = [], d.set(Et, Dt));
      const St = F.textures;
      if (Dt.length !== St.length || Dt[0] !== n.COLOR_ATTACHMENT0) {
        for (let ft = 0, ee = St.length; ft < ee; ft++)
          Dt[ft] = n.COLOR_ATTACHMENT0 + ft;
        Dt.length = St.length, Yt = !0;
      }
    } else
      Dt[0] !== n.BACK && (Dt[0] = n.BACK, Yt = !0);
    Yt && n.drawBuffers(Dt);
  }
  h(vt, "drawBuffers");
  function Nt(F) {
    return p !== F ? (n.useProgram(F), p = F, !0) : !1;
  }
  h(Nt, "useProgram");
  const _e = {
    [qr]: n.FUNC_ADD,
    [iz]: n.FUNC_SUBTRACT,
    [sz]: n.FUNC_REVERSE_SUBTRACT
  };
  _e[oz] = n.MIN, _e[rz] = n.MAX;
  const k = {
    [az]: n.ZERO,
    [cz]: n.ONE,
    [lz]: n.SRC_COLOR,
    [$p]: n.SRC_ALPHA,
    [pz]: n.SRC_ALPHA_SATURATE,
    [mz]: n.DST_COLOR,
    [hz]: n.DST_ALPHA,
    [uz]: n.ONE_MINUS_SRC_COLOR,
    [Fp]: n.ONE_MINUS_SRC_ALPHA,
    [fz]: n.ONE_MINUS_DST_COLOR,
    [dz]: n.ONE_MINUS_DST_ALPHA,
    [_z]: n.CONSTANT_COLOR,
    [gz]: n.ONE_MINUS_CONSTANT_COLOR,
    [vz]: n.CONSTANT_ALPHA,
    [bz]: n.ONE_MINUS_CONSTANT_ALPHA
  };
  function te(F, Et, Dt, Yt, St, ft, ee, be, vn, nn) {
    if (F === hr) {
      v === !0 && (J(n.BLEND), v = !1);
      return;
    }
    if (v === !1 && (it(n.BLEND), v = !0), F !== nz) {
      if (F !== _ || nn !== b) {
        if ((g !== qr || x !== qr) && (n.blendEquation(n.FUNC_ADD), g = qr, x = qr), nn)
          switch (F) {
            case wc:
              n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case Rw:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case Dw:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case Vw:
              n.blendFuncSeparate(n.DST_COLOR, n.ONE_MINUS_SRC_ALPHA, n.ZERO, n.ONE);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", F);
              break;
          }
        else
          switch (F) {
            case wc:
              n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case Rw:
              n.blendFuncSeparate(n.SRC_ALPHA, n.ONE, n.ONE, n.ONE);
              break;
            case Dw:
              console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
              break;
            case Vw:
              console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", F);
              break;
          }
        w = null, S = null, A = null, C = null, M.set(0, 0, 0), T = 0, _ = F, b = nn;
      }
      return;
    }
    St = St || Et, ft = ft || Dt, ee = ee || Yt, (Et !== g || St !== x) && (n.blendEquationSeparate(_e[Et], _e[St]), g = Et, x = St), (Dt !== w || Yt !== S || ft !== A || ee !== C) && (n.blendFuncSeparate(k[Dt], k[Yt], k[ft], k[ee]), w = Dt, S = Yt, A = ft, C = ee), (be.equals(M) === !1 || vn !== T) && (n.blendColor(be.r, be.g, be.b, vn), M.copy(be), T = vn), _ = F, b = !1;
  }
  h(te, "setBlending");
  function It(F, Et) {
    F.side === As ? J(n.CULL_FACE) : it(n.CULL_FACE);
    let Dt = F.side === Di;
    Et && (Dt = !Dt), ut(Dt), F.blending === wc && F.transparent === !1 ? te(hr) : te(F.blending, F.blendEquation, F.blendSrc, F.blendDst, F.blendEquationAlpha, F.blendSrcAlpha, F.blendDstAlpha, F.blendColor, F.blendAlpha, F.premultipliedAlpha), r.setFunc(F.depthFunc), r.setTest(F.depthTest), r.setMask(F.depthWrite), o.setMask(F.colorWrite);
    const Yt = F.stencilWrite;
    a.setTest(Yt), Yt && (a.setMask(F.stencilWriteMask), a.setFunc(F.stencilFunc, F.stencilRef, F.stencilFuncMask), a.setOp(F.stencilFail, F.stencilZFail, F.stencilZPass)), wt(F.polygonOffset, F.polygonOffsetFactor, F.polygonOffsetUnits), F.alphaToCoverage === !0 ? it(n.SAMPLE_ALPHA_TO_COVERAGE) : J(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  h(It, "setMaterial");
  function ut(F) {
    y !== F && (F ? n.frontFace(n.CW) : n.frontFace(n.CCW), y = F);
  }
  h(ut, "setFlipSided");
  function bt(F) {
    F !== tz ? (it(n.CULL_FACE), F !== E && (F === Pw ? n.cullFace(n.BACK) : F === ez ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : J(n.CULL_FACE), E = F;
  }
  h(bt, "setCullFace");
  function Ft(F) {
    F !== I && (V && n.lineWidth(F), I = F);
  }
  h(Ft, "setLineWidth");
  function wt(F, Et, Dt) {
    F ? (it(n.POLYGON_OFFSET_FILL), (B !== Et || D !== Dt) && (n.polygonOffset(Et, Dt), B = Et, D = Dt)) : J(n.POLYGON_OFFSET_FILL);
  }
  h(wt, "setPolygonOffset");
  function le(F) {
    F ? it(n.SCISSOR_TEST) : J(n.SCISSOR_TEST);
  }
  h(le, "setScissorTest");
  function dn(F) {
    F === void 0 && (F = n.TEXTURE0 + N - 1), j !== F && (n.activeTexture(F), j = F);
  }
  h(dn, "activeTexture");
  function Ze(F, Et, Dt) {
    Dt === void 0 && (j === null ? Dt = n.TEXTURE0 + N - 1 : Dt = j);
    let Yt = tt[Dt];
    Yt === void 0 && (Yt = { type: void 0, texture: void 0 }, tt[Dt] = Yt), (Yt.type !== F || Yt.texture !== Et) && (j !== Dt && (n.activeTexture(Dt), j = Dt), n.bindTexture(F, Et || Y[F]), Yt.type = F, Yt.texture = Et);
  }
  h(Ze, "bindTexture");
  function z() {
    const F = tt[j];
    F !== void 0 && F.type !== void 0 && (n.bindTexture(F.type, null), F.type = void 0, F.texture = void 0);
  }
  h(z, "unbindTexture");
  function P() {
    try {
      n.compressedTexImage2D(...arguments);
    } catch (F) {
      console.error("THREE.WebGLState:", F);
    }
  }
  h(P, "compressedTexImage2D");
  function q() {
    try {
      n.compressedTexImage3D(...arguments);
    } catch (F) {
      console.error("THREE.WebGLState:", F);
    }
  }
  h(q, "compressedTexImage3D");
  function at() {
    try {
      n.texSubImage2D(...arguments);
    } catch (F) {
      console.error("THREE.WebGLState:", F);
    }
  }
  h(at, "texSubImage2D");
  function mt() {
    try {
      n.texSubImage3D(...arguments);
    } catch (F) {
      console.error("THREE.WebGLState:", F);
    }
  }
  h(mt, "texSubImage3D");
  function ot() {
    try {
      n.compressedTexSubImage2D(...arguments);
    } catch (F) {
      console.error("THREE.WebGLState:", F);
    }
  }
  h(ot, "compressedTexSubImage2D");
  function Wt() {
    try {
      n.compressedTexSubImage3D(...arguments);
    } catch (F) {
      console.error("THREE.WebGLState:", F);
    }
  }
  h(Wt, "compressedTexSubImage3D");
  function Rt() {
    try {
      n.texStorage2D(...arguments);
    } catch (F) {
      console.error("THREE.WebGLState:", F);
    }
  }
  h(Rt, "texStorage2D");
  function ie() {
    try {
      n.texStorage3D(...arguments);
    } catch (F) {
      console.error("THREE.WebGLState:", F);
    }
  }
  h(ie, "texStorage3D");
  function se() {
    try {
      n.texImage2D(...arguments);
    } catch (F) {
      console.error("THREE.WebGLState:", F);
    }
  }
  h(se, "texImage2D");
  function Ct() {
    try {
      n.texImage3D(...arguments);
    } catch (F) {
      console.error("THREE.WebGLState:", F);
    }
  }
  h(Ct, "texImage3D");
  function Ot(F) {
    lt.equals(F) === !1 && (n.scissor(F.x, F.y, F.z, F.w), lt.copy(F));
  }
  h(Ot, "scissor");
  function fe(F) {
    gt.equals(F) === !1 && (n.viewport(F.x, F.y, F.z, F.w), gt.copy(F));
  }
  h(fe, "viewport");
  function oe(F, Et) {
    let Dt = c.get(Et);
    Dt === void 0 && (Dt = /* @__PURE__ */ new WeakMap(), c.set(Et, Dt));
    let Yt = Dt.get(F);
    Yt === void 0 && (Yt = n.getUniformBlockIndex(Et, F.name), Dt.set(F, Yt));
  }
  h(oe, "updateUBOMapping");
  function kt(F, Et) {
    const Yt = c.get(Et).get(F);
    l.get(Et) !== Yt && (n.uniformBlockBinding(Et, Yt, F.__bindingPointIndex), l.set(Et, Yt));
  }
  h(kt, "uniformBlockBinding");
  function Se() {
    n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.blendColor(0, 0, 0, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), r.setReversed(!1), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), u = {}, j = null, tt = {}, m = {}, d = /* @__PURE__ */ new WeakMap(), f = [], p = null, v = !1, _ = null, g = null, w = null, S = null, x = null, A = null, C = null, M = new Ce(0, 0, 0), T = 0, b = !1, y = null, E = null, I = null, B = null, D = null, lt.set(0, 0, n.canvas.width, n.canvas.height), gt.set(0, 0, n.canvas.width, n.canvas.height), o.reset(), r.reset(), a.reset();
  }
  return h(Se, "reset"), {
    buffers: {
      color: o,
      depth: r,
      stencil: a
    },
    enable: it,
    disable: J,
    bindFramebuffer: dt,
    drawBuffers: vt,
    useProgram: Nt,
    setBlending: te,
    setMaterial: It,
    setFlipSided: ut,
    setCullFace: bt,
    setLineWidth: Ft,
    setPolygonOffset: wt,
    setScissorTest: le,
    activeTexture: dn,
    bindTexture: Ze,
    unbindTexture: z,
    compressedTexImage2D: P,
    compressedTexImage3D: q,
    texImage2D: se,
    texImage3D: Ct,
    updateUBOMapping: oe,
    uniformBlockBinding: kt,
    texStorage2D: Rt,
    texStorage3D: ie,
    texSubImage2D: at,
    texSubImage3D: mt,
    compressedTexSubImage2D: ot,
    compressedTexSubImage3D: Wt,
    scissor: Ot,
    viewport: fe,
    reset: Se
  };
}
h(JF, "WebGLState");
function KF(n, t, e, s, i, o, r) {
  const a = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator == "undefined" ? !1 : /OculusBrowser/g.test(navigator.userAgent), c = new Pe(), u = /* @__PURE__ */ new WeakMap();
  let m;
  const d = /* @__PURE__ */ new WeakMap();
  let f = !1;
  try {
    f = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function p(z, P) {
    return f ? new OffscreenCanvas(z, P) : hd("canvas");
  }
  h(p, "createCanvas");
  function v(z, P, q) {
    let at = 1;
    const mt = Ze(z);
    if ((mt.width > q || mt.height > q) && (at = q / Math.max(mt.width, mt.height)), at < 1)
      if (typeof HTMLImageElement != "undefined" && z instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && z instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && z instanceof ImageBitmap || typeof VideoFrame != "undefined" && z instanceof VideoFrame) {
        const ot = Math.floor(at * mt.width), Wt = Math.floor(at * mt.height);
        m === void 0 && (m = p(ot, Wt));
        const Rt = P ? p(ot, Wt) : m;
        return Rt.width = ot, Rt.height = Wt, Rt.getContext("2d").drawImage(z, 0, 0, ot, Wt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + mt.width + "x" + mt.height + ") to (" + ot + "x" + Wt + ")."), Rt;
      } else
        return "data" in z && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + mt.width + "x" + mt.height + ")."), z;
    return z;
  }
  h(v, "resizeImage");
  function _(z) {
    return z.generateMipmaps;
  }
  h(_, "textureNeedsGenerateMipmaps");
  function g(z) {
    n.generateMipmap(z);
  }
  h(g, "generateMipmap");
  function w(z) {
    return z.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : z.isWebGL3DRenderTarget ? n.TEXTURE_3D : z.isWebGLArrayRenderTarget || z.isCompressedArrayTexture ? n.TEXTURE_2D_ARRAY : n.TEXTURE_2D;
  }
  h(w, "getTargetType");
  function S(z, P, q, at, mt = !1) {
    if (z !== null) {
      if (n[z] !== void 0) return n[z];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + z + "'");
    }
    let ot = P;
    if (P === n.RED && (q === n.FLOAT && (ot = n.R32F), q === n.HALF_FLOAT && (ot = n.R16F), q === n.UNSIGNED_BYTE && (ot = n.R8)), P === n.RED_INTEGER && (q === n.UNSIGNED_BYTE && (ot = n.R8UI), q === n.UNSIGNED_SHORT && (ot = n.R16UI), q === n.UNSIGNED_INT && (ot = n.R32UI), q === n.BYTE && (ot = n.R8I), q === n.SHORT && (ot = n.R16I), q === n.INT && (ot = n.R32I)), P === n.RG && (q === n.FLOAT && (ot = n.RG32F), q === n.HALF_FLOAT && (ot = n.RG16F), q === n.UNSIGNED_BYTE && (ot = n.RG8)), P === n.RG_INTEGER && (q === n.UNSIGNED_BYTE && (ot = n.RG8UI), q === n.UNSIGNED_SHORT && (ot = n.RG16UI), q === n.UNSIGNED_INT && (ot = n.RG32UI), q === n.BYTE && (ot = n.RG8I), q === n.SHORT && (ot = n.RG16I), q === n.INT && (ot = n.RG32I)), P === n.RGB_INTEGER && (q === n.UNSIGNED_BYTE && (ot = n.RGB8UI), q === n.UNSIGNED_SHORT && (ot = n.RGB16UI), q === n.UNSIGNED_INT && (ot = n.RGB32UI), q === n.BYTE && (ot = n.RGB8I), q === n.SHORT && (ot = n.RGB16I), q === n.INT && (ot = n.RGB32I)), P === n.RGBA_INTEGER && (q === n.UNSIGNED_BYTE && (ot = n.RGBA8UI), q === n.UNSIGNED_SHORT && (ot = n.RGBA16UI), q === n.UNSIGNED_INT && (ot = n.RGBA32UI), q === n.BYTE && (ot = n.RGBA8I), q === n.SHORT && (ot = n.RGBA16I), q === n.INT && (ot = n.RGBA32I)), P === n.RGB && (q === n.UNSIGNED_INT_5_9_9_9_REV && (ot = n.RGB9_E5), q === n.UNSIGNED_INT_10F_11F_11F_REV && (ot = n.R11F_G11F_B10F)), P === n.RGBA) {
      const Wt = mt ? ld : Qe.getTransfer(at);
      q === n.FLOAT && (ot = n.RGBA32F), q === n.HALF_FLOAT && (ot = n.RGBA16F), q === n.UNSIGNED_BYTE && (ot = Wt === pn ? n.SRGB8_ALPHA8 : n.RGBA8), q === n.UNSIGNED_SHORT_4_4_4_4 && (ot = n.RGBA4), q === n.UNSIGNED_SHORT_5_5_5_1 && (ot = n.RGB5_A1);
    }
    return (ot === n.R16F || ot === n.R32F || ot === n.RG16F || ot === n.RG32F || ot === n.RGBA16F || ot === n.RGBA32F) && t.get("EXT_color_buffer_float"), ot;
  }
  h(S, "getInternalFormat");
  function x(z, P) {
    let q;
    return z ? P === null || P === ga || P === ou ? q = n.DEPTH24_STENCIL8 : P === Ro ? q = n.DEPTH32F_STENCIL8 : P === su && (q = n.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : P === null || P === ga || P === ou ? q = n.DEPTH_COMPONENT24 : P === Ro ? q = n.DEPTH_COMPONENT32F : P === su && (q = n.DEPTH_COMPONENT16), q;
  }
  h(x, "getInternalDepthFormat");
  function A(z, P) {
    return _(z) === !0 || z.isFramebufferTexture && z.minFilter !== Ts && z.minFilter !== $s ? Math.log2(Math.max(P.width, P.height)) + 1 : z.mipmaps !== void 0 && z.mipmaps.length > 0 ? z.mipmaps.length : z.isCompressedTexture && Array.isArray(z.image) ? P.mipmaps.length : 1;
  }
  h(A, "getMipLevels");
  function C(z) {
    const P = z.target;
    P.removeEventListener("dispose", C), T(P), P.isVideoTexture && u.delete(P);
  }
  h(C, "onTextureDispose");
  function M(z) {
    const P = z.target;
    P.removeEventListener("dispose", M), y(P);
  }
  h(M, "onRenderTargetDispose");
  function T(z) {
    const P = s.get(z);
    if (P.__webglInit === void 0) return;
    const q = z.source, at = d.get(q);
    if (at) {
      const mt = at[P.__cacheKey];
      mt.usedTimes--, mt.usedTimes === 0 && b(z), Object.keys(at).length === 0 && d.delete(q);
    }
    s.remove(z);
  }
  h(T, "deallocateTexture");
  function b(z) {
    const P = s.get(z);
    n.deleteTexture(P.__webglTexture);
    const q = z.source, at = d.get(q);
    delete at[P.__cacheKey], r.memory.textures--;
  }
  h(b, "deleteTexture");
  function y(z) {
    const P = s.get(z);
    if (z.depthTexture && (z.depthTexture.dispose(), s.remove(z.depthTexture)), z.isWebGLCubeRenderTarget)
      for (let at = 0; at < 6; at++) {
        if (Array.isArray(P.__webglFramebuffer[at]))
          for (let mt = 0; mt < P.__webglFramebuffer[at].length; mt++) n.deleteFramebuffer(P.__webglFramebuffer[at][mt]);
        else
          n.deleteFramebuffer(P.__webglFramebuffer[at]);
        P.__webglDepthbuffer && n.deleteRenderbuffer(P.__webglDepthbuffer[at]);
      }
    else {
      if (Array.isArray(P.__webglFramebuffer))
        for (let at = 0; at < P.__webglFramebuffer.length; at++) n.deleteFramebuffer(P.__webglFramebuffer[at]);
      else
        n.deleteFramebuffer(P.__webglFramebuffer);
      if (P.__webglDepthbuffer && n.deleteRenderbuffer(P.__webglDepthbuffer), P.__webglMultisampledFramebuffer && n.deleteFramebuffer(P.__webglMultisampledFramebuffer), P.__webglColorRenderbuffer)
        for (let at = 0; at < P.__webglColorRenderbuffer.length; at++)
          P.__webglColorRenderbuffer[at] && n.deleteRenderbuffer(P.__webglColorRenderbuffer[at]);
      P.__webglDepthRenderbuffer && n.deleteRenderbuffer(P.__webglDepthRenderbuffer);
    }
    const q = z.textures;
    for (let at = 0, mt = q.length; at < mt; at++) {
      const ot = s.get(q[at]);
      ot.__webglTexture && (n.deleteTexture(ot.__webglTexture), r.memory.textures--), s.remove(q[at]);
    }
    s.remove(z);
  }
  h(y, "deallocateRenderTarget");
  let E = 0;
  function I() {
    E = 0;
  }
  h(I, "resetTextureUnits");
  function B() {
    const z = E;
    return z >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + z + " texture units while this GPU supports only " + i.maxTextures), E += 1, z;
  }
  h(B, "allocateTextureUnit");
  function D(z) {
    const P = [];
    return P.push(z.wrapS), P.push(z.wrapT), P.push(z.wrapR || 0), P.push(z.magFilter), P.push(z.minFilter), P.push(z.anisotropy), P.push(z.internalFormat), P.push(z.format), P.push(z.type), P.push(z.generateMipmaps), P.push(z.premultiplyAlpha), P.push(z.flipY), P.push(z.unpackAlignment), P.push(z.colorSpace), P.join();
  }
  h(D, "getTextureCacheKey");
  function N(z, P) {
    const q = s.get(z);
    if (z.isVideoTexture && le(z), z.isRenderTargetTexture === !1 && z.isExternalTexture !== !0 && z.version > 0 && q.__version !== z.version) {
      const at = z.image;
      if (at === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (at.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        Y(q, z, P);
        return;
      }
    } else z.isExternalTexture && (q.__webglTexture = z.sourceTexture ? z.sourceTexture : null);
    e.bindTexture(n.TEXTURE_2D, q.__webglTexture, n.TEXTURE0 + P);
  }
  h(N, "setTexture2D");
  function V(z, P) {
    const q = s.get(z);
    if (z.isRenderTargetTexture === !1 && z.version > 0 && q.__version !== z.version) {
      Y(q, z, P);
      return;
    }
    e.bindTexture(n.TEXTURE_2D_ARRAY, q.__webglTexture, n.TEXTURE0 + P);
  }
  h(V, "setTexture2DArray");
  function G(z, P) {
    const q = s.get(z);
    if (z.isRenderTargetTexture === !1 && z.version > 0 && q.__version !== z.version) {
      Y(q, z, P);
      return;
    }
    e.bindTexture(n.TEXTURE_3D, q.__webglTexture, n.TEXTURE0 + P);
  }
  h(G, "setTexture3D");
  function U(z, P) {
    const q = s.get(z);
    if (z.version > 0 && q.__version !== z.version) {
      it(q, z, P);
      return;
    }
    e.bindTexture(n.TEXTURE_CUBE_MAP, q.__webglTexture, n.TEXTURE0 + P);
  }
  h(U, "setTextureCube");
  const j = {
    [Kp]: n.REPEAT,
    [oa]: n.CLAMP_TO_EDGE,
    [Qp]: n.MIRRORED_REPEAT
  }, tt = {
    [Ts]: n.NEAREST,
    [Iz]: n.NEAREST_MIPMAP_NEAREST,
    [oh]: n.NEAREST_MIPMAP_LINEAR,
    [$s]: n.LINEAR,
    [Af]: n.LINEAR_MIPMAP_NEAREST,
    [ra]: n.LINEAR_MIPMAP_LINEAR
  }, K = {
    [Dz]: n.NEVER,
    [Uz]: n.ALWAYS,
    [Vz]: n.LESS,
    [H3]: n.LEQUAL,
    [Lz]: n.EQUAL,
    [kz]: n.GEQUAL,
    [Nz]: n.GREATER,
    [zz]: n.NOTEQUAL
  };
  function $(z, P) {
    if (P.type === Ro && t.has("OES_texture_float_linear") === !1 && (P.magFilter === $s || P.magFilter === Af || P.magFilter === oh || P.magFilter === ra || P.minFilter === $s || P.minFilter === Af || P.minFilter === oh || P.minFilter === ra) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), n.texParameteri(z, n.TEXTURE_WRAP_S, j[P.wrapS]), n.texParameteri(z, n.TEXTURE_WRAP_T, j[P.wrapT]), (z === n.TEXTURE_3D || z === n.TEXTURE_2D_ARRAY) && n.texParameteri(z, n.TEXTURE_WRAP_R, j[P.wrapR]), n.texParameteri(z, n.TEXTURE_MAG_FILTER, tt[P.magFilter]), n.texParameteri(z, n.TEXTURE_MIN_FILTER, tt[P.minFilter]), P.compareFunction && (n.texParameteri(z, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(z, n.TEXTURE_COMPARE_FUNC, K[P.compareFunction])), t.has("EXT_texture_filter_anisotropic") === !0) {
      if (P.magFilter === Ts || P.minFilter !== oh && P.minFilter !== ra || P.type === Ro && t.has("OES_texture_float_linear") === !1) return;
      if (P.anisotropy > 1 || s.get(P).__currentAnisotropy) {
        const q = t.get("EXT_texture_filter_anisotropic");
        n.texParameterf(z, q.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(P.anisotropy, i.getMaxAnisotropy())), s.get(P).__currentAnisotropy = P.anisotropy;
      }
    }
  }
  h($, "setTextureParameters");
  function lt(z, P) {
    let q = !1;
    z.__webglInit === void 0 && (z.__webglInit = !0, P.addEventListener("dispose", C));
    const at = P.source;
    let mt = d.get(at);
    mt === void 0 && (mt = {}, d.set(at, mt));
    const ot = D(P);
    if (ot !== z.__cacheKey) {
      mt[ot] === void 0 && (mt[ot] = {
        texture: n.createTexture(),
        usedTimes: 0
      }, r.memory.textures++, q = !0), mt[ot].usedTimes++;
      const Wt = mt[z.__cacheKey];
      Wt !== void 0 && (mt[z.__cacheKey].usedTimes--, Wt.usedTimes === 0 && b(P)), z.__cacheKey = ot, z.__webglTexture = mt[ot].texture;
    }
    return q;
  }
  h(lt, "initTexture");
  function gt(z, P, q) {
    return Math.floor(Math.floor(z / q) / P);
  }
  h(gt, "getRow");
  function _t(z, P, q, at) {
    const ot = z.updateRanges;
    if (ot.length === 0)
      e.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, P.width, P.height, q, at, P.data);
    else {
      ot.sort((Ct, Ot) => Ct.start - Ot.start);
      let Wt = 0;
      for (let Ct = 1; Ct < ot.length; Ct++) {
        const Ot = ot[Wt], fe = ot[Ct], oe = Ot.start + Ot.count, kt = gt(fe.start, P.width, 4), Se = gt(Ot.start, P.width, 4);
        fe.start <= oe + 1 && kt === Se && gt(fe.start + fe.count - 1, P.width, 4) === kt ? Ot.count = Math.max(
          Ot.count,
          fe.start + fe.count - Ot.start
        ) : (++Wt, ot[Wt] = fe);
      }
      ot.length = Wt + 1;
      const Rt = n.getParameter(n.UNPACK_ROW_LENGTH), ie = n.getParameter(n.UNPACK_SKIP_PIXELS), se = n.getParameter(n.UNPACK_SKIP_ROWS);
      n.pixelStorei(n.UNPACK_ROW_LENGTH, P.width);
      for (let Ct = 0, Ot = ot.length; Ct < Ot; Ct++) {
        const fe = ot[Ct], oe = Math.floor(fe.start / 4), kt = Math.ceil(fe.count / 4), Se = oe % P.width, F = Math.floor(oe / P.width), Et = kt, Dt = 1;
        n.pixelStorei(n.UNPACK_SKIP_PIXELS, Se), n.pixelStorei(n.UNPACK_SKIP_ROWS, F), e.texSubImage2D(n.TEXTURE_2D, 0, Se, F, Et, Dt, q, at, P.data);
      }
      z.clearUpdateRanges(), n.pixelStorei(n.UNPACK_ROW_LENGTH, Rt), n.pixelStorei(n.UNPACK_SKIP_PIXELS, ie), n.pixelStorei(n.UNPACK_SKIP_ROWS, se);
    }
  }
  h(_t, "updateTexture");
  function Y(z, P, q) {
    let at = n.TEXTURE_2D;
    (P.isDataArrayTexture || P.isCompressedArrayTexture) && (at = n.TEXTURE_2D_ARRAY), P.isData3DTexture && (at = n.TEXTURE_3D);
    const mt = lt(z, P), ot = P.source;
    e.bindTexture(at, z.__webglTexture, n.TEXTURE0 + q);
    const Wt = s.get(ot);
    if (ot.version !== Wt.__version || mt === !0) {
      e.activeTexture(n.TEXTURE0 + q);
      const Rt = Qe.getPrimaries(Qe.workingColorSpace), ie = P.colorSpace === rr ? null : Qe.getPrimaries(P.colorSpace), se = P.colorSpace === rr || Rt === ie ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, P.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, P.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, P.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, se);
      let Ct = v(P.image, !1, i.maxTextureSize);
      Ct = dn(P, Ct);
      const Ot = o.convert(P.format, P.colorSpace), fe = o.convert(P.type);
      let oe = S(P.internalFormat, Ot, fe, P.colorSpace, P.isVideoTexture);
      $(at, P);
      let kt;
      const Se = P.mipmaps, F = P.isVideoTexture !== !0, Et = Wt.__version === void 0 || mt === !0, Dt = ot.dataReady, Yt = A(P, Ct);
      if (P.isDepthTexture)
        oe = x(P.format === au, P.type), Et && (F ? e.texStorage2D(n.TEXTURE_2D, 1, oe, Ct.width, Ct.height) : e.texImage2D(n.TEXTURE_2D, 0, oe, Ct.width, Ct.height, 0, Ot, fe, null));
      else if (P.isDataTexture)
        if (Se.length > 0) {
          F && Et && e.texStorage2D(n.TEXTURE_2D, Yt, oe, Se[0].width, Se[0].height);
          for (let St = 0, ft = Se.length; St < ft; St++)
            kt = Se[St], F ? Dt && e.texSubImage2D(n.TEXTURE_2D, St, 0, 0, kt.width, kt.height, Ot, fe, kt.data) : e.texImage2D(n.TEXTURE_2D, St, oe, kt.width, kt.height, 0, Ot, fe, kt.data);
          P.generateMipmaps = !1;
        } else
          F ? (Et && e.texStorage2D(n.TEXTURE_2D, Yt, oe, Ct.width, Ct.height), Dt && _t(P, Ct, Ot, fe)) : e.texImage2D(n.TEXTURE_2D, 0, oe, Ct.width, Ct.height, 0, Ot, fe, Ct.data);
      else if (P.isCompressedTexture)
        if (P.isCompressedArrayTexture) {
          F && Et && e.texStorage3D(n.TEXTURE_2D_ARRAY, Yt, oe, Se[0].width, Se[0].height, Ct.depth);
          for (let St = 0, ft = Se.length; St < ft; St++)
            if (kt = Se[St], P.format !== Ms)
              if (Ot !== null)
                if (F) {
                  if (Dt)
                    if (P.layerUpdates.size > 0) {
                      const ee = oS(kt.width, kt.height, P.format, P.type);
                      for (const be of P.layerUpdates) {
                        const vn = kt.data.subarray(
                          be * ee / kt.data.BYTES_PER_ELEMENT,
                          (be + 1) * ee / kt.data.BYTES_PER_ELEMENT
                        );
                        e.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, St, 0, 0, be, kt.width, kt.height, 1, Ot, vn);
                      }
                      P.clearLayerUpdates();
                    } else
                      e.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, St, 0, 0, 0, kt.width, kt.height, Ct.depth, Ot, kt.data);
                } else
                  e.compressedTexImage3D(n.TEXTURE_2D_ARRAY, St, oe, kt.width, kt.height, Ct.depth, 0, kt.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              F ? Dt && e.texSubImage3D(n.TEXTURE_2D_ARRAY, St, 0, 0, 0, kt.width, kt.height, Ct.depth, Ot, fe, kt.data) : e.texImage3D(n.TEXTURE_2D_ARRAY, St, oe, kt.width, kt.height, Ct.depth, 0, Ot, fe, kt.data);
        } else {
          F && Et && e.texStorage2D(n.TEXTURE_2D, Yt, oe, Se[0].width, Se[0].height);
          for (let St = 0, ft = Se.length; St < ft; St++)
            kt = Se[St], P.format !== Ms ? Ot !== null ? F ? Dt && e.compressedTexSubImage2D(n.TEXTURE_2D, St, 0, 0, kt.width, kt.height, Ot, kt.data) : e.compressedTexImage2D(n.TEXTURE_2D, St, oe, kt.width, kt.height, 0, kt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : F ? Dt && e.texSubImage2D(n.TEXTURE_2D, St, 0, 0, kt.width, kt.height, Ot, fe, kt.data) : e.texImage2D(n.TEXTURE_2D, St, oe, kt.width, kt.height, 0, Ot, fe, kt.data);
        }
      else if (P.isDataArrayTexture)
        if (F) {
          if (Et && e.texStorage3D(n.TEXTURE_2D_ARRAY, Yt, oe, Ct.width, Ct.height, Ct.depth), Dt)
            if (P.layerUpdates.size > 0) {
              const St = oS(Ct.width, Ct.height, P.format, P.type);
              for (const ft of P.layerUpdates) {
                const ee = Ct.data.subarray(
                  ft * St / Ct.data.BYTES_PER_ELEMENT,
                  (ft + 1) * St / Ct.data.BYTES_PER_ELEMENT
                );
                e.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, ft, Ct.width, Ct.height, 1, Ot, fe, ee);
              }
              P.clearLayerUpdates();
            } else
              e.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Ct.width, Ct.height, Ct.depth, Ot, fe, Ct.data);
        } else
          e.texImage3D(n.TEXTURE_2D_ARRAY, 0, oe, Ct.width, Ct.height, Ct.depth, 0, Ot, fe, Ct.data);
      else if (P.isData3DTexture)
        F ? (Et && e.texStorage3D(n.TEXTURE_3D, Yt, oe, Ct.width, Ct.height, Ct.depth), Dt && e.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Ct.width, Ct.height, Ct.depth, Ot, fe, Ct.data)) : e.texImage3D(n.TEXTURE_3D, 0, oe, Ct.width, Ct.height, Ct.depth, 0, Ot, fe, Ct.data);
      else if (P.isFramebufferTexture) {
        if (Et)
          if (F)
            e.texStorage2D(n.TEXTURE_2D, Yt, oe, Ct.width, Ct.height);
          else {
            let St = Ct.width, ft = Ct.height;
            for (let ee = 0; ee < Yt; ee++)
              e.texImage2D(n.TEXTURE_2D, ee, oe, St, ft, 0, Ot, fe, null), St >>= 1, ft >>= 1;
          }
      } else if (Se.length > 0) {
        if (F && Et) {
          const St = Ze(Se[0]);
          e.texStorage2D(n.TEXTURE_2D, Yt, oe, St.width, St.height);
        }
        for (let St = 0, ft = Se.length; St < ft; St++)
          kt = Se[St], F ? Dt && e.texSubImage2D(n.TEXTURE_2D, St, 0, 0, Ot, fe, kt) : e.texImage2D(n.TEXTURE_2D, St, oe, Ot, fe, kt);
        P.generateMipmaps = !1;
      } else if (F) {
        if (Et) {
          const St = Ze(Ct);
          e.texStorage2D(n.TEXTURE_2D, Yt, oe, St.width, St.height);
        }
        Dt && e.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Ot, fe, Ct);
      } else
        e.texImage2D(n.TEXTURE_2D, 0, oe, Ot, fe, Ct);
      _(P) && g(at), Wt.__version = ot.version, P.onUpdate && P.onUpdate(P);
    }
    z.__version = P.version;
  }
  h(Y, "uploadTexture");
  function it(z, P, q) {
    if (P.image.length !== 6) return;
    const at = lt(z, P), mt = P.source;
    e.bindTexture(n.TEXTURE_CUBE_MAP, z.__webglTexture, n.TEXTURE0 + q);
    const ot = s.get(mt);
    if (mt.version !== ot.__version || at === !0) {
      e.activeTexture(n.TEXTURE0 + q);
      const Wt = Qe.getPrimaries(Qe.workingColorSpace), Rt = P.colorSpace === rr ? null : Qe.getPrimaries(P.colorSpace), ie = P.colorSpace === rr || Wt === Rt ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, P.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, P.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, P.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, ie);
      const se = P.isCompressedTexture || P.image[0].isCompressedTexture, Ct = P.image[0] && P.image[0].isDataTexture, Ot = [];
      for (let ft = 0; ft < 6; ft++)
        !se && !Ct ? Ot[ft] = v(P.image[ft], !0, i.maxCubemapSize) : Ot[ft] = Ct ? P.image[ft].image : P.image[ft], Ot[ft] = dn(P, Ot[ft]);
      const fe = Ot[0], oe = o.convert(P.format, P.colorSpace), kt = o.convert(P.type), Se = S(P.internalFormat, oe, kt, P.colorSpace), F = P.isVideoTexture !== !0, Et = ot.__version === void 0 || at === !0, Dt = mt.dataReady;
      let Yt = A(P, fe);
      $(n.TEXTURE_CUBE_MAP, P);
      let St;
      if (se) {
        F && Et && e.texStorage2D(n.TEXTURE_CUBE_MAP, Yt, Se, fe.width, fe.height);
        for (let ft = 0; ft < 6; ft++) {
          St = Ot[ft].mipmaps;
          for (let ee = 0; ee < St.length; ee++) {
            const be = St[ee];
            P.format !== Ms ? oe !== null ? F ? Dt && e.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, ee, 0, 0, be.width, be.height, oe, be.data) : e.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, ee, Se, be.width, be.height, 0, be.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : F ? Dt && e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, ee, 0, 0, be.width, be.height, oe, kt, be.data) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, ee, Se, be.width, be.height, 0, oe, kt, be.data);
          }
        }
      } else {
        if (St = P.mipmaps, F && Et) {
          St.length > 0 && Yt++;
          const ft = Ze(Ot[0]);
          e.texStorage2D(n.TEXTURE_CUBE_MAP, Yt, Se, ft.width, ft.height);
        }
        for (let ft = 0; ft < 6; ft++)
          if (Ct) {
            F ? Dt && e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, 0, 0, Ot[ft].width, Ot[ft].height, oe, kt, Ot[ft].data) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, Se, Ot[ft].width, Ot[ft].height, 0, oe, kt, Ot[ft].data);
            for (let ee = 0; ee < St.length; ee++) {
              const vn = St[ee].image[ft].image;
              F ? Dt && e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, ee + 1, 0, 0, vn.width, vn.height, oe, kt, vn.data) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, ee + 1, Se, vn.width, vn.height, 0, oe, kt, vn.data);
            }
          } else {
            F ? Dt && e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, 0, 0, oe, kt, Ot[ft]) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, Se, oe, kt, Ot[ft]);
            for (let ee = 0; ee < St.length; ee++) {
              const be = St[ee];
              F ? Dt && e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, ee + 1, 0, 0, oe, kt, be.image[ft]) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ft, ee + 1, Se, oe, kt, be.image[ft]);
            }
          }
      }
      _(P) && g(n.TEXTURE_CUBE_MAP), ot.__version = mt.version, P.onUpdate && P.onUpdate(P);
    }
    z.__version = P.version;
  }
  h(it, "uploadCubeTexture");
  function J(z, P, q, at, mt, ot) {
    const Wt = o.convert(q.format, q.colorSpace), Rt = o.convert(q.type), ie = S(q.internalFormat, Wt, Rt, q.colorSpace), se = s.get(P), Ct = s.get(q);
    if (Ct.__renderTarget = P, !se.__hasExternalTextures) {
      const Ot = Math.max(1, P.width >> ot), fe = Math.max(1, P.height >> ot);
      mt === n.TEXTURE_3D || mt === n.TEXTURE_2D_ARRAY ? e.texImage3D(mt, ot, ie, Ot, fe, P.depth, 0, Wt, Rt, null) : e.texImage2D(mt, ot, ie, Ot, fe, 0, Wt, Rt, null);
    }
    e.bindFramebuffer(n.FRAMEBUFFER, z), wt(P) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, at, mt, Ct.__webglTexture, 0, Ft(P)) : (mt === n.TEXTURE_2D || mt >= n.TEXTURE_CUBE_MAP_POSITIVE_X && mt <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, at, mt, Ct.__webglTexture, ot), e.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  h(J, "setupFrameBufferTexture");
  function dt(z, P, q) {
    if (n.bindRenderbuffer(n.RENDERBUFFER, z), P.depthBuffer) {
      const at = P.depthTexture, mt = at && at.isDepthTexture ? at.type : null, ot = x(P.stencilBuffer, mt), Wt = P.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, Rt = Ft(P);
      wt(P) ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Rt, ot, P.width, P.height) : q ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Rt, ot, P.width, P.height) : n.renderbufferStorage(n.RENDERBUFFER, ot, P.width, P.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, Wt, n.RENDERBUFFER, z);
    } else {
      const at = P.textures;
      for (let mt = 0; mt < at.length; mt++) {
        const ot = at[mt], Wt = o.convert(ot.format, ot.colorSpace), Rt = o.convert(ot.type), ie = S(ot.internalFormat, Wt, Rt, ot.colorSpace), se = Ft(P);
        q && wt(P) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, se, ie, P.width, P.height) : wt(P) ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, se, ie, P.width, P.height) : n.renderbufferStorage(n.RENDERBUFFER, ie, P.width, P.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  h(dt, "setupRenderBufferStorage");
  function vt(z, P) {
    if (P && P.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (e.bindFramebuffer(n.FRAMEBUFFER, z), !(P.depthTexture && P.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const at = s.get(P.depthTexture);
    at.__renderTarget = P, (!at.__webglTexture || P.depthTexture.image.width !== P.width || P.depthTexture.image.height !== P.height) && (P.depthTexture.image.width = P.width, P.depthTexture.image.height = P.height, P.depthTexture.needsUpdate = !0), N(P.depthTexture, 0);
    const mt = at.__webglTexture, ot = Ft(P);
    if (P.depthTexture.format === ru)
      wt(P) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, mt, 0, ot) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, mt, 0);
    else if (P.depthTexture.format === au)
      wt(P) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, mt, 0, ot) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, mt, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  h(vt, "setupDepthTexture");
  function Nt(z) {
    const P = s.get(z), q = z.isWebGLCubeRenderTarget === !0;
    if (P.__boundDepthTexture !== z.depthTexture) {
      const at = z.depthTexture;
      if (P.__depthDisposeCallback && P.__depthDisposeCallback(), at) {
        const mt = /* @__PURE__ */ h(() => {
          delete P.__boundDepthTexture, delete P.__depthDisposeCallback, at.removeEventListener("dispose", mt);
        }, "disposeEvent");
        at.addEventListener("dispose", mt), P.__depthDisposeCallback = mt;
      }
      P.__boundDepthTexture = at;
    }
    if (z.depthTexture && !P.__autoAllocateDepthBuffer) {
      if (q) throw new Error("target.depthTexture not supported in Cube render targets");
      const at = z.texture.mipmaps;
      at && at.length > 0 ? vt(P.__webglFramebuffer[0], z) : vt(P.__webglFramebuffer, z);
    } else if (q) {
      P.__webglDepthbuffer = [];
      for (let at = 0; at < 6; at++)
        if (e.bindFramebuffer(n.FRAMEBUFFER, P.__webglFramebuffer[at]), P.__webglDepthbuffer[at] === void 0)
          P.__webglDepthbuffer[at] = n.createRenderbuffer(), dt(P.__webglDepthbuffer[at], z, !1);
        else {
          const mt = z.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, ot = P.__webglDepthbuffer[at];
          n.bindRenderbuffer(n.RENDERBUFFER, ot), n.framebufferRenderbuffer(n.FRAMEBUFFER, mt, n.RENDERBUFFER, ot);
        }
    } else {
      const at = z.texture.mipmaps;
      if (at && at.length > 0 ? e.bindFramebuffer(n.FRAMEBUFFER, P.__webglFramebuffer[0]) : e.bindFramebuffer(n.FRAMEBUFFER, P.__webglFramebuffer), P.__webglDepthbuffer === void 0)
        P.__webglDepthbuffer = n.createRenderbuffer(), dt(P.__webglDepthbuffer, z, !1);
      else {
        const mt = z.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, ot = P.__webglDepthbuffer;
        n.bindRenderbuffer(n.RENDERBUFFER, ot), n.framebufferRenderbuffer(n.FRAMEBUFFER, mt, n.RENDERBUFFER, ot);
      }
    }
    e.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  h(Nt, "setupDepthRenderbuffer");
  function _e(z, P, q) {
    const at = s.get(z);
    P !== void 0 && J(at.__webglFramebuffer, z, z.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), q !== void 0 && Nt(z);
  }
  h(_e, "rebindTextures");
  function k(z) {
    const P = z.texture, q = s.get(z), at = s.get(P);
    z.addEventListener("dispose", M);
    const mt = z.textures, ot = z.isWebGLCubeRenderTarget === !0, Wt = mt.length > 1;
    if (Wt || (at.__webglTexture === void 0 && (at.__webglTexture = n.createTexture()), at.__version = P.version, r.memory.textures++), ot) {
      q.__webglFramebuffer = [];
      for (let Rt = 0; Rt < 6; Rt++)
        if (P.mipmaps && P.mipmaps.length > 0) {
          q.__webglFramebuffer[Rt] = [];
          for (let ie = 0; ie < P.mipmaps.length; ie++)
            q.__webglFramebuffer[Rt][ie] = n.createFramebuffer();
        } else
          q.__webglFramebuffer[Rt] = n.createFramebuffer();
    } else {
      if (P.mipmaps && P.mipmaps.length > 0) {
        q.__webglFramebuffer = [];
        for (let Rt = 0; Rt < P.mipmaps.length; Rt++)
          q.__webglFramebuffer[Rt] = n.createFramebuffer();
      } else
        q.__webglFramebuffer = n.createFramebuffer();
      if (Wt)
        for (let Rt = 0, ie = mt.length; Rt < ie; Rt++) {
          const se = s.get(mt[Rt]);
          se.__webglTexture === void 0 && (se.__webglTexture = n.createTexture(), r.memory.textures++);
        }
      if (z.samples > 0 && wt(z) === !1) {
        q.__webglMultisampledFramebuffer = n.createFramebuffer(), q.__webglColorRenderbuffer = [], e.bindFramebuffer(n.FRAMEBUFFER, q.__webglMultisampledFramebuffer);
        for (let Rt = 0; Rt < mt.length; Rt++) {
          const ie = mt[Rt];
          q.__webglColorRenderbuffer[Rt] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, q.__webglColorRenderbuffer[Rt]);
          const se = o.convert(ie.format, ie.colorSpace), Ct = o.convert(ie.type), Ot = S(ie.internalFormat, se, Ct, ie.colorSpace, z.isXRRenderTarget === !0), fe = Ft(z);
          n.renderbufferStorageMultisample(n.RENDERBUFFER, fe, Ot, z.width, z.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Rt, n.RENDERBUFFER, q.__webglColorRenderbuffer[Rt]);
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null), z.depthBuffer && (q.__webglDepthRenderbuffer = n.createRenderbuffer(), dt(q.__webglDepthRenderbuffer, z, !0)), e.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (ot) {
      e.bindTexture(n.TEXTURE_CUBE_MAP, at.__webglTexture), $(n.TEXTURE_CUBE_MAP, P);
      for (let Rt = 0; Rt < 6; Rt++)
        if (P.mipmaps && P.mipmaps.length > 0)
          for (let ie = 0; ie < P.mipmaps.length; ie++)
            J(q.__webglFramebuffer[Rt][ie], z, P, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Rt, ie);
        else
          J(q.__webglFramebuffer[Rt], z, P, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Rt, 0);
      _(P) && g(n.TEXTURE_CUBE_MAP), e.unbindTexture();
    } else if (Wt) {
      for (let Rt = 0, ie = mt.length; Rt < ie; Rt++) {
        const se = mt[Rt], Ct = s.get(se);
        let Ot = n.TEXTURE_2D;
        (z.isWebGL3DRenderTarget || z.isWebGLArrayRenderTarget) && (Ot = z.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY), e.bindTexture(Ot, Ct.__webglTexture), $(Ot, se), J(q.__webglFramebuffer, z, se, n.COLOR_ATTACHMENT0 + Rt, Ot, 0), _(se) && g(Ot);
      }
      e.unbindTexture();
    } else {
      let Rt = n.TEXTURE_2D;
      if ((z.isWebGL3DRenderTarget || z.isWebGLArrayRenderTarget) && (Rt = z.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY), e.bindTexture(Rt, at.__webglTexture), $(Rt, P), P.mipmaps && P.mipmaps.length > 0)
        for (let ie = 0; ie < P.mipmaps.length; ie++)
          J(q.__webglFramebuffer[ie], z, P, n.COLOR_ATTACHMENT0, Rt, ie);
      else
        J(q.__webglFramebuffer, z, P, n.COLOR_ATTACHMENT0, Rt, 0);
      _(P) && g(Rt), e.unbindTexture();
    }
    z.depthBuffer && Nt(z);
  }
  h(k, "setupRenderTarget");
  function te(z) {
    const P = z.textures;
    for (let q = 0, at = P.length; q < at; q++) {
      const mt = P[q];
      if (_(mt)) {
        const ot = w(z), Wt = s.get(mt).__webglTexture;
        e.bindTexture(ot, Wt), g(ot), e.unbindTexture();
      }
    }
  }
  h(te, "updateRenderTargetMipmap");
  const It = [], ut = [];
  function bt(z) {
    if (z.samples > 0) {
      if (wt(z) === !1) {
        const P = z.textures, q = z.width, at = z.height;
        let mt = n.COLOR_BUFFER_BIT;
        const ot = z.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, Wt = s.get(z), Rt = P.length > 1;
        if (Rt)
          for (let se = 0; se < P.length; se++)
            e.bindFramebuffer(n.FRAMEBUFFER, Wt.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + se, n.RENDERBUFFER, null), e.bindFramebuffer(n.FRAMEBUFFER, Wt.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + se, n.TEXTURE_2D, null, 0);
        e.bindFramebuffer(n.READ_FRAMEBUFFER, Wt.__webglMultisampledFramebuffer);
        const ie = z.texture.mipmaps;
        ie && ie.length > 0 ? e.bindFramebuffer(n.DRAW_FRAMEBUFFER, Wt.__webglFramebuffer[0]) : e.bindFramebuffer(n.DRAW_FRAMEBUFFER, Wt.__webglFramebuffer);
        for (let se = 0; se < P.length; se++) {
          if (z.resolveDepthBuffer && (z.depthBuffer && (mt |= n.DEPTH_BUFFER_BIT), z.stencilBuffer && z.resolveStencilBuffer && (mt |= n.STENCIL_BUFFER_BIT)), Rt) {
            n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Wt.__webglColorRenderbuffer[se]);
            const Ct = s.get(P[se]).__webglTexture;
            n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, Ct, 0);
          }
          n.blitFramebuffer(0, 0, q, at, 0, 0, q, at, mt, n.NEAREST), l === !0 && (It.length = 0, ut.length = 0, It.push(n.COLOR_ATTACHMENT0 + se), z.depthBuffer && z.resolveDepthBuffer === !1 && (It.push(ot), ut.push(ot), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, ut)), n.invalidateFramebuffer(n.READ_FRAMEBUFFER, It));
        }
        if (e.bindFramebuffer(n.READ_FRAMEBUFFER, null), e.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), Rt)
          for (let se = 0; se < P.length; se++) {
            e.bindFramebuffer(n.FRAMEBUFFER, Wt.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + se, n.RENDERBUFFER, Wt.__webglColorRenderbuffer[se]);
            const Ct = s.get(P[se]).__webglTexture;
            e.bindFramebuffer(n.FRAMEBUFFER, Wt.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + se, n.TEXTURE_2D, Ct, 0);
          }
        e.bindFramebuffer(n.DRAW_FRAMEBUFFER, Wt.__webglMultisampledFramebuffer);
      } else if (z.depthBuffer && z.resolveDepthBuffer === !1 && l) {
        const P = z.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [P]);
      }
    }
  }
  h(bt, "updateMultisampleRenderTarget");
  function Ft(z) {
    return Math.min(i.maxSamples, z.samples);
  }
  h(Ft, "getRenderTargetSamples");
  function wt(z) {
    const P = s.get(z);
    return z.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && P.__useRenderToTexture !== !1;
  }
  h(wt, "useMultisampledRTT");
  function le(z) {
    const P = r.render.frame;
    u.get(z) !== P && (u.set(z, P), z.update());
  }
  h(le, "updateVideoTexture");
  function dn(z, P) {
    const q = z.colorSpace, at = z.format, mt = z.type;
    return z.isCompressedTexture === !0 || z.isVideoTexture === !0 || q !== Oc && q !== rr && (Qe.getTransfer(q) === pn ? (at !== Ms || mt !== Xs) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", q)), P;
  }
  h(dn, "verifyColorSpace");
  function Ze(z) {
    return typeof HTMLImageElement != "undefined" && z instanceof HTMLImageElement ? (c.width = z.naturalWidth || z.width, c.height = z.naturalHeight || z.height) : typeof VideoFrame != "undefined" && z instanceof VideoFrame ? (c.width = z.displayWidth, c.height = z.displayHeight) : (c.width = z.width, c.height = z.height), c;
  }
  h(Ze, "getDimensions"), this.allocateTextureUnit = B, this.resetTextureUnits = I, this.setTexture2D = N, this.setTexture2DArray = V, this.setTexture3D = G, this.setTextureCube = U, this.rebindTextures = _e, this.setupRenderTarget = k, this.updateRenderTargetMipmap = te, this.updateMultisampleRenderTarget = bt, this.setupDepthRenderbuffer = Nt, this.setupFrameBufferTexture = J, this.useMultisampledRTT = wt;
}
h(KF, "WebGLTextures");
function QF(n, t) {
  function e(s, i = rr) {
    let o;
    const r = Qe.getTransfer(i);
    if (s === Xs) return n.UNSIGNED_BYTE;
    if (s === k2) return n.UNSIGNED_SHORT_4_4_4_4;
    if (s === U2) return n.UNSIGNED_SHORT_5_5_5_1;
    if (s === z3) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (s === k3) return n.UNSIGNED_INT_10F_11F_11F_REV;
    if (s === L3) return n.BYTE;
    if (s === N3) return n.SHORT;
    if (s === su) return n.UNSIGNED_SHORT;
    if (s === z2) return n.INT;
    if (s === ga) return n.UNSIGNED_INT;
    if (s === Ro) return n.FLOAT;
    if (s === Nu) return n.HALF_FLOAT;
    if (s === U3) return n.ALPHA;
    if (s === O3) return n.RGB;
    if (s === Ms) return n.RGBA;
    if (s === ru) return n.DEPTH_COMPONENT;
    if (s === au) return n.DEPTH_STENCIL;
    if (s === $3) return n.RED;
    if (s === O2) return n.RED_INTEGER;
    if (s === F3) return n.RG;
    if (s === $2) return n.RG_INTEGER;
    if (s === F2) return n.RGBA_INTEGER;
    if (s === Vh || s === Lh || s === Nh || s === zh)
      if (r === pn)
        if (o = t.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (s === Vh) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === Lh) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === Nh) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === zh) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = t.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (s === Vh) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Lh) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === Nh) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === zh) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (s === t_ || s === e_ || s === n_ || s === i_)
      if (o = t.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (s === t_) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === e_) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === n_) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === i_) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (s === s_ || s === o_ || s === r_)
      if (o = t.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (s === s_ || s === o_) return r === pn ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (s === r_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (s === a_ || s === c_ || s === l_ || s === u_ || s === h_ || s === d_ || s === m_ || s === f_ || s === p_ || s === __ || s === g_ || s === v_ || s === b_ || s === y_)
      if (o = t.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (s === a_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === c_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === l_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === u_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === h_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === d_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === m_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === f_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === p_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === __) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === g_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === v_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === b_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === y_) return r === pn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (s === x_ || s === w_ || s === S_)
      if (o = t.get("EXT_texture_compression_bptc"), o !== null) {
        if (s === x_) return r === pn ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (s === w_) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (s === S_) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (s === A_ || s === M_ || s === C_ || s === E_)
      if (o = t.get("EXT_texture_compression_rgtc"), o !== null) {
        if (s === A_) return o.COMPRESSED_RED_RGTC1_EXT;
        if (s === M_) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === C_) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === E_) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return s === ou ? n.UNSIGNED_INT_24_8 : n[s] !== void 0 ? n[s] : null;
  }
  return h(e, "convert"), { convert: e };
}
h(QF, "WebGLUtils");
const t8 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, e8 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`, Ey = class Ey {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(t, e) {
    if (this.texture === null) {
      const s = new bd(t.texture);
      (t.depthNear !== e.depthNear || t.depthFar !== e.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = s;
    }
  }
  getMesh(t) {
    if (this.texture !== null && this.mesh === null) {
      const e = t.cameras[0].viewport, s = new Qs({
        vertexShader: t8,
        fragmentShader: e8,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: e.z },
          depthHeight: { value: e.w }
        }
      });
      this.mesh = new Bi(new hu(20, 20), s);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
};
h(Ey, "WebXRDepthSensing");
let Z_ = Ey;
const Ty = class Ty extends xr {
  constructor(t, e) {
    super();
    const s = this;
    let i = null, o = 1, r = null, a = "local-floor", l = 1, c = null, u = null, m = null, d = null, f = null, p = null;
    const v = typeof XRWebGLBinding != "undefined", _ = new Z_(), g = {}, w = e.getContextAttributes();
    let S = null, x = null;
    const A = [], C = [], M = new Pe();
    let T = null;
    const b = new si();
    b.viewport = new an();
    const y = new si();
    y.viewport = new an();
    const E = [b, y], I = new F_();
    let B = null, D = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(Y) {
      let it = A[Y];
      return it === void 0 && (it = new Vl(), A[Y] = it), it.getTargetRaySpace();
    }, this.getControllerGrip = function(Y) {
      let it = A[Y];
      return it === void 0 && (it = new Vl(), A[Y] = it), it.getGripSpace();
    }, this.getHand = function(Y) {
      let it = A[Y];
      return it === void 0 && (it = new Vl(), A[Y] = it), it.getHandSpace();
    };
    function N(Y) {
      const it = C.indexOf(Y.inputSource);
      if (it === -1)
        return;
      const J = A[it];
      J !== void 0 && (J.update(Y.inputSource, Y.frame, c || r), J.dispatchEvent({ type: Y.type, data: Y.inputSource }));
    }
    h(N, "onSessionEvent");
    function V() {
      i.removeEventListener("select", N), i.removeEventListener("selectstart", N), i.removeEventListener("selectend", N), i.removeEventListener("squeeze", N), i.removeEventListener("squeezestart", N), i.removeEventListener("squeezeend", N), i.removeEventListener("end", V), i.removeEventListener("inputsourceschange", G);
      for (let Y = 0; Y < A.length; Y++) {
        const it = C[Y];
        it !== null && (C[Y] = null, A[Y].disconnect(it));
      }
      B = null, D = null, _.reset();
      for (const Y in g)
        delete g[Y];
      t.setRenderTarget(S), f = null, d = null, m = null, i = null, x = null, _t.stop(), s.isPresenting = !1, t.setPixelRatio(T), t.setSize(M.width, M.height, !1), s.dispatchEvent({ type: "sessionend" });
    }
    h(V, "onSessionEnd"), this.setFramebufferScaleFactor = function(Y) {
      o = Y, s.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(Y) {
      a = Y, s.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || r;
    }, this.setReferenceSpace = function(Y) {
      c = Y;
    }, this.getBaseLayer = function() {
      return d !== null ? d : f;
    }, this.getBinding = function() {
      return m === null && v && (m = new XRWebGLBinding(i, e)), m;
    }, this.getFrame = function() {
      return p;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(Y) {
      if (i = Y, i !== null) {
        if (S = t.getRenderTarget(), i.addEventListener("select", N), i.addEventListener("selectstart", N), i.addEventListener("selectend", N), i.addEventListener("squeeze", N), i.addEventListener("squeezestart", N), i.addEventListener("squeezeend", N), i.addEventListener("end", V), i.addEventListener("inputsourceschange", G), w.xrCompatible !== !0 && await e.makeXRCompatible(), T = t.getPixelRatio(), t.getSize(M), v && "createProjectionLayer" in XRWebGLBinding.prototype) {
          let J = null, dt = null, vt = null;
          w.depth && (vt = w.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, J = w.stencil ? au : ru, dt = w.stencil ? ou : ga);
          const Nt = {
            colorFormat: e.RGBA8,
            depthFormat: vt,
            scaleFactor: o
          };
          m = this.getBinding(), d = m.createProjectionLayer(Nt), i.updateRenderState({ layers: [d] }), t.setPixelRatio(1), t.setSize(d.textureWidth, d.textureHeight, !1), x = new Oo(
            d.textureWidth,
            d.textureHeight,
            {
              format: Ms,
              type: Xs,
              depthTexture: new vd(d.textureWidth, d.textureHeight, dt, void 0, void 0, void 0, void 0, void 0, void 0, J),
              stencilBuffer: w.stencil,
              colorSpace: t.outputColorSpace,
              samples: w.antialias ? 4 : 0,
              resolveDepthBuffer: d.ignoreDepthValues === !1,
              resolveStencilBuffer: d.ignoreDepthValues === !1
            }
          );
        } else {
          const J = {
            antialias: w.antialias,
            alpha: !0,
            depth: w.depth,
            stencil: w.stencil,
            framebufferScaleFactor: o
          };
          f = new XRWebGLLayer(i, e, J), i.updateRenderState({ baseLayer: f }), t.setPixelRatio(1), t.setSize(f.framebufferWidth, f.framebufferHeight, !1), x = new Oo(
            f.framebufferWidth,
            f.framebufferHeight,
            {
              format: Ms,
              type: Xs,
              colorSpace: t.outputColorSpace,
              stencilBuffer: w.stencil,
              resolveDepthBuffer: f.ignoreDepthValues === !1,
              resolveStencilBuffer: f.ignoreDepthValues === !1
            }
          );
        }
        x.isXRRenderTarget = !0, this.setFoveation(l), c = null, r = await i.requestReferenceSpace(a), _t.setContext(i), _t.start(), s.isPresenting = !0, s.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null)
        return i.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return _.getDepthTexture();
    };
    function G(Y) {
      for (let it = 0; it < Y.removed.length; it++) {
        const J = Y.removed[it], dt = C.indexOf(J);
        dt >= 0 && (C[dt] = null, A[dt].disconnect(J));
      }
      for (let it = 0; it < Y.added.length; it++) {
        const J = Y.added[it];
        let dt = C.indexOf(J);
        if (dt === -1) {
          for (let Nt = 0; Nt < A.length; Nt++)
            if (Nt >= C.length) {
              C.push(J), dt = Nt;
              break;
            } else if (C[Nt] === null) {
              C[Nt] = J, dt = Nt;
              break;
            }
          if (dt === -1) break;
        }
        const vt = A[dt];
        vt && vt.connect(J);
      }
    }
    h(G, "onInputSourcesChange");
    const U = new O(), j = new O();
    function tt(Y, it, J) {
      U.setFromMatrixPosition(it.matrixWorld), j.setFromMatrixPosition(J.matrixWorld);
      const dt = U.distanceTo(j), vt = it.projectionMatrix.elements, Nt = J.projectionMatrix.elements, _e = vt[14] / (vt[10] - 1), k = vt[14] / (vt[10] + 1), te = (vt[9] + 1) / vt[5], It = (vt[9] - 1) / vt[5], ut = (vt[8] - 1) / vt[0], bt = (Nt[8] + 1) / Nt[0], Ft = _e * ut, wt = _e * bt, le = dt / (-ut + bt), dn = le * -ut;
      if (it.matrixWorld.decompose(Y.position, Y.quaternion, Y.scale), Y.translateX(dn), Y.translateZ(le), Y.matrixWorld.compose(Y.position, Y.quaternion, Y.scale), Y.matrixWorldInverse.copy(Y.matrixWorld).invert(), vt[10] === -1)
        Y.projectionMatrix.copy(it.projectionMatrix), Y.projectionMatrixInverse.copy(it.projectionMatrixInverse);
      else {
        const Ze = _e + le, z = k + le, P = Ft - dn, q = wt + (dt - dn), at = te * k / z * Ze, mt = It * k / z * Ze;
        Y.projectionMatrix.makePerspective(P, q, at, mt, Ze, z), Y.projectionMatrixInverse.copy(Y.projectionMatrix).invert();
      }
    }
    h(tt, "setProjectionFromUnion");
    function K(Y, it) {
      it === null ? Y.matrixWorld.copy(Y.matrix) : Y.matrixWorld.multiplyMatrices(it.matrixWorld, Y.matrix), Y.matrixWorldInverse.copy(Y.matrixWorld).invert();
    }
    h(K, "updateCamera"), this.updateCamera = function(Y) {
      if (i === null) return;
      let it = Y.near, J = Y.far;
      _.texture !== null && (_.depthNear > 0 && (it = _.depthNear), _.depthFar > 0 && (J = _.depthFar)), I.near = y.near = b.near = it, I.far = y.far = b.far = J, (B !== I.near || D !== I.far) && (i.updateRenderState({
        depthNear: I.near,
        depthFar: I.far
      }), B = I.near, D = I.far), I.layers.mask = Y.layers.mask | 6, b.layers.mask = I.layers.mask & 3, y.layers.mask = I.layers.mask & 5;
      const dt = Y.parent, vt = I.cameras;
      K(I, dt);
      for (let Nt = 0; Nt < vt.length; Nt++)
        K(vt[Nt], dt);
      vt.length === 2 ? tt(I, b, y) : I.projectionMatrix.copy(b.projectionMatrix), $(Y, I, dt);
    };
    function $(Y, it, J) {
      J === null ? Y.matrix.copy(it.matrixWorld) : (Y.matrix.copy(J.matrixWorld), Y.matrix.invert(), Y.matrix.multiply(it.matrixWorld)), Y.matrix.decompose(Y.position, Y.quaternion, Y.scale), Y.updateMatrixWorld(!0), Y.projectionMatrix.copy(it.projectionMatrix), Y.projectionMatrixInverse.copy(it.projectionMatrixInverse), Y.isPerspectiveCamera && (Y.fov = $c * 2 * Math.atan(1 / Y.projectionMatrix.elements[5]), Y.zoom = 1);
    }
    h($, "updateUserCamera"), this.getCamera = function() {
      return I;
    }, this.getFoveation = function() {
      if (!(d === null && f === null))
        return l;
    }, this.setFoveation = function(Y) {
      l = Y, d !== null && (d.fixedFoveation = Y), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = Y);
    }, this.hasDepthSensing = function() {
      return _.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return _.getMesh(I);
    }, this.getCameraTexture = function(Y) {
      return g[Y];
    };
    let lt = null;
    function gt(Y, it) {
      if (u = it.getViewerPose(c || r), p = it, u !== null) {
        const J = u.views;
        f !== null && (t.setRenderTargetFramebuffer(x, f.framebuffer), t.setRenderTarget(x));
        let dt = !1;
        J.length !== I.cameras.length && (I.cameras.length = 0, dt = !0);
        for (let k = 0; k < J.length; k++) {
          const te = J[k];
          let It = null;
          if (f !== null)
            It = f.getViewport(te);
          else {
            const bt = m.getViewSubImage(d, te);
            It = bt.viewport, k === 0 && (t.setRenderTargetTextures(
              x,
              bt.colorTexture,
              bt.depthStencilTexture
            ), t.setRenderTarget(x));
          }
          let ut = E[k];
          ut === void 0 && (ut = new si(), ut.layers.enable(k), ut.viewport = new an(), E[k] = ut), ut.matrix.fromArray(te.transform.matrix), ut.matrix.decompose(ut.position, ut.quaternion, ut.scale), ut.projectionMatrix.fromArray(te.projectionMatrix), ut.projectionMatrixInverse.copy(ut.projectionMatrix).invert(), ut.viewport.set(It.x, It.y, It.width, It.height), k === 0 && (I.matrix.copy(ut.matrix), I.matrix.decompose(I.position, I.quaternion, I.scale)), dt === !0 && I.cameras.push(ut);
        }
        const vt = i.enabledFeatures;
        if (vt && vt.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && v) {
          m = s.getBinding();
          const k = m.getDepthInformation(J[0]);
          k && k.isValid && k.texture && _.init(k, i.renderState);
        }
        if (vt && vt.includes("camera-access") && v) {
          t.state.unbindTexture(), m = s.getBinding();
          for (let k = 0; k < J.length; k++) {
            const te = J[k].camera;
            if (te) {
              let It = g[te];
              It || (It = new bd(), g[te] = It);
              const ut = m.getCameraImage(te);
              It.sourceTexture = ut;
            }
          }
        }
      }
      for (let J = 0; J < A.length; J++) {
        const dt = C[J], vt = A[J];
        dt !== null && vt !== void 0 && vt.update(dt, it, c || r);
      }
      lt && lt(Y, it), it.detectedPlanes && s.dispatchEvent({ type: "planesdetected", data: it }), p = null;
    }
    h(gt, "onAnimationFrame");
    const _t = new Z3();
    _t.setAnimationLoop(gt), this.setAnimationLoop = function(Y) {
      lt = Y;
    }, this.dispose = function() {
    };
  }
};
h(Ty, "WebXRManager");
let Y_ = Ty;
const zr = new Js(), n8 = new Re();
function i8(n, t) {
  function e(_, g) {
    _.matrixAutoUpdate === !0 && _.updateMatrix(), g.value.copy(_.matrix);
  }
  h(e, "refreshTransformUniform");
  function s(_, g) {
    g.color.getRGB(_.fogColor.value, q3(n)), g.isFog ? (_.fogNear.value = g.near, _.fogFar.value = g.far) : g.isFogExp2 && (_.fogDensity.value = g.density);
  }
  h(s, "refreshFogUniforms");
  function i(_, g, w, S, x) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial ? o(_, g) : g.isMeshToonMaterial ? (o(_, g), m(_, g)) : g.isMeshPhongMaterial ? (o(_, g), u(_, g)) : g.isMeshStandardMaterial ? (o(_, g), d(_, g), g.isMeshPhysicalMaterial && f(_, g, x)) : g.isMeshMatcapMaterial ? (o(_, g), p(_, g)) : g.isMeshDepthMaterial ? o(_, g) : g.isMeshDistanceMaterial ? (o(_, g), v(_, g)) : g.isMeshNormalMaterial ? o(_, g) : g.isLineBasicMaterial ? (r(_, g), g.isLineDashedMaterial && a(_, g)) : g.isPointsMaterial ? l(_, g, w, S) : g.isSpriteMaterial ? c(_, g) : g.isShadowMaterial ? (_.color.value.copy(g.color), _.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  h(i, "refreshMaterialUniforms");
  function o(_, g) {
    _.opacity.value = g.opacity, g.color && _.diffuse.value.copy(g.color), g.emissive && _.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (_.map.value = g.map, e(g.map, _.mapTransform)), g.alphaMap && (_.alphaMap.value = g.alphaMap, e(g.alphaMap, _.alphaMapTransform)), g.bumpMap && (_.bumpMap.value = g.bumpMap, e(g.bumpMap, _.bumpMapTransform), _.bumpScale.value = g.bumpScale, g.side === Di && (_.bumpScale.value *= -1)), g.normalMap && (_.normalMap.value = g.normalMap, e(g.normalMap, _.normalMapTransform), _.normalScale.value.copy(g.normalScale), g.side === Di && _.normalScale.value.negate()), g.displacementMap && (_.displacementMap.value = g.displacementMap, e(g.displacementMap, _.displacementMapTransform), _.displacementScale.value = g.displacementScale, _.displacementBias.value = g.displacementBias), g.emissiveMap && (_.emissiveMap.value = g.emissiveMap, e(g.emissiveMap, _.emissiveMapTransform)), g.specularMap && (_.specularMap.value = g.specularMap, e(g.specularMap, _.specularMapTransform)), g.alphaTest > 0 && (_.alphaTest.value = g.alphaTest);
    const w = t.get(g), S = w.envMap, x = w.envMapRotation;
    S && (_.envMap.value = S, zr.copy(x), zr.x *= -1, zr.y *= -1, zr.z *= -1, S.isCubeTexture && S.isRenderTargetTexture === !1 && (zr.y *= -1, zr.z *= -1), _.envMapRotation.value.setFromMatrix4(n8.makeRotationFromEuler(zr)), _.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, _.reflectivity.value = g.reflectivity, _.ior.value = g.ior, _.refractionRatio.value = g.refractionRatio), g.lightMap && (_.lightMap.value = g.lightMap, _.lightMapIntensity.value = g.lightMapIntensity, e(g.lightMap, _.lightMapTransform)), g.aoMap && (_.aoMap.value = g.aoMap, _.aoMapIntensity.value = g.aoMapIntensity, e(g.aoMap, _.aoMapTransform));
  }
  h(o, "refreshUniformsCommon");
  function r(_, g) {
    _.diffuse.value.copy(g.color), _.opacity.value = g.opacity, g.map && (_.map.value = g.map, e(g.map, _.mapTransform));
  }
  h(r, "refreshUniformsLine");
  function a(_, g) {
    _.dashSize.value = g.dashSize, _.totalSize.value = g.dashSize + g.gapSize, _.scale.value = g.scale;
  }
  h(a, "refreshUniformsDash");
  function l(_, g, w, S) {
    _.diffuse.value.copy(g.color), _.opacity.value = g.opacity, _.size.value = g.size * w, _.scale.value = S * 0.5, g.map && (_.map.value = g.map, e(g.map, _.uvTransform)), g.alphaMap && (_.alphaMap.value = g.alphaMap, e(g.alphaMap, _.alphaMapTransform)), g.alphaTest > 0 && (_.alphaTest.value = g.alphaTest);
  }
  h(l, "refreshUniformsPoints");
  function c(_, g) {
    _.diffuse.value.copy(g.color), _.opacity.value = g.opacity, _.rotation.value = g.rotation, g.map && (_.map.value = g.map, e(g.map, _.mapTransform)), g.alphaMap && (_.alphaMap.value = g.alphaMap, e(g.alphaMap, _.alphaMapTransform)), g.alphaTest > 0 && (_.alphaTest.value = g.alphaTest);
  }
  h(c, "refreshUniformsSprites");
  function u(_, g) {
    _.specular.value.copy(g.specular), _.shininess.value = Math.max(g.shininess, 1e-4);
  }
  h(u, "refreshUniformsPhong");
  function m(_, g) {
    g.gradientMap && (_.gradientMap.value = g.gradientMap);
  }
  h(m, "refreshUniformsToon");
  function d(_, g) {
    _.metalness.value = g.metalness, g.metalnessMap && (_.metalnessMap.value = g.metalnessMap, e(g.metalnessMap, _.metalnessMapTransform)), _.roughness.value = g.roughness, g.roughnessMap && (_.roughnessMap.value = g.roughnessMap, e(g.roughnessMap, _.roughnessMapTransform)), g.envMap && (_.envMapIntensity.value = g.envMapIntensity);
  }
  h(d, "refreshUniformsStandard");
  function f(_, g, w) {
    _.ior.value = g.ior, g.sheen > 0 && (_.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), _.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (_.sheenColorMap.value = g.sheenColorMap, e(g.sheenColorMap, _.sheenColorMapTransform)), g.sheenRoughnessMap && (_.sheenRoughnessMap.value = g.sheenRoughnessMap, e(g.sheenRoughnessMap, _.sheenRoughnessMapTransform))), g.clearcoat > 0 && (_.clearcoat.value = g.clearcoat, _.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (_.clearcoatMap.value = g.clearcoatMap, e(g.clearcoatMap, _.clearcoatMapTransform)), g.clearcoatRoughnessMap && (_.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap, e(g.clearcoatRoughnessMap, _.clearcoatRoughnessMapTransform)), g.clearcoatNormalMap && (_.clearcoatNormalMap.value = g.clearcoatNormalMap, e(g.clearcoatNormalMap, _.clearcoatNormalMapTransform), _.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === Di && _.clearcoatNormalScale.value.negate())), g.dispersion > 0 && (_.dispersion.value = g.dispersion), g.iridescence > 0 && (_.iridescence.value = g.iridescence, _.iridescenceIOR.value = g.iridescenceIOR, _.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], _.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (_.iridescenceMap.value = g.iridescenceMap, e(g.iridescenceMap, _.iridescenceMapTransform)), g.iridescenceThicknessMap && (_.iridescenceThicknessMap.value = g.iridescenceThicknessMap, e(g.iridescenceThicknessMap, _.iridescenceThicknessMapTransform))), g.transmission > 0 && (_.transmission.value = g.transmission, _.transmissionSamplerMap.value = w.texture, _.transmissionSamplerSize.value.set(w.width, w.height), g.transmissionMap && (_.transmissionMap.value = g.transmissionMap, e(g.transmissionMap, _.transmissionMapTransform)), _.thickness.value = g.thickness, g.thicknessMap && (_.thicknessMap.value = g.thicknessMap, e(g.thicknessMap, _.thicknessMapTransform)), _.attenuationDistance.value = g.attenuationDistance, _.attenuationColor.value.copy(g.attenuationColor)), g.anisotropy > 0 && (_.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && (_.anisotropyMap.value = g.anisotropyMap, e(g.anisotropyMap, _.anisotropyMapTransform))), _.specularIntensity.value = g.specularIntensity, _.specularColor.value.copy(g.specularColor), g.specularColorMap && (_.specularColorMap.value = g.specularColorMap, e(g.specularColorMap, _.specularColorMapTransform)), g.specularIntensityMap && (_.specularIntensityMap.value = g.specularIntensityMap, e(g.specularIntensityMap, _.specularIntensityMapTransform));
  }
  h(f, "refreshUniformsPhysical");
  function p(_, g) {
    g.matcap && (_.matcap.value = g.matcap);
  }
  h(p, "refreshUniformsMatcap");
  function v(_, g) {
    const w = t.get(g).light;
    _.referencePosition.value.setFromMatrixPosition(w.matrixWorld), _.nearDistance.value = w.shadow.camera.near, _.farDistance.value = w.shadow.camera.far;
  }
  return h(v, "refreshUniformsDistance"), {
    refreshFogUniforms: s,
    refreshMaterialUniforms: i
  };
}
h(i8, "WebGLMaterials");
function s8(n, t, e, s) {
  let i = {}, o = {}, r = [];
  const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(w, S) {
    const x = S.program;
    s.uniformBlockBinding(w, x);
  }
  h(l, "bind");
  function c(w, S) {
    let x = i[w.id];
    x === void 0 && (p(w), x = u(w), i[w.id] = x, w.addEventListener("dispose", _));
    const A = S.program;
    s.updateUBOMapping(w, A);
    const C = t.render.frame;
    o[w.id] !== C && (d(w), o[w.id] = C);
  }
  h(c, "update");
  function u(w) {
    const S = m();
    w.__bindingPointIndex = S;
    const x = n.createBuffer(), A = w.__size, C = w.usage;
    return n.bindBuffer(n.UNIFORM_BUFFER, x), n.bufferData(n.UNIFORM_BUFFER, A, C), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, S, x), x;
  }
  h(u, "createBuffer");
  function m() {
    for (let w = 0; w < a; w++)
      if (r.indexOf(w) === -1)
        return r.push(w), w;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  h(m, "allocateBindingPointIndex");
  function d(w) {
    const S = i[w.id], x = w.uniforms, A = w.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, S);
    for (let C = 0, M = x.length; C < M; C++) {
      const T = Array.isArray(x[C]) ? x[C] : [x[C]];
      for (let b = 0, y = T.length; b < y; b++) {
        const E = T[b];
        if (f(E, C, b, A) === !0) {
          const I = E.__offset, B = Array.isArray(E.value) ? E.value : [E.value];
          let D = 0;
          for (let N = 0; N < B.length; N++) {
            const V = B[N], G = v(V);
            typeof V == "number" || typeof V == "boolean" ? (E.__data[0] = V, n.bufferSubData(n.UNIFORM_BUFFER, I + D, E.__data)) : V.isMatrix3 ? (E.__data[0] = V.elements[0], E.__data[1] = V.elements[1], E.__data[2] = V.elements[2], E.__data[3] = 0, E.__data[4] = V.elements[3], E.__data[5] = V.elements[4], E.__data[6] = V.elements[5], E.__data[7] = 0, E.__data[8] = V.elements[6], E.__data[9] = V.elements[7], E.__data[10] = V.elements[8], E.__data[11] = 0) : (V.toArray(E.__data, D), D += G.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          n.bufferSubData(n.UNIFORM_BUFFER, I, E.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  h(d, "updateBufferData");
  function f(w, S, x, A) {
    const C = w.value, M = S + "_" + x;
    if (A[M] === void 0)
      return typeof C == "number" || typeof C == "boolean" ? A[M] = C : A[M] = C.clone(), !0;
    {
      const T = A[M];
      if (typeof C == "number" || typeof C == "boolean") {
        if (T !== C)
          return A[M] = C, !0;
      } else if (T.equals(C) === !1)
        return T.copy(C), !0;
    }
    return !1;
  }
  h(f, "hasUniformChanged");
  function p(w) {
    const S = w.uniforms;
    let x = 0;
    const A = 16;
    for (let M = 0, T = S.length; M < T; M++) {
      const b = Array.isArray(S[M]) ? S[M] : [S[M]];
      for (let y = 0, E = b.length; y < E; y++) {
        const I = b[y], B = Array.isArray(I.value) ? I.value : [I.value];
        for (let D = 0, N = B.length; D < N; D++) {
          const V = B[D], G = v(V), U = x % A, j = U % G.boundary, tt = U + j;
          x += j, tt !== 0 && A - tt < G.storage && (x += A - tt), I.__data = new Float32Array(G.storage / Float32Array.BYTES_PER_ELEMENT), I.__offset = x, x += G.storage;
        }
      }
    }
    const C = x % A;
    return C > 0 && (x += A - C), w.__size = x, w.__cache = {}, this;
  }
  h(p, "prepareUniformsGroup");
  function v(w) {
    const S = {
      boundary: 0,
      storage: 0
    };
    return typeof w == "number" || typeof w == "boolean" ? (S.boundary = 4, S.storage = 4) : w.isVector2 ? (S.boundary = 8, S.storage = 8) : w.isVector3 || w.isColor ? (S.boundary = 16, S.storage = 12) : w.isVector4 ? (S.boundary = 16, S.storage = 16) : w.isMatrix3 ? (S.boundary = 48, S.storage = 48) : w.isMatrix4 ? (S.boundary = 64, S.storage = 64) : w.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", w), S;
  }
  h(v, "getUniformSize");
  function _(w) {
    const S = w.target;
    S.removeEventListener("dispose", _);
    const x = r.indexOf(S.__bindingPointIndex);
    r.splice(x, 1), n.deleteBuffer(i[S.id]), delete i[S.id], delete o[S.id];
  }
  h(_, "onUniformsGroupsDispose");
  function g() {
    for (const w in i)
      n.deleteBuffer(i[w]);
    r = [], i = {}, o = {};
  }
  return h(g, "dispose"), {
    bind: l,
    update: c,
    dispose: g
  };
}
h(s8, "WebGLUniformsGroups");
const Iy = class Iy {
  constructor(t = {}) {
    const {
      canvas: e = ik(),
      context: s = null,
      depth: i = !0,
      stencil: o = !1,
      alpha: r = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: m = !1,
      reversedDepthBuffer: d = !1
    } = t;
    this.isWebGLRenderer = !0;
    let f;
    if (s !== null) {
      if (typeof WebGLRenderingContext != "undefined" && s instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      f = s.getContextAttributes().alpha;
    } else
      f = r;
    const p = new Uint32Array(4), v = new Int32Array(4);
    let _ = null, g = null;
    const w = [], S = [];
    this.domElement = e, this.debug = {
      checkShaderErrors: !0,
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = dr, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
    const x = this;
    let A = !1;
    this._outputColorSpace = rs;
    let C = 0, M = 0, T = null, b = -1, y = null;
    const E = new an(), I = new an();
    let B = null;
    const D = new Ce(0);
    let N = 0, V = e.width, G = e.height, U = 1, j = null, tt = null;
    const K = new an(0, 0, V, G), $ = new an(0, 0, V, G);
    let lt = !1;
    const gt = new ya();
    let _t = !1, Y = !1;
    const it = new Re(), J = new O(), dt = new an(), vt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let Nt = !1;
    function _e() {
      return T === null ? U : 1;
    }
    h(_e, "getTargetPixelRatio");
    let k = s;
    function te(L, W) {
      return e.getContext(L, W);
    }
    h(te, "getContext");
    try {
      const L = {
        alpha: !0,
        depth: i,
        stencil: o,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: m
      };
      if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${N2}`), e.addEventListener("webglcontextlost", Dt, !1), e.addEventListener("webglcontextrestored", Yt, !1), e.addEventListener("webglcontextcreationerror", St, !1), k === null) {
        const W = "webgl2";
        if (k = te(W, L), k === null)
          throw te(W) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (L) {
      throw console.error("THREE.WebGLRenderer: " + L.message), L;
    }
    let It, ut, bt, Ft, wt, le, dn, Ze, z, P, q, at, mt, ot, Wt, Rt, ie, se, Ct, Ot, fe, oe, kt, Se;
    function F() {
      It = new w$(k), It.init(), oe = new QF(k, It), ut = new p$(k, It, t, oe), bt = new JF(k, It), ut.reversedDepthBuffer && d && bt.buffers.depth.setReversed(!0), Ft = new M$(k), wt = new kF(), le = new KF(k, It, bt, wt, ut, oe, Ft), dn = new g$(x), Ze = new x$(x), z = new Pk(k), kt = new m$(k, z), P = new S$(k, z, Ft, kt), q = new E$(k, P, z, Ft), Ct = new C$(k, ut, le), Rt = new _$(wt), at = new zF(x, dn, Ze, It, ut, kt, Rt), mt = new i8(x, wt), ot = new OF(), Wt = new WF(It), se = new d$(x, dn, Ze, bt, q, f, l), ie = new ZF(x, q, ut), Se = new s8(k, Ft, ut, bt), Ot = new f$(k, It, Ft), fe = new A$(k, It, Ft), Ft.programs = at.programs, x.capabilities = ut, x.extensions = It, x.properties = wt, x.renderLists = ot, x.shadowMap = ie, x.state = bt, x.info = Ft;
    }
    h(F, "initGLContext"), F();
    const Et = new Y_(x, k);
    this.xr = Et, this.getContext = function() {
      return k;
    }, this.getContextAttributes = function() {
      return k.getContextAttributes();
    }, this.forceContextLoss = function() {
      const L = It.get("WEBGL_lose_context");
      L && L.loseContext();
    }, this.forceContextRestore = function() {
      const L = It.get("WEBGL_lose_context");
      L && L.restoreContext();
    }, this.getPixelRatio = function() {
      return U;
    }, this.setPixelRatio = function(L) {
      L !== void 0 && (U = L, this.setSize(V, G, !1));
    }, this.getSize = function(L) {
      return L.set(V, G);
    }, this.setSize = function(L, W, et = !0) {
      if (Et.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      V = L, G = W, e.width = Math.floor(L * U), e.height = Math.floor(W * U), et === !0 && (e.style.width = L + "px", e.style.height = W + "px"), this.setViewport(0, 0, L, W);
    }, this.getDrawingBufferSize = function(L) {
      return L.set(V * U, G * U).floor();
    }, this.setDrawingBufferSize = function(L, W, et) {
      V = L, G = W, U = et, e.width = Math.floor(L * et), e.height = Math.floor(W * et), this.setViewport(0, 0, L, W);
    }, this.getCurrentViewport = function(L) {
      return L.copy(E);
    }, this.getViewport = function(L) {
      return L.copy(K);
    }, this.setViewport = function(L, W, et, nt) {
      L.isVector4 ? K.set(L.x, L.y, L.z, L.w) : K.set(L, W, et, nt), bt.viewport(E.copy(K).multiplyScalar(U).round());
    }, this.getScissor = function(L) {
      return L.copy($);
    }, this.setScissor = function(L, W, et, nt) {
      L.isVector4 ? $.set(L.x, L.y, L.z, L.w) : $.set(L, W, et, nt), bt.scissor(I.copy($).multiplyScalar(U).round());
    }, this.getScissorTest = function() {
      return lt;
    }, this.setScissorTest = function(L) {
      bt.setScissorTest(lt = L);
    }, this.setOpaqueSort = function(L) {
      j = L;
    }, this.setTransparentSort = function(L) {
      tt = L;
    }, this.getClearColor = function(L) {
      return L.copy(se.getClearColor());
    }, this.setClearColor = function() {
      se.setClearColor(...arguments);
    }, this.getClearAlpha = function() {
      return se.getClearAlpha();
    }, this.setClearAlpha = function() {
      se.setClearAlpha(...arguments);
    }, this.clear = function(L = !0, W = !0, et = !0) {
      let nt = 0;
      if (L) {
        let X = !1;
        if (T !== null) {
          const At = T.texture.format;
          X = At === F2 || At === $2 || At === O2;
        }
        if (X) {
          const At = T.texture.type, Ut = At === Xs || At === ga || At === su || At === ou || At === k2 || At === U2, Qt = se.getClearColor(), qt = se.getClearAlpha(), me = Qt.r, pe = Qt.g, ce = Qt.b;
          Ut ? (p[0] = me, p[1] = pe, p[2] = ce, p[3] = qt, k.clearBufferuiv(k.COLOR, 0, p)) : (v[0] = me, v[1] = pe, v[2] = ce, v[3] = qt, k.clearBufferiv(k.COLOR, 0, v));
        } else
          nt |= k.COLOR_BUFFER_BIT;
      }
      W && (nt |= k.DEPTH_BUFFER_BIT), et && (nt |= k.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), k.clear(nt);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      e.removeEventListener("webglcontextlost", Dt, !1), e.removeEventListener("webglcontextrestored", Yt, !1), e.removeEventListener("webglcontextcreationerror", St, !1), se.dispose(), ot.dispose(), Wt.dispose(), wt.dispose(), dn.dispose(), Ze.dispose(), q.dispose(), kt.dispose(), Se.dispose(), at.dispose(), Et.dispose(), Et.removeEventListener("sessionstart", Rs), Et.removeEventListener("sessionend", mx), Ir.stop();
    };
    function Dt(L) {
      L.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), A = !0;
    }
    h(Dt, "onContextLost");
    function Yt() {
      console.log("THREE.WebGLRenderer: Context Restored."), A = !1;
      const L = Ft.autoReset, W = ie.enabled, et = ie.autoUpdate, nt = ie.needsUpdate, X = ie.type;
      F(), Ft.autoReset = L, ie.enabled = W, ie.autoUpdate = et, ie.needsUpdate = nt, ie.type = X;
    }
    h(Yt, "onContextRestore");
    function St(L) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", L.statusMessage);
    }
    h(St, "onContextCreationError");
    function ft(L) {
      const W = L.target;
      W.removeEventListener("dispose", ft), ee(W);
    }
    h(ft, "onMaterialDispose");
    function ee(L) {
      be(L), wt.remove(L);
    }
    h(ee, "deallocateMaterial");
    function be(L) {
      const W = wt.get(L).programs;
      W !== void 0 && (W.forEach(function(et) {
        at.releaseProgram(et);
      }), L.isShaderMaterial && at.releaseShaderCache(L));
    }
    h(be, "releaseMaterialProgramReferences"), this.renderBufferDirect = function(L, W, et, nt, X, At) {
      W === null && (W = vt);
      const Ut = X.isMesh && X.matrixWorld.determinant() < 0, Qt = vI(L, W, et, nt, X);
      bt.setMaterial(nt, Ut);
      let qt = et.index, me = 1;
      if (nt.wireframe === !0) {
        if (qt = P.getWireframeAttribute(et), qt === void 0) return;
        me = 2;
      }
      const pe = et.drawRange, ce = et.attributes.position;
      let ze = pe.start * me, mn = (pe.start + pe.count) * me;
      At !== null && (ze = Math.max(ze, At.start * me), mn = Math.min(mn, (At.start + At.count) * me)), qt !== null ? (ze = Math.max(ze, 0), mn = Math.min(mn, qt.count)) : ce != null && (ze = Math.max(ze, 0), mn = Math.min(mn, ce.count));
      const Pn = mn - ze;
      if (Pn < 0 || Pn === 1 / 0) return;
      kt.setup(X, nt, Qt, et, qt);
      let An, _n = Ot;
      if (qt !== null && (An = z.get(qt), _n = fe, _n.setIndex(An)), X.isMesh)
        nt.wireframe === !0 ? (bt.setLineWidth(nt.wireframeLinewidth * _e()), _n.setMode(k.LINES)) : _n.setMode(k.TRIANGLES);
      else if (X.isLine) {
        let de = nt.linewidth;
        de === void 0 && (de = 1), bt.setLineWidth(de * _e()), X.isLineSegments ? _n.setMode(k.LINES) : X.isLineLoop ? _n.setMode(k.LINE_LOOP) : _n.setMode(k.LINE_STRIP);
      } else X.isPoints ? _n.setMode(k.POINTS) : X.isSprite && _n.setMode(k.TRIANGLES);
      if (X.isBatchedMesh)
        if (X._multiDrawInstances !== null)
          cu("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), _n.renderMultiDrawInstances(X._multiDrawStarts, X._multiDrawCounts, X._multiDrawCount, X._multiDrawInstances);
        else if (It.get("WEBGL_multi_draw"))
          _n.renderMultiDraw(X._multiDrawStarts, X._multiDrawCounts, X._multiDrawCount);
        else {
          const de = X._multiDrawStarts, In = X._multiDrawCounts, Ye = X._multiDrawCount, Li = qt ? z.get(qt).bytesPerElement : 1, Oa = wt.get(nt).currentProgram.getUniforms();
          for (let Ni = 0; Ni < Ye; Ni++)
            Oa.setValue(k, "_gl_DrawID", Ni), _n.render(de[Ni] / Li, In[Ni]);
        }
      else if (X.isInstancedMesh)
        _n.renderInstances(ze, Pn, X.count);
      else if (et.isInstancedBufferGeometry) {
        const de = et._maxInstanceCount !== void 0 ? et._maxInstanceCount : 1 / 0, In = Math.min(et.instanceCount, de);
        _n.renderInstances(ze, Pn, In);
      } else
        _n.render(ze, Pn);
    };
    function vn(L, W, et) {
      L.transparent === !0 && L.side === As && L.forceSinglePass === !1 ? (L.side = Di, L.needsUpdate = !0, Hu(L, W, et), L.side = yr, L.needsUpdate = !0, Hu(L, W, et), L.side = As) : Hu(L, W, et);
    }
    h(vn, "prepareMaterial"), this.compile = function(L, W, et = null) {
      et === null && (et = L), g = Wt.get(et), g.init(W), S.push(g), et.traverseVisible(function(X) {
        X.isLight && X.layers.test(W.layers) && (g.pushLight(X), X.castShadow && g.pushShadow(X));
      }), L !== et && L.traverseVisible(function(X) {
        X.isLight && X.layers.test(W.layers) && (g.pushLight(X), X.castShadow && g.pushShadow(X));
      }), g.setupLights();
      const nt = /* @__PURE__ */ new Set();
      return L.traverse(function(X) {
        if (!(X.isMesh || X.isPoints || X.isLine || X.isSprite))
          return;
        const At = X.material;
        if (At)
          if (Array.isArray(At))
            for (let Ut = 0; Ut < At.length; Ut++) {
              const Qt = At[Ut];
              vn(Qt, et, X), nt.add(Qt);
            }
          else
            vn(At, et, X), nt.add(At);
      }), g = S.pop(), nt;
    }, this.compileAsync = function(L, W, et = null) {
      const nt = this.compile(L, W, et);
      return new Promise((X) => {
        function At() {
          if (nt.forEach(function(Ut) {
            wt.get(Ut).currentProgram.isReady() && nt.delete(Ut);
          }), nt.size === 0) {
            X(L);
            return;
          }
          setTimeout(At, 10);
        }
        h(At, "checkMaterialsReady"), It.get("KHR_parallel_shader_compile") !== null ? At() : setTimeout(At, 10);
      });
    };
    let nn = null;
    function io(L) {
      nn && nn(L);
    }
    h(io, "onAnimationFrame");
    function Rs() {
      Ir.stop();
    }
    h(Rs, "onXRSessionStart");
    function mx() {
      Ir.start();
    }
    h(mx, "onXRSessionEnd");
    const Ir = new Z3();
    Ir.setAnimationLoop(io), typeof self != "undefined" && Ir.setContext(self), this.setAnimationLoop = function(L) {
      nn = L, Et.setAnimationLoop(L), L === null ? Ir.stop() : Ir.start();
    }, Et.addEventListener("sessionstart", Rs), Et.addEventListener("sessionend", mx), this.render = function(L, W) {
      if (W !== void 0 && W.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (A === !0) return;
      if (L.matrixWorldAutoUpdate === !0 && L.updateMatrixWorld(), W.parent === null && W.matrixWorldAutoUpdate === !0 && W.updateMatrixWorld(), Et.enabled === !0 && Et.isPresenting === !0 && (Et.cameraAutoUpdate === !0 && Et.updateCamera(W), W = Et.getCamera()), L.isScene === !0 && L.onBeforeRender(x, L, W, T), g = Wt.get(L, S.length), g.init(W), S.push(g), it.multiplyMatrices(W.projectionMatrix, W.matrixWorldInverse), gt.setFromProjectionMatrix(it, Fs, W.reversedDepth), Y = this.localClippingEnabled, _t = Rt.init(this.clippingPlanes, Y), _ = ot.get(L, w.length), _.init(), w.push(_), Et.enabled === !0 && Et.isPresenting === !0) {
        const At = x.xr.getDepthSensingMesh();
        At !== null && sf(At, W, -1 / 0, x.sortObjects);
      }
      sf(L, W, 0, x.sortObjects), _.finish(), x.sortObjects === !0 && _.sort(j, tt), Nt = Et.enabled === !1 || Et.isPresenting === !1 || Et.hasDepthSensing() === !1, Nt && se.addToRenderList(_, L), this.info.render.frame++, _t === !0 && Rt.beginShadows();
      const et = g.state.shadowsArray;
      ie.render(et, L, W), _t === !0 && Rt.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const nt = _.opaque, X = _.transmissive;
      if (g.setupLights(), W.isArrayCamera) {
        const At = W.cameras;
        if (X.length > 0)
          for (let Ut = 0, Qt = At.length; Ut < Qt; Ut++) {
            const qt = At[Ut];
            px(nt, X, L, qt);
          }
        Nt && se.render(L);
        for (let Ut = 0, Qt = At.length; Ut < Qt; Ut++) {
          const qt = At[Ut];
          fx(_, L, qt, qt.viewport);
        }
      } else
        X.length > 0 && px(nt, X, L, W), Nt && se.render(L), fx(_, L, W);
      T !== null && M === 0 && (le.updateMultisampleRenderTarget(T), le.updateRenderTargetMipmap(T)), L.isScene === !0 && L.onAfterRender(x, L, W), kt.resetDefaultState(), b = -1, y = null, S.pop(), S.length > 0 ? (g = S[S.length - 1], _t === !0 && Rt.setGlobalState(x.clippingPlanes, g.state.camera)) : g = null, w.pop(), w.length > 0 ? _ = w[w.length - 1] : _ = null;
    };
    function sf(L, W, et, nt) {
      if (L.visible === !1) return;
      if (L.layers.test(W.layers)) {
        if (L.isGroup)
          et = L.renderOrder;
        else if (L.isLOD)
          L.autoUpdate === !0 && L.update(W);
        else if (L.isLight)
          g.pushLight(L), L.castShadow && g.pushShadow(L);
        else if (L.isSprite) {
          if (!L.frustumCulled || gt.intersectsSprite(L)) {
            nt && dt.setFromMatrixPosition(L.matrixWorld).applyMatrix4(it);
            const Ut = q.update(L), Qt = L.material;
            Qt.visible && _.push(L, Ut, Qt, et, dt.z, null);
          }
        } else if ((L.isMesh || L.isLine || L.isPoints) && (!L.frustumCulled || gt.intersectsObject(L))) {
          const Ut = q.update(L), Qt = L.material;
          if (nt && (L.boundingSphere !== void 0 ? (L.boundingSphere === null && L.computeBoundingSphere(), dt.copy(L.boundingSphere.center)) : (Ut.boundingSphere === null && Ut.computeBoundingSphere(), dt.copy(Ut.boundingSphere.center)), dt.applyMatrix4(L.matrixWorld).applyMatrix4(it)), Array.isArray(Qt)) {
            const qt = Ut.groups;
            for (let me = 0, pe = qt.length; me < pe; me++) {
              const ce = qt[me], ze = Qt[ce.materialIndex];
              ze && ze.visible && _.push(L, Ut, ze, et, dt.z, ce);
            }
          } else Qt.visible && _.push(L, Ut, Qt, et, dt.z, null);
        }
      }
      const At = L.children;
      for (let Ut = 0, Qt = At.length; Ut < Qt; Ut++)
        sf(At[Ut], W, et, nt);
    }
    h(sf, "projectObject");
    function fx(L, W, et, nt) {
      const X = L.opaque, At = L.transmissive, Ut = L.transparent;
      g.setupLightsView(et), _t === !0 && Rt.setGlobalState(x.clippingPlanes, et), nt && bt.viewport(E.copy(nt)), X.length > 0 && Gu(X, W, et), At.length > 0 && Gu(At, W, et), Ut.length > 0 && Gu(Ut, W, et), bt.buffers.depth.setTest(!0), bt.buffers.depth.setMask(!0), bt.buffers.color.setMask(!0), bt.setPolygonOffset(!1);
    }
    h(fx, "renderScene");
    function px(L, W, et, nt) {
      if ((et.isScene === !0 ? et.overrideMaterial : null) !== null)
        return;
      g.state.transmissionRenderTarget[nt.id] === void 0 && (g.state.transmissionRenderTarget[nt.id] = new Oo(1, 1, {
        generateMipmaps: !0,
        type: It.has("EXT_color_buffer_half_float") || It.has("EXT_color_buffer_float") ? Nu : Xs,
        minFilter: ra,
        samples: 4,
        stencilBuffer: o,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: Qe.workingColorSpace
      }));
      const At = g.state.transmissionRenderTarget[nt.id], Ut = nt.viewport || E;
      At.setSize(Ut.z * x.transmissionResolutionScale, Ut.w * x.transmissionResolutionScale);
      const Qt = x.getRenderTarget(), qt = x.getActiveCubeFace(), me = x.getActiveMipmapLevel();
      x.setRenderTarget(At), x.getClearColor(D), N = x.getClearAlpha(), N < 1 && x.setClearColor(16777215, 0.5), x.clear(), Nt && se.render(et);
      const pe = x.toneMapping;
      x.toneMapping = dr;
      const ce = nt.viewport;
      if (nt.viewport !== void 0 && (nt.viewport = void 0), g.setupLightsView(nt), _t === !0 && Rt.setGlobalState(x.clippingPlanes, nt), Gu(L, et, nt), le.updateMultisampleRenderTarget(At), le.updateRenderTargetMipmap(At), It.has("WEBGL_multisampled_render_to_texture") === !1) {
        let ze = !1;
        for (let mn = 0, Pn = W.length; mn < Pn; mn++) {
          const An = W[mn], _n = An.object, de = An.geometry, In = An.material, Ye = An.group;
          if (In.side === As && _n.layers.test(nt.layers)) {
            const Li = In.side;
            In.side = Di, In.needsUpdate = !0, _x(_n, et, nt, de, In, Ye), In.side = Li, In.needsUpdate = !0, ze = !0;
          }
        }
        ze === !0 && (le.updateMultisampleRenderTarget(At), le.updateRenderTargetMipmap(At));
      }
      x.setRenderTarget(Qt, qt, me), x.setClearColor(D, N), ce !== void 0 && (nt.viewport = ce), x.toneMapping = pe;
    }
    h(px, "renderTransmissionPass");
    function Gu(L, W, et) {
      const nt = W.isScene === !0 ? W.overrideMaterial : null;
      for (let X = 0, At = L.length; X < At; X++) {
        const Ut = L[X], Qt = Ut.object, qt = Ut.geometry, me = Ut.group;
        let pe = Ut.material;
        pe.allowOverride === !0 && nt !== null && (pe = nt), Qt.layers.test(et.layers) && _x(Qt, W, et, qt, pe, me);
      }
    }
    h(Gu, "renderObjects");
    function _x(L, W, et, nt, X, At) {
      L.onBeforeRender(x, W, et, nt, X, At), L.modelViewMatrix.multiplyMatrices(et.matrixWorldInverse, L.matrixWorld), L.normalMatrix.getNormalMatrix(L.modelViewMatrix), X.onBeforeRender(x, W, et, nt, L, At), X.transparent === !0 && X.side === As && X.forceSinglePass === !1 ? (X.side = Di, X.needsUpdate = !0, x.renderBufferDirect(et, W, nt, X, L, At), X.side = yr, X.needsUpdate = !0, x.renderBufferDirect(et, W, nt, X, L, At), X.side = As) : x.renderBufferDirect(et, W, nt, X, L, At), L.onAfterRender(x, W, et, nt, X, At);
    }
    h(_x, "renderObject");
    function Hu(L, W, et) {
      W.isScene !== !0 && (W = vt);
      const nt = wt.get(L), X = g.state.lights, At = g.state.shadowsArray, Ut = X.state.version, Qt = at.getParameters(L, X.state, At, W, et), qt = at.getProgramCacheKey(Qt);
      let me = nt.programs;
      nt.environment = L.isMeshStandardMaterial ? W.environment : null, nt.fog = W.fog, nt.envMap = (L.isMeshStandardMaterial ? Ze : dn).get(L.envMap || nt.environment), nt.envMapRotation = nt.environment !== null && L.envMap === null ? W.environmentRotation : L.envMapRotation, me === void 0 && (L.addEventListener("dispose", ft), me = /* @__PURE__ */ new Map(), nt.programs = me);
      let pe = me.get(qt);
      if (pe !== void 0) {
        if (nt.currentProgram === pe && nt.lightsStateVersion === Ut)
          return vx(L, Qt), pe;
      } else
        Qt.uniforms = at.getUniforms(L), L.onBeforeCompile(Qt, x), pe = at.acquireProgram(Qt, qt), me.set(qt, pe), nt.uniforms = Qt.uniforms;
      const ce = nt.uniforms;
      return (!L.isShaderMaterial && !L.isRawShaderMaterial || L.clipping === !0) && (ce.clippingPlanes = Rt.uniform), vx(L, Qt), nt.needsLights = yI(L), nt.lightsStateVersion = Ut, nt.needsLights && (ce.ambientLightColor.value = X.state.ambient, ce.lightProbe.value = X.state.probe, ce.directionalLights.value = X.state.directional, ce.directionalLightShadows.value = X.state.directionalShadow, ce.spotLights.value = X.state.spot, ce.spotLightShadows.value = X.state.spotShadow, ce.rectAreaLights.value = X.state.rectArea, ce.ltc_1.value = X.state.rectAreaLTC1, ce.ltc_2.value = X.state.rectAreaLTC2, ce.pointLights.value = X.state.point, ce.pointLightShadows.value = X.state.pointShadow, ce.hemisphereLights.value = X.state.hemi, ce.directionalShadowMap.value = X.state.directionalShadowMap, ce.directionalShadowMatrix.value = X.state.directionalShadowMatrix, ce.spotShadowMap.value = X.state.spotShadowMap, ce.spotLightMatrix.value = X.state.spotLightMatrix, ce.spotLightMap.value = X.state.spotLightMap, ce.pointShadowMap.value = X.state.pointShadowMap, ce.pointShadowMatrix.value = X.state.pointShadowMatrix), nt.currentProgram = pe, nt.uniformsList = null, pe;
    }
    h(Hu, "getProgram");
    function gx(L) {
      if (L.uniformsList === null) {
        const W = L.currentProgram.getUniforms();
        L.uniformsList = Ac.seqWithValue(W.seq, L.uniforms);
      }
      return L.uniformsList;
    }
    h(gx, "getUniformList");
    function vx(L, W) {
      const et = wt.get(L);
      et.outputColorSpace = W.outputColorSpace, et.batching = W.batching, et.batchingColor = W.batchingColor, et.instancing = W.instancing, et.instancingColor = W.instancingColor, et.instancingMorph = W.instancingMorph, et.skinning = W.skinning, et.morphTargets = W.morphTargets, et.morphNormals = W.morphNormals, et.morphColors = W.morphColors, et.morphTargetsCount = W.morphTargetsCount, et.numClippingPlanes = W.numClippingPlanes, et.numIntersection = W.numClipIntersection, et.vertexAlphas = W.vertexAlphas, et.vertexTangents = W.vertexTangents, et.toneMapping = W.toneMapping;
    }
    h(vx, "updateCommonMaterialProperties");
    function vI(L, W, et, nt, X) {
      W.isScene !== !0 && (W = vt), le.resetTextureUnits();
      const At = W.fog, Ut = nt.isMeshStandardMaterial ? W.environment : null, Qt = T === null ? x.outputColorSpace : T.isXRRenderTarget === !0 ? T.texture.colorSpace : Oc, qt = (nt.isMeshStandardMaterial ? Ze : dn).get(nt.envMap || Ut), me = nt.vertexColors === !0 && !!et.attributes.color && et.attributes.color.itemSize === 4, pe = !!et.attributes.tangent && (!!nt.normalMap || nt.anisotropy > 0), ce = !!et.morphAttributes.position, ze = !!et.morphAttributes.normal, mn = !!et.morphAttributes.color;
      let Pn = dr;
      nt.toneMapped && (T === null || T.isXRRenderTarget === !0) && (Pn = x.toneMapping);
      const An = et.morphAttributes.position || et.morphAttributes.normal || et.morphAttributes.color, _n = An !== void 0 ? An.length : 0, de = wt.get(nt), In = g.state.lights;
      if (_t === !0 && (Y === !0 || L !== y)) {
        const pi = L === y && nt.id === b;
        Rt.setState(nt, L, pi);
      }
      let Ye = !1;
      nt.version === de.__version ? (de.needsLights && de.lightsStateVersion !== In.state.version || de.outputColorSpace !== Qt || X.isBatchedMesh && de.batching === !1 || !X.isBatchedMesh && de.batching === !0 || X.isBatchedMesh && de.batchingColor === !0 && X.colorTexture === null || X.isBatchedMesh && de.batchingColor === !1 && X.colorTexture !== null || X.isInstancedMesh && de.instancing === !1 || !X.isInstancedMesh && de.instancing === !0 || X.isSkinnedMesh && de.skinning === !1 || !X.isSkinnedMesh && de.skinning === !0 || X.isInstancedMesh && de.instancingColor === !0 && X.instanceColor === null || X.isInstancedMesh && de.instancingColor === !1 && X.instanceColor !== null || X.isInstancedMesh && de.instancingMorph === !0 && X.morphTexture === null || X.isInstancedMesh && de.instancingMorph === !1 && X.morphTexture !== null || de.envMap !== qt || nt.fog === !0 && de.fog !== At || de.numClippingPlanes !== void 0 && (de.numClippingPlanes !== Rt.numPlanes || de.numIntersection !== Rt.numIntersection) || de.vertexAlphas !== me || de.vertexTangents !== pe || de.morphTargets !== ce || de.morphNormals !== ze || de.morphColors !== mn || de.toneMapping !== Pn || de.morphTargetsCount !== _n) && (Ye = !0) : (Ye = !0, de.__version = nt.version);
      let Li = de.currentProgram;
      Ye === !0 && (Li = Hu(nt, W, X));
      let Oa = !1, Ni = !1, ol = !1;
      const Bn = Li.getUniforms(), Ki = de.uniforms;
      if (bt.useProgram(Li.program) && (Oa = !0, Ni = !0, ol = !0), nt.id !== b && (b = nt.id, Ni = !0), Oa || y !== L) {
        bt.buffers.depth.getReversed() && L.reversedDepth !== !0 && (L._reversedDepth = !0, L.updateProjectionMatrix()), Bn.setValue(k, "projectionMatrix", L.projectionMatrix), Bn.setValue(k, "viewMatrix", L.matrixWorldInverse);
        const Mi = Bn.map.cameraPosition;
        Mi !== void 0 && Mi.setValue(k, J.setFromMatrixPosition(L.matrixWorld)), ut.logarithmicDepthBuffer && Bn.setValue(
          k,
          "logDepthBufFC",
          2 / (Math.log(L.far + 1) / Math.LN2)
        ), (nt.isMeshPhongMaterial || nt.isMeshToonMaterial || nt.isMeshLambertMaterial || nt.isMeshBasicMaterial || nt.isMeshStandardMaterial || nt.isShaderMaterial) && Bn.setValue(k, "isOrthographic", L.isOrthographicCamera === !0), y !== L && (y = L, Ni = !0, ol = !0);
      }
      if (X.isSkinnedMesh) {
        Bn.setOptional(k, X, "bindMatrix"), Bn.setOptional(k, X, "bindMatrixInverse");
        const pi = X.skeleton;
        pi && (pi.boneTexture === null && pi.computeBoneTexture(), Bn.setValue(k, "boneTexture", pi.boneTexture, le));
      }
      X.isBatchedMesh && (Bn.setOptional(k, X, "batchingTexture"), Bn.setValue(k, "batchingTexture", X._matricesTexture, le), Bn.setOptional(k, X, "batchingIdTexture"), Bn.setValue(k, "batchingIdTexture", X._indirectTexture, le), Bn.setOptional(k, X, "batchingColorTexture"), X._colorsTexture !== null && Bn.setValue(k, "batchingColorTexture", X._colorsTexture, le));
      const Qi = et.morphAttributes;
      if ((Qi.position !== void 0 || Qi.normal !== void 0 || Qi.color !== void 0) && Ct.update(X, et, Li), (Ni || de.receiveShadow !== X.receiveShadow) && (de.receiveShadow = X.receiveShadow, Bn.setValue(k, "receiveShadow", X.receiveShadow)), nt.isMeshGouraudMaterial && nt.envMap !== null && (Ki.envMap.value = qt, Ki.flipEnvMap.value = qt.isCubeTexture && qt.isRenderTargetTexture === !1 ? -1 : 1), nt.isMeshStandardMaterial && nt.envMap === null && W.environment !== null && (Ki.envMapIntensity.value = W.environmentIntensity), Ni && (Bn.setValue(k, "toneMappingExposure", x.toneMappingExposure), de.needsLights && bI(Ki, ol), At && nt.fog === !0 && mt.refreshFogUniforms(Ki, At), mt.refreshMaterialUniforms(Ki, nt, U, G, g.state.transmissionRenderTarget[L.id]), Ac.upload(k, gx(de), Ki, le)), nt.isShaderMaterial && nt.uniformsNeedUpdate === !0 && (Ac.upload(k, gx(de), Ki, le), nt.uniformsNeedUpdate = !1), nt.isSpriteMaterial && Bn.setValue(k, "center", X.center), Bn.setValue(k, "modelViewMatrix", X.modelViewMatrix), Bn.setValue(k, "normalMatrix", X.normalMatrix), Bn.setValue(k, "modelMatrix", X.matrixWorld), nt.isShaderMaterial || nt.isRawShaderMaterial) {
        const pi = nt.uniformsGroups;
        for (let Mi = 0, of = pi.length; Mi < of; Mi++) {
          const Br = pi[Mi];
          Se.update(Br, Li), Se.bind(Br, Li);
        }
      }
      return Li;
    }
    h(vI, "setProgram");
    function bI(L, W) {
      L.ambientLightColor.needsUpdate = W, L.lightProbe.needsUpdate = W, L.directionalLights.needsUpdate = W, L.directionalLightShadows.needsUpdate = W, L.pointLights.needsUpdate = W, L.pointLightShadows.needsUpdate = W, L.spotLights.needsUpdate = W, L.spotLightShadows.needsUpdate = W, L.rectAreaLights.needsUpdate = W, L.hemisphereLights.needsUpdate = W;
    }
    h(bI, "markUniformsLightsNeedsUpdate");
    function yI(L) {
      return L.isMeshLambertMaterial || L.isMeshToonMaterial || L.isMeshPhongMaterial || L.isMeshStandardMaterial || L.isShadowMaterial || L.isShaderMaterial && L.lights === !0;
    }
    h(yI, "materialNeedsLights"), this.getActiveCubeFace = function() {
      return C;
    }, this.getActiveMipmapLevel = function() {
      return M;
    }, this.getRenderTarget = function() {
      return T;
    }, this.setRenderTargetTextures = function(L, W, et) {
      const nt = wt.get(L);
      nt.__autoAllocateDepthBuffer = L.resolveDepthBuffer === !1, nt.__autoAllocateDepthBuffer === !1 && (nt.__useRenderToTexture = !1), wt.get(L.texture).__webglTexture = W, wt.get(L.depthTexture).__webglTexture = nt.__autoAllocateDepthBuffer ? void 0 : et, nt.__hasExternalTextures = !0;
    }, this.setRenderTargetFramebuffer = function(L, W) {
      const et = wt.get(L);
      et.__webglFramebuffer = W, et.__useDefaultFramebuffer = W === void 0;
    };
    const xI = k.createFramebuffer();
    this.setRenderTarget = function(L, W = 0, et = 0) {
      T = L, C = W, M = et;
      let nt = !0, X = null, At = !1, Ut = !1;
      if (L) {
        const qt = wt.get(L);
        if (qt.__useDefaultFramebuffer !== void 0)
          bt.bindFramebuffer(k.FRAMEBUFFER, null), nt = !1;
        else if (qt.__webglFramebuffer === void 0)
          le.setupRenderTarget(L);
        else if (qt.__hasExternalTextures)
          le.rebindTextures(L, wt.get(L.texture).__webglTexture, wt.get(L.depthTexture).__webglTexture);
        else if (L.depthBuffer) {
          const ce = L.depthTexture;
          if (qt.__boundDepthTexture !== ce) {
            if (ce !== null && wt.has(ce) && (L.width !== ce.image.width || L.height !== ce.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            le.setupDepthRenderbuffer(L);
          }
        }
        const me = L.texture;
        (me.isData3DTexture || me.isDataArrayTexture || me.isCompressedArrayTexture) && (Ut = !0);
        const pe = wt.get(L).__webglFramebuffer;
        L.isWebGLCubeRenderTarget ? (Array.isArray(pe[W]) ? X = pe[W][et] : X = pe[W], At = !0) : L.samples > 0 && le.useMultisampledRTT(L) === !1 ? X = wt.get(L).__webglMultisampledFramebuffer : Array.isArray(pe) ? X = pe[et] : X = pe, E.copy(L.viewport), I.copy(L.scissor), B = L.scissorTest;
      } else
        E.copy(K).multiplyScalar(U).floor(), I.copy($).multiplyScalar(U).floor(), B = lt;
      if (et !== 0 && (X = xI), bt.bindFramebuffer(k.FRAMEBUFFER, X) && nt && bt.drawBuffers(L, X), bt.viewport(E), bt.scissor(I), bt.setScissorTest(B), At) {
        const qt = wt.get(L.texture);
        k.framebufferTexture2D(k.FRAMEBUFFER, k.COLOR_ATTACHMENT0, k.TEXTURE_CUBE_MAP_POSITIVE_X + W, qt.__webglTexture, et);
      } else if (Ut) {
        const qt = W;
        for (let me = 0; me < L.textures.length; me++) {
          const pe = wt.get(L.textures[me]);
          k.framebufferTextureLayer(k.FRAMEBUFFER, k.COLOR_ATTACHMENT0 + me, pe.__webglTexture, et, qt);
        }
      } else if (L !== null && et !== 0) {
        const qt = wt.get(L.texture);
        k.framebufferTexture2D(k.FRAMEBUFFER, k.COLOR_ATTACHMENT0, k.TEXTURE_2D, qt.__webglTexture, et);
      }
      b = -1;
    }, this.readRenderTargetPixels = function(L, W, et, nt, X, At, Ut, Qt = 0) {
      if (!(L && L.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let qt = wt.get(L).__webglFramebuffer;
      if (L.isWebGLCubeRenderTarget && Ut !== void 0 && (qt = qt[Ut]), qt) {
        bt.bindFramebuffer(k.FRAMEBUFFER, qt);
        try {
          const me = L.textures[Qt], pe = me.format, ce = me.type;
          if (!ut.textureFormatReadable(pe)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!ut.textureTypeReadable(ce)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          W >= 0 && W <= L.width - nt && et >= 0 && et <= L.height - X && (L.textures.length > 1 && k.readBuffer(k.COLOR_ATTACHMENT0 + Qt), k.readPixels(W, et, nt, X, oe.convert(pe), oe.convert(ce), At));
        } finally {
          const me = T !== null ? wt.get(T).__webglFramebuffer : null;
          bt.bindFramebuffer(k.FRAMEBUFFER, me);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(L, W, et, nt, X, At, Ut, Qt = 0) {
      if (!(L && L.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let qt = wt.get(L).__webglFramebuffer;
      if (L.isWebGLCubeRenderTarget && Ut !== void 0 && (qt = qt[Ut]), qt)
        if (W >= 0 && W <= L.width - nt && et >= 0 && et <= L.height - X) {
          bt.bindFramebuffer(k.FRAMEBUFFER, qt);
          const me = L.textures[Qt], pe = me.format, ce = me.type;
          if (!ut.textureFormatReadable(pe))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
          if (!ut.textureTypeReadable(ce))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
          const ze = k.createBuffer();
          k.bindBuffer(k.PIXEL_PACK_BUFFER, ze), k.bufferData(k.PIXEL_PACK_BUFFER, At.byteLength, k.STREAM_READ), L.textures.length > 1 && k.readBuffer(k.COLOR_ATTACHMENT0 + Qt), k.readPixels(W, et, nt, X, oe.convert(pe), oe.convert(ce), 0);
          const mn = T !== null ? wt.get(T).__webglFramebuffer : null;
          bt.bindFramebuffer(k.FRAMEBUFFER, mn);
          const Pn = k.fenceSync(k.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return k.flush(), await sk(k, Pn, 4), k.bindBuffer(k.PIXEL_PACK_BUFFER, ze), k.getBufferSubData(k.PIXEL_PACK_BUFFER, 0, At), k.deleteBuffer(ze), k.deleteSync(Pn), At;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
    }, this.copyFramebufferToTexture = function(L, W = null, et = 0) {
      const nt = Math.pow(2, -et), X = Math.floor(L.image.width * nt), At = Math.floor(L.image.height * nt), Ut = W !== null ? W.x : 0, Qt = W !== null ? W.y : 0;
      le.setTexture2D(L, 0), k.copyTexSubImage2D(k.TEXTURE_2D, et, 0, 0, Ut, Qt, X, At), bt.unbindTexture();
    };
    const wI = k.createFramebuffer(), SI = k.createFramebuffer();
    this.copyTextureToTexture = function(L, W, et = null, nt = null, X = 0, At = null) {
      At === null && (X !== 0 ? (cu("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), At = X, X = 0) : At = 0);
      let Ut, Qt, qt, me, pe, ce, ze, mn, Pn;
      const An = L.isCompressedTexture ? L.mipmaps[At] : L.image;
      if (et !== null)
        Ut = et.max.x - et.min.x, Qt = et.max.y - et.min.y, qt = et.isBox3 ? et.max.z - et.min.z : 1, me = et.min.x, pe = et.min.y, ce = et.isBox3 ? et.min.z : 0;
      else {
        const Qi = Math.pow(2, -X);
        Ut = Math.floor(An.width * Qi), Qt = Math.floor(An.height * Qi), L.isDataArrayTexture ? qt = An.depth : L.isData3DTexture ? qt = Math.floor(An.depth * Qi) : qt = 1, me = 0, pe = 0, ce = 0;
      }
      nt !== null ? (ze = nt.x, mn = nt.y, Pn = nt.z) : (ze = 0, mn = 0, Pn = 0);
      const _n = oe.convert(W.format), de = oe.convert(W.type);
      let In;
      W.isData3DTexture ? (le.setTexture3D(W, 0), In = k.TEXTURE_3D) : W.isDataArrayTexture || W.isCompressedArrayTexture ? (le.setTexture2DArray(W, 0), In = k.TEXTURE_2D_ARRAY) : (le.setTexture2D(W, 0), In = k.TEXTURE_2D), k.pixelStorei(k.UNPACK_FLIP_Y_WEBGL, W.flipY), k.pixelStorei(k.UNPACK_PREMULTIPLY_ALPHA_WEBGL, W.premultiplyAlpha), k.pixelStorei(k.UNPACK_ALIGNMENT, W.unpackAlignment);
      const Ye = k.getParameter(k.UNPACK_ROW_LENGTH), Li = k.getParameter(k.UNPACK_IMAGE_HEIGHT), Oa = k.getParameter(k.UNPACK_SKIP_PIXELS), Ni = k.getParameter(k.UNPACK_SKIP_ROWS), ol = k.getParameter(k.UNPACK_SKIP_IMAGES);
      k.pixelStorei(k.UNPACK_ROW_LENGTH, An.width), k.pixelStorei(k.UNPACK_IMAGE_HEIGHT, An.height), k.pixelStorei(k.UNPACK_SKIP_PIXELS, me), k.pixelStorei(k.UNPACK_SKIP_ROWS, pe), k.pixelStorei(k.UNPACK_SKIP_IMAGES, ce);
      const Bn = L.isDataArrayTexture || L.isData3DTexture, Ki = W.isDataArrayTexture || W.isData3DTexture;
      if (L.isDepthTexture) {
        const Qi = wt.get(L), pi = wt.get(W), Mi = wt.get(Qi.__renderTarget), of = wt.get(pi.__renderTarget);
        bt.bindFramebuffer(k.READ_FRAMEBUFFER, Mi.__webglFramebuffer), bt.bindFramebuffer(k.DRAW_FRAMEBUFFER, of.__webglFramebuffer);
        for (let Br = 0; Br < qt; Br++)
          Bn && (k.framebufferTextureLayer(k.READ_FRAMEBUFFER, k.COLOR_ATTACHMENT0, wt.get(L).__webglTexture, X, ce + Br), k.framebufferTextureLayer(k.DRAW_FRAMEBUFFER, k.COLOR_ATTACHMENT0, wt.get(W).__webglTexture, At, Pn + Br)), k.blitFramebuffer(me, pe, Ut, Qt, ze, mn, Ut, Qt, k.DEPTH_BUFFER_BIT, k.NEAREST);
        bt.bindFramebuffer(k.READ_FRAMEBUFFER, null), bt.bindFramebuffer(k.DRAW_FRAMEBUFFER, null);
      } else if (X !== 0 || L.isRenderTargetTexture || wt.has(L)) {
        const Qi = wt.get(L), pi = wt.get(W);
        bt.bindFramebuffer(k.READ_FRAMEBUFFER, wI), bt.bindFramebuffer(k.DRAW_FRAMEBUFFER, SI);
        for (let Mi = 0; Mi < qt; Mi++)
          Bn ? k.framebufferTextureLayer(k.READ_FRAMEBUFFER, k.COLOR_ATTACHMENT0, Qi.__webglTexture, X, ce + Mi) : k.framebufferTexture2D(k.READ_FRAMEBUFFER, k.COLOR_ATTACHMENT0, k.TEXTURE_2D, Qi.__webglTexture, X), Ki ? k.framebufferTextureLayer(k.DRAW_FRAMEBUFFER, k.COLOR_ATTACHMENT0, pi.__webglTexture, At, Pn + Mi) : k.framebufferTexture2D(k.DRAW_FRAMEBUFFER, k.COLOR_ATTACHMENT0, k.TEXTURE_2D, pi.__webglTexture, At), X !== 0 ? k.blitFramebuffer(me, pe, Ut, Qt, ze, mn, Ut, Qt, k.COLOR_BUFFER_BIT, k.NEAREST) : Ki ? k.copyTexSubImage3D(In, At, ze, mn, Pn + Mi, me, pe, Ut, Qt) : k.copyTexSubImage2D(In, At, ze, mn, me, pe, Ut, Qt);
        bt.bindFramebuffer(k.READ_FRAMEBUFFER, null), bt.bindFramebuffer(k.DRAW_FRAMEBUFFER, null);
      } else
        Ki ? L.isDataTexture || L.isData3DTexture ? k.texSubImage3D(In, At, ze, mn, Pn, Ut, Qt, qt, _n, de, An.data) : W.isCompressedArrayTexture ? k.compressedTexSubImage3D(In, At, ze, mn, Pn, Ut, Qt, qt, _n, An.data) : k.texSubImage3D(In, At, ze, mn, Pn, Ut, Qt, qt, _n, de, An) : L.isDataTexture ? k.texSubImage2D(k.TEXTURE_2D, At, ze, mn, Ut, Qt, _n, de, An.data) : L.isCompressedTexture ? k.compressedTexSubImage2D(k.TEXTURE_2D, At, ze, mn, An.width, An.height, _n, An.data) : k.texSubImage2D(k.TEXTURE_2D, At, ze, mn, Ut, Qt, _n, de, An);
      k.pixelStorei(k.UNPACK_ROW_LENGTH, Ye), k.pixelStorei(k.UNPACK_IMAGE_HEIGHT, Li), k.pixelStorei(k.UNPACK_SKIP_PIXELS, Oa), k.pixelStorei(k.UNPACK_SKIP_ROWS, Ni), k.pixelStorei(k.UNPACK_SKIP_IMAGES, ol), At === 0 && W.generateMipmaps && k.generateMipmap(In), bt.unbindTexture();
    }, this.initRenderTarget = function(L) {
      wt.get(L).__webglFramebuffer === void 0 && le.setupRenderTarget(L);
    }, this.initTexture = function(L) {
      L.isCubeTexture ? le.setTextureCube(L, 0) : L.isData3DTexture ? le.setTexture3D(L, 0) : L.isDataArrayTexture || L.isCompressedArrayTexture ? le.setTexture2DArray(L, 0) : le.setTexture2D(L, 0), bt.unbindTexture();
    }, this.resetState = function() {
      C = 0, M = 0, T = null, bt.reset(), kt.reset();
    }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Fs;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(t) {
    this._outputColorSpace = t;
    const e = this.getContext();
    e.drawingBufferColorSpace = Qe._getDrawingBufferColorSpace(t), e.unpackColorSpace = Qe._getUnpackColorSpace();
  }
};
h(Iy, "WebGLRenderer");
let J_ = Iy;
const o8 = new hn().with(ne).with(ia), r8 = new hn().with(ne).with(Bl), a8 = new hn().with(rn);
let IS = !1, K_ = !1;
function c8(n, t, e, s) {
  const o = n.world, r = t == null ? void 0 : t.canvas;
  if (!r) return;
  o._threeInitialized || (l8(o, r, e), o._threeInitialized = !0), IS || (console.log("🎨 Three.js renderer initialized"), console.log("  Canvas:", r.width, "x", r.height), console.log("  Shadows:", o._threeRenderer.shadowMap.enabled ? "Enabled (PCFSoft)" : "Disabled"), IS = !0);
  const a = o._threeRenderer, l = o._threeScene, c = o._threeMeshes, u = o._threeLights, d = n.query(o8).find((f) => ia.component.isActive[f] === 1);
  if (d === void 0) {
    console.warn("No active 3D camera found");
    return;
  }
  if (u8(o, d, r.width / r.height), h8(n, l, u), d8(n, l, c), !K_) {
    console.log("🎭 Scene loaded:", l.children.length, "children"), console.log("🔦 Lights:", u.size, "| 📦 Meshes:", c.size);
    let f = 0, p = 0;
    const v = o._threeCamera;
    console.log("📷 Camera position:", v.position.x, v.position.y, v.position.z), console.log("📷 Camera rotation:", v.rotation.x, v.rotation.y, v.rotation.z), console.log("🎭 Scene children:", l.children.length), console.log("🔦 Lights in scene:", u.size);
    for (const [_, g] of u.entries())
      console.log(`  Light ${_}: type=${g.type} intensity=${g.intensity} color=`, g.color);
    console.log("📦 Meshes in scene:", c.size);
    for (const [_, g] of c.entries())
      g.castShadow && f++, g.receiveShadow && p++;
    console.log("🌑 Shadow casting objects:", f, "| receiving:", p), K_ = !0;
  }
  a.render(l, o._threeCamera);
}
h(c8, "renderSystem3D");
function l8(n, t, e) {
  const s = new J_({
    canvas: t,
    antialias: !0,
    alpha: !1
  });
  s.setSize(t.width, t.height, !1), s.setPixelRatio(1), s.shadowMap.enabled = !0, s.shadowMap.type = R3;
  const i = new Ce(e || "#0a0a19");
  s.setClearColor(i, 1);
  const o = new Mk(), r = new si(60, t.width / t.height, 0.1, 1e3);
  r.position.set(0, 5, 10), r.lookAt(0, 0, 0), n._threeRenderer = s, n._threeScene = o, n._threeCamera = r, n._threeMeshes = /* @__PURE__ */ new Map(), n._threeLights = /* @__PURE__ */ new Map();
}
h(l8, "initializeThreeJS");
function u8(n, t, e) {
  const s = n._threeCamera;
  s.position.set(
    ne.component.x[t],
    ne.component.y[t],
    ne.component.z[t]
  );
  const i = ne.component.rotationX[t] || 0, o = ne.component.rotationY[t] || 0, r = {
    x: Math.sin(o) * Math.cos(i),
    y: -Math.sin(i),
    z: Math.cos(o) * Math.cos(i)
  }, a = {
    x: s.position.x + r.x,
    y: s.position.y + r.y,
    z: s.position.z + r.z
  };
  s.lookAt(a.x, a.y, a.z), ia.component.projectionType[t] === 0 && s instanceof si && (s.fov = nk.radToDeg(ia.component.fov[t]), s.near = ia.component.near[t], s.far = ia.component.far[t], s.aspect = e, s.updateProjectionMatrix());
}
h(u8, "syncCamera");
function h8(n, t, e) {
  var i, o, r;
  const s = n.query(a8);
  for (const a of s) {
    let l = e.get(a);
    if (!l) {
      const u = rn.lightType[a], m = new Ce(
        rn.colorR[a],
        rn.colorG[a],
        rn.colorB[a]
      ), d = rn.intensity[a];
      switch (u) {
        case 0:
          l = new Ad(m, d);
          break;
        case 1:
          l = new Ll(m, d);
          break;
        case 2:
          l = new wd(m, d);
          break;
        case 3:
          l = new xd(m, d);
          break;
        default:
          l = new Ad(m, d);
      }
      t.add(l), e.set(a, l);
    }
    l.color.setRGB(
      rn.colorR[a],
      rn.colorG[a],
      rn.colorB[a]
    ), l.intensity = rn.intensity[a];
    const c = rn.castsShadows[a] === 1;
    if (l.castShadow = c, c && l instanceof Ll && (l.shadow.mapSize.width = 2048, l.shadow.mapSize.height = 2048, l.shadow.camera.near = 0.5, l.shadow.camera.far = 100, l.shadow.camera.left = -30, l.shadow.camera.right = 30, l.shadow.camera.top = 30, l.shadow.camera.bottom = -30, l.shadow.bias = -5e-4, l.shadow.normalBias = 0.02, K_ || console.log("☀️ Shadows configured: bias=-0.0005, normalBias=0.02")), l instanceof Ll) {
      const u = ((i = rn.directionX) == null ? void 0 : i[a]) || 0, m = ((o = rn.directionY) == null ? void 0 : o[a]) || -1, d = ((r = rn.directionZ) == null ? void 0 : r[a]) || 0;
      l.position.set(10, 20, 10), l.target.position.set(u, m, d), l.target.updateMatrixWorld();
    } else (l instanceof wd || l instanceof xd) && n.doesEntityHaveComponent(a, ne) && l.position.set(
      ne.component.x[a],
      ne.component.y[a],
      ne.component.z[a]
    );
  }
}
h(h8, "syncLights");
function d8(n, t, e) {
  const s = n.query(r8);
  for (const o of s) {
    if (Bl.component.isVisible[o] !== 1) {
      const a = e.get(o);
      a && (t.remove(a), a.geometry.dispose(), a.material instanceof $o && a.material.dispose(), e.delete(o));
      continue;
    }
    let r = e.get(o);
    r || (r = m8(n, o), t.add(r), e.set(o, r)), r.position.set(
      ne.component.x[o],
      ne.component.y[o],
      ne.component.z[o]
    ), r.rotation.set(
      ne.component.rotationX[o],
      ne.component.rotationY[o],
      ne.component.rotationZ[o]
    ), r.scale.set(
      ne.component.sx[o],
      ne.component.sy[o],
      ne.component.sz[o]
    ), r.castShadow = Bl.component.castsShadows[o] === 1, r.receiveShadow = Bl.component.receivesShadows[o] === 1, _8(n, o, r);
  }
  const i = new Set(s);
  for (const [o, r] of e.entries())
    i.has(o) || (t.remove(r), r.geometry.dispose(), r.material instanceof $o && r.material.dispose(), e.delete(o));
}
h(d8, "syncModels");
function m8(n, t) {
  const e = f8(n, t), s = p8(n, t);
  return new Bi(e, s);
}
h(m8, "createThreeMesh");
function f8(n, t) {
  let e = 1;
  switch (n.doesEntityHaveComponent(t, qn) && (e = qn.primitiveType[t]), e) {
    case 1:
      return new ba(1, 1, 1);
    case 2:
      return new V_(0.5, 32, 32);
    case 3:
      return new yd(0.5, 0.5, 1, 32);
    case 4:
      return new hu(1, 1);
    case 5:
      return new D_(0.5, 1, 32);
    case 6:
      return new L_(0.4, 0.1, 16, 100);
    default:
      return new ba(1, 1, 1);
  }
}
h(f8, "createThreeGeometry");
function p8(n, t) {
  if (!n.doesEntityHaveComponent(t, ke))
    return new du({
      color: new Ce(1, 1, 1),
      roughness: 0.5,
      metalness: 0,
      side: As
    });
  const e = new Ce(
    ke.colorR[t],
    ke.colorG[t],
    ke.colorB[t]
  ), s = ke.roughness[t], i = ke.metallic[t], o = ke.alpha[t], r = new Ce(
    ke.emissiveR[t],
    ke.emissiveG[t],
    ke.emissiveB[t]
  );
  return new du({
    color: e,
    roughness: s,
    metalness: i,
    emissive: r,
    opacity: o,
    transparent: o < 1,
    side: As
  });
}
h(p8, "createThreeMaterial");
function _8(n, t, e) {
  n.doesEntityHaveComponent(t, ke) && e.material instanceof du && (e.material.color.setRGB(
    ke.colorR[t],
    ke.colorG[t],
    ke.colorB[t]
  ), e.material.roughness = ke.roughness[t], e.material.metalness = ke.metallic[t], e.material.opacity = ke.alpha[t], e.material.transparent = ke.alpha[t] < 1, e.material.emissive.setRGB(
    ke.emissiveR[t],
    ke.emissiveG[t],
    ke.emissiveB[t]
  ), e.material.needsUpdate = !0);
}
h(_8, "updateMeshMaterial");
const tI = "#000000", g8 = "transparent", Um = he({
  "@name": $t().default("Scene"),
  "@firstScene": je().optional().default(!1),
  "@backgroundColor": $t().min(1).optional().refine(
    (n) => n === void 0 || T2(n),
    { message: "Invalid CSS color" }
  )
}), eI = Um.extend({
  "@type": jo("2d"),
  "@gravity": ct().optional(),
  "@gameBoundsWidth": ct().int().positive().optional(),
  "@gameBoundsHeight": ct().int().positive().optional(),
  entity: cn([vr, We(vr)]).optional(),
  template: cn([br, We(br)]).optional()
}).transform((n) => {
  var s, i;
  const t = Ji(n.entity), e = t.some((o) => {
    var r;
    return (r = o.components) == null ? void 0 : r.some((a) => a.type === "Camera");
  });
  return {
    type: "2d",
    name: n["@name"],
    firstScene: n["@firstScene"],
    backgroundColor: (s = n["@backgroundColor"]) != null ? s : tI,
    gravity: (i = n["@gravity"]) != null ? i : 0,
    gameBoundsWidth: n["@gameBoundsWidth"],
    gameBoundsHeight: n["@gameBoundsHeight"],
    templates: Ji(n.template),
    entities: t,
    hasCamera: e
  };
}), nI = Um.extend({
  "@type": jo("ui"),
  "@suspendBehind": je().optional().default(!0),
  html: Il().optional(),
  style: Il().optional(),
  script: Il().optional()
}).transform((n) => {
  var t;
  return {
    type: "ui",
    name: n["@name"],
    firstScene: n["@firstScene"],
    backgroundColor: (t = n["@backgroundColor"]) != null ? t : g8,
    suspendBehind: n["@suspendBehind"],
    html: Pl(n.html),
    style: Pl(n.style),
    scripts: Ji(n.script).map(Pl)
  };
}), iI = Um.extend({
  "@type": jo("3d"),
  "@gravity": ct().optional(),
  entity: cn([vr, We(vr)]).optional(),
  template: cn([br, We(br)]).optional()
}).transform((n) => {
  var s, i;
  const t = Ji(n.entity), e = t.some((o) => {
    var r;
    return (r = o.components) == null ? void 0 : r.some((a) => a.type === "Camera3D");
  });
  return {
    type: "3d",
    name: n["@name"],
    firstScene: n["@firstScene"],
    backgroundColor: (s = n["@backgroundColor"]) != null ? s : tI,
    gravity: (i = n["@gravity"]) != null ? i : -9.81,
    templates: Ji(n.template),
    entities: t,
    hasCamera: e
  };
}), BS = cn([eI, iI, nI]), v8 = Um.extend({
  "@type": jo("composite"),
  scene: cn([BS, We(BS)]).optional(),
  template: cn([br, We(br)]).optional()
}).transform((n) => ({
  type: "composite",
  name: n["@name"],
  firstScene: n["@firstScene"],
  children: Ji(n.scene),
  templates: Ji(n.template)
})), PS = cn([eI, iI, nI, v8]), b8 = ls().positive().or($t()).transform((n) => {
  if (typeof n == "number") return n;
  const t = String(n).trim();
  if (t.includes("/") || t.includes(":")) {
    const [e, s] = t.split(/[/:]/);
    return Number(e) / Number(s);
  }
  return Number(t);
}).refine((n) => !isNaN(n) && n > 0, {
  message: 'Invalid aspect ratio; must be "w:h", "w/h", or a positive number'
}), y8 = he({
  game: he({
    "@name": $t().default("Untitled Game"),
    "@aspectRatio": b8,
    scene: cn([PS, We(PS)]),
    template: cn([br, We(br)]).optional(),
    style: Il().optional()
  })
}).transform(({ game: n }) => {
  var i;
  const t = Ji(n.scene), e = Ji(n.template), s = (i = t.find((o) => o.firstScene)) != null ? i : t[0];
  return {
    aspectRatio: n["@aspectRatio"],
    name: n["@name"],
    globalStyle: Pl(n.style),
    scenes: t,
    templates: e,
    firstSceneName: s ? s.name : "Root"
  };
}), RS = /* @__PURE__ */ new Set([
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight",
  " "
]), Jr = class Jr {
  static init() {
    this.initialized || (this.initialized = !0, window.addEventListener("keydown", (t) => {
      RS.has(t.key) && t.preventDefault(), this.keys.get(t.key) || this.justPressed.add(t.key), this.keys.set(t.key, !0);
    }), window.addEventListener("keyup", (t) => {
      RS.has(t.key) && t.preventDefault(), this.keys.set(t.key, !1), this.justReleased.add(t.key);
    }));
  }
  static isKeyDown(t) {
    var e;
    return this.init(), (e = this.keys.get(t)) != null ? e : !1;
  }
  static isKeyPressed(t) {
    return this.init(), this.justPressed.has(t);
  }
  static isKeyReleased(t) {
    return this.init(), this.justReleased.has(t);
  }
  static reset() {
    this.justPressed.clear(), this.justReleased.clear();
  }
};
h(Jr, "KeyboardManager"), Jr.keys = /* @__PURE__ */ new Map(), Jr.justPressed = /* @__PURE__ */ new Set(), Jr.justReleased = /* @__PURE__ */ new Set(), Jr.initialized = !1;
let Nn = Jr;
const cm = class cm {
  static register(t) {
    this.actions.set(t.name, t);
  }
  static get(t) {
    return this.actions.get(t);
  }
  static update(t, e, s, i) {
    for (const o of this.actions.values())
      o.updateWithMouseState(e, s, i, t);
  }
  static reset() {
    this.actions.clear();
  }
  static isPressed(t) {
    const e = this.actions.get(t);
    return e ? e.pressed : (console.warn(`[ActionManager] Action "${t}" not found. Did you forget to createAction()?`), !1);
  }
  static isDown(t) {
    const e = this.actions.get(t);
    return e ? e.down : (console.warn(`[ActionManager] Action "${t}" not found. Did you forget to createAction()?`), !1);
  }
  static isReleased(t) {
    const e = this.actions.get(t);
    return e ? e.released : (console.warn(`[ActionManager] Action "${t}" not found. Did you forget to createAction()?`), !1);
  }
  static getHoldDuration(t) {
    const e = this.actions.get(t);
    return e ? e.holdDuration : (console.warn(`[ActionManager] Action "${t}" not found. Did you forget to createAction()?`), 0);
  }
};
h(cm, "ActionManager"), cm.actions = /* @__PURE__ */ new Map();
let cr = cm;
const DS = 0.1, VS = 0.2, x8 = 0.01, lm = class lm {
  static attachJoystickById(t, e) {
    if (this.joysticks.has(t)) return this.joysticks.get(t);
    const s = e.querySelector(".joystick-handle");
    if (!s || !(s instanceof HTMLElement))
      return console.warn(`[VirtualJoystickManager] Joystick handle not found in element with id: ${t}`), null;
    const i = e.getBoundingClientRect(), o = Math.min(i.width, i.height) / 2, r = {
      element: e,
      handle: s,
      value: { x: 0, y: 0 },
      isActive: !1,
      listeners: [],
      baseRadius: o,
      centerX: 0,
      centerY: 0,
      springBackAnimationId: null,
      currentOffsetX: 0,
      currentOffsetY: 0
    };
    return this.joysticks.set(t, r), this.setupEventListeners(t, r), r;
  }
  static getJoystickValue(t) {
    const e = t.startsWith("#") ? t.slice(1) : t, s = this.joysticks.get(e);
    return s ? s.value : null;
  }
  static detachJoystick(t) {
    const e = this.joysticks.get(t);
    if (e) {
      e.springBackAnimationId !== null && cancelAnimationFrame(e.springBackAnimationId);
      for (const { element: s, event: i, handler: o } of e.listeners)
        s.removeEventListener(i, o);
      e.handle.style.transform = "translate(0, 0)", this.joysticks.delete(t);
    }
  }
  static setupEventListeners(t, e) {
    const s = /* @__PURE__ */ h((d, f) => {
      e.springBackAnimationId !== null && (cancelAnimationFrame(e.springBackAnimationId), e.springBackAnimationId = null);
      const p = e.element.getBoundingClientRect();
      e.centerX = p.left + p.width / 2, e.centerY = p.top + p.height / 2, e.baseRadius = Math.min(p.width, p.height) / 2, e.isActive = !0, this.updateJoystickPosition(e, d, f);
    }, "startInteraction"), i = /* @__PURE__ */ h((d, f) => {
      e.isActive && this.updateJoystickPosition(e, d, f);
    }, "moveInteraction"), o = /* @__PURE__ */ h(() => {
      e.isActive && (e.isActive = !1, this.startSpringBackAnimation(e));
    }, "endInteraction"), r = /* @__PURE__ */ h((d) => {
      const f = d;
      f.preventDefault(), s(f.clientX, f.clientY);
    }, "onMouseDown"), a = /* @__PURE__ */ h((d) => {
      const f = d;
      i(f.clientX, f.clientY);
    }, "onMouseMove"), l = /* @__PURE__ */ h(() => {
      o();
    }, "onMouseUp"), c = /* @__PURE__ */ h((d) => {
      const f = d;
      if (f.preventDefault(), f.touches.length > 0) {
        const p = f.touches[0];
        s(p.clientX, p.clientY);
      }
    }, "onTouchStart"), u = /* @__PURE__ */ h((d) => {
      const f = d;
      if (f.preventDefault(), f.touches.length > 0) {
        const p = f.touches[0];
        i(p.clientX, p.clientY);
      }
    }, "onTouchMove"), m = /* @__PURE__ */ h((d) => {
      d.preventDefault(), o();
    }, "onTouchEnd");
    e.handle.addEventListener("mousedown", r), document.addEventListener("mousemove", a), document.addEventListener("mouseup", l), e.handle.addEventListener("touchstart", c), document.addEventListener("touchmove", u, { passive: !1 }), document.addEventListener("touchend", m), document.addEventListener("touchcancel", m), e.listeners.push(
      { element: e.handle, event: "mousedown", handler: r },
      { element: document, event: "mousemove", handler: a },
      { element: document, event: "mouseup", handler: l },
      { element: e.handle, event: "touchstart", handler: c },
      { element: document, event: "touchmove", handler: u },
      { element: document, event: "touchend", handler: m },
      { element: document, event: "touchcancel", handler: m }
    );
  }
  static updateJoystickPosition(t, e, s) {
    let i = e - t.centerX, o = s - t.centerY;
    const r = Math.sqrt(i * i + o * o);
    if (r > t.baseRadius) {
      const u = t.baseRadius / r;
      i *= u, o *= u;
    }
    t.currentOffsetX = i, t.currentOffsetY = o, t.handle.style.transform = `translate(${i}px, ${o}px)`;
    const a = i / t.baseRadius, l = -o / t.baseRadius, c = Math.sqrt(a * a + l * l);
    t.value = c > DS ? { x: a, y: l } : { x: 0, y: 0 };
  }
  static startSpringBackAnimation(t) {
    const e = /* @__PURE__ */ h(() => {
      if (t.currentOffsetX += (0 - t.currentOffsetX) * VS, t.currentOffsetY += (0 - t.currentOffsetY) * VS, Math.sqrt(
        t.currentOffsetX * t.currentOffsetX + t.currentOffsetY * t.currentOffsetY
      ) < x8) {
        t.currentOffsetX = 0, t.currentOffsetY = 0, t.handle.style.transform = "translate(0px, 0px)", t.value = { x: 0, y: 0 }, t.springBackAnimationId = null;
        return;
      }
      t.handle.style.transform = `translate(${t.currentOffsetX}px, ${t.currentOffsetY}px)`;
      const i = t.currentOffsetX / t.baseRadius, o = -t.currentOffsetY / t.baseRadius;
      Math.sqrt(i * i + o * o) < DS ? t.value = { x: 0, y: 0 } : t.value = { x: i, y: o }, t.springBackAnimationId = requestAnimationFrame(e);
    }, "animate");
    t.springBackAnimationId = requestAnimationFrame(e);
  }
  static cleanup() {
    for (const t of this.joysticks.keys())
      this.detachJoystick(t);
  }
};
h(lm, "VirtualJoystickManager"), lm.joysticks = /* @__PURE__ */ new Map();
let jc = lm;
const Kr = class Kr {
  static attachDPad(t, e) {
    if (this.dpads.has(t)) return;
    const s = /* @__PURE__ */ h((c) => e.querySelector(c), "$"), i = s(".dpad-up"), o = s(".dpad-down"), r = s(".dpad-left"), a = s(".dpad-right");
    if (!i || !o || !r || !a)
      return console.warn(`[VirtualDPadManager] D-pad missing required child buttons: ${t}`);
    const l = {
      element: e,
      upButton: i,
      downButton: o,
      leftButton: r,
      rightButton: a,
      isActive: !1,
      listeners: [],
      centerX: 0,
      centerY: 0,
      radius: 0
    };
    this.dpads.set(t, l), this.setupEventListeners(t, l), this.syntheticButtons.set(`${t} .dpad-up`, { down: !1, justPressed: !1, justReleased: !1 }), this.syntheticButtons.set(`${t} .dpad-down`, { down: !1, justPressed: !1, justReleased: !1 }), this.syntheticButtons.set(`${t} .dpad-left`, { down: !1, justPressed: !1, justReleased: !1 }), this.syntheticButtons.set(`${t} .dpad-right`, { down: !1, justPressed: !1, justReleased: !1 });
  }
  static detachDPad(t) {
    const e = this.dpads.get(t);
    if (e) {
      for (const { element: s, event: i, handler: o } of e.listeners)
        s.removeEventListener(i, o);
      this.syntheticButtons.delete(`${t} .dpad-up`), this.syntheticButtons.delete(`${t} .dpad-down`), this.syntheticButtons.delete(`${t} .dpad-left`), this.syntheticButtons.delete(`${t} .dpad-right`), e.upButton.classList.remove("active"), e.downButton.classList.remove("active"), e.leftButton.classList.remove("active"), e.rightButton.classList.remove("active"), this.dpads.delete(t);
    }
  }
  static getSyntheticButtonState(t) {
    var e, s;
    return (s = (e = this.syntheticButtons.get(t)) == null ? void 0 : e.down) != null ? s : !1;
  }
  static getSyntheticButtonPressed(t) {
    var e, s;
    return (s = (e = this.syntheticButtons.get(t)) == null ? void 0 : e.justPressed) != null ? s : !1;
  }
  static getSyntheticButtonReleased(t) {
    var e, s;
    return (s = (e = this.syntheticButtons.get(t)) == null ? void 0 : e.justReleased) != null ? s : !1;
  }
  static update() {
    for (const t of this.syntheticButtons.values())
      t.justPressed = !1, t.justReleased = !1;
  }
  static cleanup() {
    for (const t of Array.from(this.dpads.keys()))
      this.detachDPad(t);
  }
  static setupEventListeners(t, e) {
    const s = /* @__PURE__ */ h((d, f) => {
      const p = e.element.getBoundingClientRect();
      e.centerX = p.left + p.width / 2, e.centerY = p.top + p.height / 2, e.radius = Math.min(p.width, p.height) / 2, e.isActive = !0, this.updateDPadPosition(t, e, d, f);
    }, "startInteraction"), i = /* @__PURE__ */ h((d, f) => {
      e.isActive && this.updateDPadPosition(t, e, d, f);
    }, "moveInteraction"), o = /* @__PURE__ */ h(() => {
      e.isActive && (e.isActive = !1, this.updateSyntheticButton(`${t} .dpad-up`, !1), this.updateSyntheticButton(`${t} .dpad-down`, !1), this.updateSyntheticButton(`${t} .dpad-left`, !1), this.updateSyntheticButton(`${t} .dpad-right`, !1), e.upButton.classList.remove("active"), e.downButton.classList.remove("active"), e.leftButton.classList.remove("active"), e.rightButton.classList.remove("active"));
    }, "endInteraction"), r = /* @__PURE__ */ h((d) => {
      const f = d;
      f.preventDefault(), s(f.clientX, f.clientY);
    }, "onMouseDown"), a = /* @__PURE__ */ h((d) => {
      const f = d;
      i(f.clientX, f.clientY);
    }, "onMouseMove"), l = /* @__PURE__ */ h(() => {
      o();
    }, "onMouseUp"), c = /* @__PURE__ */ h((d) => {
      const f = d;
      if (f.preventDefault(), f.touches.length > 0) {
        const p = f.touches[0];
        s(p.clientX, p.clientY);
      }
    }, "onTouchStart"), u = /* @__PURE__ */ h((d) => {
      const f = d;
      if (f.preventDefault(), f.touches.length > 0) {
        const p = f.touches[0];
        i(p.clientX, p.clientY);
      }
    }, "onTouchMove"), m = /* @__PURE__ */ h((d) => {
      d.preventDefault(), o();
    }, "onTouchEnd");
    e.element.addEventListener("mousedown", r), document.addEventListener("mousemove", a), document.addEventListener("mouseup", l), e.element.addEventListener("touchstart", c), document.addEventListener("touchmove", u, { passive: !1 }), document.addEventListener("touchend", m), document.addEventListener("touchcancel", m), e.listeners.push(
      { element: e.element, event: "mousedown", handler: r },
      { element: document, event: "mousemove", handler: a },
      { element: document, event: "mouseup", handler: l },
      { element: e.element, event: "touchstart", handler: c },
      { element: document, event: "touchmove", handler: u },
      { element: document, event: "touchend", handler: m },
      { element: document, event: "touchcancel", handler: m }
    );
  }
  static updateDPadPosition(t, e, s, i) {
    const o = s - e.centerX, r = i - e.centerY;
    if (Math.sqrt(o * o + r * r) / e.radius < this.DEAD_ZONE) {
      this.updateSyntheticButton(`${t} .dpad-up`, !1), this.updateSyntheticButton(`${t} .dpad-down`, !1), this.updateSyntheticButton(`${t} .dpad-left`, !1), this.updateSyntheticButton(`${t} .dpad-right`, !1), e.upButton.classList.remove("active"), e.downButton.classList.remove("active"), e.leftButton.classList.remove("active"), e.rightButton.classList.remove("active");
      return;
    }
    const c = Math.atan2(-r, o), u = this.isInAngleRange(c, Math.PI / 2, this.DIAGONAL_ANGLE), m = this.isInAngleRange(c, -Math.PI / 2, this.DIAGONAL_ANGLE), d = this.isInAngleRange(c, Math.PI, this.DIAGONAL_ANGLE), f = this.isInAngleRange(c, 0, this.DIAGONAL_ANGLE);
    this.updateSyntheticButton(`${t} .dpad-up`, u), this.updateSyntheticButton(`${t} .dpad-down`, m), this.updateSyntheticButton(`${t} .dpad-left`, d), this.updateSyntheticButton(`${t} .dpad-right`, f), e.upButton.classList.toggle("active", u), e.downButton.classList.toggle("active", m), e.leftButton.classList.toggle("active", d), e.rightButton.classList.toggle("active", f);
  }
  static isInAngleRange(t, e, s) {
    const i = Math.atan2(Math.sin(t), Math.cos(t)), o = Math.atan2(Math.sin(e), Math.cos(e));
    let r = Math.abs(i - o);
    return r > Math.PI && (r = 2 * Math.PI - r), r <= s;
  }
  static updateSyntheticButton(t, e) {
    const s = this.syntheticButtons.get(t);
    if (!s) return;
    const i = s.down;
    s.down = e, e && !i && (s.justPressed = !0), !e && i && (s.justReleased = !0);
  }
};
h(Kr, "VirtualDPadManager"), Kr.dpads = /* @__PURE__ */ new Map(), Kr.syntheticButtons = /* @__PURE__ */ new Map(), Kr.DEAD_ZONE = 0.2, Kr.DIAGONAL_ANGLE = Math.PI / 8;
let No = Kr;
const um = class um {
  static attachButton(t, e) {
    if (this.buttons.has(t)) return;
    const s = {
      element: e,
      down: !1,
      justPressed: !1,
      justReleased: !1,
      listeners: []
    };
    this.buttons.set(t, s), this.setupEventListeners(t, s);
  }
  static detachButton(t) {
    const e = this.buttons.get(t);
    if (e) {
      for (const { element: s, event: i, handler: o } of e.listeners)
        s.removeEventListener(i, o);
      this.buttons.delete(t);
    }
  }
  static isDown(t) {
    const e = this.buttons.get(t);
    return e != null && e.down ? !0 : No.getSyntheticButtonState(t);
  }
  static isPressed(t) {
    const e = this.buttons.get(t);
    return e != null && e.justPressed ? !0 : No.getSyntheticButtonPressed(t);
  }
  static isReleased(t) {
    const e = this.buttons.get(t);
    return e != null && e.justReleased ? !0 : No.getSyntheticButtonReleased(t);
  }
  static update() {
    for (const t of this.buttons.values())
      t.justPressed = !1, t.justReleased = !1;
  }
  static cleanup() {
    const t = Array.from(this.buttons.keys());
    for (const e of t)
      this.detachButton(e);
  }
  static setupEventListeners(t, e) {
    const s = /* @__PURE__ */ h((c) => {
      c.preventDefault(), e.down || (e.down = !0, e.justPressed = !0, e.element.classList.add("active"));
    }, "onStart"), i = /* @__PURE__ */ h((c) => {
      c.preventDefault(), e.down && (e.down = !1, e.justReleased = !0, e.element.classList.remove("active"));
    }, "onEnd"), o = /* @__PURE__ */ h((c) => s(c), "onMouseDown"), r = /* @__PURE__ */ h((c) => i(c), "onMouseUp"), a = /* @__PURE__ */ h((c) => s(c), "onTouchStart"), l = /* @__PURE__ */ h((c) => i(c), "onTouchEnd");
    e.element.addEventListener("mousedown", o), e.element.addEventListener("mouseup", r), e.element.addEventListener("mouseleave", r), e.element.addEventListener("touchstart", a), e.element.addEventListener("touchend", l), e.element.addEventListener("touchcancel", l), e.listeners.push(
      { element: e.element, event: "mousedown", handler: o },
      { element: e.element, event: "mouseup", handler: r },
      { element: e.element, event: "mouseleave", handler: r },
      { element: e.element, event: "touchstart", handler: a },
      { element: e.element, event: "touchend", handler: l },
      { element: e.element, event: "touchcancel", handler: l }
    );
  }
};
h(um, "VirtualButtonManager"), um.buttons = /* @__PURE__ */ new Map();
let Xi = um;
const Q_ = /* @__PURE__ */ h((n, t, e) => n + (t - n) * e, "lerp");
function sI(n, t) {
  return {
    name: n.name,
    components: n.components.map((e) => w8(e, t)),
    children: n.children.map((e) => sI(e, t))
  };
}
h(sI, "applyTemplateParams");
function w8(n, t) {
  const e = {};
  for (const [s, i] of Object.entries(n.attributes))
    e[s] = S8(i, t);
  return {
    type: n.type,
    attributes: e
  };
}
h(w8, "applyParamsToComponent");
function S8(n, t) {
  return typeof n == "string" ? n.replace(/\{(\w+)\}/g, (e, s) => s in t ? String(t[s]) : (console.warn(`Template parameter {${s}} not provided, leaving as-is`), e)) : n;
}
h(S8, "substituteValue");
const By = class By {
  constructor(t, e, s, i, o) {
    this.tweenData = {}, this._delay = 0, this._autoStart = !0, this.scene = t, this.eid = e, this.tweenData = {
      target: s,
      to: i,
      duration: o / 1e3,
      loop: !1,
      yoyo: !1,
      easing: Op("linear")
    };
  }
  from(t) {
    return this.tweenData.from = t, this;
  }
  easing(t) {
    return this.tweenData.easing = Op(t), this;
  }
  delay(t) {
    return this._delay = t / 1e3, this;
  }
  loop(t = !0) {
    return this.tweenData.loop = t, this;
  }
  yoyo(t = !0) {
    return this.tweenData.yoyo = t, t && (this.tweenData.loop = !0), this;
  }
  onComplete(t) {
    return this.tweenData.onComplete = t, this;
  }
  onUpdate(t) {
    return this.tweenData.onUpdate = t, this;
  }
  noAutoStart() {
    return this._autoStart = !1, this;
  }
  build() {
    this.tweenData.from === void 0 && (this.tweenData.from = A8(this.eid, this.tweenData.target));
    const t = {
      target: this.tweenData.target,
      from: this.tweenData.from,
      to: this.tweenData.to,
      duration: this.tweenData.duration,
      delay: this._delay,
      easing: this.tweenData.easing,
      loop: this.tweenData.loop,
      yoyo: this.tweenData.yoyo,
      onUpdate: this.tweenData.onUpdate,
      onComplete: this.tweenData.onComplete
    }, e = this.scene.tweenRegistry.length;
    this.scene.tweenRegistry.push(t), Zi(this.scene.world, Be, this.eid) || wn(this.scene.world, Be, this.eid), Be.component.tweenId[this.eid] = e, Be.component.isActive[this.eid] = this._autoStart ? 1 : 0, Be.component.elapsed[this.eid] = 0, Be.component.duration[this.eid] = t.duration, Be.component.delay[this.eid] = t.delay, Be.component.delayElapsed[this.eid] = 0;
  }
};
h(By, "TweenBuilder");
let t0 = By;
function uj(n, t, e, s, i) {
  return new t0(n, t, e, s, i);
}
h(uj, "tween");
function A8(n, t) {
  var o, r, a, l;
  const e = t.split(".");
  if (e.length !== 2) return 0;
  const [s, i] = e;
  switch (s) {
    case "Transform":
      return (r = (o = ue[i]) == null ? void 0 : o[n]) != null ? r : 0;
    case "Sprite":
      return (l = (a = ht[i]) == null ? void 0 : a[n]) != null ? l : 0;
    default:
      return 0;
  }
}
h(A8, "getCurrentValue");
const M8 = new hn().with(D2).with(ue);
function C8(n, t) {
  const e = M8._compile().base(n), s = t / 1e3;
  for (const i of e) {
    const r = D2.component.speed[i] * s;
    let a = 0, l = 0;
    if ((Nn.isKeyDown("w") || Nn.isKeyDown("ArrowUp")) && (l += r), (Nn.isKeyDown("s") || Nn.isKeyDown("ArrowDown")) && (l -= r), (Nn.isKeyDown("a") || Nn.isKeyDown("ArrowLeft")) && (a -= r), (Nn.isKeyDown("d") || Nn.isKeyDown("ArrowRight")) && (a += r), a !== 0 || l !== 0) {
      const c = ue.read(i);
      ue.assign(i, { x: c.x + a, y: c.y + l });
    }
  }
}
h(C8, "playerControllerSystem");
const E8 = new hn().with(zs);
function T8(n, t) {
  const e = n.query(E8), s = t / 1e3;
  for (const i of e)
    (zs.component.isInvulnerable[i] | 0) === 1 && (zs.component.invulnerableTimer[i] -= s, zs.component.invulnerableTimer[i] <= 0 && (zs.component.isInvulnerable[i] = 0, zs.component.invulnerableTimer[i] = 0)), zs.component.current[i] <= 0 && !(zs.component.isDead[i] | 0) && (zs.component.isDead[i] = 1);
}
h(T8, "healthSystem");
const Py = class Py {
  constructor() {
    this.nextBodyId = 1;
  }
};
h(Py, "PhysicsEngine2D");
let e0 = Py;
var Ch = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function za(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
h(za, "getDefaultExportFromCjs");
var $i = {}, Xe = {}, ps = {}, W2 = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.configure = n.settings = void 0;
  const t = {
    lengthUnitsPerMeter: 1,
    maxPolygonVertices: 8
  };
  n.settings = { ...t };
  function e(s) {
    Object.assign(n.settings, t, s);
  }
  h(e, "configure"), n.configure = e;
})(W2);
za(W2);
Object.defineProperty(ps, "__esModule", { value: !0 });
ps.b2_maxPolygonVertices = ps.b2_lengthUnitsPerMeter = void 0;
const oI = W2;
ps.b2_lengthUnitsPerMeter = oI.settings.lengthUnitsPerMeter;
ps.b2_maxPolygonVertices = oI.settings.maxPolygonVertices;
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.b2MakeArray = n.b2MakeBooleanArray = n.b2MakeNumberArray = n.b2_version = n.b2_angularSleepTolerance = n.b2_linearSleepTolerance = n.b2_timeToSleep = n.b2_toiBaumgarte = n.b2_baumgarte = n.b2_maxRotationSquared = n.b2_maxRotation = n.b2_maxTranslationSquared = n.b2_maxTranslation = n.b2_maxAngularCorrection = n.b2_maxLinearCorrection = n.b2_maxTOIContacts = n.b2_maxSubSteps = n.b2_polygonRadius = n.b2_angularSlop = n.b2_linearSlop = n.b2_aabbMultiplier = n.b2_aabbExtension = n.b2_maxManifoldPoints = n.b2_epsilon_sq = n.b2_epsilon = n.b2_maxFloat = n.b2Verify = n.b2Assert = void 0;
  const t = ps;
  function e(a, l) {
    if (!a)
      throw new Error(l);
  }
  h(e, "b2Assert"), n.b2Assert = e;
  function s(a) {
    if (a === null)
      throw new Error();
    return a;
  }
  h(s, "b2Verify"), n.b2Verify = s, n.b2_maxFloat = 1e37, n.b2_epsilon = 1e-5, n.b2_epsilon_sq = n.b2_epsilon * n.b2_epsilon, n.b2_maxManifoldPoints = 2, n.b2_aabbExtension = 0.1 * t.b2_lengthUnitsPerMeter, n.b2_aabbMultiplier = 4, n.b2_linearSlop = 5e-3 * t.b2_lengthUnitsPerMeter, n.b2_angularSlop = 2 / 180 * Math.PI, n.b2_polygonRadius = 2 * n.b2_linearSlop, n.b2_maxSubSteps = 8, n.b2_maxTOIContacts = 32, n.b2_maxLinearCorrection = 0.2 * t.b2_lengthUnitsPerMeter, n.b2_maxAngularCorrection = 8 / 180 * Math.PI, n.b2_maxTranslation = 2 * t.b2_lengthUnitsPerMeter, n.b2_maxTranslationSquared = n.b2_maxTranslation * n.b2_maxTranslation, n.b2_maxRotation = 0.5 * Math.PI, n.b2_maxRotationSquared = n.b2_maxRotation * n.b2_maxRotation, n.b2_baumgarte = 0.2, n.b2_toiBaumgarte = 0.75, n.b2_timeToSleep = 0.5, n.b2_linearSleepTolerance = 0.01 * t.b2_lengthUnitsPerMeter, n.b2_angularSleepTolerance = 2 / 180 * Math.PI, n.b2_version = {
    major: 2,
    minor: 4,
    patch: 1
  };
  function i(a, l = 0) {
    const c = new Array(a);
    for (let u = 0; u < a; u++)
      c[u] = l;
    return c;
  }
  h(i, "b2MakeNumberArray"), n.b2MakeNumberArray = i;
  function o(a, l = !1) {
    const c = new Array(a);
    for (let u = 0; u < a; u++)
      c[u] = l;
    return c;
  }
  h(o, "b2MakeBooleanArray"), n.b2MakeBooleanArray = o;
  function r(a, l) {
    const c = new Array(a);
    for (let u = 0; u < a; u++)
      c[u] = new l();
    return c;
  }
  h(r, "b2MakeArray"), n.b2MakeArray = r;
})(Xe);
za(Xe);
var Fe = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.b2Sweep = n.b2Transform = n.b2Rot = n.b2Mat33 = n.b2Mat22 = n.b2Vec3 = n.b2Vec2 = n.b2RandomInt = n.b2RandomFloat = n.b2Random = n.b2IsPowerOfTwo = n.b2NextPowerOfTwo = n.b2RadToDeg = n.b2DegToRad = n.b2Clamp = n.b2_two_pi = n.b2_180_over_pi = n.b2_pi_over_180 = void 0;
  const t = Xe;
  n.b2_pi_over_180 = Math.PI / 180, n.b2_180_over_pi = 180 / Math.PI, n.b2_two_pi = 2 * Math.PI;
  function e(T, b, y) {
    return T < b ? b : T > y ? y : T;
  }
  h(e, "b2Clamp"), n.b2Clamp = e;
  function s(T) {
    return T * n.b2_pi_over_180;
  }
  h(s, "b2DegToRad"), n.b2DegToRad = s;
  function i(T) {
    return T * n.b2_180_over_pi;
  }
  h(i, "b2RadToDeg"), n.b2RadToDeg = i;
  function o(T) {
    return T |= T >> 1, T |= T >> 2, T |= T >> 4, T |= T >> 8, T |= T >> 16, T + 1;
  }
  h(o, "b2NextPowerOfTwo"), n.b2NextPowerOfTwo = o;
  function r(T) {
    return T > 0 && (T & T - 1) === 0;
  }
  h(r, "b2IsPowerOfTwo"), n.b2IsPowerOfTwo = r;
  function a() {
    return Math.random() * 2 - 1;
  }
  h(a, "b2Random"), n.b2Random = a;
  function l(T, b) {
    return (b - T) * Math.random() + T;
  }
  h(l, "b2RandomFloat"), n.b2RandomFloat = l;
  function c(T, b) {
    return Math.round((b - T) * Math.random() + T);
  }
  h(c, "b2RandomInt"), n.b2RandomInt = c;
  const g = class g {
    constructor(b = 0, y = 0) {
      this.x = b, this.y = y;
    }
    Clone() {
      return new g(this.x, this.y);
    }
    SetZero() {
      return this.x = 0, this.y = 0, this;
    }
    Set(b, y) {
      return this.x = b, this.y = y, this;
    }
    Copy(b) {
      return this.x = b.x, this.y = b.y, this;
    }
    Add(b) {
      return this.x += b.x, this.y += b.y, this;
    }
    AddXY(b, y) {
      return this.x += b, this.y += y, this;
    }
    Subtract(b) {
      return this.x -= b.x, this.y -= b.y, this;
    }
    SubtractXY(b, y) {
      return this.x -= b, this.y -= y, this;
    }
    Scale(b) {
      return this.x *= b, this.y *= b, this;
    }
    AddScaled(b, y) {
      return this.x += b * y.x, this.y += b * y.y, this;
    }
    SubtractScaled(b, y) {
      return this.x -= b * y.x, this.y -= b * y.y, this;
    }
    Dot(b) {
      return this.x * b.x + this.y * b.y;
    }
    Cross(b) {
      return this.x * b.y - this.y * b.x;
    }
    Length() {
      const { x: b, y } = this;
      return Math.sqrt(b * b + y * y);
    }
    LengthSquared() {
      const { x: b, y } = this;
      return b * b + y * y;
    }
    Normalize() {
      const b = this.Length();
      if (b < t.b2_epsilon)
        return 0;
      const y = 1 / b;
      return this.x *= y, this.y *= y, b;
    }
    Rotate(b) {
      const y = Math.cos(b), E = Math.sin(b), { x: I } = this;
      return this.x = y * I - E * this.y, this.y = E * I + y * this.y, this;
    }
    RotateCosSin(b, y) {
      const { x: E } = this;
      return this.x = b * E - y * this.y, this.y = y * E + b * this.y, this;
    }
    IsValid() {
      return Number.isFinite(this.x) && Number.isFinite(this.y);
    }
    Abs() {
      return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
    }
    GetAbs(b) {
      return b.x = Math.abs(this.x), b.y = Math.abs(this.y), b;
    }
    Negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    Skew() {
      const { x: b } = this;
      return this.x = -this.y, this.y = b, this;
    }
    static Min(b, y, E) {
      return E.x = Math.min(b.x, y.x), E.y = Math.min(b.y, y.y), E;
    }
    static Max(b, y, E) {
      return E.x = Math.max(b.x, y.x), E.y = Math.max(b.y, y.y), E;
    }
    static Clamp(b, y, E, I) {
      return I.x = e(b.x, y.x, E.x), I.y = e(b.y, y.y, E.y), I;
    }
    static Rotate(b, y, E) {
      const I = b.x, B = b.y, D = Math.cos(y), N = Math.sin(y);
      return E.x = D * I - N * B, E.y = N * I + D * B, E;
    }
    static Dot(b, y) {
      return b.x * y.x + b.y * y.y;
    }
    static Cross(b, y) {
      return b.x * y.y - b.y * y.x;
    }
    static CrossVec2Scalar(b, y, E) {
      const I = b.x;
      return E.x = y * b.y, E.y = -y * I, E;
    }
    static CrossVec2One(b, y) {
      const E = b.x;
      return y.x = b.y, y.y = -E, y;
    }
    static CrossScalarVec2(b, y, E) {
      const I = y.x;
      return E.x = -b * y.y, E.y = b * I, E;
    }
    static CrossOneVec2(b, y) {
      const E = b.x;
      return y.x = -b.y, y.y = E, y;
    }
    static Add(b, y, E) {
      return E.x = b.x + y.x, E.y = b.y + y.y, E;
    }
    static Subtract(b, y, E) {
      return E.x = b.x - y.x, E.y = b.y - y.y, E;
    }
    static Scale(b, y, E) {
      return E.x = y.x * b, E.y = y.y * b, E;
    }
    static AddScaled(b, y, E, I) {
      return I.x = b.x + y * E.x, I.y = b.y + y * E.y, I;
    }
    static SubtractScaled(b, y, E, I) {
      return I.x = b.x - y * E.x, I.y = b.y - y * E.y, I;
    }
    static AddCrossScalarVec2(b, y, E, I) {
      const B = E.x;
      return I.x = b.x - y * E.y, I.y = b.y + y * B, I;
    }
    static Mid(b, y, E) {
      return E.x = (b.x + y.x) * 0.5, E.y = (b.y + y.y) * 0.5, E;
    }
    static Extents(b, y, E) {
      return E.x = (y.x - b.x) * 0.5, E.y = (y.y - b.y) * 0.5, E;
    }
    static Equals(b, y) {
      return b.x === y.x && b.y === y.y;
    }
    static Distance(b, y) {
      return Math.sqrt((b.x - y.x) ** 2 + (b.y - y.y) ** 2);
    }
    static DistanceSquared(b, y) {
      return (b.x - y.x) ** 2 + (b.y - y.y) ** 2;
    }
    static Negate(b, y) {
      return y.x = -b.x, y.y = -b.y, y;
    }
    static Normalize(b, y) {
      const E = b.x ** 2 + b.y ** 2;
      if (E >= t.b2_epsilon_sq) {
        const I = 1 / Math.sqrt(E);
        y.x = I * b.x, y.y = I * b.y;
      } else
        y.x = 0, y.y = 0;
      return y;
    }
    static Skew(b, y) {
      const { x: E } = b;
      return y.x = -b.y, y.y = E, y;
    }
  };
  h(g, "b2Vec2");
  let u = g;
  n.b2Vec2 = u, u.ZERO = new u(), u.UNITX = new u(1, 0), u.UNITY = new u(0, 1), u.s_t0 = new u(), u.s_t1 = new u(), u.s_t2 = new u(), u.s_t3 = new u();
  const w = class w {
    constructor(b = 0, y = 0, E = 0) {
      this.x = b, this.y = y, this.z = E;
    }
    Clone() {
      return new w(this.x, this.y, this.z);
    }
    SetZero() {
      return this.x = 0, this.y = 0, this.z = 0, this;
    }
    Set(b, y, E) {
      return this.x = b, this.y = y, this.z = E, this;
    }
    Copy(b) {
      return this.x = b.x, this.y = b.y, this.z = b.z, this;
    }
    Negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    Add(b) {
      return this.x += b.x, this.y += b.y, this.z += b.z, this;
    }
    AddXYZ(b, y, E) {
      return this.x += b, this.y += y, this.z += E, this;
    }
    Subtract(b) {
      return this.x -= b.x, this.y -= b.y, this.z -= b.z, this;
    }
    SubtractXYZ(b, y, E) {
      return this.x -= b, this.y -= y, this.z -= E, this;
    }
    Scale(b) {
      return this.x *= b, this.y *= b, this.z *= b, this;
    }
    static Dot(b, y) {
      return b.x * y.x + b.y * y.y + b.z * y.z;
    }
    static Cross(b, y, E) {
      const I = b.x, B = b.y, D = b.z, N = y.x, V = y.y, G = y.z;
      return E.x = B * G - D * V, E.y = D * N - I * G, E.z = I * V - B * N, E;
    }
  };
  h(w, "b2Vec3");
  let m = w;
  n.b2Vec3 = m, m.ZERO = new m(0, 0, 0), m.s_t0 = new m();
  const S = class S {
    constructor() {
      this.ex = new u(1, 0), this.ey = new u(0, 1);
    }
    Clone() {
      return new S().Copy(this);
    }
    static FromColumns(b, y) {
      return new S().SetColumns(b, y);
    }
    static FromScalars(b, y, E, I) {
      return new S().SetScalars(b, y, E, I);
    }
    static FromAngle(b) {
      return new S().SetAngle(b);
    }
    SetScalars(b, y, E, I) {
      return this.ex.Set(b, E), this.ey.Set(y, I), this;
    }
    SetColumns(b, y) {
      return this.ex.Copy(b), this.ey.Copy(y), this;
    }
    SetAngle(b) {
      const y = Math.cos(b), E = Math.sin(b);
      return this.ex.Set(y, E), this.ey.Set(-E, y), this;
    }
    Copy(b) {
      return this.ex.Copy(b.ex), this.ey.Copy(b.ey), this;
    }
    SetIdentity() {
      return this.ex.Set(1, 0), this.ey.Set(0, 1), this;
    }
    SetZero() {
      return this.ex.SetZero(), this.ey.SetZero(), this;
    }
    GetAngle() {
      return Math.atan2(this.ex.y, this.ex.x);
    }
    Solve(b, y, E) {
      const I = this.ex.x, B = this.ey.x, D = this.ex.y, N = this.ey.y;
      let V = I * N - B * D;
      return V !== 0 && (V = 1 / V), E.x = V * (N * b - B * y), E.y = V * (I * y - D * b), E;
    }
    Abs() {
      return this.ex.Abs(), this.ey.Abs(), this;
    }
    Inverse() {
      return this.GetInverse(this), this;
    }
    Add(b) {
      return this.ex.Add(b.ex), this.ey.Add(b.ey), this;
    }
    Subtract(b) {
      return this.ex.Subtract(b.ex), this.ey.Subtract(b.ey), this;
    }
    GetInverse(b) {
      const y = this.ex.x, E = this.ey.x, I = this.ex.y, B = this.ey.y;
      let D = y * B - E * I;
      return D !== 0 && (D = 1 / D), b.ex.x = D * B, b.ey.x = -D * E, b.ex.y = -D * I, b.ey.y = D * y, b;
    }
    GetAbs(b) {
      return b.ex.x = Math.abs(this.ex.x), b.ex.y = Math.abs(this.ex.y), b.ey.x = Math.abs(this.ey.x), b.ey.y = Math.abs(this.ey.y), b;
    }
    static MultiplyVec2(b, y, E) {
      const I = y.x, B = y.y;
      return E.x = b.ex.x * I + b.ey.x * B, E.y = b.ex.y * I + b.ey.y * B, E;
    }
    static TransposeMultiplyVec2(b, y, E) {
      const I = y.x, B = y.y;
      return E.x = b.ex.x * I + b.ex.y * B, E.y = b.ey.x * I + b.ey.y * B, E;
    }
    static Add(b, y, E) {
      return E.ex.x = b.ex.x + y.ex.x, E.ex.y = b.ex.y + y.ex.y, E.ey.x = b.ey.x + y.ey.x, E.ey.y = b.ey.y + y.ey.y, E;
    }
    static Multiply(b, y, E) {
      const I = b.ex.x, B = b.ex.y, D = b.ey.x, N = b.ey.y, V = y.ex.x, G = y.ex.y, U = y.ey.x, j = y.ey.y;
      return E.ex.x = I * V + D * G, E.ex.y = B * V + N * G, E.ey.x = I * U + D * j, E.ey.y = B * U + N * j, E;
    }
    static TransposeMultiply(b, y, E) {
      const I = b.ex.x, B = b.ex.y, D = b.ey.x, N = b.ey.y, V = y.ex.x, G = y.ex.y, U = y.ey.x, j = y.ey.y;
      return E.ex.x = I * V + B * G, E.ex.y = D * V + N * G, E.ey.x = I * U + B * j, E.ey.y = D * U + N * j, E;
    }
  };
  h(S, "b2Mat22");
  let d = S;
  n.b2Mat22 = d, d.IDENTITY = new d();
  const x = class x {
    constructor() {
      this.ex = new m(1, 0, 0), this.ey = new m(0, 1, 0), this.ez = new m(0, 0, 1);
    }
    Clone() {
      return new x().Copy(this);
    }
    SetColumns(b, y, E) {
      return this.ex.Copy(b), this.ey.Copy(y), this.ez.Copy(E), this;
    }
    Copy(b) {
      return this.ex.Copy(b.ex), this.ey.Copy(b.ey), this.ez.Copy(b.ez), this;
    }
    SetIdentity() {
      return this.ex.Set(1, 0, 0), this.ey.Set(0, 1, 0), this.ez.Set(0, 0, 1), this;
    }
    SetZero() {
      return this.ex.SetZero(), this.ey.SetZero(), this.ez.SetZero(), this;
    }
    Add(b) {
      return this.ex.Add(b.ex), this.ey.Add(b.ey), this.ez.Add(b.ez), this;
    }
    Solve33(b, y, E, I) {
      const B = this.ex.x, D = this.ex.y, N = this.ex.z, V = this.ey.x, G = this.ey.y, U = this.ey.z, j = this.ez.x, tt = this.ez.y, K = this.ez.z;
      let $ = B * (G * K - U * tt) + D * (U * j - V * K) + N * (V * tt - G * j);
      return $ !== 0 && ($ = 1 / $), I.x = $ * (b * (G * K - U * tt) + y * (U * j - V * K) + E * (V * tt - G * j)), I.y = $ * (B * (y * K - E * tt) + D * (E * j - b * K) + N * (b * tt - y * j)), I.z = $ * (B * (G * E - U * y) + D * (U * b - V * E) + N * (V * y - G * b)), I;
    }
    Solve22(b, y, E) {
      const I = this.ex.x, B = this.ey.x, D = this.ex.y, N = this.ey.y;
      let V = I * N - B * D;
      return V !== 0 && (V = 1 / V), E.x = V * (N * b - B * y), E.y = V * (I * y - D * b), E;
    }
    GetInverse22(b) {
      const y = this.ex.x, E = this.ey.x, I = this.ex.y, B = this.ey.y;
      let D = y * B - E * I;
      D !== 0 && (D = 1 / D), b.ex.x = D * B, b.ey.x = -D * E, b.ex.z = 0, b.ex.y = -D * I, b.ey.y = D * y, b.ey.z = 0, b.ez.x = 0, b.ez.y = 0, b.ez.z = 0;
    }
    GetSymInverse33(b) {
      let y = m.Dot(this.ex, m.Cross(this.ey, this.ez, m.s_t0));
      y !== 0 && (y = 1 / y);
      const E = this.ex.x, I = this.ey.x, B = this.ez.x, D = this.ey.y, N = this.ez.y, V = this.ez.z;
      b.ex.x = y * (D * V - N * N), b.ex.y = y * (B * N - I * V), b.ex.z = y * (I * N - B * D), b.ey.x = b.ex.y, b.ey.y = y * (E * V - B * B), b.ey.z = y * (B * I - E * N), b.ez.x = b.ex.z, b.ez.y = b.ey.z, b.ez.z = y * (E * D - I * I);
    }
    static MultiplyVec3(b, y, E) {
      const { x: I, y: B, z: D } = y;
      return E.x = b.ex.x * I + b.ey.x * B + b.ez.x * D, E.y = b.ex.y * I + b.ey.y * B + b.ez.y * D, E.z = b.ex.z * I + b.ey.z * B + b.ez.z * D, E;
    }
    static MultiplyVec2(b, y, E) {
      const { x: I, y: B } = y;
      return E.x = b.ex.x * I + b.ey.x * B, E.y = b.ex.y * I + b.ey.y * B, E;
    }
  };
  h(x, "b2Mat33");
  let f = x;
  n.b2Mat33 = f, f.IDENTITY = new f();
  const A = class A {
    constructor(b = 0) {
      this.s = 0, this.c = 1, b && (this.s = Math.sin(b), this.c = Math.cos(b));
    }
    Clone() {
      return new A().Copy(this);
    }
    Copy(b) {
      return this.s = b.s, this.c = b.c, this;
    }
    Set(b) {
      return this.s = Math.sin(b), this.c = Math.cos(b), this;
    }
    SetIdentity() {
      return this.s = 0, this.c = 1, this;
    }
    GetAngle() {
      return Math.atan2(this.s, this.c);
    }
    GetXAxis(b) {
      return b.x = this.c, b.y = this.s, b;
    }
    GetYAxis(b) {
      return b.x = -this.s, b.y = this.c, b;
    }
    static Multiply(b, y, E) {
      const I = b.s * y.c + b.c * y.s, B = b.c * y.c - b.s * y.s;
      return E.s = I, E.c = B, E;
    }
    static TransposeMultiply(b, y, E) {
      const I = b.c * y.s - b.s * y.c, B = b.c * y.c + b.s * y.s;
      return E.s = I, E.c = B, E;
    }
    static MultiplyVec2(b, y, E) {
      const I = y.x, B = y.y;
      return E.x = b.c * I - b.s * B, E.y = b.s * I + b.c * B, E;
    }
    static TransposeMultiplyVec2(b, y, E) {
      const I = y.x, B = y.y;
      return E.x = b.c * I + b.s * B, E.y = -b.s * I + b.c * B, E;
    }
  };
  h(A, "b2Rot");
  let p = A;
  n.b2Rot = p, p.IDENTITY = new p();
  const C = class C {
    constructor() {
      this.p = new u(), this.q = new p();
    }
    Clone() {
      return new C().Copy(this);
    }
    Copy(b) {
      return this.p.Copy(b.p), this.q.Copy(b.q), this;
    }
    SetIdentity() {
      return this.p.SetZero(), this.q.SetIdentity(), this;
    }
    SetPositionRotation(b, y) {
      return this.p.Copy(b), this.q.Copy(y), this;
    }
    SetPositionAngle(b, y) {
      return this.p.Copy(b), this.q.Set(y), this;
    }
    SetPosition(b) {
      return this.p.Copy(b), this;
    }
    SetPositionXY(b, y) {
      return this.p.Set(b, y), this;
    }
    SetRotation(b) {
      return this.q.Copy(b), this;
    }
    SetRotationAngle(b) {
      return this.q.Set(b), this;
    }
    GetPosition() {
      return this.p;
    }
    GetRotation() {
      return this.q;
    }
    GetAngle() {
      return this.q.GetAngle();
    }
    static MultiplyVec2(b, y, E) {
      const I = y.x, B = y.y;
      return E.x = b.q.c * I - b.q.s * B + b.p.x, E.y = b.q.s * I + b.q.c * B + b.p.y, E;
    }
    static TransposeMultiplyVec2(b, y, E) {
      const I = y.x - b.p.x, B = y.y - b.p.y;
      return E.x = b.q.c * I + b.q.s * B, E.y = -b.q.s * I + b.q.c * B, E;
    }
    static Multiply(b, y, E) {
      return p.Multiply(b.q, y.q, E.q), p.MultiplyVec2(b.q, y.p, E.p).Add(b.p), E;
    }
    static TransposeMultiply(b, y, E) {
      return p.TransposeMultiply(b.q, y.q, E.q), p.TransposeMultiplyVec2(b.q, u.Subtract(y.p, b.p, E.p), E.p), E;
    }
  };
  h(C, "b2Transform");
  let v = C;
  n.b2Transform = v, v.IDENTITY = new v();
  const M = class M {
    constructor() {
      this.localCenter = new u(), this.c0 = new u(), this.c = new u(), this.a0 = 0, this.a = 0, this.alpha0 = 0;
    }
    Clone() {
      return new M().Copy(this);
    }
    Copy(b) {
      return this.localCenter.Copy(b.localCenter), this.c0.Copy(b.c0), this.c.Copy(b.c), this.a0 = b.a0, this.a = b.a, this.alpha0 = b.alpha0, this;
    }
    GetTransform(b, y) {
      const E = 1 - y;
      b.p.x = E * this.c0.x + y * this.c.x, b.p.y = E * this.c0.y + y * this.c.y;
      const I = E * this.a0 + y * this.a;
      return b.q.Set(I), b.p.Subtract(p.MultiplyVec2(b.q, this.localCenter, u.s_t0)), b;
    }
    Advance(b) {
      const y = (b - this.alpha0) / (1 - this.alpha0);
      this.c0.x += y * (this.c.x - this.c0.x), this.c0.y += y * (this.c.y - this.c0.y), this.a0 += y * (this.a - this.a0), this.alpha0 = b;
    }
    Normalize() {
      const b = n.b2_two_pi * Math.floor(this.a0 / n.b2_two_pi);
      this.a0 -= b, this.a -= b;
    }
  };
  h(M, "b2Sweep");
  let _ = M;
  n.b2Sweep = _;
})(Fe);
za(Fe);
var Ai = {};
Object.defineProperty(Ai, "__esModule", { value: !0 });
Ai.debugColors = Ai.b2Color = void 0;
const Hl = class Hl {
  constructor(t = 0.5, e = 0.5, s = 0.5, i = 1) {
    this.r = t, this.g = e, this.b = s, this.a = i;
  }
  Clone() {
    return new Hl(this.r, this.g, this.b, this.a);
  }
  Copy(t) {
    return this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, this;
  }
  IsEqual(t) {
    return this.r === t.r && this.g === t.g && this.b === t.b && this.a === t.a;
  }
  IsZero() {
    return this.r === 0 && this.g === 0 && this.b === 0 && this.a === 0;
  }
  SetByteRGB(t, e, s) {
    return this.r = t / 255, this.g = e / 255, this.b = s / 255, this;
  }
  SetByteRGBA(t, e, s, i) {
    return this.r = t / 255, this.g = e / 255, this.b = s / 255, this.a = i / 255, this;
  }
  SetRGB(t, e, s) {
    return this.r = t, this.g = e, this.b = s, this;
  }
  SetRGBA(t, e, s, i) {
    return this.r = t, this.g = e, this.b = s, this.a = i, this;
  }
  Add(t) {
    return this.r += t.r, this.g += t.g, this.b += t.b, this.a += t.a, this;
  }
  Subtract(t) {
    return this.r -= t.r, this.g -= t.g, this.b -= t.b, this.a -= t.a, this;
  }
  Scale(t) {
    return this.r *= t, this.g *= t, this.b *= t, this.a *= t, this;
  }
  Mix(t, e) {
    Hl.MixColors(this, t, e);
  }
  static Add(t, e, s) {
    return s.r = t.r + e.r, s.g = t.g + e.g, s.b = t.b + e.b, s.a = t.a + e.a, s;
  }
  static Subtract(t, e, s) {
    return s.r = t.r - e.r, s.g = t.g - e.g, s.b = t.b - e.b, s.a = t.a - e.a, s;
  }
  static Scale(t, e, s) {
    return s.r = t.r * e, s.g = t.g * e, s.b = t.b * e, s.a = t.a * e, s;
  }
  static MixColors(t, e, s) {
    const i = s * (e.r - t.r), o = s * (e.g - t.g), r = s * (e.b - t.b), a = s * (e.a - t.a);
    t.r += i, t.g += o, t.b += r, t.a += a, e.r -= i, e.g -= o, e.b -= r, e.a -= a;
  }
};
h(Hl, "b2Color");
let Ge = Hl;
Ai.b2Color = Ge;
Ge.ZERO = new Ge(0, 0, 0, 0);
Ge.RED = new Ge(1, 0, 0);
Ge.GREEN = new Ge(0, 1, 0);
Ge.BLUE = new Ge(0, 0, 1);
Ge.WHITE = new Ge(1, 1, 1);
Ge.BLACK = new Ge(0, 0, 0);
Ai.debugColors = {
  badBody: new Ge(1, 0, 0),
  disabledBody: new Ge(0.5, 0.5, 0.3),
  staticBody: new Ge(0.5, 0.9, 0.5),
  kinematicBody: new Ge(0.5, 0.5, 0.9),
  sleepingBody: new Ge(0.6, 0.6, 0.6),
  body: new Ge(0.9, 0.7, 0.7),
  pair: new Ge(0.3, 0.9, 0.9),
  aabb: new Ge(0.9, 0.3, 0.9),
  joint1: new Ge(0.7, 0.7, 0.7),
  joint2: new Ge(0.3, 0.9, 0.3),
  joint3: new Ge(0.9, 0.3, 0.3),
  joint4: new Ge(0.3, 0.3, 0.9),
  joint5: new Ge(0.4, 0.4, 0.4),
  joint6: new Ge(0.5, 0.8, 0.8),
  joint7: new Ge(0, 1, 0),
  joint8: new Ge(0.8, 0.8, 0.8),
  rope: new Ge(0.4, 0.5, 0.7),
  ropePointG: new Ge(0.1, 0.8, 0.1),
  ropePointD: new Ge(0.7, 0.2, 0.4)
};
var Ti = {}, to = {}, wi = {};
Object.defineProperty(wi, "__esModule", { value: !0 });
wi.b2Shape = wi.b2ShapeType = wi.b2MassData = void 0;
const I8 = Fe, Ry = class Ry {
  constructor() {
    this.mass = 0, this.center = new I8.b2Vec2(), this.I = 0;
  }
};
h(Ry, "b2MassData");
let n0 = Ry;
wi.b2MassData = n0;
var LS;
(function(n) {
  n[n.e_unknown = -1] = "e_unknown", n[n.e_circle = 0] = "e_circle", n[n.e_edge = 1] = "e_edge", n[n.e_polygon = 2] = "e_polygon", n[n.e_chain = 3] = "e_chain", n[n.e_typeCount = 4] = "e_typeCount";
})(LS || (wi.b2ShapeType = LS = {}));
const Dy = class Dy {
  constructor(t, e) {
    this.m_radius = 0, this.m_type = t, this.m_radius = e;
  }
  Copy(t) {
    return this.m_radius = t.m_radius, this;
  }
  GetType() {
    return this.m_type;
  }
};
h(Dy, "b2Shape");
let i0 = Dy;
wi.b2Shape = i0;
var Om = {}, ge = {}, zu = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.b2ShapeCast = n.b2Distance = n.b2Gjk = n.b2ShapeCastOutput = n.b2ShapeCastInput = n.b2DistanceOutput = n.b2DistanceInput = n.b2SimplexCache = n.b2DistanceProxy = void 0;
  const t = Xe, e = Fe, B = class B {
    constructor() {
      this.m_buffer = (0, t.b2MakeArray)(2, e.b2Vec2), this.m_vertices = this.m_buffer, this.m_count = 0, this.m_radius = 0;
    }
    Copy($) {
      return $.m_vertices === $.m_buffer ? (this.m_vertices = this.m_buffer, this.m_buffer[0] = $.m_buffer[0], this.m_buffer[1] = $.m_buffer[1]) : this.m_vertices = $.m_vertices, this.m_count = $.m_count, this.m_radius = $.m_radius, this;
    }
    Reset() {
      return this.m_vertices = this.m_buffer, this.m_count = 0, this.m_radius = 0, this;
    }
    SetShape($, lt) {
      $.SetupDistanceProxy(this, lt);
    }
    SetVerticesRadius($, lt, gt) {
      this.m_vertices = $, this.m_count = lt, this.m_radius = gt;
    }
    GetSupport($) {
      let lt = 0, gt = e.b2Vec2.Dot(this.m_vertices[0], $);
      for (let _t = 1; _t < this.m_count; ++_t) {
        const Y = e.b2Vec2.Dot(this.m_vertices[_t], $);
        Y > gt && (lt = _t, gt = Y);
      }
      return lt;
    }
    GetSupportVertex($) {
      let lt = 0, gt = e.b2Vec2.Dot(this.m_vertices[0], $);
      for (let _t = 1; _t < this.m_count; ++_t) {
        const Y = e.b2Vec2.Dot(this.m_vertices[_t], $);
        Y > gt && (lt = _t, gt = Y);
      }
      return this.m_vertices[lt];
    }
    GetVertexCount() {
      return this.m_count;
    }
    GetVertex($) {
      return this.m_vertices[$];
    }
  };
  h(B, "b2DistanceProxy");
  let s = B;
  n.b2DistanceProxy = s;
  const D = class D {
    constructor() {
      this.metric = 0, this.count = 0, this.indexA = [0, 0, 0], this.indexB = [0, 0, 0];
    }
    Reset() {
      return this.metric = 0, this.count = 0, this;
    }
  };
  h(D, "b2SimplexCache");
  let i = D;
  n.b2SimplexCache = i;
  const N = class N {
    constructor() {
      this.proxyA = new s(), this.proxyB = new s(), this.transformA = new e.b2Transform(), this.transformB = new e.b2Transform(), this.useRadii = !1;
    }
    Reset() {
      return this.proxyA.Reset(), this.proxyB.Reset(), this.transformA.SetIdentity(), this.transformB.SetIdentity(), this.useRadii = !1, this;
    }
  };
  h(N, "b2DistanceInput");
  let o = N;
  n.b2DistanceInput = o;
  const V = class V {
    constructor() {
      this.pointA = new e.b2Vec2(), this.pointB = new e.b2Vec2(), this.distance = 0, this.iterations = 0;
    }
    Reset() {
      return this.pointA.SetZero(), this.pointB.SetZero(), this.distance = 0, this.iterations = 0, this;
    }
  };
  h(V, "b2DistanceOutput");
  let r = V;
  n.b2DistanceOutput = r;
  const G = class G {
    constructor() {
      this.proxyA = new s(), this.proxyB = new s(), this.transformA = new e.b2Transform(), this.transformB = new e.b2Transform(), this.translationB = new e.b2Vec2();
    }
  };
  h(G, "b2ShapeCastInput");
  let a = G;
  n.b2ShapeCastInput = a;
  const U = class U {
    constructor() {
      this.point = new e.b2Vec2(), this.normal = new e.b2Vec2(), this.lambda = 0, this.iterations = 0;
    }
  };
  h(U, "b2ShapeCastOutput");
  let l = U;
  n.b2ShapeCastOutput = l, n.b2Gjk = {
    calls: 0,
    iters: 0,
    maxIters: 0,
    reset() {
      this.calls = 0, this.iters = 0, this.maxIters = 0;
    }
  };
  const j = class j {
    constructor() {
      this.wA = new e.b2Vec2(), this.wB = new e.b2Vec2(), this.w = new e.b2Vec2(), this.a = 0, this.indexA = 0, this.indexB = 0;
    }
    Copy($) {
      return this.wA.Copy($.wA), this.wB.Copy($.wB), this.w.Copy($.w), this.a = $.a, this.indexA = $.indexA, this.indexB = $.indexB, this;
    }
  };
  h(j, "b2SimplexVertex");
  let c = j;
  const tt = class tt {
    constructor() {
      this.m_v1 = new c(), this.m_v2 = new c(), this.m_v3 = new c(), this.m_count = 0, this.m_vertices = [this.m_v1, this.m_v2, this.m_v3];
    }
    ReadCache($, lt, gt, _t, Y) {
      this.m_count = $.count;
      const it = this.m_vertices;
      for (let J = 0; J < this.m_count; ++J) {
        const dt = it[J];
        dt.indexA = $.indexA[J], dt.indexB = $.indexB[J];
        const vt = lt.GetVertex(dt.indexA), Nt = _t.GetVertex(dt.indexB);
        e.b2Transform.MultiplyVec2(gt, vt, dt.wA), e.b2Transform.MultiplyVec2(Y, Nt, dt.wB), e.b2Vec2.Subtract(dt.wB, dt.wA, dt.w), dt.a = 0;
      }
      if (this.m_count > 1) {
        const J = $.metric, dt = this.GetMetric();
        (dt < 0.5 * J || 2 * J < dt || dt < t.b2_epsilon) && (this.m_count = 0);
      }
      if (this.m_count === 0) {
        const J = it[0];
        J.indexA = 0, J.indexB = 0;
        const dt = lt.GetVertex(0), vt = _t.GetVertex(0);
        e.b2Transform.MultiplyVec2(gt, dt, J.wA), e.b2Transform.MultiplyVec2(Y, vt, J.wB), e.b2Vec2.Subtract(J.wB, J.wA, J.w), J.a = 1, this.m_count = 1;
      }
    }
    WriteCache($) {
      $.metric = this.GetMetric(), $.count = this.m_count;
      const lt = this.m_vertices;
      for (let gt = 0; gt < this.m_count; ++gt)
        $.indexA[gt] = lt[gt].indexA, $.indexB[gt] = lt[gt].indexB;
    }
    GetSearchDirection($) {
      switch (this.m_count) {
        case 1:
          return e.b2Vec2.Negate(this.m_v1.w, $);
        case 2: {
          const lt = e.b2Vec2.Subtract(this.m_v2.w, this.m_v1.w, $);
          return e.b2Vec2.Cross(lt, e.b2Vec2.Negate(this.m_v1.w, e.b2Vec2.s_t0)) > 0 ? e.b2Vec2.CrossOneVec2(lt, $) : e.b2Vec2.CrossVec2One(lt, $);
        }
        default:
          return $.SetZero();
      }
    }
    GetClosestPoint($) {
      switch (this.m_count) {
        case 0:
          return $.SetZero();
        case 1:
          return $.Copy(this.m_v1.w);
        case 2:
          return $.Set(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
        case 3:
          return $.SetZero();
        default:
          return $.SetZero();
      }
    }
    GetWitnessPoints($, lt) {
      switch (this.m_count) {
        case 0:
          break;
        case 1:
          $.Copy(this.m_v1.wA), lt.Copy(this.m_v1.wB);
          break;
        case 2:
          $.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, $.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, lt.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, lt.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
          break;
        case 3:
          lt.x = $.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, lt.y = $.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
          break;
      }
    }
    GetMetric() {
      switch (this.m_count) {
        case 0:
          return 0;
        case 1:
          return 0;
        case 2:
          return e.b2Vec2.Distance(this.m_v1.w, this.m_v2.w);
        case 3:
          return e.b2Vec2.Cross(e.b2Vec2.Subtract(this.m_v2.w, this.m_v1.w, e.b2Vec2.s_t0), e.b2Vec2.Subtract(this.m_v3.w, this.m_v1.w, e.b2Vec2.s_t1));
        default:
          return 0;
      }
    }
    Solve2() {
      const $ = this.m_v1.w, lt = this.m_v2.w, gt = e.b2Vec2.Subtract(lt, $, tt.s_e12), _t = -e.b2Vec2.Dot($, gt);
      if (_t <= 0) {
        this.m_v1.a = 1, this.m_count = 1;
        return;
      }
      const Y = e.b2Vec2.Dot(lt, gt);
      if (Y <= 0) {
        this.m_v2.a = 1, this.m_count = 1, this.m_v1.Copy(this.m_v2);
        return;
      }
      const it = 1 / (Y + _t);
      this.m_v1.a = Y * it, this.m_v2.a = _t * it, this.m_count = 2;
    }
    Solve3() {
      const $ = this.m_v1.w, lt = this.m_v2.w, gt = this.m_v3.w, _t = e.b2Vec2.Subtract(lt, $, tt.s_e12), Y = e.b2Vec2.Dot($, _t), J = e.b2Vec2.Dot(lt, _t), dt = -Y, vt = e.b2Vec2.Subtract(gt, $, tt.s_e13), Nt = e.b2Vec2.Dot($, vt), k = e.b2Vec2.Dot(gt, vt), te = -Nt, It = e.b2Vec2.Subtract(gt, lt, tt.s_e23), ut = e.b2Vec2.Dot(lt, It), Ft = e.b2Vec2.Dot(gt, It), wt = -ut, le = e.b2Vec2.Cross(_t, vt), dn = le * e.b2Vec2.Cross(lt, gt), Ze = le * e.b2Vec2.Cross(gt, $), z = le * e.b2Vec2.Cross($, lt);
      if (dt <= 0 && te <= 0) {
        this.m_v1.a = 1, this.m_count = 1;
        return;
      }
      if (J > 0 && dt > 0 && z <= 0) {
        const q = 1 / (J + dt);
        this.m_v1.a = J * q, this.m_v2.a = dt * q, this.m_count = 2;
        return;
      }
      if (k > 0 && te > 0 && Ze <= 0) {
        const q = 1 / (k + te);
        this.m_v1.a = k * q, this.m_v3.a = te * q, this.m_count = 2, this.m_v2.Copy(this.m_v3);
        return;
      }
      if (J <= 0 && wt <= 0) {
        this.m_v2.a = 1, this.m_count = 1, this.m_v1.Copy(this.m_v2);
        return;
      }
      if (k <= 0 && Ft <= 0) {
        this.m_v3.a = 1, this.m_count = 1, this.m_v1.Copy(this.m_v3);
        return;
      }
      if (Ft > 0 && wt > 0 && dn <= 0) {
        const q = 1 / (Ft + wt);
        this.m_v2.a = Ft * q, this.m_v3.a = wt * q, this.m_count = 2, this.m_v1.Copy(this.m_v3);
        return;
      }
      const P = 1 / (dn + Ze + z);
      this.m_v1.a = dn * P, this.m_v2.a = Ze * P, this.m_v3.a = z * P, this.m_count = 3;
    }
  };
  h(tt, "b2Simplex");
  let u = tt;
  u.s_e12 = new e.b2Vec2(), u.s_e13 = new e.b2Vec2(), u.s_e23 = new e.b2Vec2();
  const m = new u(), d = [0, 0, 0], f = [0, 0, 0], p = new e.b2Vec2(), v = new e.b2Vec2(), _ = new e.b2Vec2(), g = new e.b2Vec2(), w = new e.b2Vec2();
  function S(K, $, lt) {
    ++n.b2Gjk.calls;
    const { proxyA: gt, proxyB: _t, transformA: Y, transformB: it } = lt, J = m;
    J.ReadCache($, gt, Y, _t, it);
    const dt = J.m_vertices, vt = 20, Nt = d, _e = f;
    let k = 0, te = 0;
    for (; te < vt; ) {
      k = J.m_count;
      for (let Ft = 0; Ft < k; ++Ft)
        Nt[Ft] = dt[Ft].indexA, _e[Ft] = dt[Ft].indexB;
      switch (J.m_count) {
        case 1:
          break;
        case 2:
          J.Solve2();
          break;
        case 3:
          J.Solve3();
          break;
      }
      if (J.m_count === 3)
        break;
      const It = J.GetSearchDirection(v);
      if (It.LengthSquared() < t.b2_epsilon_sq)
        break;
      const ut = dt[J.m_count];
      ut.indexA = gt.GetSupport(e.b2Rot.TransposeMultiplyVec2(Y.q, e.b2Vec2.Negate(It, e.b2Vec2.s_t0), g)), e.b2Transform.MultiplyVec2(Y, gt.GetVertex(ut.indexA), ut.wA), ut.indexB = _t.GetSupport(e.b2Rot.TransposeMultiplyVec2(it.q, It, w)), e.b2Transform.MultiplyVec2(it, _t.GetVertex(ut.indexB), ut.wB), e.b2Vec2.Subtract(ut.wB, ut.wA, ut.w), ++te, ++n.b2Gjk.iters;
      let bt = !1;
      for (let Ft = 0; Ft < k; ++Ft)
        if (ut.indexA === Nt[Ft] && ut.indexB === _e[Ft]) {
          bt = !0;
          break;
        }
      if (bt)
        break;
      ++J.m_count;
    }
    if (n.b2Gjk.maxIters = Math.max(n.b2Gjk.maxIters, te), J.GetWitnessPoints(K.pointA, K.pointB), K.distance = e.b2Vec2.Distance(K.pointA, K.pointB), K.iterations = te, J.WriteCache($), lt.useRadii)
      if (K.distance < t.b2_epsilon) {
        const It = e.b2Vec2.Mid(K.pointA, K.pointB, p);
        K.pointA.Copy(It), K.pointB.Copy(It), K.distance = 0;
      } else {
        const It = gt.m_radius, ut = _t.m_radius, bt = e.b2Vec2.Subtract(K.pointB, K.pointA, _);
        bt.Normalize(), K.distance = Math.max(0, K.distance - It - ut), K.pointA.AddScaled(It, bt), K.pointB.SubtractScaled(ut, bt);
      }
  }
  h(S, "b2Distance"), n.b2Distance = S;
  const x = new e.b2Vec2(), A = new u(), C = new e.b2Vec2(), M = new e.b2Vec2(), T = new e.b2Vec2(), b = new e.b2Vec2(), y = new e.b2Vec2(), E = new e.b2Vec2();
  function I(K, $) {
    K.iterations = 0, K.lambda = 1, K.normal.SetZero(), K.point.SetZero();
    const { proxyA: lt, proxyB: gt } = $, _t = Math.max(lt.m_radius, t.b2_polygonRadius), Y = Math.max(gt.m_radius, t.b2_polygonRadius), it = _t + Y, J = $.transformA, dt = $.transformB, vt = $.translationB, Nt = x.SetZero();
    let _e = 0;
    const k = A;
    k.m_count = 0;
    const te = k.m_vertices;
    let It = lt.GetSupport(e.b2Rot.TransposeMultiplyVec2(J.q, e.b2Vec2.Negate(vt, e.b2Vec2.s_t1), e.b2Vec2.s_t0)), ut = e.b2Transform.MultiplyVec2(J, lt.GetVertex(It), C), bt = gt.GetSupport(e.b2Rot.TransposeMultiplyVec2(dt.q, vt, e.b2Vec2.s_t0)), Ft = e.b2Transform.MultiplyVec2(dt, gt.GetVertex(bt), M);
    const wt = e.b2Vec2.Subtract(ut, Ft, T), le = Math.max(t.b2_polygonRadius, it - t.b2_polygonRadius), dn = 0.5 * t.b2_linearSlop, Ze = 20;
    let z = 0;
    for (; z < Ze && wt.Length() - le > dn; ) {
      K.iterations += 1, It = lt.GetSupport(e.b2Rot.TransposeMultiplyVec2(J.q, e.b2Vec2.Negate(wt, e.b2Vec2.s_t1), e.b2Vec2.s_t0)), ut = e.b2Transform.MultiplyVec2(J, lt.GetVertex(It), C), bt = gt.GetSupport(e.b2Rot.TransposeMultiplyVec2(dt.q, wt, e.b2Vec2.s_t0)), Ft = e.b2Transform.MultiplyVec2(dt, gt.GetVertex(bt), M);
      const at = e.b2Vec2.Subtract(ut, Ft, b);
      wt.Normalize();
      const mt = e.b2Vec2.Dot(wt, at), ot = e.b2Vec2.Dot(wt, vt);
      if (mt - le > _e * ot) {
        if (ot <= 0 || (_e = (mt - le) / ot, _e > 1))
          return !1;
        e.b2Vec2.Negate(wt, Nt), k.m_count = 0;
      }
      const Wt = te[k.m_count];
      switch (Wt.indexA = bt, e.b2Vec2.AddScaled(Ft, _e, vt, Wt.wA), Wt.indexB = It, Wt.wB.Copy(ut), e.b2Vec2.Subtract(Wt.wB, Wt.wA, Wt.w), Wt.a = 1, k.m_count += 1, k.m_count) {
        case 1:
          break;
        case 2:
          k.Solve2();
          break;
        case 3:
          k.Solve3();
          break;
      }
      if (k.m_count === 3)
        return !1;
      k.GetClosestPoint(wt), ++z;
    }
    if (z === 0)
      return !1;
    const P = y, q = E;
    return k.GetWitnessPoints(P, q), wt.LengthSquared() > 0 && (e.b2Vec2.Negate(wt, Nt), Nt.Normalize()), e.b2Vec2.AddScaled(P, _t, Nt, K.point), K.normal.Copy(Nt), K.lambda = _e, K.iterations = z, !0;
  }
  h(I, "b2ShapeCast"), n.b2ShapeCast = I;
})(zu);
za(zu);
Object.defineProperty(ge, "__esModule", { value: !0 });
ge.b2ValidateHull = ge.b2ComputeHull = ge.b2TestOverlap = ge.b2ClipSegmentToLine = ge.b2AABB = ge.b2RayCastOutput = ge.b2RayCastInput = ge.b2ClipVertex = ge.b2GetPointStates = ge.b2PointState = ge.b2WorldManifold = ge.b2Manifold = ge.b2ManifoldType = ge.b2ManifoldPoint = ge.b2ContactID = ge.b2ContactFeature = ge.b2ContactFeatureType = void 0;
const un = Xe, Tt = Fe, $m = zu, Nl = ps;
var Wc;
(function(n) {
  n[n.e_vertex = 0] = "e_vertex", n[n.e_face = 1] = "e_face";
})(Wc || (ge.b2ContactFeatureType = Wc = {}));
const Vy = class Vy {
  constructor() {
    this.m_key = 0, this.m_key_invalid = !1, this.m_indexA = 0, this.m_indexB = 0, this.m_typeA = Wc.e_vertex, this.m_typeB = Wc.e_vertex;
  }
  get key() {
    return this.m_key_invalid && (this.m_key_invalid = !1, this.m_key = this.m_indexA | this.m_indexB << 8 | this.m_typeA << 16 | this.m_typeB << 24), this.m_key;
  }
  set key(t) {
    this.m_key = t, this.m_key_invalid = !1, this.m_indexA = this.m_key & 255, this.m_indexB = this.m_key >> 8 & 255, this.m_typeA = this.m_key >> 16 & 255, this.m_typeB = this.m_key >> 24 & 255;
  }
  get indexA() {
    return this.m_indexA;
  }
  set indexA(t) {
    this.m_indexA = t, this.m_key_invalid = !0;
  }
  get indexB() {
    return this.m_indexB;
  }
  set indexB(t) {
    this.m_indexB = t, this.m_key_invalid = !0;
  }
  get typeA() {
    return this.m_typeA;
  }
  set typeA(t) {
    this.m_typeA = t, this.m_key_invalid = !0;
  }
  get typeB() {
    return this.m_typeB;
  }
  set typeB(t) {
    this.m_typeB = t, this.m_key_invalid = !0;
  }
};
h(Vy, "b2ContactFeature");
let Cd = Vy;
ge.b2ContactFeature = Cd;
const hm = class hm {
  constructor() {
    this.cf = new Cd();
  }
  Copy(t) {
    return this.key = t.key, this;
  }
  Clone() {
    return new hm().Copy(this);
  }
  get key() {
    return this.cf.key;
  }
  set key(t) {
    this.cf.key = t;
  }
};
h(hm, "b2ContactID");
let fu = hm;
ge.b2ContactID = fu;
const Ly = class Ly {
  constructor() {
    this.localPoint = new Tt.b2Vec2(), this.normalImpulse = 0, this.tangentImpulse = 0, this.id = new fu();
  }
  Reset() {
    this.localPoint.SetZero(), this.normalImpulse = 0, this.tangentImpulse = 0, this.id.key = 0;
  }
  Copy(t) {
    return this.localPoint.Copy(t.localPoint), this.normalImpulse = t.normalImpulse, this.tangentImpulse = t.tangentImpulse, this.id.Copy(t.id), this;
  }
};
h(Ly, "b2ManifoldPoint");
let Ed = Ly;
ge.b2ManifoldPoint = Ed;
var da;
(function(n) {
  n[n.e_circles = 0] = "e_circles", n[n.e_faceA = 1] = "e_faceA", n[n.e_faceB = 2] = "e_faceB";
})(da || (ge.b2ManifoldType = da = {}));
const dm = class dm {
  constructor() {
    this.points = (0, un.b2MakeArray)(un.b2_maxManifoldPoints, Ed), this.localNormal = new Tt.b2Vec2(), this.localPoint = new Tt.b2Vec2(), this.type = da.e_circles, this.pointCount = 0;
  }
  Reset() {
    for (let t = 0; t < un.b2_maxManifoldPoints; ++t)
      this.points[t].Reset();
    this.localNormal.SetZero(), this.localPoint.SetZero(), this.type = da.e_circles, this.pointCount = 0;
  }
  Copy(t) {
    this.pointCount = t.pointCount;
    for (let e = 0; e < un.b2_maxManifoldPoints; ++e)
      this.points[e].Copy(t.points[e]);
    return this.localNormal.Copy(t.localNormal), this.localPoint.Copy(t.localPoint), this.type = t.type, this;
  }
  Clone() {
    return new dm().Copy(this);
  }
};
h(dm, "b2Manifold");
let s0 = dm;
ge.b2Manifold = s0;
const bi = class bi {
  constructor() {
    this.normal = new Tt.b2Vec2(), this.points = (0, un.b2MakeArray)(un.b2_maxManifoldPoints, Tt.b2Vec2), this.separations = (0, un.b2MakeNumberArray)(un.b2_maxManifoldPoints);
  }
  Initialize(t, e, s, i, o) {
    if (t.pointCount !== 0)
      switch (t.type) {
        case da.e_circles: {
          this.normal.Set(1, 0);
          const r = Tt.b2Transform.MultiplyVec2(e, t.localPoint, bi.Initialize_s_pointA), a = Tt.b2Transform.MultiplyVec2(i, t.points[0].localPoint, bi.Initialize_s_pointB);
          Tt.b2Vec2.DistanceSquared(r, a) > un.b2_epsilon_sq && Tt.b2Vec2.Subtract(a, r, this.normal).Normalize();
          const l = Tt.b2Vec2.AddScaled(r, s, this.normal, bi.Initialize_s_cA), c = Tt.b2Vec2.SubtractScaled(a, o, this.normal, bi.Initialize_s_cB);
          Tt.b2Vec2.Mid(l, c, this.points[0]), this.separations[0] = Tt.b2Vec2.Dot(Tt.b2Vec2.Subtract(c, l, Tt.b2Vec2.s_t0), this.normal);
          break;
        }
        case da.e_faceA: {
          Tt.b2Rot.MultiplyVec2(e.q, t.localNormal, this.normal);
          const r = Tt.b2Transform.MultiplyVec2(e, t.localPoint, bi.Initialize_s_planePoint);
          for (let a = 0; a < t.pointCount; ++a) {
            const l = Tt.b2Transform.MultiplyVec2(i, t.points[a].localPoint, bi.Initialize_s_clipPoint), c = s - Tt.b2Vec2.Dot(Tt.b2Vec2.Subtract(l, r, Tt.b2Vec2.s_t0), this.normal), u = Tt.b2Vec2.AddScaled(l, c, this.normal, bi.Initialize_s_cA), m = Tt.b2Vec2.SubtractScaled(l, o, this.normal, bi.Initialize_s_cB);
            Tt.b2Vec2.Mid(u, m, this.points[a]), this.separations[a] = Tt.b2Vec2.Dot(Tt.b2Vec2.Subtract(m, u, Tt.b2Vec2.s_t0), this.normal);
          }
          break;
        }
        case da.e_faceB: {
          Tt.b2Rot.MultiplyVec2(i.q, t.localNormal, this.normal);
          const r = Tt.b2Transform.MultiplyVec2(i, t.localPoint, bi.Initialize_s_planePoint);
          for (let a = 0; a < t.pointCount; ++a) {
            const l = Tt.b2Transform.MultiplyVec2(e, t.points[a].localPoint, bi.Initialize_s_clipPoint), c = o - Tt.b2Vec2.Dot(Tt.b2Vec2.Subtract(l, r, Tt.b2Vec2.s_t0), this.normal), u = Tt.b2Vec2.AddScaled(l, c, this.normal, bi.Initialize_s_cB), m = Tt.b2Vec2.SubtractScaled(l, s, this.normal, bi.Initialize_s_cA);
            Tt.b2Vec2.Mid(m, u, this.points[a]), this.separations[a] = Tt.b2Vec2.Dot(Tt.b2Vec2.Subtract(m, u, Tt.b2Vec2.s_t0), this.normal);
          }
          this.normal.Negate();
          break;
        }
      }
  }
};
h(bi, "b2WorldManifold");
let Fo = bi;
ge.b2WorldManifold = Fo;
Fo.Initialize_s_pointA = new Tt.b2Vec2();
Fo.Initialize_s_pointB = new Tt.b2Vec2();
Fo.Initialize_s_cA = new Tt.b2Vec2();
Fo.Initialize_s_cB = new Tt.b2Vec2();
Fo.Initialize_s_planePoint = new Tt.b2Vec2();
Fo.Initialize_s_clipPoint = new Tt.b2Vec2();
var nr;
(function(n) {
  n[n.b2_nullState = 0] = "b2_nullState", n[n.b2_addState = 1] = "b2_addState", n[n.b2_persistState = 2] = "b2_persistState", n[n.b2_removeState = 3] = "b2_removeState";
})(nr || (ge.b2PointState = nr = {}));
function B8(n, t, e, s) {
  let i;
  for (i = 0; i < e.pointCount; ++i) {
    const { key: o } = e.points[i].id;
    n[i] = nr.b2_removeState;
    for (let r = 0; r < s.pointCount; ++r)
      if (s.points[r].id.key === o) {
        n[i] = nr.b2_persistState;
        break;
      }
  }
  for (; i < un.b2_maxManifoldPoints; ++i)
    n[i] = nr.b2_nullState;
  for (i = 0; i < s.pointCount; ++i) {
    const { key: o } = s.points[i].id;
    t[i] = nr.b2_addState;
    for (let r = 0; r < e.pointCount; ++r)
      if (e.points[r].id.key === o) {
        t[i] = nr.b2_persistState;
        break;
      }
  }
  for (; i < un.b2_maxManifoldPoints; ++i)
    t[i] = nr.b2_nullState;
}
h(B8, "b2GetPointStates");
ge.b2GetPointStates = B8;
const Ny = class Ny {
  constructor() {
    this.v = new Tt.b2Vec2(), this.id = new fu();
  }
  Copy(t) {
    return this.v.Copy(t.v), this.id.Copy(t.id), this;
  }
};
h(Ny, "b2ClipVertex");
let o0 = Ny;
ge.b2ClipVertex = o0;
const zy = class zy {
  constructor() {
    this.p1 = new Tt.b2Vec2(), this.p2 = new Tt.b2Vec2(), this.maxFraction = 1;
  }
  Copy(t) {
    return this.p1.Copy(t.p1), this.p2.Copy(t.p2), this.maxFraction = t.maxFraction, this;
  }
};
h(zy, "b2RayCastInput");
let r0 = zy;
ge.b2RayCastInput = r0;
const ky = class ky {
  constructor() {
    this.normal = new Tt.b2Vec2(), this.fraction = 0;
  }
  Copy(t) {
    return this.normal.Copy(t.normal), this.fraction = t.fraction, this;
  }
};
h(ky, "b2RayCastOutput");
let a0 = ky;
ge.b2RayCastOutput = a0;
const Uy = class Uy {
  constructor() {
    this.lowerBound = new Tt.b2Vec2(), this.upperBound = new Tt.b2Vec2();
  }
  Copy(t) {
    return this.lowerBound.Copy(t.lowerBound), this.upperBound.Copy(t.upperBound), this;
  }
  IsValid() {
    return this.lowerBound.IsValid() && this.upperBound.IsValid() && this.upperBound.x >= this.lowerBound.x && this.upperBound.y >= this.lowerBound.y;
  }
  GetCenter(t) {
    return Tt.b2Vec2.Mid(this.lowerBound, this.upperBound, t);
  }
  GetExtents(t) {
    return Tt.b2Vec2.Extents(this.lowerBound, this.upperBound, t);
  }
  GetPerimeter() {
    const t = this.upperBound.x - this.lowerBound.x, e = this.upperBound.y - this.lowerBound.y;
    return 2 * (t + e);
  }
  Combine1(t) {
    return this.lowerBound.x = Math.min(this.lowerBound.x, t.lowerBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, t.lowerBound.y), this.upperBound.x = Math.max(this.upperBound.x, t.upperBound.x), this.upperBound.y = Math.max(this.upperBound.y, t.upperBound.y), this;
  }
  Combine2(t, e) {
    return this.lowerBound.x = Math.min(t.lowerBound.x, e.lowerBound.x), this.lowerBound.y = Math.min(t.lowerBound.y, e.lowerBound.y), this.upperBound.x = Math.max(t.upperBound.x, e.upperBound.x), this.upperBound.y = Math.max(t.upperBound.y, e.upperBound.y), this;
  }
  static Combine(t, e, s) {
    return s.Combine2(t, e), s;
  }
  Contains(t) {
    return this.lowerBound.x <= t.lowerBound.x && this.lowerBound.y <= t.lowerBound.y && t.upperBound.x <= this.upperBound.x && t.upperBound.y <= this.upperBound.y;
  }
  RayCast(t, e) {
    let s = -un.b2_maxFloat, i = un.b2_maxFloat;
    const o = e.p1.x, r = e.p1.y, a = e.p2.x - e.p1.x, l = e.p2.y - e.p1.y, c = Math.abs(a), u = Math.abs(l), { normal: m } = t;
    if (c < un.b2_epsilon) {
      if (o < this.lowerBound.x || this.upperBound.x < o)
        return !1;
    } else {
      const d = 1 / a;
      let f = (this.lowerBound.x - o) * d, p = (this.upperBound.x - o) * d, v = -1;
      if (f > p) {
        const _ = f;
        f = p, p = _, v = 1;
      }
      if (f > s && (m.x = v, m.y = 0, s = f), i = Math.min(i, p), s > i)
        return !1;
    }
    if (u < un.b2_epsilon) {
      if (r < this.lowerBound.y || this.upperBound.y < r)
        return !1;
    } else {
      const d = 1 / l;
      let f = (this.lowerBound.y - r) * d, p = (this.upperBound.y - r) * d, v = -1;
      if (f > p) {
        const _ = f;
        f = p, p = _, v = 1;
      }
      if (f > s && (m.x = 0, m.y = v, s = f), i = Math.min(i, p), s > i)
        return !1;
    }
    return s < 0 || e.maxFraction < s ? !1 : (t.fraction = s, !0);
  }
  TestContain(t) {
    return !(t.x < this.lowerBound.x || this.upperBound.x < t.x || t.y < this.lowerBound.y || this.upperBound.y < t.y);
  }
  TestOverlap(t) {
    return !(this.upperBound.x < t.lowerBound.x || this.upperBound.y < t.lowerBound.y || t.upperBound.x < this.lowerBound.x || t.upperBound.y < this.lowerBound.y);
  }
};
h(Uy, "b2AABB");
let Td = Uy;
ge.b2AABB = Td;
function P8(n, [t, e], s, i, o) {
  let r = 0;
  const a = Tt.b2Vec2.Dot(s, t.v) - i, l = Tt.b2Vec2.Dot(s, e.v) - i;
  if (a <= 0 && n[r++].Copy(t), l <= 0 && n[r++].Copy(e), a * l < 0) {
    const c = a / (a - l), { v: u, id: m } = n[r];
    u.x = t.v.x + c * (e.v.x - t.v.x), u.y = t.v.y + c * (e.v.y - t.v.y), m.cf.indexA = o, m.cf.indexB = t.id.cf.indexB, m.cf.typeA = Wc.e_vertex, m.cf.typeB = Wc.e_face, ++r;
  }
  return r;
}
h(P8, "b2ClipSegmentToLine");
ge.b2ClipSegmentToLine = P8;
const R8 = new $m.b2DistanceInput(), D8 = new $m.b2SimplexCache(), V8 = new $m.b2DistanceOutput();
function L8(n, t, e, s, i, o) {
  const r = R8.Reset();
  r.proxyA.SetShape(n, t), r.proxyB.SetShape(e, s), r.transformA.Copy(i), r.transformB.Copy(o), r.useRadii = !0;
  const a = D8.Reset();
  a.count = 0;
  const l = V8.Reset();
  return (0, $m.b2Distance)(l, a, r), l.distance < 10 * un.b2_epsilon;
}
h(L8, "b2TestOverlap");
ge.b2TestOverlap = L8;
const N8 = new Tt.b2Vec2(), NS = new Tt.b2Vec2(), zl = [];
function Id(n, t, e) {
  if (e.length === 0)
    return zl;
  const s = Tt.b2Vec2.Subtract(t, n, N8);
  s.Normalize();
  const i = [];
  let o = 0, r = Tt.b2Vec2.Cross(Tt.b2Vec2.Subtract(e[o], n, NS), s);
  r > 0 && i.push(e[o]);
  for (let m = 1; m < e.length; ++m) {
    const d = Tt.b2Vec2.Cross(Tt.b2Vec2.Subtract(e[m], n, NS), s);
    d > r && (o = m, r = d), d > 0 && i.push(e[m]);
  }
  if (r < 2 * un.b2_linearSlop)
    return zl;
  const a = e[o], l = Id(n, a, i), c = Id(a, t, i), u = [...l, a, ...c];
  return (0, un.b2Assert)(u.length < Nl.b2_maxPolygonVertices), u;
}
h(Id, "b2RecurseHull");
const zS = new Tt.b2Vec2(), z8 = new Tt.b2Vec2(), k8 = new Tt.b2Vec2(), U8 = new Tt.b2Vec2(), O8 = new Td();
function $8(n, t) {
  if (t < 3 || t > Nl.b2_maxPolygonVertices)
    return zl;
  t = Math.min(t, Nl.b2_maxPolygonVertices);
  const e = O8;
  e.lowerBound.Set(un.b2_maxFloat, un.b2_maxFloat), e.upperBound.Set(-un.b2_maxFloat, -un.b2_maxFloat);
  const s = [], i = 16 * un.b2_linearSlop * un.b2_linearSlop;
  for (let x = 0; x < t; ++x) {
    Tt.b2Vec2.Min(e.lowerBound, n[x], e.lowerBound), Tt.b2Vec2.Max(e.upperBound, n[x], e.upperBound);
    const A = n[x];
    let C = !0;
    for (let M = 0; M < x; ++M) {
      const T = n[M];
      if (Tt.b2Vec2.DistanceSquared(A, T) < i) {
        C = !1;
        break;
      }
    }
    C && s.push(A);
  }
  let o = s.length;
  if (o < 3)
    return zl;
  const r = e.GetCenter(k8);
  let a = 0, l = Tt.b2Vec2.DistanceSquared(r, s[a]);
  for (let x = 1; x < o; ++x) {
    const A = Tt.b2Vec2.DistanceSquared(r, s[x]);
    A > l && (a = x, l = A);
  }
  const c = s[a];
  s[a] = s[o - 1], o -= 1;
  let u = 0, m = Tt.b2Vec2.DistanceSquared(c, s[u]);
  for (let x = 1; x < o; ++x) {
    const A = Tt.b2Vec2.DistanceSquared(c, s[x]);
    A > m && (u = x, m = A);
  }
  const d = s[u];
  s[u] = s[o - 1], o -= 1;
  const f = [], p = [], v = Tt.b2Vec2.Subtract(d, c, zS);
  v.Normalize();
  for (let x = 0; x < o; ++x) {
    const A = Tt.b2Vec2.Cross(Tt.b2Vec2.Subtract(s[x], c, U8), v);
    A >= 2 * un.b2_linearSlop ? f.push(s[x]) : A <= -2 * un.b2_linearSlop && p.push(s[x]);
  }
  const _ = Id(c, d, f), g = Id(d, c, p);
  if (_.length === 0 && g.length === 0)
    return zl;
  const w = [c, ..._, d, ...g];
  (0, un.b2Assert)(w.length <= Nl.b2_maxPolygonVertices);
  let S = !0;
  for (; S && w.length > 2; ) {
    S = !1;
    for (let x = 0; x < w.length; ++x) {
      const A = x, C = (x + 1) % w.length, M = (x + 2) % w.length, T = w[A], b = w[C], y = w[M], E = Tt.b2Vec2.Subtract(y, T, zS);
      E.Normalize();
      const I = Tt.b2Vec2.Subtract(b, T, z8);
      if (Tt.b2Vec2.Cross(I, E) <= 2 * un.b2_linearSlop) {
        w.splice(C, 1), S = !0;
        break;
      }
    }
  }
  return w.length < 3 && (w.length = 0), w;
}
h($8, "b2ComputeHull");
ge.b2ComputeHull = $8;
const kS = new Tt.b2Vec2(), US = new Tt.b2Vec2();
function F8(n, t) {
  if (t < 3 || Nl.b2_maxPolygonVertices < t)
    return !1;
  for (let e = 0; e < t; ++e) {
    const s = e, i = e < t - 1 ? s + 1 : 0, o = n[s], r = Tt.b2Vec2.Subtract(n[i], o, kS);
    r.Normalize();
    for (let a = 0; a < t; ++a) {
      if (a === s || a === i)
        continue;
      if (Tt.b2Vec2.Cross(Tt.b2Vec2.Subtract(n[a], o, US), r) >= 0)
        return !1;
    }
  }
  for (let e = 0; e < t; ++e) {
    const s = e, i = (e + 1) % t, o = (e + 2) % t, r = n[s], a = n[i], l = n[o], c = Tt.b2Vec2.Subtract(l, r, kS);
    if (c.Normalize(), Tt.b2Vec2.Cross(Tt.b2Vec2.Subtract(a, r, US), c) <= un.b2_linearSlop)
      return !1;
  }
  return !0;
}
h(F8, "b2ValidateHull");
ge.b2ValidateHull = F8;
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.b2Fixture = n.b2FixtureProxy = n.b2DefaultFilter = void 0;
  const t = Fe, e = ge, s = wi, i = Xe, o = ps, r = {
    c1: new t.b2Vec2(),
    c2: new t.b2Vec2()
  };
  n.b2DefaultFilter = {
    categoryBits: 1,
    maskBits: 65535,
    groupIndex: 0
  };
  const d = class d {
    constructor(v, _, g, w) {
      this.aabb = new e.b2AABB(), this.fixture = v, this.childIndex = w, v.m_shape.ComputeAABB(this.aabb, g, w), this.treeNode = _.CreateProxy(this.aabb, this);
    }
  };
  h(d, "b2FixtureProxy");
  let a = d;
  n.b2FixtureProxy = a;
  const l = new e.b2AABB(), c = new e.b2AABB(), u = new t.b2Vec2(), f = class f {
    get m_proxyCount() {
      return this.m_proxies.length;
    }
    constructor(v, _) {
      var g, w, S, x, A;
      this.m_density = 0, this.m_next = null, this.m_friction = 0, this.m_restitution = 0, this.m_restitutionThreshold = 0, this.m_proxies = [], this.m_isSensor = !1, this.m_userData = {}, this.m_body = v, this.m_shape = _.shape.Clone(), _.userData && this.SetUserData(_.userData), this.m_friction = (g = _.friction) !== null && g !== void 0 ? g : 0.2, this.m_restitution = (w = _.restitution) !== null && w !== void 0 ? w : 0, this.m_restitutionThreshold = (S = _.restitutionThreshold) !== null && S !== void 0 ? S : o.b2_lengthUnitsPerMeter, this.m_filter = {
        ...n.b2DefaultFilter,
        ..._.filter
      }, this.m_isSensor = (x = _.isSensor) !== null && x !== void 0 ? x : !1, this.m_density = (A = _.density) !== null && A !== void 0 ? A : 0;
    }
    GetType() {
      return this.m_shape.GetType();
    }
    GetShape() {
      return this.m_shape;
    }
    SetSensor(v) {
      v !== this.m_isSensor && (this.m_body.SetAwake(!0), this.m_isSensor = v);
    }
    IsSensor() {
      return this.m_isSensor;
    }
    SetFilterData(v) {
      var _, g, w;
      this.m_filter.categoryBits = (_ = v.categoryBits) !== null && _ !== void 0 ? _ : n.b2DefaultFilter.categoryBits, this.m_filter.groupIndex = (g = v.groupIndex) !== null && g !== void 0 ? g : n.b2DefaultFilter.groupIndex, this.m_filter.maskBits = (w = v.maskBits) !== null && w !== void 0 ? w : n.b2DefaultFilter.maskBits, this.Refilter();
    }
    GetFilterData() {
      return this.m_filter;
    }
    Refilter() {
      let v = this.m_body.GetContactList();
      for (; v; ) {
        const { contact: w } = v, S = w.GetFixtureA(), x = w.GetFixtureB();
        (S === this || x === this) && w.FlagForFiltering(), v = v.next;
      }
      const g = this.m_body.GetWorld().m_contactManager.m_broadPhase;
      for (const w of this.m_proxies)
        g.TouchProxy(w.treeNode);
    }
    GetBody() {
      return this.m_body;
    }
    GetNext() {
      return this.m_next;
    }
    GetUserData() {
      return this.m_userData;
    }
    SetUserData(v) {
      Object.assign(this.m_userData, v);
    }
    TestPoint(v) {
      return this.m_shape.TestPoint(this.m_body.GetTransform(), v);
    }
    RayCast(v, _, g) {
      return this.m_shape.RayCast(v, _, this.m_body.GetTransform(), g);
    }
    GetMassData(v = new s.b2MassData()) {
      return this.m_shape.ComputeMass(v, this.m_density), v;
    }
    SetDensity(v) {
      this.m_density = v;
    }
    GetDensity() {
      return this.m_density;
    }
    GetFriction() {
      return this.m_friction;
    }
    SetFriction(v) {
      this.m_friction = v;
    }
    GetRestitution() {
      return this.m_restitution;
    }
    SetRestitution(v) {
      this.m_restitution = v;
    }
    GetRestitutionThreshold() {
      return this.m_restitutionThreshold;
    }
    SetRestitutionThreshold(v) {
      this.m_restitutionThreshold = v;
    }
    GetAABB(v) {
      return this.m_proxies[v].aabb;
    }
    CreateProxies(v, _) {
      (0, i.b2Assert)(this.m_proxies.length === 0), this.m_proxies.length = this.m_shape.GetChildCount();
      for (let g = 0; g < this.m_proxies.length; ++g)
        this.m_proxies[g] = new a(this, v, _, g);
    }
    DestroyProxies(v) {
      for (const _ of this.m_proxies)
        v.DestroyProxy(_.treeNode);
      this.m_proxies.length = 0;
    }
    Synchronize(v, _, g) {
      const { c1: w, c2: S } = r, x = u;
      for (const A of this.m_proxies) {
        const C = l, M = c;
        this.m_shape.ComputeAABB(C, _, A.childIndex), this.m_shape.ComputeAABB(M, g, A.childIndex), A.aabb.Combine2(C, M), t.b2Vec2.Subtract(M.GetCenter(S), C.GetCenter(w), x), v.MoveProxy(A.treeNode, A.aabb, x);
      }
    }
  };
  h(f, "b2Fixture");
  let m = f;
  n.b2Fixture = m;
})(Om);
za(Om);
Object.defineProperty(to, "__esModule", { value: !0 });
to.b2Body = to.b2BodyType = void 0;
const Le = Fe, G8 = wi, H8 = Om, rc = Xe;
var Vn;
(function(n) {
  n[n.b2_staticBody = 0] = "b2_staticBody", n[n.b2_kinematicBody = 1] = "b2_kinematicBody", n[n.b2_dynamicBody = 2] = "b2_dynamicBody";
})(Vn || (to.b2BodyType = Vn = {}));
const or = class or {
  constructor(t, e) {
    var s, i, o, r, a, l, c, u, m, d, f, p, v, _;
    this.m_type = Vn.b2_staticBody, this.m_islandFlag = !1, this.m_awakeFlag = !1, this.m_autoSleepFlag = !1, this.m_bulletFlag = !1, this.m_fixedRotationFlag = !1, this.m_enabledFlag = !1, this.m_toiFlag = !1, this.m_islandIndex = 0, this.m_xf = new Le.b2Transform(), this.m_sweep = new Le.b2Sweep(), this.m_linearVelocity = new Le.b2Vec2(), this.m_angularVelocity = 0, this.m_force = new Le.b2Vec2(), this.m_torque = 0, this.m_prev = null, this.m_next = null, this.m_fixtureList = null, this.m_fixtureCount = 0, this.m_jointList = null, this.m_contactList = null, this.m_mass = 1, this.m_invMass = 1, this.m_I = 0, this.m_invI = 0, this.m_linearDamping = 0, this.m_angularDamping = 0, this.m_gravityScale = 1, this.m_sleepTime = 0, this.m_userData = {}, this.m_bulletFlag = (s = t.bullet) !== null && s !== void 0 ? s : !1, this.m_fixedRotationFlag = (i = t.fixedRotation) !== null && i !== void 0 ? i : !1, this.m_autoSleepFlag = (o = t.allowSleep) !== null && o !== void 0 ? o : !0, (!((r = t.awake) !== null && r !== void 0) || r) && ((a = t.type) !== null && a !== void 0 ? a : Vn.b2_staticBody) !== Vn.b2_staticBody && (this.m_awakeFlag = !0), this.m_enabledFlag = (l = t.enabled) !== null && l !== void 0 ? l : !0, this.m_world = e, this.m_xf.p.Copy((c = t.position) !== null && c !== void 0 ? c : Le.b2Vec2.ZERO), this.m_xf.q.Set((u = t.angle) !== null && u !== void 0 ? u : 0), this.m_sweep.localCenter.SetZero(), this.m_sweep.c0.Copy(this.m_xf.p), this.m_sweep.c.Copy(this.m_xf.p), this.m_sweep.a0 = this.m_sweep.a = this.m_xf.q.GetAngle(), this.m_sweep.alpha0 = 0, this.m_linearVelocity.Copy((m = t.linearVelocity) !== null && m !== void 0 ? m : Le.b2Vec2.ZERO), this.m_angularVelocity = (d = t.angularVelocity) !== null && d !== void 0 ? d : 0, this.m_linearDamping = (f = t.linearDamping) !== null && f !== void 0 ? f : 0, this.m_angularDamping = (p = t.angularDamping) !== null && p !== void 0 ? p : 0, this.m_gravityScale = (v = t.gravityScale) !== null && v !== void 0 ? v : 1, this.m_force.SetZero(), this.m_torque = 0, this.m_sleepTime = 0, this.m_type = (_ = t.type) !== null && _ !== void 0 ? _ : Vn.b2_staticBody, this.m_mass = 0, this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, t.userData && this.SetUserData(t.userData), this.m_fixtureList = null, this.m_fixtureCount = 0;
  }
  CreateFixture(t) {
    (0, rc.b2Assert)(!this.m_world.IsLocked());
    const e = new H8.b2Fixture(this, t);
    if (this.m_enabledFlag) {
      const s = this.m_world.m_contactManager.m_broadPhase;
      e.CreateProxies(s, this.m_xf);
    }
    return e.m_next = this.m_fixtureList, this.m_fixtureList = e, ++this.m_fixtureCount, e.m_density > 0 && this.ResetMassData(), this.m_world.m_newContacts = !0, e;
  }
  DestroyFixture(t) {
    (0, rc.b2Assert)(!this.m_world.IsLocked());
    let e = this.m_fixtureList, s = null;
    for (; e !== null; ) {
      if (e === t) {
        s ? s.m_next = t.m_next : this.m_fixtureList = t.m_next;
        break;
      }
      s = e, e = e.m_next;
    }
    const i = t.m_density;
    let o = this.m_contactList;
    for (; o; ) {
      const r = o.contact;
      o = o.next;
      const a = r.GetFixtureA(), l = r.GetFixtureB();
      (t === a || t === l) && this.m_world.m_contactManager.Destroy(r);
    }
    if (this.m_enabledFlag) {
      const r = this.m_world.m_contactManager.m_broadPhase;
      t.DestroyProxies(r);
    }
    t.m_next = null, --this.m_fixtureCount, i > 0 && this.ResetMassData();
  }
  SetTransformVec(t, e) {
    this.SetTransformXY(t.x, t.y, e);
  }
  SetTransformXY(t, e, s) {
    (0, rc.b2Assert)(!this.m_world.IsLocked()), this.m_xf.q.Set(s), this.m_xf.p.Set(t, e), Le.b2Transform.MultiplyVec2(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.a = s, this.m_sweep.c0.Copy(this.m_sweep.c), this.m_sweep.a0 = s;
    const i = this.m_world.m_contactManager.m_broadPhase;
    for (let o = this.m_fixtureList; o; o = o.m_next)
      o.Synchronize(i, this.m_xf, this.m_xf);
    this.m_world.m_newContacts = !0;
  }
  SetTransform(t) {
    this.SetTransformVec(t.p, t.GetAngle());
  }
  GetTransform() {
    return this.m_xf;
  }
  GetPosition() {
    return this.m_xf.p;
  }
  GetAngle() {
    return this.m_sweep.a;
  }
  SetAngle(t) {
    this.SetTransformVec(this.GetPosition(), t);
  }
  GetWorldCenter() {
    return this.m_sweep.c;
  }
  GetLocalCenter() {
    return this.m_sweep.localCenter;
  }
  SetLinearVelocity(t) {
    this.m_type !== Vn.b2_staticBody && (Le.b2Vec2.Dot(t, t) > 0 && this.SetAwake(!0), this.m_linearVelocity.Copy(t));
  }
  GetLinearVelocity() {
    return this.m_linearVelocity;
  }
  SetAngularVelocity(t) {
    this.m_type !== Vn.b2_staticBody && (t * t > 0 && this.SetAwake(!0), this.m_angularVelocity = t);
  }
  GetAngularVelocity() {
    return this.m_angularVelocity;
  }
  ApplyForce(t, e, s = !0) {
    this.m_type === Vn.b2_dynamicBody && (s && !this.m_awakeFlag && this.SetAwake(!0), this.m_awakeFlag && (this.m_force.x += t.x, this.m_force.y += t.y, this.m_torque += (e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x));
  }
  ApplyForceToCenter(t, e = !0) {
    this.m_type === Vn.b2_dynamicBody && (e && !this.m_awakeFlag && this.SetAwake(!0), this.m_awakeFlag && (this.m_force.x += t.x, this.m_force.y += t.y));
  }
  ApplyTorque(t, e = !0) {
    this.m_type === Vn.b2_dynamicBody && (e && !this.m_awakeFlag && this.SetAwake(!0), this.m_awakeFlag && (this.m_torque += t));
  }
  ApplyLinearImpulse(t, e, s = !0) {
    this.m_type === Vn.b2_dynamicBody && (s && !this.m_awakeFlag && this.SetAwake(!0), this.m_awakeFlag && (this.m_linearVelocity.x += this.m_invMass * t.x, this.m_linearVelocity.y += this.m_invMass * t.y, this.m_angularVelocity += this.m_invI * ((e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x)));
  }
  ApplyLinearImpulseToCenter(t, e = !0) {
    this.m_type === Vn.b2_dynamicBody && (e && !this.m_awakeFlag && this.SetAwake(!0), this.m_awakeFlag && (this.m_linearVelocity.x += this.m_invMass * t.x, this.m_linearVelocity.y += this.m_invMass * t.y));
  }
  ApplyAngularImpulse(t, e = !0) {
    this.m_type === Vn.b2_dynamicBody && (e && !this.m_awakeFlag && this.SetAwake(!0), this.m_awakeFlag && (this.m_angularVelocity += this.m_invI * t));
  }
  GetMass() {
    return this.m_mass;
  }
  GetInertia() {
    return this.m_I + this.m_mass * Le.b2Vec2.Dot(this.m_sweep.localCenter, this.m_sweep.localCenter);
  }
  GetMassData(t) {
    return t.mass = this.m_mass, t.I = this.m_I + this.m_mass * Le.b2Vec2.Dot(this.m_sweep.localCenter, this.m_sweep.localCenter), t.center.Copy(this.m_sweep.localCenter), t;
  }
  SetMassData(t) {
    if ((0, rc.b2Assert)(!this.m_world.IsLocked()), this.m_type !== Vn.b2_dynamicBody)
      return;
    this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_mass = t.mass, this.m_mass <= 0 && (this.m_mass = 1), this.m_invMass = 1 / this.m_mass, t.I > 0 && !this.m_fixedRotationFlag && (this.m_I = t.I - this.m_mass * Le.b2Vec2.Dot(t.center, t.center), this.m_invI = 1 / this.m_I);
    const e = or.SetMassData_s_oldCenter.Copy(this.m_sweep.c);
    this.m_sweep.localCenter.Copy(t.center), Le.b2Transform.MultiplyVec2(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.c0.Copy(this.m_sweep.c), Le.b2Vec2.AddCrossScalarVec2(this.m_linearVelocity, this.m_angularVelocity, Le.b2Vec2.Subtract(this.m_sweep.c, e, Le.b2Vec2.s_t0), this.m_linearVelocity);
  }
  ResetMassData() {
    if (this.m_mass = 0, this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_sweep.localCenter.SetZero(), this.m_type === Vn.b2_staticBody || this.m_type === Vn.b2_kinematicBody) {
      this.m_sweep.c0.Copy(this.m_xf.p), this.m_sweep.c.Copy(this.m_xf.p), this.m_sweep.a0 = this.m_sweep.a;
      return;
    }
    const t = or.ResetMassData_s_localCenter.SetZero();
    for (let s = this.m_fixtureList; s; s = s.m_next) {
      if (s.m_density === 0)
        continue;
      const i = s.GetMassData(or.ResetMassData_s_massData);
      this.m_mass += i.mass, t.AddScaled(i.mass, i.center), this.m_I += i.I;
    }
    this.m_mass > 0 && (this.m_invMass = 1 / this.m_mass, t.Scale(this.m_invMass)), this.m_I > 0 && !this.m_fixedRotationFlag ? (this.m_I -= this.m_mass * Le.b2Vec2.Dot(t, t), this.m_invI = 1 / this.m_I) : (this.m_I = 0, this.m_invI = 0);
    const e = or.ResetMassData_s_oldCenter.Copy(this.m_sweep.c);
    this.m_sweep.localCenter.Copy(t), Le.b2Transform.MultiplyVec2(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.c0.Copy(this.m_sweep.c), Le.b2Vec2.AddCrossScalarVec2(this.m_linearVelocity, this.m_angularVelocity, Le.b2Vec2.Subtract(this.m_sweep.c, e, Le.b2Vec2.s_t0), this.m_linearVelocity);
  }
  GetWorldPoint(t, e) {
    return Le.b2Transform.MultiplyVec2(this.m_xf, t, e);
  }
  GetWorldVector(t, e) {
    return Le.b2Rot.MultiplyVec2(this.m_xf.q, t, e);
  }
  GetLocalPoint(t, e) {
    return Le.b2Transform.TransposeMultiplyVec2(this.m_xf, t, e);
  }
  GetLocalVector(t, e) {
    return Le.b2Rot.TransposeMultiplyVec2(this.m_xf.q, t, e);
  }
  GetLinearVelocityFromWorldPoint(t, e) {
    return Le.b2Vec2.AddCrossScalarVec2(this.m_linearVelocity, this.m_angularVelocity, Le.b2Vec2.Subtract(t, this.m_sweep.c, Le.b2Vec2.s_t0), e);
  }
  GetLinearVelocityFromLocalPoint(t, e) {
    return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(t, e), e);
  }
  GetLinearDamping() {
    return this.m_linearDamping;
  }
  SetLinearDamping(t) {
    this.m_linearDamping = t;
  }
  GetAngularDamping() {
    return this.m_angularDamping;
  }
  SetAngularDamping(t) {
    this.m_angularDamping = t;
  }
  GetGravityScale() {
    return this.m_gravityScale;
  }
  SetGravityScale(t) {
    this.m_gravityScale = t;
  }
  SetType(t) {
    if ((0, rc.b2Assert)(!this.m_world.IsLocked()), this.m_type === t)
      return;
    this.m_type = t, this.ResetMassData(), this.m_type === Vn.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_sweep.a0 = this.m_sweep.a, this.m_sweep.c0.Copy(this.m_sweep.c), this.m_awakeFlag = !1, this.SynchronizeFixtures()), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0;
    let e = this.m_contactList;
    for (; e; ) {
      const i = e;
      e = e.next, this.m_world.m_contactManager.Destroy(i.contact);
    }
    this.m_contactList = null;
    const s = this.m_world.m_contactManager.m_broadPhase;
    for (let i = this.m_fixtureList; i; i = i.m_next)
      for (const o of i.m_proxies)
        s.TouchProxy(o.treeNode);
  }
  GetType() {
    return this.m_type;
  }
  SetBullet(t) {
    this.m_bulletFlag = t;
  }
  IsBullet() {
    return this.m_bulletFlag;
  }
  SetSleepingAllowed(t) {
    this.m_autoSleepFlag = t, t || this.SetAwake(!0);
  }
  IsSleepingAllowed() {
    return this.m_autoSleepFlag;
  }
  SetAwake(t) {
    this.m_type !== Vn.b2_staticBody && (t ? (this.m_awakeFlag = !0, this.m_sleepTime = 0) : (this.m_awakeFlag = !1, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0));
  }
  IsAwake() {
    return this.m_awakeFlag;
  }
  SetEnabled(t) {
    if ((0, rc.b2Assert)(!this.m_world.IsLocked()), t === this.IsEnabled())
      return;
    this.m_enabledFlag = t;
    const e = this.m_world.m_contactManager.m_broadPhase;
    if (t) {
      for (let s = this.m_fixtureList; s; s = s.m_next)
        s.CreateProxies(e, this.m_xf);
      this.m_world.m_newContacts = !0;
    } else {
      for (let i = this.m_fixtureList; i; i = i.m_next)
        i.DestroyProxies(e);
      let s = this.m_contactList;
      for (; s; ) {
        const i = s;
        s = s.next, this.m_world.m_contactManager.Destroy(i.contact);
      }
      this.m_contactList = null;
    }
  }
  IsEnabled() {
    return this.m_enabledFlag;
  }
  SetFixedRotation(t) {
    this.m_fixedRotationFlag !== t && (this.m_fixedRotationFlag = t, this.m_angularVelocity = 0, this.ResetMassData());
  }
  IsFixedRotation() {
    return this.m_fixedRotationFlag;
  }
  GetFixtureList() {
    return this.m_fixtureList;
  }
  GetJointList() {
    return this.m_jointList;
  }
  GetContactList() {
    return this.m_contactList;
  }
  GetNext() {
    return this.m_next;
  }
  GetUserData() {
    return this.m_userData;
  }
  SetUserData(t) {
    Object.assign(this.m_userData, t);
  }
  GetWorld() {
    return this.m_world;
  }
  SynchronizeFixtures() {
    const t = this.m_world.m_contactManager.m_broadPhase;
    if (this.m_awakeFlag) {
      const e = or.SynchronizeFixtures_s_xf1;
      e.q.Set(this.m_sweep.a0), Le.b2Rot.MultiplyVec2(e.q, this.m_sweep.localCenter, e.p), Le.b2Vec2.Subtract(this.m_sweep.c0, e.p, e.p);
      for (let s = this.m_fixtureList; s; s = s.m_next)
        s.Synchronize(t, e, this.m_xf);
    } else
      for (let e = this.m_fixtureList; e; e = e.m_next)
        e.Synchronize(t, this.m_xf, this.m_xf);
  }
  SynchronizeTransform() {
    this.m_xf.q.Set(this.m_sweep.a), Le.b2Rot.MultiplyVec2(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p), Le.b2Vec2.Subtract(this.m_sweep.c, this.m_xf.p, this.m_xf.p);
  }
  ShouldCollide(t) {
    return this.m_type !== Vn.b2_dynamicBody && t.m_type !== Vn.b2_dynamicBody ? !1 : this.ShouldCollideConnected(t);
  }
  ShouldCollideConnected(t) {
    for (let e = this.m_jointList; e; e = e.next)
      if (e.other === t && !e.joint.m_collideConnected)
        return !1;
    return !0;
  }
  Advance(t) {
    this.m_sweep.Advance(t), this.m_sweep.c.Copy(this.m_sweep.c0), this.m_sweep.a = this.m_sweep.a0, this.m_xf.q.Set(this.m_sweep.a), Le.b2Rot.MultiplyVec2(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p), Le.b2Vec2.Subtract(this.m_sweep.c, this.m_xf.p, this.m_xf.p);
  }
};
h(or, "b2Body");
let wr = or;
to.b2Body = wr;
wr.SetMassData_s_oldCenter = new Le.b2Vec2();
wr.ResetMassData_s_localCenter = new Le.b2Vec2();
wr.ResetMassData_s_oldCenter = new Le.b2Vec2();
wr.ResetMassData_s_massData = new G8.b2MassData();
wr.SynchronizeFixtures_s_xf1 = new Le.b2Transform();
Object.defineProperty(Ti, "__esModule", { value: !0 });
Ti.DrawCenterOfMasses = Ti.DrawAABBs = Ti.DrawPairs = Ti.DrawJoints = Ti.DrawShapes = Ti.GetShapeColor = void 0;
const Eh = Fe, ir = Ai, tp = to, j8 = Xe, Bd = {
  cA: new Eh.b2Vec2(),
  cB: new Eh.b2Vec2(),
  vs: (0, j8.b2MakeArray)(4, Eh.b2Vec2),
  xf: new Eh.b2Transform()
};
function rI(n) {
  return n.GetType() === tp.b2BodyType.b2_dynamicBody && n.m_mass === 0 ? ir.debugColors.badBody : n.IsEnabled() ? n.GetType() === tp.b2BodyType.b2_staticBody ? ir.debugColors.staticBody : n.GetType() === tp.b2BodyType.b2_kinematicBody ? ir.debugColors.kinematicBody : n.IsAwake() ? ir.debugColors.body : ir.debugColors.sleepingBody : ir.debugColors.disabledBody;
}
h(rI, "GetShapeColor");
Ti.GetShapeColor = rI;
function W8(n, t) {
  for (let e = 0; e < n.m_proxyCount; e++)
    if (t.TestOverlap(n.GetAABB(e)))
      return !0;
  return !1;
}
h(W8, "testOverlap");
function q8(n, t, e) {
  for (let s = t.GetBodyList(); s; s = s.m_next) {
    const i = s.m_xf;
    n.PushTransform(i);
    for (let o = s.GetFixtureList(); o; o = o.m_next)
      e && !W8(o, e) || o.GetShape().Draw(n, rI(s));
    n.PopTransform(i);
  }
}
h(q8, "DrawShapes");
Ti.DrawShapes = q8;
function X8(n, t) {
  for (let e = t.GetJointList(); e; e = e.m_next)
    e.Draw(n);
}
h(X8, "DrawJoints");
Ti.DrawJoints = X8;
function Z8(n, t) {
  for (let e = t.GetContactList(); e; e = e.m_next) {
    const s = e.GetFixtureA(), i = e.GetFixtureB(), o = e.GetChildIndexA(), r = e.GetChildIndexB(), a = s.GetAABB(o).GetCenter(Bd.cA), l = i.GetAABB(r).GetCenter(Bd.cB);
    n.DrawSegment(a, l, ir.debugColors.pair);
  }
}
h(Z8, "DrawPairs");
Ti.DrawPairs = Z8;
function Y8(n, t, e) {
  const { vs: s } = Bd;
  for (let i = t.GetBodyList(); i; i = i.m_next)
    if (i.IsEnabled())
      for (let o = i.GetFixtureList(); o; o = o.m_next)
        for (let r = 0; r < o.m_proxyCount; ++r) {
          const { aabb: a } = o.m_proxies[r].treeNode;
          e && !e.TestOverlap(a) || (s[0].Set(a.lowerBound.x, a.lowerBound.y), s[1].Set(a.upperBound.x, a.lowerBound.y), s[2].Set(a.upperBound.x, a.upperBound.y), s[3].Set(a.lowerBound.x, a.upperBound.y), n.DrawPolygon(s, 4, ir.debugColors.aabb));
        }
}
h(Y8, "DrawAABBs");
Ti.DrawAABBs = Y8;
function J8(n, t) {
  const { xf: e } = Bd;
  for (let s = t.GetBodyList(); s; s = s.m_next)
    e.q.Copy(s.m_xf.q), e.p.Copy(s.GetWorldCenter()), n.DrawTransform(e);
}
h(J8, "DrawCenterOfMasses");
Ti.DrawCenterOfMasses = J8;
var ka = {};
Object.defineProperty(ka, "__esModule", { value: !0 });
ka.b2Timer = void 0;
const Oy = class Oy {
  constructor() {
    this.m_start = performance.now();
  }
  Reset() {
    return this.m_start = performance.now(), this;
  }
  GetMilliseconds() {
    return performance.now() - this.m_start;
  }
};
h(Oy, "b2Timer");
let c0 = Oy;
ka.b2Timer = c0;
var Fm = {};
Object.defineProperty(Fm, "__esModule", { value: !0 });
Fm.b2_augment = void 0;
function K8(n, t) {
  for (const e of Object.keys(t)) {
    const s = t[e], i = n[e], o = /* @__PURE__ */ h(function(...r) {
      return s.call(this, i.bind(this), ...r);
    }, "wrapper");
    Object.defineProperty(o, "name", { value: e }), n[e] = o;
  }
}
h(K8, "b2_augment");
Fm.b2_augment = K8;
var aI = {};
Object.defineProperty(aI, "__esModule", { value: !0 });
var ku = {}, xa = {};
Object.defineProperty(xa, "__esModule", { value: !0 });
xa.b2DynamicTree = xa.b2TreeNode = void 0;
const bn = Xe, Gn = Fe, jr = ge, go = {
  stack: [],
  t: new Gn.b2Vec2(),
  r: new Gn.b2Vec2(),
  v: new Gn.b2Vec2(),
  abs_v: new Gn.b2Vec2(),
  segmentAABB: new jr.b2AABB(),
  subInput: new jr.b2RayCastInput(),
  combinedAABB: new jr.b2AABB(),
  aabb: new jr.b2AABB(),
  fatAABB: new jr.b2AABB(),
  hugeAABB: new jr.b2AABB(),
  c: new Gn.b2Vec2(),
  h: new Gn.b2Vec2()
};
let Q8 = 0;
const $y = class $y {
  constructor() {
    this.aabb = new jr.b2AABB(), this.userData = null, this.parent = null, this.child1 = null, this.child2 = null, this.height = 0, this.moved = !1, this.id = Q8++;
  }
  Reset() {
    this.child1 = null, this.child2 = null, this.height = -1, this.userData = null;
  }
  IsLeaf() {
    return this.child1 === null;
  }
  GetArea() {
    if (this.IsLeaf())
      return 0;
    let t = this.aabb.GetPerimeter();
    return this.child1 && (t += this.child1.GetArea()), this.child2 && (t += this.child2.GetArea()), t;
  }
  ComputeHeight() {
    if (this.IsLeaf())
      return 0;
    (0, bn.b2Assert)(this.child1 !== null && this.child2 !== null);
    const t = (0, bn.b2Verify)(this.child1).ComputeHeight(), e = (0, bn.b2Verify)(this.child2).ComputeHeight();
    return 1 + Math.max(t, e);
  }
  GetMaxBalance() {
    if (this.height <= 1)
      return 0;
    const t = (0, bn.b2Verify)(this.child1), e = (0, bn.b2Verify)(this.child2);
    return Math.max(t.GetMaxBalance(), e.GetMaxBalance(), Math.abs(e.height - t.height));
  }
  ShiftOrigin(t) {
    this.height <= 1 || ((0, bn.b2Verify)(this.child1).ShiftOrigin(t), (0, bn.b2Verify)(this.child2).ShiftOrigin(t), this.aabb.lowerBound.Subtract(t), this.aabb.upperBound.Subtract(t));
  }
};
h($y, "b2TreeNode");
let Pd = $y;
xa.b2TreeNode = Pd;
const Fy = class Fy {
  constructor() {
    this.m_root = null, this.m_freeList = null;
  }
  Query(t, e) {
    const s = go.stack;
    s.length = 0;
    let i = this.m_root;
    for (; i; ) {
      if (i.aabb.TestOverlap(t))
        if (i.IsLeaf()) {
          if (!e(i))
            return;
        } else
          s.push(i.child1), s.push(i.child2);
      i = s.pop();
    }
  }
  QueryPoint(t, e) {
    const s = go.stack;
    s.length = 0;
    let i = this.m_root;
    for (; i; ) {
      if (i.aabb.TestContain(t))
        if (i.IsLeaf()) {
          if (!e(i))
            return;
        } else
          s.push(i.child1), s.push(i.child2);
      i = s.pop();
    }
  }
  RayCast(t, e) {
    const { p1: s, p2: i } = t, o = Gn.b2Vec2.Subtract(i, s, go.r);
    o.Normalize();
    const r = Gn.b2Vec2.CrossOneVec2(o, go.v), a = r.GetAbs(go.abs_v);
    let { maxFraction: l } = t;
    const { segmentAABB: c, subInput: u, c: m, h: d, t: f } = go;
    Gn.b2Vec2.AddScaled(s, l, Gn.b2Vec2.Subtract(i, s, f), f), Gn.b2Vec2.Min(s, f, c.lowerBound), Gn.b2Vec2.Max(s, f, c.upperBound);
    const p = go.stack;
    p.length = 0;
    let v = this.m_root;
    for (; v; ) {
      if (!v.aabb.TestOverlap(c)) {
        v = p.pop();
        continue;
      }
      if (v.aabb.GetCenter(m), v.aabb.GetExtents(d), Math.abs(Gn.b2Vec2.Dot(r, Gn.b2Vec2.Subtract(s, m, Gn.b2Vec2.s_t0))) - Gn.b2Vec2.Dot(a, d) > 0) {
        v = p.pop();
        continue;
      }
      if (v.IsLeaf()) {
        u.p1.Copy(t.p1), u.p2.Copy(t.p2), u.maxFraction = l;
        const g = e(u, v);
        if (g === 0)
          return;
        g > 0 && (l = g, Gn.b2Vec2.AddScaled(s, l, Gn.b2Vec2.Subtract(i, s, f), f), Gn.b2Vec2.Min(s, f, c.lowerBound), Gn.b2Vec2.Max(s, f, c.upperBound));
      } else
        p.push(v.child1), p.push(v.child2);
      v = p.pop();
    }
  }
  AllocateNode() {
    if (this.m_freeList === null)
      return new Pd();
    const t = this.m_freeList;
    return this.m_freeList = t.parent, t.parent = null, t.child1 = null, t.child2 = null, t.height = 0, t.moved = !1, t;
  }
  FreeNode(t) {
    t.parent = this.m_freeList, t.Reset(), this.m_freeList = t;
  }
  CreateProxy(t, e) {
    const s = this.AllocateNode(), i = bn.b2_aabbExtension;
    return s.aabb.lowerBound.Set(t.lowerBound.x - i, t.lowerBound.y - i), s.aabb.upperBound.Set(t.upperBound.x + i, t.upperBound.y + i), s.userData = e, s.height = 0, s.moved = !0, this.InsertLeaf(s), s;
  }
  DestroyProxy(t) {
    this.RemoveLeaf(t), this.FreeNode(t);
  }
  MoveProxy(t, e, s) {
    const { fatAABB: i, hugeAABB: o } = go, r = bn.b2_aabbExtension;
    i.lowerBound.Set(e.lowerBound.x - r, e.lowerBound.y - r), i.upperBound.Set(e.upperBound.x + r, e.upperBound.y + r);
    const a = bn.b2_aabbMultiplier * s.x, l = bn.b2_aabbMultiplier * s.y;
    a < 0 ? i.lowerBound.x += a : i.upperBound.x += a, l < 0 ? i.lowerBound.y += l : i.upperBound.y += l;
    const c = t.aabb;
    if (c.Contains(e)) {
      const u = 4 * bn.b2_aabbExtension;
      if (o.lowerBound.Set(i.lowerBound.x - u, e.lowerBound.y - u), o.upperBound.Set(i.upperBound.x + u, e.upperBound.y + u), o.Contains(c))
        return !1;
    }
    return this.RemoveLeaf(t), t.aabb.Copy(i), this.InsertLeaf(t), t.moved = !0, !0;
  }
  InsertLeaf(t) {
    if (this.m_root === null) {
      this.m_root = t, this.m_root.parent = null;
      return;
    }
    const { combinedAABB: e, aabb: s } = go, i = t.aabb;
    let o = this.m_root;
    for (; !o.IsLeaf(); ) {
      const c = (0, bn.b2Verify)(o.child1), u = (0, bn.b2Verify)(o.child2), m = o.aabb.GetPerimeter();
      e.Combine2(o.aabb, i);
      const d = e.GetPerimeter(), f = 2 * d, p = 2 * (d - m);
      let v, _, g;
      c.IsLeaf() ? (s.Combine2(i, c.aabb), v = s.GetPerimeter() + p) : (s.Combine2(i, c.aabb), _ = c.aabb.GetPerimeter(), g = s.GetPerimeter(), v = g - _ + p);
      let w;
      if (u.IsLeaf() ? (s.Combine2(i, u.aabb), w = s.GetPerimeter() + p) : (s.Combine2(i, u.aabb), _ = u.aabb.GetPerimeter(), g = s.GetPerimeter(), w = g - _ + p), f < v && f < w)
        break;
      v < w ? o = c : o = u;
    }
    const r = o.parent, a = this.AllocateNode();
    a.parent = r, a.userData = null, a.aabb.Combine2(i, o.aabb), a.height = o.height + 1, r !== null ? (r.child1 === o ? r.child1 = a : r.child2 = a, a.child1 = o, a.child2 = t, o.parent = a, t.parent = a) : (a.child1 = o, a.child2 = t, o.parent = a, t.parent = a, this.m_root = a);
    let l = t.parent;
    for (; l !== null; ) {
      l = this.Balance(l);
      const c = (0, bn.b2Verify)(l.child1), u = (0, bn.b2Verify)(l.child2);
      l.height = 1 + Math.max(c.height, u.height), l.aabb.Combine2(c.aabb, u.aabb), l = l.parent;
    }
  }
  RemoveLeaf(t) {
    if (t === this.m_root) {
      this.m_root = null;
      return;
    }
    const e = (0, bn.b2Verify)(t.parent), s = e.parent, i = (0, bn.b2Verify)(e.child1 === t ? e.child2 : e.child1);
    if (s !== null) {
      s.child1 === e ? s.child1 = i : s.child2 = i, i.parent = s, this.FreeNode(e);
      let o = s;
      for (; o !== null; ) {
        o = this.Balance(o);
        const r = (0, bn.b2Verify)(o.child1), a = (0, bn.b2Verify)(o.child2);
        o.aabb.Combine2(r.aabb, a.aabb), o.height = 1 + Math.max(r.height, a.height), o = o.parent;
      }
    } else
      this.m_root = i, i.parent = null, this.FreeNode(e);
  }
  Balance(t) {
    if (t.IsLeaf() || t.height < 2)
      return t;
    const e = (0, bn.b2Verify)(t.child1), s = (0, bn.b2Verify)(t.child2), i = s.height - e.height;
    if (i > 1) {
      const o = (0, bn.b2Verify)(s.child1), r = (0, bn.b2Verify)(s.child2);
      return s.child1 = t, s.parent = t.parent, t.parent = s, s.parent !== null ? s.parent.child1 === t ? s.parent.child1 = s : s.parent.child2 = s : this.m_root = s, o.height > r.height ? (s.child2 = o, t.child2 = r, r.parent = t, t.aabb.Combine2(e.aabb, r.aabb), s.aabb.Combine2(t.aabb, o.aabb), t.height = 1 + Math.max(e.height, r.height), s.height = 1 + Math.max(t.height, o.height)) : (s.child2 = r, t.child2 = o, o.parent = t, t.aabb.Combine2(e.aabb, o.aabb), s.aabb.Combine2(t.aabb, r.aabb), t.height = 1 + Math.max(e.height, o.height), s.height = 1 + Math.max(t.height, r.height)), s;
    }
    if (i < -1) {
      const o = (0, bn.b2Verify)(e.child1), r = (0, bn.b2Verify)(e.child2);
      return e.child1 = t, e.parent = t.parent, t.parent = e, e.parent !== null ? e.parent.child1 === t ? e.parent.child1 = e : e.parent.child2 = e : this.m_root = e, o.height > r.height ? (e.child2 = o, t.child1 = r, r.parent = t, t.aabb.Combine2(s.aabb, r.aabb), e.aabb.Combine2(t.aabb, o.aabb), t.height = 1 + Math.max(s.height, r.height), e.height = 1 + Math.max(t.height, o.height)) : (e.child2 = r, t.child1 = o, o.parent = t, t.aabb.Combine2(s.aabb, o.aabb), e.aabb.Combine2(t.aabb, r.aabb), t.height = 1 + Math.max(s.height, o.height), e.height = 1 + Math.max(t.height, r.height)), e;
    }
    return t;
  }
  GetHeight() {
    return this.m_root === null ? 0 : this.m_root.height;
  }
  GetAreaRatio() {
    if (this.m_root === null)
      return 0;
    const t = this.m_root, e = t.aabb.GetPerimeter();
    return t.GetArea() / e;
  }
  GetMaxBalance() {
    return this.m_root === null ? 0 : this.m_root.GetMaxBalance();
  }
  ShiftOrigin(t) {
    var e;
    (e = this.m_root) === null || e === void 0 || e.ShiftOrigin(t);
  }
};
h(Fy, "b2DynamicTree");
let l0 = Fy;
xa.b2DynamicTree = l0;
Object.defineProperty(ku, "__esModule", { value: !0 });
ku.b2BroadPhase = void 0;
const OS = Xe, $S = xa, Gy = class Gy {
  constructor() {
    this.m_tree = new $S.b2DynamicTree(), this.m_proxyCount = 0, this.m_moveCount = 0, this.m_moveBuffer = [], this.m_pairCount = 0, this.m_pairBuffer = [], this.m_queryProxy = new $S.b2TreeNode(), this.QueryCallback = (t) => (t.id === this.m_queryProxy.id || t.moved && t.id > this.m_queryProxy.id || (this.m_pairBuffer[this.m_pairCount] = t.id < this.m_queryProxy.id ? [t, this.m_queryProxy] : [this.m_queryProxy, t], ++this.m_pairCount), !0);
  }
  CreateProxy(t, e) {
    const s = this.m_tree.CreateProxy(t, e);
    return ++this.m_proxyCount, this.BufferMove(s), s;
  }
  DestroyProxy(t) {
    this.UnBufferMove(t), --this.m_proxyCount, this.m_tree.DestroyProxy(t);
  }
  MoveProxy(t, e, s) {
    this.m_tree.MoveProxy(t, e, s) && this.BufferMove(t);
  }
  TouchProxy(t) {
    this.BufferMove(t);
  }
  GetProxyCount() {
    return this.m_proxyCount;
  }
  UpdatePairs(t) {
    this.m_pairCount = 0;
    for (let e = 0; e < this.m_moveCount; ++e) {
      const s = this.m_moveBuffer[e];
      if (s === null)
        continue;
      this.m_queryProxy = s;
      const i = s.aabb;
      this.m_tree.Query(i, this.QueryCallback);
    }
    for (let e = 0; e < this.m_pairCount; ++e) {
      const s = this.m_pairBuffer[e], i = (0, OS.b2Verify)(s[0].userData), o = (0, OS.b2Verify)(s[1].userData);
      t(i, o);
    }
    for (let e = 0; e < this.m_moveCount; ++e) {
      const s = this.m_moveBuffer[e];
      s && (s.moved = !1);
    }
    this.m_moveCount = 0;
  }
  Query(t, e) {
    this.m_tree.Query(t, e);
  }
  QueryPoint(t, e) {
    this.m_tree.QueryPoint(t, e);
  }
  RayCast(t, e) {
    this.m_tree.RayCast(t, e);
  }
  GetTreeHeight() {
    return this.m_tree.GetHeight();
  }
  GetTreeBalance() {
    return this.m_tree.GetMaxBalance();
  }
  GetTreeQuality() {
    return this.m_tree.GetAreaRatio();
  }
  ShiftOrigin(t) {
    this.m_tree.ShiftOrigin(t);
  }
  BufferMove(t) {
    this.m_moveBuffer[this.m_moveCount] = t, ++this.m_moveCount;
  }
  UnBufferMove(t) {
    const e = this.m_moveBuffer.indexOf(t);
    this.m_moveBuffer[e] = null;
  }
};
h(Gy, "b2BroadPhase");
let u0 = Gy;
ku.b2BroadPhase = u0;
var Gm = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.b2TimeOfImpact = n.b2TOIOutput = n.b2TOIOutputState = n.b2TOIInput = n.b2Toi = void 0;
  const t = Xe, e = ps, s = Fe, i = ka, o = zu;
  n.b2Toi = {
    time: 0,
    maxTime: 0,
    calls: 0,
    iters: 0,
    maxIters: 0,
    rootIters: 0,
    maxRootIters: 0,
    reset() {
      this.time = 0, this.maxTime = 0, this.calls = 0, this.iters = 0, this.maxIters = 0, this.rootIters = 0, this.maxRootIters = 0;
    }
  };
  const r = new s.b2Transform(), a = new s.b2Transform(), l = new s.b2Vec2(), c = new s.b2Vec2(), u = new s.b2Vec2(), m = new s.b2Vec2(), d = new s.b2Vec2(), I = class I {
    constructor() {
      this.proxyA = new o.b2DistanceProxy(), this.proxyB = new o.b2DistanceProxy(), this.sweepA = new s.b2Sweep(), this.sweepB = new s.b2Sweep(), this.tMax = 0;
    }
  };
  h(I, "b2TOIInput");
  let f = I;
  n.b2TOIInput = f;
  var p;
  (function(N) {
    N[N.e_unknown = 0] = "e_unknown", N[N.e_failed = 1] = "e_failed", N[N.e_overlapped = 2] = "e_overlapped", N[N.e_touching = 3] = "e_touching", N[N.e_separated = 4] = "e_separated";
  })(p || (n.b2TOIOutputState = p = {}));
  const B = class B {
    constructor() {
      this.state = p.e_unknown, this.t = 0;
    }
  };
  h(B, "b2TOIOutput");
  let v = B;
  n.b2TOIOutput = v;
  var _;
  (function(N) {
    N[N.e_points = 0] = "e_points", N[N.e_faceA = 1] = "e_faceA", N[N.e_faceB = 2] = "e_faceB";
  })(_ || (_ = {}));
  const D = class D {
    constructor() {
      this.m_sweepA = new s.b2Sweep(), this.m_sweepB = new s.b2Sweep(), this.m_type = _.e_points, this.m_localPoint = new s.b2Vec2(), this.m_axis = new s.b2Vec2();
    }
    Initialize(V, G, U, j, tt, K) {
      this.m_proxyA = G, this.m_proxyB = j;
      const { count: $ } = V;
      this.m_sweepA.Copy(U), this.m_sweepB.Copy(tt);
      const lt = this.m_sweepA.GetTransform(r, K), gt = this.m_sweepB.GetTransform(a, K);
      if ($ === 1) {
        this.m_type = _.e_points;
        const _e = this.m_proxyA.GetVertex(V.indexA[0]), k = this.m_proxyB.GetVertex(V.indexB[0]), te = s.b2Transform.MultiplyVec2(lt, _e, l), It = s.b2Transform.MultiplyVec2(gt, k, c);
        return s.b2Vec2.Subtract(It, te, this.m_axis), this.m_axis.Normalize();
      }
      if (V.indexA[0] === V.indexA[1]) {
        this.m_type = _.e_faceB;
        const _e = this.m_proxyB.GetVertex(V.indexB[0]), k = this.m_proxyB.GetVertex(V.indexB[1]);
        s.b2Vec2.CrossVec2One(s.b2Vec2.Subtract(k, _e, s.b2Vec2.s_t0), this.m_axis).Normalize();
        const te = s.b2Rot.MultiplyVec2(gt.q, this.m_axis, u);
        s.b2Vec2.Mid(_e, k, this.m_localPoint);
        const It = s.b2Transform.MultiplyVec2(gt, this.m_localPoint, c), ut = this.m_proxyA.GetVertex(V.indexA[0]), bt = s.b2Transform.MultiplyVec2(lt, ut, l);
        let Ft = s.b2Vec2.Dot(s.b2Vec2.Subtract(bt, It, s.b2Vec2.s_t0), te);
        return Ft < 0 && (this.m_axis.Negate(), Ft = -Ft), Ft;
      }
      this.m_type = _.e_faceA;
      const _t = this.m_proxyA.GetVertex(V.indexA[0]), Y = this.m_proxyA.GetVertex(V.indexA[1]);
      s.b2Vec2.CrossVec2One(s.b2Vec2.Subtract(Y, _t, s.b2Vec2.s_t0), this.m_axis).Normalize();
      const it = s.b2Rot.MultiplyVec2(lt.q, this.m_axis, u);
      s.b2Vec2.Mid(_t, Y, this.m_localPoint);
      const J = s.b2Transform.MultiplyVec2(lt, this.m_localPoint, l), dt = this.m_proxyB.GetVertex(V.indexB[0]), vt = s.b2Transform.MultiplyVec2(gt, dt, c);
      let Nt = s.b2Vec2.Dot(s.b2Vec2.Subtract(vt, J, s.b2Vec2.s_t0), it);
      return Nt < 0 && (this.m_axis.Negate(), Nt = -Nt), Nt;
    }
    FindMinSeparation(V, G, U) {
      const j = this.m_sweepA.GetTransform(r, U), tt = this.m_sweepB.GetTransform(a, U);
      switch (this.m_type) {
        case _.e_points: {
          const K = s.b2Rot.TransposeMultiplyVec2(j.q, this.m_axis, m), $ = s.b2Rot.TransposeMultiplyVec2(tt.q, s.b2Vec2.Negate(this.m_axis, s.b2Vec2.s_t0), d);
          V[0] = this.m_proxyA.GetSupport(K), G[0] = this.m_proxyB.GetSupport($);
          const lt = this.m_proxyA.GetVertex(V[0]), gt = this.m_proxyB.GetVertex(G[0]), _t = s.b2Transform.MultiplyVec2(j, lt, l), Y = s.b2Transform.MultiplyVec2(tt, gt, c);
          return s.b2Vec2.Dot(s.b2Vec2.Subtract(Y, _t, s.b2Vec2.s_t0), this.m_axis);
        }
        case _.e_faceA: {
          const K = s.b2Rot.MultiplyVec2(j.q, this.m_axis, u), $ = s.b2Transform.MultiplyVec2(j, this.m_localPoint, l), lt = s.b2Rot.TransposeMultiplyVec2(tt.q, s.b2Vec2.Negate(K, s.b2Vec2.s_t0), d);
          V[0] = -1, G[0] = this.m_proxyB.GetSupport(lt);
          const gt = this.m_proxyB.GetVertex(G[0]), _t = s.b2Transform.MultiplyVec2(tt, gt, c);
          return s.b2Vec2.Dot(s.b2Vec2.Subtract(_t, $, s.b2Vec2.s_t0), K);
        }
        case _.e_faceB: {
          const K = s.b2Rot.MultiplyVec2(tt.q, this.m_axis, u), $ = s.b2Transform.MultiplyVec2(tt, this.m_localPoint, c), lt = s.b2Rot.TransposeMultiplyVec2(j.q, s.b2Vec2.Negate(K, s.b2Vec2.s_t0), m);
          G[0] = -1, V[0] = this.m_proxyA.GetSupport(lt);
          const gt = this.m_proxyA.GetVertex(V[0]), _t = s.b2Transform.MultiplyVec2(j, gt, l);
          return s.b2Vec2.Dot(s.b2Vec2.Subtract(_t, $, s.b2Vec2.s_t0), K);
        }
        default:
          return V[0] = -1, G[0] = -1, 0;
      }
    }
    Evaluate(V, G, U) {
      const j = this.m_sweepA.GetTransform(r, U), tt = this.m_sweepB.GetTransform(a, U);
      switch (this.m_type) {
        case _.e_points: {
          const K = this.m_proxyA.GetVertex(V), $ = this.m_proxyB.GetVertex(G), lt = s.b2Transform.MultiplyVec2(j, K, l), gt = s.b2Transform.MultiplyVec2(tt, $, c);
          return s.b2Vec2.Dot(s.b2Vec2.Subtract(gt, lt, s.b2Vec2.s_t0), this.m_axis);
        }
        case _.e_faceA: {
          const K = s.b2Rot.MultiplyVec2(j.q, this.m_axis, u), $ = s.b2Transform.MultiplyVec2(j, this.m_localPoint, l), lt = this.m_proxyB.GetVertex(G), gt = s.b2Transform.MultiplyVec2(tt, lt, c);
          return s.b2Vec2.Dot(s.b2Vec2.Subtract(gt, $, s.b2Vec2.s_t0), K);
        }
        case _.e_faceB: {
          const K = s.b2Rot.MultiplyVec2(tt.q, this.m_axis, u), $ = s.b2Transform.MultiplyVec2(tt, this.m_localPoint, c), lt = this.m_proxyA.GetVertex(V), gt = s.b2Transform.MultiplyVec2(j, lt, l);
          return s.b2Vec2.Dot(s.b2Vec2.Subtract(gt, $, s.b2Vec2.s_t0), K);
        }
        default:
          return (0, t.b2Assert)(!1), 0;
      }
    }
  };
  h(D, "b2SeparationFunction");
  let g = D;
  const w = new i.b2Timer(), S = new o.b2SimplexCache(), x = new o.b2DistanceInput(), A = new o.b2DistanceOutput(), C = new g(), M = [0], T = [0], b = new s.b2Sweep(), y = new s.b2Sweep();
  function E(N, V) {
    const G = w.Reset();
    ++n.b2Toi.calls, N.state = p.e_unknown, N.t = V.tMax;
    const { proxyA: U, proxyB: j, tMax: tt } = V, K = Math.max(e.b2_maxPolygonVertices, U.m_count, j.m_count), $ = b.Copy(V.sweepA), lt = y.Copy(V.sweepB);
    $.Normalize(), lt.Normalize();
    const gt = U.m_radius + j.m_radius, _t = Math.max(t.b2_linearSlop, gt - 3 * t.b2_linearSlop), Y = 0.25 * t.b2_linearSlop;
    let it = 0;
    const J = 20;
    let dt = 0;
    const vt = S;
    vt.count = 0;
    const Nt = x;
    for (Nt.proxyA.Copy(V.proxyA), Nt.proxyB.Copy(V.proxyB), Nt.useRadii = !1; ; ) {
      const k = $.GetTransform(r, it), te = lt.GetTransform(a, it);
      Nt.transformA.Copy(k), Nt.transformB.Copy(te);
      const It = A;
      if ((0, o.b2Distance)(It, vt, Nt), It.distance <= 0) {
        N.state = p.e_overlapped, N.t = 0;
        break;
      }
      if (It.distance < _t + Y) {
        N.state = p.e_touching, N.t = it;
        break;
      }
      const ut = C;
      ut.Initialize(vt, U, $, j, lt, it);
      let bt = !1, Ft = tt, wt = 0;
      for (; ; ) {
        const le = M, dn = T;
        let Ze = ut.FindMinSeparation(le, dn, Ft);
        if (Ze > _t + Y) {
          N.state = p.e_separated, N.t = tt, bt = !0;
          break;
        }
        if (Ze > _t - Y) {
          it = Ft;
          break;
        }
        let z = ut.Evaluate(le[0], dn[0], it);
        if (z < _t - Y) {
          N.state = p.e_failed, N.t = it, bt = !0;
          break;
        }
        if (z <= _t + Y) {
          N.state = p.e_touching, N.t = it, bt = !0;
          break;
        }
        let P = 0, q = it, at = Ft;
        for (; ; ) {
          let mt;
          P & 1 ? mt = q + (_t - z) * (at - q) / (Ze - z) : mt = 0.5 * (q + at), ++P, ++n.b2Toi.rootIters;
          const ot = ut.Evaluate(le[0], dn[0], mt);
          if (Math.abs(ot - _t) < Y) {
            Ft = mt;
            break;
          }
          if (ot > _t ? (q = mt, z = ot) : (at = mt, Ze = ot), P === 50)
            break;
        }
        if (n.b2Toi.maxRootIters = Math.max(n.b2Toi.maxRootIters, P), ++wt, wt === K)
          break;
      }
      if (++dt, ++n.b2Toi.iters, bt)
        break;
      if (dt === J) {
        N.state = p.e_failed, N.t = it;
        break;
      }
    }
    n.b2Toi.maxIters = Math.max(n.b2Toi.maxIters, dt);
    const _e = G.GetMilliseconds();
    n.b2Toi.maxTime = Math.max(n.b2Toi.maxTime, _e), n.b2Toi.time += _e;
  }
  h(E, "b2TimeOfImpact"), n.b2TimeOfImpact = E;
})(Gm);
za(Gm);
var Sr = {};
Object.defineProperty(Sr, "__esModule", { value: !0 });
Sr.b2CollidePolygonAndCircle = Sr.b2CollideCircles = void 0;
const FS = Xe, Je = Fe, Al = ge, tG = new Je.b2Vec2(), eG = new Je.b2Vec2();
function nG(n, t, e, s, i) {
  n.pointCount = 0;
  const o = Je.b2Transform.MultiplyVec2(e, t.m_p, tG), r = Je.b2Transform.MultiplyVec2(i, s.m_p, eG), a = Je.b2Vec2.DistanceSquared(o, r), l = t.m_radius + s.m_radius;
  a > l * l || (n.type = Al.b2ManifoldType.e_circles, n.localPoint.Copy(t.m_p), n.localNormal.SetZero(), n.pointCount = 1, n.points[0].localPoint.Copy(s.m_p), n.points[0].id.key = 0);
}
h(nG, "b2CollideCircles");
Sr.b2CollideCircles = nG;
const iG = new Je.b2Vec2(), sG = new Je.b2Vec2(), oG = new Je.b2Vec2();
function rG(n, t, e, s, i) {
  n.pointCount = 0;
  const o = Je.b2Transform.MultiplyVec2(i, s.m_p, iG), r = Je.b2Transform.TransposeMultiplyVec2(e, o, sG);
  let a = 0, l = -FS.b2_maxFloat;
  const c = t.m_radius + s.m_radius, u = t.m_count, m = t.m_vertices, d = t.m_normals;
  for (let S = 0; S < u; ++S) {
    const x = Je.b2Vec2.Dot(d[S], Je.b2Vec2.Subtract(r, m[S], Je.b2Vec2.s_t0));
    if (x > c)
      return;
    x > l && (l = x, a = S);
  }
  const f = a, p = f + 1 < u ? f + 1 : 0, v = m[f], _ = m[p];
  if (l < FS.b2_epsilon) {
    n.pointCount = 1, n.type = Al.b2ManifoldType.e_faceA, n.localNormal.Copy(d[a]), Je.b2Vec2.Mid(v, _, n.localPoint), n.points[0].localPoint.Copy(s.m_p), n.points[0].id.key = 0;
    return;
  }
  const g = Je.b2Vec2.Dot(Je.b2Vec2.Subtract(r, v, Je.b2Vec2.s_t0), Je.b2Vec2.Subtract(_, v, Je.b2Vec2.s_t1)), w = Je.b2Vec2.Dot(Je.b2Vec2.Subtract(r, _, Je.b2Vec2.s_t0), Je.b2Vec2.Subtract(v, _, Je.b2Vec2.s_t1));
  if (g <= 0) {
    if (Je.b2Vec2.DistanceSquared(r, v) > c * c)
      return;
    n.pointCount = 1, n.type = Al.b2ManifoldType.e_faceA, Je.b2Vec2.Subtract(r, v, n.localNormal).Normalize(), n.localPoint.Copy(v), n.points[0].localPoint.Copy(s.m_p), n.points[0].id.key = 0;
  } else if (w <= 0) {
    if (Je.b2Vec2.DistanceSquared(r, _) > c * c)
      return;
    n.pointCount = 1, n.type = Al.b2ManifoldType.e_faceA, Je.b2Vec2.Subtract(r, _, n.localNormal).Normalize(), n.localPoint.Copy(_), n.points[0].localPoint.Copy(s.m_p), n.points[0].id.key = 0;
  } else {
    const S = Je.b2Vec2.Mid(v, _, oG);
    if (Je.b2Vec2.Dot(Je.b2Vec2.Subtract(r, S, Je.b2Vec2.s_t1), d[f]) > c)
      return;
    n.pointCount = 1, n.type = Al.b2ManifoldType.e_faceA, n.localNormal.Copy(d[f]), n.localPoint.Copy(S), n.points[0].localPoint.Copy(s.m_p), n.points[0].id.key = 0;
  }
}
h(rG, "b2CollidePolygonAndCircle");
Sr.b2CollidePolygonAndCircle = rG;
var Uu = {};
Object.defineProperty(Uu, "__esModule", { value: !0 });
Uu.b2CollidePolygons = void 0;
const pu = Xe, Ne = Fe, Pi = ge, aG = new Ne.b2Transform(), cG = new Ne.b2Vec2(), lG = new Ne.b2Vec2();
function GS(n, t, e, s, i) {
  const o = t.m_count, r = s.m_count, a = t.m_normals, l = t.m_vertices, c = s.m_vertices, u = Ne.b2Transform.TransposeMultiply(i, e, aG);
  let m = 0, d = -pu.b2_maxFloat;
  for (let f = 0; f < o; ++f) {
    const p = Ne.b2Rot.MultiplyVec2(u.q, a[f], cG), v = Ne.b2Transform.MultiplyVec2(u, l[f], lG);
    let _ = pu.b2_maxFloat;
    for (let g = 0; g < r; ++g) {
      const w = Ne.b2Vec2.Dot(p, Ne.b2Vec2.Subtract(c[g], v, Ne.b2Vec2.s_t0));
      w < _ && (_ = w);
    }
    _ > d && (d = _, m = f);
  }
  return n[0] = m, d;
}
h(GS, "b2FindMaxSeparation");
const uG = new Ne.b2Vec2();
function hG(n, t, e, s, i, o) {
  const r = t.m_normals, a = i.m_count, l = i.m_vertices, c = i.m_normals, u = Ne.b2Rot.TransposeMultiplyVec2(o.q, Ne.b2Rot.MultiplyVec2(e.q, r[s], Ne.b2Vec2.s_t0), uG);
  let m = 0, d = pu.b2_maxFloat;
  for (let S = 0; S < a; ++S) {
    const x = Ne.b2Vec2.Dot(u, c[S]);
    x < d && (d = x, m = S);
  }
  const f = m, p = f + 1 < a ? f + 1 : 0, v = n[0];
  Ne.b2Transform.MultiplyVec2(o, l[f], v.v);
  const _ = v.id.cf;
  _.indexA = s, _.indexB = f, _.typeA = Pi.b2ContactFeatureType.e_face, _.typeB = Pi.b2ContactFeatureType.e_vertex;
  const g = n[1];
  Ne.b2Transform.MultiplyVec2(o, l[p], g.v);
  const w = g.id.cf;
  w.indexA = s, w.indexB = p, w.typeA = Pi.b2ContactFeatureType.e_face, w.typeB = Pi.b2ContactFeatureType.e_vertex;
}
h(hG, "b2FindIncidentEdge");
const dG = [new Pi.b2ClipVertex(), new Pi.b2ClipVertex()], mG = [new Pi.b2ClipVertex(), new Pi.b2ClipVertex()], fG = [new Pi.b2ClipVertex(), new Pi.b2ClipVertex()], pG = [0], _G = [0], gG = new Ne.b2Vec2(), vG = new Ne.b2Vec2(), bG = new Ne.b2Vec2(), yG = new Ne.b2Vec2(), xG = new Ne.b2Vec2(), wG = new Ne.b2Vec2(), SG = new Ne.b2Vec2(), AG = new Ne.b2Vec2();
function MG(n, t, e, s, i) {
  n.pointCount = 0;
  const o = t.m_radius + s.m_radius, r = pG, a = GS(r, t, e, s, i);
  if (a > o)
    return;
  const l = _G, c = GS(l, s, i, t, e);
  if (c > o)
    return;
  let u, m, d, f, p, v;
  const _ = 0.1 * pu.b2_linearSlop;
  c > a + _ ? (u = s, m = t, d = i, f = e, p = l[0], n.type = Pi.b2ManifoldType.e_faceB, v = 1) : (u = t, m = s, d = e, f = i, p = r[0], n.type = Pi.b2ManifoldType.e_faceA, v = 0);
  const g = dG;
  hG(g, u, d, p, m, f);
  const w = u.m_count, S = u.m_vertices, x = p, A = p + 1 < w ? p + 1 : 0;
  let C = S[x], M = S[A];
  const T = Ne.b2Vec2.Subtract(M, C, gG);
  T.Normalize();
  const b = Ne.b2Vec2.CrossVec2One(T, vG), y = Ne.b2Vec2.Mid(C, M, bG), E = Ne.b2Rot.MultiplyVec2(d.q, T, xG), I = Ne.b2Vec2.CrossVec2One(E, yG);
  C = Ne.b2Transform.MultiplyVec2(d, C, SG), M = Ne.b2Transform.MultiplyVec2(d, M, AG);
  const B = Ne.b2Vec2.Dot(I, C), D = -Ne.b2Vec2.Dot(E, C) + o, N = Ne.b2Vec2.Dot(E, M) + o, V = mG, G = fG, U = Ne.b2Vec2.Negate(E, wG);
  let j = (0, Pi.b2ClipSegmentToLine)(V, g, U, D, x);
  if (j < 2 || (j = (0, Pi.b2ClipSegmentToLine)(G, V, E, N, A), j < 2))
    return;
  n.localNormal.Copy(b), n.localPoint.Copy(y);
  let tt = 0;
  for (let K = 0; K < pu.b2_maxManifoldPoints; ++K) {
    const $ = G[K];
    if (Ne.b2Vec2.Dot(I, $.v) - B <= o) {
      const gt = n.points[tt];
      if (Ne.b2Transform.TransposeMultiplyVec2(f, $.v, gt.localPoint), gt.id.Copy($.id), v) {
        const { cf: _t } = gt.id;
        _t.indexA = _t.indexB, _t.indexB = _t.indexA, _t.typeA = _t.typeB, _t.typeB = _t.typeA;
      }
      ++tt;
    }
  }
  n.pointCount = tt;
}
h(MG, "b2CollidePolygons");
Uu.b2CollidePolygons = MG;
var eo = {};
Object.defineProperty(eo, "__esModule", { value: !0 });
eo.b2CollideEdgeAndPolygon = eo.b2CollideEdgeAndCircle = void 0;
const mr = Xe, Mt = Fe, yn = ge, HS = ps, CG = new Mt.b2Vec2(), EG = new Mt.b2Vec2(), ep = new Mt.b2Vec2(), TG = new Mt.b2Vec2(), IG = new Mt.b2Vec2(), BG = new Mt.b2Vec2(), PG = new Mt.b2Vec2(), RG = new yn.b2ContactID();
function DG(n, t, e, s, i) {
  n.pointCount = 0;
  const o = Mt.b2Transform.TransposeMultiplyVec2(e, Mt.b2Transform.MultiplyVec2(i, s.m_p, Mt.b2Vec2.s_t0), CG), r = t.m_vertex1, a = t.m_vertex2, l = Mt.b2Vec2.Subtract(a, r, EG), c = PG.Set(l.y, -l.x), u = Mt.b2Vec2.Dot(c, Mt.b2Vec2.Subtract(o, r, Mt.b2Vec2.s_t0));
  if (t.m_oneSided && u < 0)
    return;
  const d = Mt.b2Vec2.Dot(l, Mt.b2Vec2.Subtract(a, o, Mt.b2Vec2.s_t0)), f = Mt.b2Vec2.Dot(l, Mt.b2Vec2.Subtract(o, r, Mt.b2Vec2.s_t0)), p = t.m_radius + s.m_radius, v = RG;
  if (v.cf.indexB = 0, v.cf.typeB = yn.b2ContactFeatureType.e_vertex, f <= 0) {
    const x = r, A = Mt.b2Vec2.Subtract(o, x, ep);
    if (Mt.b2Vec2.Dot(A, A) > p * p)
      return;
    if (t.m_oneSided) {
      const M = t.m_vertex0, T = r, b = Mt.b2Vec2.Subtract(T, M, TG);
      if (Mt.b2Vec2.Dot(b, Mt.b2Vec2.Subtract(T, o, Mt.b2Vec2.s_t0)) > 0)
        return;
    }
    v.cf.indexA = 0, v.cf.typeA = yn.b2ContactFeatureType.e_vertex, n.pointCount = 1, n.type = yn.b2ManifoldType.e_circles, n.localNormal.SetZero(), n.localPoint.Copy(x), n.points[0].id.Copy(v), n.points[0].localPoint.Copy(s.m_p);
    return;
  }
  if (d <= 0) {
    const x = a, A = Mt.b2Vec2.Subtract(o, x, ep);
    if (Mt.b2Vec2.Dot(A, A) > p * p)
      return;
    if (t.m_oneSided) {
      const M = t.m_vertex3, T = a, b = Mt.b2Vec2.Subtract(M, T, IG);
      if (Mt.b2Vec2.Dot(b, Mt.b2Vec2.Subtract(o, T, Mt.b2Vec2.s_t0)) > 0)
        return;
    }
    v.cf.indexA = 1, v.cf.typeA = yn.b2ContactFeatureType.e_vertex, n.pointCount = 1, n.type = yn.b2ManifoldType.e_circles, n.localNormal.SetZero(), n.localPoint.Copy(x), n.points[0].id.Copy(v), n.points[0].localPoint.Copy(s.m_p);
    return;
  }
  const _ = Mt.b2Vec2.Dot(l, l), g = BG;
  g.x = 1 / _ * (d * r.x + f * a.x), g.y = 1 / _ * (d * r.y + f * a.y);
  const w = Mt.b2Vec2.Subtract(o, g, ep);
  Mt.b2Vec2.Dot(w, w) > p * p || (u < 0 && c.Set(-c.x, -c.y), c.Normalize(), v.cf.indexA = 0, v.cf.typeA = yn.b2ContactFeatureType.e_face, n.pointCount = 1, n.type = yn.b2ManifoldType.e_faceA, n.localNormal.Copy(c), n.localPoint.Copy(r), n.points[0].id.Copy(v), n.points[0].localPoint.Copy(s.m_p));
}
h(DG, "b2CollideEdgeAndCircle");
eo.b2CollideEdgeAndCircle = DG;
var zo;
(function(n) {
  n[n.e_unknown = 0] = "e_unknown", n[n.e_edgeA = 1] = "e_edgeA", n[n.e_edgeB = 2] = "e_edgeB";
})(zo || (zo = {}));
const Hy = class Hy {
  constructor() {
    this.normal = new Mt.b2Vec2(), this.type = zo.e_unknown, this.index = 0, this.separation = 0;
  }
};
h(Hy, "b2EPAxis");
let Rd = Hy;
const jy = class jy {
  constructor() {
    this.vertices = (0, mr.b2MakeArray)(HS.b2_maxPolygonVertices, Mt.b2Vec2), this.normals = (0, mr.b2MakeArray)(HS.b2_maxPolygonVertices, Mt.b2Vec2), this.count = 0;
  }
};
h(jy, "b2TempPolygon");
let h0 = jy;
const Wy = class Wy {
  constructor() {
    this.i1 = 0, this.i2 = 0, this.v1 = new Mt.b2Vec2(), this.v2 = new Mt.b2Vec2(), this.normal = new Mt.b2Vec2(), this.sideNormal1 = new Mt.b2Vec2(), this.sideOffset1 = 0, this.sideNormal2 = new Mt.b2Vec2(), this.sideOffset2 = 0;
  }
};
h(Wy, "b2ReferenceFace");
let d0 = Wy;
const VG = new Rd(), LG = [new Mt.b2Vec2(), new Mt.b2Vec2()];
function NG(n, t, e) {
  const s = VG;
  s.type = zo.e_edgeA, s.index = -1, s.separation = -mr.b2_maxFloat, s.normal.SetZero();
  const i = LG;
  i[0].Copy(e), Mt.b2Vec2.Negate(e, i[1]);
  for (let o = 0; o < 2; ++o) {
    let r = mr.b2_maxFloat;
    for (let a = 0; a < n.count; ++a) {
      const l = Mt.b2Vec2.Dot(i[o], Mt.b2Vec2.Subtract(n.vertices[a], t, Mt.b2Vec2.s_t0));
      l < r && (r = l);
    }
    r > s.separation && (s.index = o, s.separation = r, s.normal.Copy(i[o]));
  }
  return s;
}
h(NG, "b2ComputeEdgeSeparation");
const zG = new Rd(), kG = new Mt.b2Vec2();
function UG(n, t, e) {
  const s = zG;
  s.type = zo.e_unknown, s.index = -1, s.separation = -mr.b2_maxFloat, s.normal.SetZero();
  for (let i = 0; i < n.count; ++i) {
    const o = Mt.b2Vec2.Negate(n.normals[i], kG), r = Mt.b2Vec2.Dot(o, Mt.b2Vec2.Subtract(n.vertices[i], t, Mt.b2Vec2.s_t0)), a = Mt.b2Vec2.Dot(o, Mt.b2Vec2.Subtract(n.vertices[i], e, Mt.b2Vec2.s_t0)), l = Math.min(r, a);
    l > s.separation && (s.type = zo.e_edgeB, s.index = i, s.separation = l, s.normal.Copy(o));
  }
  return s;
}
h(UG, "b2ComputePolygonSeparation");
const OG = new Mt.b2Transform(), $G = new Mt.b2Vec2(), FG = new Mt.b2Vec2(), GG = new Mt.b2Vec2(), HG = new Mt.b2Vec2(), jG = new Mt.b2Vec2(), WG = new Mt.b2Vec2(), qG = new Mt.b2Vec2(), XG = new h0(), ZG = new d0(), YG = [new yn.b2ClipVertex(), new yn.b2ClipVertex()], JG = [new yn.b2ClipVertex(), new yn.b2ClipVertex()], KG = [new yn.b2ClipVertex(), new yn.b2ClipVertex()];
function QG(n, t, e, s, i) {
  n.pointCount = 0;
  const o = Mt.b2Transform.TransposeMultiply(e, i, OG), r = Mt.b2Transform.MultiplyVec2(o, s.m_centroid, $G), a = t.m_vertex1, l = t.m_vertex2, c = Mt.b2Vec2.Subtract(l, a, FG);
  c.Normalize();
  const u = GG.Set(c.y, -c.x), m = Mt.b2Vec2.Dot(u, Mt.b2Vec2.Subtract(r, a, Mt.b2Vec2.s_t0)), d = t.m_oneSided;
  if (d && m < 0)
    return;
  const f = XG;
  f.count = s.m_count;
  for (let y = 0; y < s.m_count; ++y)
    Mt.b2Transform.MultiplyVec2(o, s.m_vertices[y], f.vertices[y]), Mt.b2Rot.MultiplyVec2(o.q, s.m_normals[y], f.normals[y]);
  const p = s.m_radius + t.m_radius, v = NG(f, a, u);
  if (v.separation > p)
    return;
  const _ = UG(f, a, l);
  if (_.separation > p)
    return;
  const g = 0.98, w = 1e-3;
  let S;
  if (_.separation - p > g * (v.separation - p) + w ? S = _ : S = v, d) {
    const y = Mt.b2Vec2.Subtract(a, t.m_vertex0, HG);
    y.Normalize();
    const E = jG.Set(y.y, -y.x), I = Mt.b2Vec2.Cross(y, c) >= 0, B = Mt.b2Vec2.Subtract(t.m_vertex3, l, WG);
    B.Normalize();
    const D = qG.Set(B.y, -B.x), N = Mt.b2Vec2.Cross(c, B) >= 0, V = 0.1;
    if (Mt.b2Vec2.Dot(S.normal, c) <= 0)
      if (I) {
        if (Mt.b2Vec2.Cross(S.normal, E) > V)
          return;
      } else
        S = v;
    else if (N) {
      if (Mt.b2Vec2.Cross(D, S.normal) > V)
        return;
    } else
      S = v;
  }
  const x = YG, A = ZG;
  if (S.type === zo.e_edgeA) {
    n.type = yn.b2ManifoldType.e_faceA;
    let y = 0, E = Mt.b2Vec2.Dot(S.normal, f.normals[0]);
    for (let D = 1; D < f.count; ++D) {
      const N = Mt.b2Vec2.Dot(S.normal, f.normals[D]);
      N < E && (E = N, y = D);
    }
    const I = y, B = I + 1 < f.count ? I + 1 : 0;
    x[0].v.Copy(f.vertices[I]), x[0].id.cf.indexA = 0, x[0].id.cf.indexB = I, x[0].id.cf.typeA = yn.b2ContactFeatureType.e_face, x[0].id.cf.typeB = yn.b2ContactFeatureType.e_vertex, x[1].v.Copy(f.vertices[B]), x[1].id.cf.indexA = 0, x[1].id.cf.indexB = B, x[1].id.cf.typeA = yn.b2ContactFeatureType.e_face, x[1].id.cf.typeB = yn.b2ContactFeatureType.e_vertex, A.i1 = 0, A.i2 = 1, A.v1.Copy(a), A.v2.Copy(l), A.normal.Copy(S.normal), Mt.b2Vec2.Negate(c, A.sideNormal1), A.sideNormal2.Copy(c);
  } else
    n.type = yn.b2ManifoldType.e_faceB, x[0].v.Copy(l), x[0].id.cf.indexA = 1, x[0].id.cf.indexB = S.index, x[0].id.cf.typeA = yn.b2ContactFeatureType.e_vertex, x[0].id.cf.typeB = yn.b2ContactFeatureType.e_face, x[1].v.Copy(a), x[1].id.cf.indexA = 0, x[1].id.cf.indexB = S.index, x[1].id.cf.typeA = yn.b2ContactFeatureType.e_vertex, x[1].id.cf.typeB = yn.b2ContactFeatureType.e_face, A.i1 = S.index, A.i2 = A.i1 + 1 < f.count ? A.i1 + 1 : 0, A.v1.Copy(f.vertices[A.i1]), A.v2.Copy(f.vertices[A.i2]), A.normal.Copy(f.normals[A.i1]), A.sideNormal1.Set(A.normal.y, -A.normal.x), Mt.b2Vec2.Negate(A.sideNormal1, A.sideNormal2);
  A.sideOffset1 = Mt.b2Vec2.Dot(A.sideNormal1, A.v1), A.sideOffset2 = Mt.b2Vec2.Dot(A.sideNormal2, A.v2);
  const C = JG, M = KG;
  let T;
  if (T = (0, yn.b2ClipSegmentToLine)(C, x, A.sideNormal1, A.sideOffset1, A.i1), T < mr.b2_maxManifoldPoints || (T = (0, yn.b2ClipSegmentToLine)(M, C, A.sideNormal2, A.sideOffset2, A.i2), T < mr.b2_maxManifoldPoints))
    return;
  S.type === zo.e_edgeA ? (n.localNormal.Copy(A.normal), n.localPoint.Copy(A.v1)) : (n.localNormal.Copy(s.m_normals[A.i1]), n.localPoint.Copy(s.m_vertices[A.i1]));
  let b = 0;
  for (let y = 0; y < mr.b2_maxManifoldPoints; ++y)
    if (Mt.b2Vec2.Dot(A.normal, Mt.b2Vec2.Subtract(M[y].v, A.v1, Mt.b2Vec2.s_t0)) <= p) {
      const I = n.points[b];
      S.type === zo.e_edgeA ? (Mt.b2Transform.TransposeMultiplyVec2(o, M[y].v, I.localPoint), I.id.Copy(M[y].id)) : (I.localPoint.Copy(M[y].v), I.id.cf.typeA = M[y].id.cf.typeB, I.id.cf.typeB = M[y].id.cf.typeA, I.id.cf.indexA = M[y].id.cf.indexB, I.id.cf.indexB = M[y].id.cf.indexA), ++b;
    }
  n.pointCount = b;
}
h(QG, "b2CollideEdgeAndPolygon");
eo.b2CollideEdgeAndPolygon = QG;
var Hm = {};
Object.defineProperty(Hm, "__esModule", { value: !0 });
Hm.b2CircleShape = void 0;
const t9 = Xe, Hn = Fe, jS = wi, Us = class Us extends jS.b2Shape {
  constructor(t = 0) {
    super(jS.b2ShapeType.e_circle, t), this.m_p = new Hn.b2Vec2();
  }
  Set(t, e = this.m_radius) {
    return this.m_p.Copy(t), this.m_radius = e, this;
  }
  Clone() {
    return new Us().Copy(this);
  }
  Copy(t) {
    return super.Copy(t), this.m_p.Copy(t.m_p), this;
  }
  GetChildCount() {
    return 1;
  }
  TestPoint(t, e) {
    const s = Hn.b2Transform.MultiplyVec2(t, this.m_p, Us.TestPoint_s_center), i = Hn.b2Vec2.Subtract(e, s, Us.TestPoint_s_d);
    return Hn.b2Vec2.Dot(i, i) <= this.m_radius ** 2;
  }
  RayCast(t, e, s, i) {
    const o = Hn.b2Transform.MultiplyVec2(s, this.m_p, Us.RayCast_s_position), r = Hn.b2Vec2.Subtract(e.p1, o, Us.RayCast_s_s), a = Hn.b2Vec2.Dot(r, r) - this.m_radius ** 2, l = Hn.b2Vec2.Subtract(e.p2, e.p1, Us.RayCast_s_r), c = Hn.b2Vec2.Dot(r, l), u = Hn.b2Vec2.Dot(l, l), m = c * c - u * a;
    if (m < 0 || u < t9.b2_epsilon)
      return !1;
    let d = -(c + Math.sqrt(m));
    return d >= 0 && d <= e.maxFraction * u ? (d /= u, t.fraction = d, Hn.b2Vec2.AddScaled(r, d, l, t.normal).Normalize(), !0) : !1;
  }
  ComputeAABB(t, e, s) {
    const i = Hn.b2Transform.MultiplyVec2(e, this.m_p, Us.ComputeAABB_s_p);
    t.lowerBound.Set(i.x - this.m_radius, i.y - this.m_radius), t.upperBound.Set(i.x + this.m_radius, i.y + this.m_radius);
  }
  ComputeMass(t, e) {
    const s = this.m_radius ** 2;
    t.mass = e * Math.PI * s, t.center.Copy(this.m_p), t.I = t.mass * (0.5 * s + Hn.b2Vec2.Dot(this.m_p, this.m_p));
  }
  SetupDistanceProxy(t, e) {
    t.m_vertices = t.m_buffer, t.m_vertices[0] = this.m_p, t.m_count = 1, t.m_radius = this.m_radius;
  }
  Draw(t, e) {
    const s = this.m_p, i = this.m_radius, o = Hn.b2Vec2.UNITX;
    t.DrawSolidCircle(s, i, o, e);
  }
};
h(Us, "b2CircleShape");
let Go = Us;
Hm.b2CircleShape = Go;
Go.TestPoint_s_center = new Hn.b2Vec2();
Go.TestPoint_s_d = new Hn.b2Vec2();
Go.RayCast_s_position = new Hn.b2Vec2();
Go.RayCast_s_s = new Hn.b2Vec2();
Go.RayCast_s_r = new Hn.b2Vec2();
Go.ComputeAABB_s_p = new Hn.b2Vec2();
var jm = {};
Object.defineProperty(jm, "__esModule", { value: !0 });
jm.b2PolygonShape = void 0;
const Qo = Xe, Kt = Fe, e9 = ps, WS = ge, qS = wi, ws = {
  ComputeCentroid: {
    s: new Kt.b2Vec2(),
    p1: new Kt.b2Vec2(),
    p2: new Kt.b2Vec2(),
    p3: new Kt.b2Vec2(),
    e1: new Kt.b2Vec2(),
    e2: new Kt.b2Vec2()
  },
  TestPoint: {
    pLocal: new Kt.b2Vec2()
  },
  ComputeAABB: {
    v: new Kt.b2Vec2()
  },
  ComputeMass: {
    center: new Kt.b2Vec2(),
    s: new Kt.b2Vec2(),
    e1: new Kt.b2Vec2(),
    e2: new Kt.b2Vec2()
  },
  Validate: {
    e: new Kt.b2Vec2(),
    v: new Kt.b2Vec2()
  },
  Set: {
    r: new Kt.b2Vec2(),
    v: new Kt.b2Vec2()
  },
  RayCast: {
    p1: new Kt.b2Vec2(),
    p2: new Kt.b2Vec2(),
    d: new Kt.b2Vec2()
  },
  SetAsBox: {
    xf: new Kt.b2Transform()
  }
};
function n9(n, t, e) {
  const s = e;
  s.SetZero();
  let i = 0;
  const { s: o, p1: r, p2: a, p3: l, e1: c, e2: u } = ws.ComputeCentroid;
  o.Copy(n[0]);
  const m = 1 / 3;
  for (let f = 0; f < t; ++f) {
    Kt.b2Vec2.Subtract(n[0], o, r), Kt.b2Vec2.Subtract(n[f], o, a), Kt.b2Vec2.Subtract(n[f + 1 < t ? f + 1 : 0], o, l), Kt.b2Vec2.Subtract(a, r, c), Kt.b2Vec2.Subtract(l, r, u);
    const v = 0.5 * Kt.b2Vec2.Cross(c, u);
    i += v, s.x += v * m * (r.x + a.x + l.x), s.y += v * m * (r.y + a.y + l.y);
  }
  const d = 1 / i;
  return s.x = d * s.x + o.x, s.y = d * s.y + o.y, s;
}
h(n9, "ComputeCentroid");
const i9 = new Kt.b2Vec2(), mm = class mm extends qS.b2Shape {
  constructor() {
    super(qS.b2ShapeType.e_polygon, Qo.b2_polygonRadius), this.m_centroid = new Kt.b2Vec2(), this.m_vertices = [], this.m_normals = [], this.m_count = 0;
  }
  Clone() {
    return new mm().Copy(this);
  }
  Copy(t) {
    super.Copy(t), this.m_centroid.Copy(t.m_centroid), this.m_count = t.m_count, this.m_vertices = (0, Qo.b2MakeArray)(this.m_count, Kt.b2Vec2), this.m_normals = (0, Qo.b2MakeArray)(this.m_count, Kt.b2Vec2);
    for (let e = 0; e < this.m_count; ++e)
      this.m_vertices[e].Copy(t.m_vertices[e]), this.m_normals[e].Copy(t.m_normals[e]);
    return this;
  }
  GetChildCount() {
    return 1;
  }
  Set(t, e = t.length) {
    const s = (0, WS.b2ComputeHull)(t, e);
    return s.length < 3 ? !1 : (this.SetHull(s, s.length), !0);
  }
  SetHull(t, e) {
    (0, Qo.b2Assert)(e >= 3), this.m_count = e, this.m_vertices = (0, Qo.b2MakeArray)(e, Kt.b2Vec2);
    for (let s = 0; s < e; ++s)
      this.m_vertices[s].Copy(t[s]);
    this.m_normals = (0, Qo.b2MakeArray)(e, Kt.b2Vec2);
    for (let s = 0; s < this.m_count; ++s) {
      const i = s, o = s + 1 < this.m_count ? s + 1 : 0, r = Kt.b2Vec2.Subtract(this.m_vertices[o], this.m_vertices[i], i9);
      Kt.b2Vec2.CrossVec2Scalar(r, 1, this.m_normals[s]), this.m_normals[s].Normalize();
    }
    return n9(this.m_vertices, this.m_count, this.m_centroid), this;
  }
  SetAsBox(t, e, s, i = 0) {
    if (this.m_count = 4, this.m_vertices = (0, Qo.b2MakeArray)(this.m_count, Kt.b2Vec2), this.m_normals = (0, Qo.b2MakeArray)(this.m_count, Kt.b2Vec2), this.m_vertices[0].Set(-t, -e), this.m_vertices[1].Set(t, -e), this.m_vertices[2].Set(t, e), this.m_vertices[3].Set(-t, e), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), s) {
      this.m_centroid.Copy(s);
      const { xf: o } = ws.SetAsBox;
      o.SetPosition(s), o.SetRotationAngle(i);
      for (let r = 0; r < this.m_count; ++r)
        Kt.b2Transform.MultiplyVec2(o, this.m_vertices[r], this.m_vertices[r]), Kt.b2Rot.MultiplyVec2(o.q, this.m_normals[r], this.m_normals[r]);
    } else
      this.m_centroid.SetZero();
    return this;
  }
  TestPoint(t, e) {
    const s = Kt.b2Transform.TransposeMultiplyVec2(t, e, ws.TestPoint.pLocal);
    for (let i = 0; i < this.m_count; ++i)
      if (Kt.b2Vec2.Dot(this.m_normals[i], Kt.b2Vec2.Subtract(s, this.m_vertices[i], Kt.b2Vec2.s_t0)) > 0)
        return !1;
    return !0;
  }
  RayCast(t, e, s, i) {
    const o = Kt.b2Transform.TransposeMultiplyVec2(s, e.p1, ws.RayCast.p1), r = Kt.b2Transform.TransposeMultiplyVec2(s, e.p2, ws.RayCast.p2), a = Kt.b2Vec2.Subtract(r, o, ws.RayCast.d);
    let l = 0, c = e.maxFraction, u = -1;
    for (let m = 0; m < this.m_count; ++m) {
      const d = Kt.b2Vec2.Dot(this.m_normals[m], Kt.b2Vec2.Subtract(this.m_vertices[m], o, Kt.b2Vec2.s_t0)), f = Kt.b2Vec2.Dot(this.m_normals[m], a);
      if (f === 0) {
        if (d < 0)
          return !1;
      } else f < 0 && d < l * f ? (l = d / f, u = m) : f > 0 && d < c * f && (c = d / f);
      if (c < l)
        return !1;
    }
    return u >= 0 ? (t.fraction = l, Kt.b2Rot.MultiplyVec2(s.q, this.m_normals[u], t.normal), !0) : !1;
  }
  ComputeAABB(t, e, s) {
    const i = Kt.b2Transform.MultiplyVec2(e, this.m_vertices[0], t.lowerBound), o = t.upperBound.Copy(i);
    for (let a = 1; a < this.m_count; ++a) {
      const l = Kt.b2Transform.MultiplyVec2(e, this.m_vertices[a], ws.ComputeAABB.v);
      Kt.b2Vec2.Min(i, l, i), Kt.b2Vec2.Max(o, l, o);
    }
    const r = this.m_radius;
    i.SubtractXY(r, r), o.AddXY(r, r);
  }
  ComputeMass(t, e) {
    const s = ws.ComputeMass.center.SetZero();
    let i = 0, o = 0;
    const r = ws.ComputeMass.s.Copy(this.m_vertices[0]), a = 1 / 3;
    for (let l = 0; l < this.m_count; ++l) {
      const c = Kt.b2Vec2.Subtract(this.m_vertices[l], r, ws.ComputeMass.e1), u = Kt.b2Vec2.Subtract(this.m_vertices[l + 1 < this.m_count ? l + 1 : 0], r, ws.ComputeMass.e2), m = Kt.b2Vec2.Cross(c, u), d = 0.5 * m;
      i += d, s.AddScaled(d * a, Kt.b2Vec2.Add(c, u, Kt.b2Vec2.s_t0));
      const f = c.x, p = c.y, v = u.x, _ = u.y, g = f * f + v * f + v * v, w = p * p + _ * p + _ * _;
      o += 0.25 * a * m * (g + w);
    }
    t.mass = e * i, s.Scale(1 / i), Kt.b2Vec2.Add(s, r, t.center), t.I = e * o, t.I += t.mass * (Kt.b2Vec2.Dot(t.center, t.center) - Kt.b2Vec2.Dot(s, s));
  }
  Validate() {
    return this.m_count < 3 || e9.b2_maxPolygonVertices < this.m_count ? !1 : (0, WS.b2ValidateHull)(this.m_vertices, this.m_count);
  }
  SetupDistanceProxy(t, e) {
    t.m_vertices = this.m_vertices, t.m_count = this.m_count, t.m_radius = this.m_radius;
  }
  Draw(t, e) {
    const s = this.m_count, i = this.m_vertices;
    t.DrawSolidPolygon(i, s, e);
  }
};
h(mm, "b2PolygonShape");
let m0 = mm;
jm.b2PolygonShape = m0;
var Ua = {};
Object.defineProperty(Ua, "__esModule", { value: !0 });
Ua.b2EdgeShape = void 0;
const s9 = Xe, Ke = Fe, XS = wi, ns = class ns extends XS.b2Shape {
  constructor() {
    super(XS.b2ShapeType.e_edge, s9.b2_polygonRadius), this.m_vertex1 = new Ke.b2Vec2(), this.m_vertex2 = new Ke.b2Vec2(), this.m_vertex0 = new Ke.b2Vec2(), this.m_vertex3 = new Ke.b2Vec2(), this.m_oneSided = !1;
  }
  SetOneSided(t, e, s, i) {
    return this.m_vertex0.Copy(t), this.m_vertex1.Copy(e), this.m_vertex2.Copy(s), this.m_vertex3.Copy(i), this.m_oneSided = !0, this;
  }
  SetTwoSided(t, e) {
    return this.m_vertex1.Copy(t), this.m_vertex2.Copy(e), this.m_oneSided = !1, this;
  }
  Clone() {
    return new ns().Copy(this);
  }
  Copy(t) {
    return super.Copy(t), this.m_vertex1.Copy(t.m_vertex1), this.m_vertex2.Copy(t.m_vertex2), this.m_vertex0.Copy(t.m_vertex0), this.m_vertex3.Copy(t.m_vertex3), this.m_oneSided = t.m_oneSided, this;
  }
  GetChildCount() {
    return 1;
  }
  TestPoint(t, e) {
    return !1;
  }
  RayCast(t, e, s, i) {
    const o = Ke.b2Transform.TransposeMultiplyVec2(s, e.p1, ns.RayCast_s_p1), r = Ke.b2Transform.TransposeMultiplyVec2(s, e.p2, ns.RayCast_s_p2), a = Ke.b2Vec2.Subtract(r, o, ns.RayCast_s_d), l = this.m_vertex1, c = this.m_vertex2, u = Ke.b2Vec2.Subtract(c, l, ns.RayCast_s_e), { normal: m } = t;
    m.Set(u.y, -u.x).Normalize();
    const d = Ke.b2Vec2.Dot(m, Ke.b2Vec2.Subtract(l, o, Ke.b2Vec2.s_t0));
    if (this.m_oneSided && d > 0)
      return !1;
    const f = Ke.b2Vec2.Dot(m, a);
    if (f === 0)
      return !1;
    const p = d / f;
    if (p < 0 || e.maxFraction < p)
      return !1;
    const v = Ke.b2Vec2.AddScaled(o, p, a, ns.RayCast_s_q), _ = Ke.b2Vec2.Subtract(c, l, ns.RayCast_s_r), g = Ke.b2Vec2.Dot(_, _);
    if (g === 0)
      return !1;
    const w = Ke.b2Vec2.Dot(Ke.b2Vec2.Subtract(v, l, Ke.b2Vec2.s_t0), _) / g;
    return w < 0 || w > 1 ? !1 : (t.fraction = p, Ke.b2Rot.MultiplyVec2(s.q, t.normal, t.normal), d > 0 && t.normal.Negate(), !0);
  }
  ComputeAABB(t, e, s) {
    const i = Ke.b2Transform.MultiplyVec2(e, this.m_vertex1, ns.ComputeAABB_s_v1), o = Ke.b2Transform.MultiplyVec2(e, this.m_vertex2, ns.ComputeAABB_s_v2);
    Ke.b2Vec2.Min(i, o, t.lowerBound), Ke.b2Vec2.Max(i, o, t.upperBound);
    const r = this.m_radius;
    t.lowerBound.SubtractXY(r, r), t.upperBound.AddXY(r, r);
  }
  ComputeMass(t, e) {
    t.mass = 0, Ke.b2Vec2.Mid(this.m_vertex1, this.m_vertex2, t.center), t.I = 0;
  }
  SetupDistanceProxy(t, e) {
    t.m_vertices = t.m_buffer, t.m_vertices[0] = this.m_vertex1, t.m_vertices[1] = this.m_vertex2, t.m_count = 2, t.m_radius = this.m_radius;
  }
  Draw(t, e) {
    const s = this.m_vertex1, i = this.m_vertex2;
    t.DrawSegment(s, i, e), this.m_oneSided === !1 && (t.DrawPoint(s, 4, e), t.DrawPoint(i, 4, e));
  }
};
h(ns, "b2EdgeShape");
let Ps = ns;
Ua.b2EdgeShape = Ps;
Ps.RayCast_s_p1 = new Ke.b2Vec2();
Ps.RayCast_s_p2 = new Ke.b2Vec2();
Ps.RayCast_s_d = new Ke.b2Vec2();
Ps.RayCast_s_e = new Ke.b2Vec2();
Ps.RayCast_s_q = new Ke.b2Vec2();
Ps.RayCast_s_r = new Ke.b2Vec2();
Ps.ComputeAABB_s_v1 = new Ke.b2Vec2();
Ps.ComputeAABB_s_v2 = new Ke.b2Vec2();
var Wm = {};
Object.defineProperty(Wm, "__esModule", { value: !0 });
Wm.b2ChainShape = void 0;
const o9 = Xe, ss = Fe, ZS = wi, r9 = Ua, So = class So extends ZS.b2Shape {
  constructor() {
    super(ZS.b2ShapeType.e_chain, o9.b2_polygonRadius), this.m_vertices = [], this.m_prevVertex = new ss.b2Vec2(), this.m_nextVertex = new ss.b2Vec2();
  }
  CreateLoop(t, e = t.length) {
    if (e < 3)
      return this;
    this.m_vertices.length = e + 1;
    for (let s = 0; s < e; ++s) {
      const { x: i, y: o } = t[s];
      this.m_vertices[s] = new ss.b2Vec2(i, o);
    }
    return this.m_vertices[e] = this.m_vertices[0].Clone(), this.m_prevVertex.Copy(this.m_vertices[this.m_vertices.length - 2]), this.m_nextVertex.Copy(this.m_vertices[1]), this;
  }
  CreateChain(t, e, s, i) {
    this.m_vertices.length = e;
    for (let o = 0; o < e; ++o) {
      const { x: r, y: a } = t[o];
      this.m_vertices[o] = new ss.b2Vec2(r, a);
    }
    return this.m_prevVertex.Copy(s), this.m_nextVertex.Copy(i), this;
  }
  Clone() {
    return new So().Copy(this);
  }
  Copy(t) {
    return super.Copy(t), this.CreateChain(t.m_vertices, t.m_vertices.length, t.m_prevVertex, t.m_nextVertex);
  }
  GetChildCount() {
    return this.m_vertices.length - 1;
  }
  GetChildEdge(t, e) {
    t.m_radius = this.m_radius, t.m_vertex1.Copy(this.m_vertices[e]), t.m_vertex2.Copy(this.m_vertices[e + 1]), t.m_oneSided = !0, e > 0 ? t.m_vertex0.Copy(this.m_vertices[e - 1]) : t.m_vertex0.Copy(this.m_prevVertex), e < this.m_vertices.length - 2 ? t.m_vertex3.Copy(this.m_vertices[e + 2]) : t.m_vertex3.Copy(this.m_nextVertex);
  }
  TestPoint(t, e) {
    return !1;
  }
  RayCast(t, e, s, i) {
    const o = So.RayCast_s_edgeShape, r = i;
    let a = i + 1;
    return a === this.m_vertices.length && (a = 0), o.m_vertex1.Copy(this.m_vertices[r]), o.m_vertex2.Copy(this.m_vertices[a]), o.RayCast(t, e, s, 0);
  }
  ComputeAABB(t, e, s) {
    const i = s;
    let o = s + 1;
    o === this.m_vertices.length && (o = 0);
    const r = ss.b2Transform.MultiplyVec2(e, this.m_vertices[i], So.ComputeAABB_s_v1), a = ss.b2Transform.MultiplyVec2(e, this.m_vertices[o], So.ComputeAABB_s_v2), l = ss.b2Vec2.Min(r, a, So.ComputeAABB_s_lower), c = ss.b2Vec2.Max(r, a, So.ComputeAABB_s_upper);
    t.lowerBound.x = l.x - this.m_radius, t.lowerBound.y = l.y - this.m_radius, t.upperBound.x = c.x + this.m_radius, t.upperBound.y = c.y + this.m_radius;
  }
  ComputeMass(t, e) {
    t.mass = 0, t.center.SetZero(), t.I = 0;
  }
  SetupDistanceProxy(t, e) {
    t.m_vertices = t.m_buffer, t.m_vertices[0] = this.m_vertices[e];
    const s = e + 1 < this.m_vertices.length ? e + 1 : 0;
    t.m_vertices[1] = this.m_vertices[s], t.m_count = 2, t.m_radius = this.m_radius;
  }
  Draw(t, e) {
    const s = this.m_vertices;
    let i = s[0];
    for (let o = 1; o < s.length; ++o) {
      const r = s[o];
      t.DrawSegment(i, r, e), i = r;
    }
  }
};
h(So, "b2ChainShape");
let Ar = So;
Wm.b2ChainShape = Ar;
Ar.RayCast_s_edgeShape = new r9.b2EdgeShape();
Ar.ComputeAABB_s_v1 = new ss.b2Vec2();
Ar.ComputeAABB_s_v2 = new ss.b2Vec2();
Ar.ComputeAABB_s_lower = new ss.b2Vec2();
Ar.ComputeAABB_s_upper = new ss.b2Vec2();
var qm = {}, xn = {};
Object.defineProperty(xn, "__esModule", { value: !0 });
xn.b2Joint = xn.b2AngularStiffness = xn.b2LinearStiffness = xn.b2JointDef = xn.b2JointEdge = xn.b2JointType = void 0;
const np = Ai, YS = Fe, JS = {
  pA: new YS.b2Vec2(),
  pB: new YS.b2Vec2()
};
var f0;
(function(n) {
  n[n.e_unknownJoint = 0] = "e_unknownJoint", n[n.e_revoluteJoint = 1] = "e_revoluteJoint", n[n.e_prismaticJoint = 2] = "e_prismaticJoint", n[n.e_distanceJoint = 3] = "e_distanceJoint", n[n.e_pulleyJoint = 4] = "e_pulleyJoint", n[n.e_mouseJoint = 5] = "e_mouseJoint", n[n.e_gearJoint = 6] = "e_gearJoint", n[n.e_wheelJoint = 7] = "e_wheelJoint", n[n.e_weldJoint = 8] = "e_weldJoint", n[n.e_frictionJoint = 9] = "e_frictionJoint", n[n.e_motorJoint = 10] = "e_motorJoint", n[n.e_areaJoint = 11] = "e_areaJoint";
})(f0 || (xn.b2JointType = f0 = {}));
const qy = class qy {
  constructor(t, e) {
    this.prev = null, this.next = null, this.joint = t, this.other = e;
  }
};
h(qy, "b2JointEdge");
let _u = qy;
xn.b2JointEdge = _u;
const Xy = class Xy {
  constructor(t) {
    this.userData = {}, this.collideConnected = !1, this.type = t;
  }
};
h(Xy, "b2JointDef");
let p0 = Xy;
xn.b2JointDef = p0;
function a9(n, t, e, s, i) {
  const o = s.GetMass(), r = i.GetMass();
  let a;
  o > 0 && r > 0 ? a = o * r / (o + r) : o > 0 ? a = o : a = r;
  const l = 2 * Math.PI * t;
  n.stiffness = a * l * l, n.damping = 2 * a * e * l;
}
h(a9, "b2LinearStiffness");
xn.b2LinearStiffness = a9;
function c9(n, t, e, s, i) {
  const o = s.GetInertia(), r = i.GetInertia();
  let a;
  o > 0 && r > 0 ? a = o * r / (o + r) : o > 0 ? a = o : a = r;
  const l = 2 * Math.PI * t;
  n.stiffness = a * l * l, n.damping = 2 * a * e * l;
}
h(c9, "b2AngularStiffness");
xn.b2AngularStiffness = c9;
const Zy = class Zy {
  constructor(t) {
    var e;
    this.m_type = f0.e_unknownJoint, this.m_prev = null, this.m_next = null, this.m_islandFlag = !1, this.m_collideConnected = !1, this.m_userData = {}, this.m_type = t.type, this.m_edgeA = new _u(this, t.bodyB), this.m_edgeB = new _u(this, t.bodyA), this.m_bodyA = t.bodyA, this.m_bodyB = t.bodyB, this.m_collideConnected = (e = t.collideConnected) !== null && e !== void 0 ? e : !1, this.SetUserData(t.userData);
  }
  GetType() {
    return this.m_type;
  }
  GetBodyA() {
    return this.m_bodyA;
  }
  GetBodyB() {
    return this.m_bodyB;
  }
  GetNext() {
    return this.m_next;
  }
  GetUserData() {
    return this.m_userData;
  }
  SetUserData(t) {
    Object.assign(this.m_userData, t);
  }
  IsEnabled() {
    return this.m_bodyA.IsEnabled() && this.m_bodyB.IsEnabled();
  }
  GetCollideConnected() {
    return this.m_collideConnected;
  }
  ShiftOrigin(t) {
  }
  Draw(t) {
    const e = this.m_bodyA.GetTransform().p, s = this.m_bodyB.GetTransform().p, i = this.GetAnchorA(JS.pA), o = this.GetAnchorB(JS.pB);
    t.DrawSegment(e, i, np.debugColors.joint6), t.DrawSegment(i, o, np.debugColors.joint6), t.DrawSegment(s, o, np.debugColors.joint6);
  }
};
h(Zy, "b2Joint");
let _0 = Zy;
xn.b2Joint = _0;
var wa = {}, Mr = {};
Object.defineProperty(Mr, "__esModule", { value: !0 });
Mr.b2DistanceJoint = Mr.b2DistanceJointDef = void 0;
const ks = Xe, Lt = Fe, g0 = xn, Th = Ai, En = {
  worldPointA: new Lt.b2Vec2(),
  worldPointB: new Lt.b2Vec2(),
  vpA: new Lt.b2Vec2(),
  vpB: new Lt.b2Vec2(),
  vpBA: new Lt.b2Vec2(),
  P: new Lt.b2Vec2(),
  qA: new Lt.b2Rot(),
  qB: new Lt.b2Rot(),
  lalcA: new Lt.b2Vec2(),
  lalcB: new Lt.b2Vec2(),
  Draw: {
    pA: new Lt.b2Vec2(),
    pB: new Lt.b2Vec2(),
    axis: new Lt.b2Vec2(),
    pRest: new Lt.b2Vec2(),
    p1: new Lt.b2Vec2(),
    p2: new Lt.b2Vec2()
  }
}, Yy = class Yy extends g0.b2JointDef {
  constructor() {
    super(g0.b2JointType.e_distanceJoint), this.localAnchorA = new Lt.b2Vec2(), this.localAnchorB = new Lt.b2Vec2(), this.length = 1, this.minLength = 0, this.maxLength = ks.b2_maxFloat, this.stiffness = 0, this.damping = 0;
  }
  Initialize(t, e, s, i) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(s, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.length = Math.max(Lt.b2Vec2.Distance(s, i), ks.b2_linearSlop), this.minLength = this.length, this.maxLength = this.length;
  }
};
h(Yy, "b2DistanceJointDef");
let v0 = Yy;
Mr.b2DistanceJointDef = v0;
const Jy = class Jy extends g0.b2Joint {
  constructor(t) {
    var e, s;
    super(t), this.m_bias = 0, this.m_localAnchorA = new Lt.b2Vec2(), this.m_localAnchorB = new Lt.b2Vec2(), this.m_gamma = 0, this.m_impulse = 0, this.m_lowerImpulse = 0, this.m_upperImpulse = 0, this.m_indexA = 0, this.m_indexB = 0, this.m_u = new Lt.b2Vec2(), this.m_rA = new Lt.b2Vec2(), this.m_rB = new Lt.b2Vec2(), this.m_localCenterA = new Lt.b2Vec2(), this.m_localCenterB = new Lt.b2Vec2(), this.m_currentLength = 0, this.m_invMassA = 0, this.m_invMassB = 0, this.m_invIA = 0, this.m_invIB = 0, this.m_softMass = 0, this.m_mass = 0, this.m_localAnchorA.Copy(t.localAnchorA), this.m_localAnchorB.Copy(t.localAnchorB), this.m_length = Math.max(t.length, ks.b2_linearSlop), this.m_minLength = Math.max(t.minLength, ks.b2_linearSlop), this.m_maxLength = Math.max(t.maxLength, this.m_minLength), this.m_stiffness = (e = t.stiffness) !== null && e !== void 0 ? e : 0, this.m_damping = (s = t.damping) !== null && s !== void 0 ? s : 0;
  }
  GetAnchorA(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t);
  }
  GetAnchorB(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t);
  }
  GetReactionForce(t, e) {
    const s = t * (this.m_impulse + this.m_lowerImpulse - this.m_upperImpulse);
    return e.x = s * this.m_u.x, e.y = s * this.m_u.y, e;
  }
  GetReactionTorque(t) {
    return 0;
  }
  GetLocalAnchorA() {
    return this.m_localAnchorA;
  }
  GetLocalAnchorB() {
    return this.m_localAnchorB;
  }
  SetLength(t) {
    return this.m_impulse = 0, this.m_length = Math.max(ks.b2_linearSlop, t), this.m_length;
  }
  GetLength() {
    return this.m_length;
  }
  SetMinLength(t) {
    return this.m_lowerImpulse = 0, this.m_minLength = (0, Lt.b2Clamp)(t, ks.b2_linearSlop, this.m_maxLength), this.m_minLength;
  }
  GetMinLength() {
    return this.m_minLength;
  }
  SetMaxLength(t) {
    return this.m_upperImpulse = 0, this.m_maxLength = Math.max(t, this.m_minLength), this.m_maxLength;
  }
  GetMaxLength() {
    return this.m_maxLength;
  }
  GetCurrentLength() {
    const t = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, En.worldPointA), e = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, En.worldPointB);
    return Lt.b2Vec2.Distance(e, t);
  }
  SetStiffness(t) {
    this.m_stiffness = t;
  }
  GetStiffness() {
    return this.m_stiffness;
  }
  SetDamping(t) {
    this.m_damping = t;
  }
  GetDamping() {
    return this.m_damping;
  }
  InitVelocityConstraints(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    const e = t.positions[this.m_indexA].c, s = t.positions[this.m_indexA].a, i = t.velocities[this.m_indexA].v;
    let o = t.velocities[this.m_indexA].w;
    const r = t.positions[this.m_indexB].c, a = t.positions[this.m_indexB].a, l = t.velocities[this.m_indexB].v;
    let c = t.velocities[this.m_indexB].w;
    const { qA: u, qB: m, lalcA: d, lalcB: f } = En;
    u.Set(s), m.Set(a), Lt.b2Rot.MultiplyVec2(u, Lt.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, d), this.m_rA), Lt.b2Rot.MultiplyVec2(m, Lt.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, f), this.m_rB), this.m_u.x = r.x + this.m_rB.x - e.x - this.m_rA.x, this.m_u.y = r.y + this.m_rB.y - e.y - this.m_rA.y, this.m_currentLength = this.m_u.Length(), this.m_currentLength > ks.b2_linearSlop ? this.m_u.Scale(1 / this.m_currentLength) : (this.m_u.SetZero(), this.m_mass = 0, this.m_impulse = 0, this.m_lowerImpulse = 0, this.m_upperImpulse = 0);
    const p = Lt.b2Vec2.Cross(this.m_rA, this.m_u), v = Lt.b2Vec2.Cross(this.m_rB, this.m_u);
    let _ = this.m_invMassA + this.m_invIA * p * p + this.m_invMassB + this.m_invIB * v * v;
    if (this.m_mass = _ !== 0 ? 1 / _ : 0, this.m_stiffness > 0 && this.m_minLength < this.m_maxLength) {
      const g = this.m_currentLength - this.m_length, w = this.m_damping, S = this.m_stiffness, x = t.step.dt;
      this.m_gamma = x * (w + x * S), this.m_gamma = this.m_gamma !== 0 ? 1 / this.m_gamma : 0, this.m_bias = g * x * S * this.m_gamma, _ += this.m_gamma, this.m_softMass = _ !== 0 ? 1 / _ : 0;
    } else
      this.m_gamma = 0, this.m_bias = 0, this.m_softMass = this.m_mass;
    if (t.step.warmStarting) {
      this.m_impulse *= t.step.dtRatio, this.m_lowerImpulse *= t.step.dtRatio, this.m_upperImpulse *= t.step.dtRatio;
      const { P: g } = En;
      Lt.b2Vec2.Scale(this.m_impulse + this.m_lowerImpulse - this.m_upperImpulse, this.m_u, g), i.SubtractScaled(this.m_invMassA, g), o -= this.m_invIA * Lt.b2Vec2.Cross(this.m_rA, g), l.AddScaled(this.m_invMassB, g), c += this.m_invIB * Lt.b2Vec2.Cross(this.m_rB, g);
    } else
      this.m_impulse = 0;
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = c;
  }
  SolveVelocityConstraints(t) {
    const e = t.velocities[this.m_indexA].v;
    let s = t.velocities[this.m_indexA].w;
    const i = t.velocities[this.m_indexB].v;
    let o = t.velocities[this.m_indexB].w;
    if (this.m_minLength < this.m_maxLength) {
      if (this.m_stiffness > 0) {
        const r = Lt.b2Vec2.AddCrossScalarVec2(e, s, this.m_rA, En.vpA), a = Lt.b2Vec2.AddCrossScalarVec2(i, o, this.m_rB, En.vpB), l = Lt.b2Vec2.Dot(this.m_u, Lt.b2Vec2.Subtract(a, r, En.vpBA)), c = -this.m_softMass * (l + this.m_bias + this.m_gamma * this.m_impulse);
        this.m_impulse += c;
        const u = Lt.b2Vec2.Scale(c, this.m_u, En.P);
        e.SubtractScaled(this.m_invMassA, u), s -= this.m_invIA * Lt.b2Vec2.Cross(this.m_rA, u), i.AddScaled(this.m_invMassB, u), o += this.m_invIB * Lt.b2Vec2.Cross(this.m_rB, u);
      }
      {
        const r = this.m_currentLength - this.m_minLength, a = Math.max(0, r) * t.step.inv_dt, l = Lt.b2Vec2.AddCrossScalarVec2(e, s, this.m_rA, En.vpA), c = Lt.b2Vec2.AddCrossScalarVec2(i, o, this.m_rB, En.vpB), u = Lt.b2Vec2.Dot(this.m_u, Lt.b2Vec2.Subtract(c, l, En.vpBA));
        let m = -this.m_mass * (u + a);
        const d = this.m_lowerImpulse;
        this.m_lowerImpulse = Math.max(0, this.m_lowerImpulse + m), m = this.m_lowerImpulse - d;
        const f = Lt.b2Vec2.Scale(m, this.m_u, En.P);
        e.SubtractScaled(this.m_invMassA, f), s -= this.m_invIA * Lt.b2Vec2.Cross(this.m_rA, f), i.AddScaled(this.m_invMassB, f), o += this.m_invIB * Lt.b2Vec2.Cross(this.m_rB, f);
      }
      {
        const r = this.m_maxLength - this.m_currentLength, a = Math.max(0, r) * t.step.inv_dt, l = Lt.b2Vec2.AddCrossScalarVec2(e, s, this.m_rA, En.vpA), c = Lt.b2Vec2.AddCrossScalarVec2(i, o, this.m_rB, En.vpB), u = Lt.b2Vec2.Dot(this.m_u, Lt.b2Vec2.Subtract(l, c, En.vpBA));
        let m = -this.m_mass * (u + a);
        const d = this.m_upperImpulse;
        this.m_upperImpulse = Math.max(0, this.m_upperImpulse + m), m = this.m_upperImpulse - d;
        const f = Lt.b2Vec2.Scale(-m, this.m_u, En.P);
        e.SubtractScaled(this.m_invMassA, f), s -= this.m_invIA * Lt.b2Vec2.Cross(this.m_rA, f), i.AddScaled(this.m_invMassB, f), o += this.m_invIB * Lt.b2Vec2.Cross(this.m_rB, f);
      }
    } else {
      const r = Lt.b2Vec2.AddCrossScalarVec2(e, s, this.m_rA, En.vpA), a = Lt.b2Vec2.AddCrossScalarVec2(i, o, this.m_rB, En.vpB), l = Lt.b2Vec2.Dot(this.m_u, Lt.b2Vec2.Subtract(a, r, En.vpBA)), c = -this.m_mass * l;
      this.m_impulse += c;
      const u = Lt.b2Vec2.Scale(c, this.m_u, En.P);
      e.SubtractScaled(this.m_invMassA, u), s -= this.m_invIA * Lt.b2Vec2.Cross(this.m_rA, u), i.AddScaled(this.m_invMassB, u), o += this.m_invIB * Lt.b2Vec2.Cross(this.m_rB, u);
    }
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = o;
  }
  SolvePositionConstraints(t) {
    const e = t.positions[this.m_indexA].c;
    let s = t.positions[this.m_indexA].a;
    const i = t.positions[this.m_indexB].c;
    let o = t.positions[this.m_indexB].a;
    const { qA: r, qB: a, lalcA: l, lalcB: c, P: u } = En;
    r.Set(s), a.Set(o);
    const m = Lt.b2Rot.MultiplyVec2(r, Lt.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, l), this.m_rA), d = Lt.b2Rot.MultiplyVec2(a, Lt.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, c), this.m_rB);
    this.m_u.x = i.x + d.x - e.x - m.x, this.m_u.y = i.y + d.y - e.y - m.y;
    const f = this.m_u.Normalize();
    let p;
    if (this.m_minLength === this.m_maxLength)
      p = f - this.m_minLength;
    else if (f < this.m_minLength)
      p = f - this.m_minLength;
    else if (this.m_maxLength < f)
      p = f - this.m_maxLength;
    else
      return !0;
    const v = -this.m_mass * p;
    return Lt.b2Vec2.Scale(v, this.m_u, u), e.SubtractScaled(this.m_invMassA, u), s -= this.m_invIA * Lt.b2Vec2.Cross(m, u), i.AddScaled(this.m_invMassB, u), o += this.m_invIB * Lt.b2Vec2.Cross(d, u), t.positions[this.m_indexA].a = s, t.positions[this.m_indexB].a = o, Math.abs(p) < ks.b2_linearSlop;
  }
  Draw(t) {
    const { pA: e, pB: s, axis: i, pRest: o } = En.Draw, r = this.m_bodyA.GetTransform(), a = this.m_bodyB.GetTransform();
    if (Lt.b2Transform.MultiplyVec2(r, this.m_localAnchorA, e), Lt.b2Transform.MultiplyVec2(a, this.m_localAnchorB, s), Lt.b2Vec2.Subtract(s, e, i), i.Normalize(), t.DrawSegment(e, s, Th.debugColors.joint5), Lt.b2Vec2.AddScaled(e, this.m_length, i, o), t.DrawPoint(o, 8, Th.debugColors.joint1), this.m_minLength !== this.m_maxLength) {
      if (this.m_minLength > ks.b2_linearSlop) {
        const l = Lt.b2Vec2.AddScaled(e, this.m_minLength, i, En.Draw.p1);
        t.DrawPoint(l, 4, Th.debugColors.joint2);
      }
      if (this.m_maxLength < ks.b2_maxFloat) {
        const l = Lt.b2Vec2.AddScaled(e, this.m_maxLength, i, En.Draw.p1);
        t.DrawPoint(l, 4, Th.debugColors.joint3);
      }
    }
  }
};
h(Jy, "b2DistanceJoint");
let b0 = Jy;
Mr.b2DistanceJoint = b0;
Object.defineProperty(wa, "__esModule", { value: !0 });
wa.b2AreaJoint = wa.b2AreaJointDef = void 0;
const kr = Xe, Ns = Fe, y0 = xn, l9 = Mr, Ky = class Ky extends y0.b2JointDef {
  constructor() {
    super(y0.b2JointType.e_areaJoint), this.bodies = [], this.stiffness = 0, this.damping = 0;
  }
  AddBody(t) {
    this.bodies.push(t), this.bodies.length === 1 ? this.bodyA = t : this.bodies.length === 2 && (this.bodyB = t);
  }
};
h(Ky, "b2AreaJointDef");
let x0 = Ky;
wa.b2AreaJointDef = x0;
const Qy = class Qy extends y0.b2Joint {
  constructor(t) {
    var e, s;
    super(t), this.m_stiffness = 0, this.m_damping = 0, this.m_impulse = 0, this.m_targetArea = 0, this.m_joints = [], this.m_delta = new Ns.b2Vec2(), this.m_bodies = t.bodies, this.m_stiffness = (e = t.stiffness) !== null && e !== void 0 ? e : 0, this.m_damping = (s = t.damping) !== null && s !== void 0 ? s : 0, this.m_targetLengths = (0, kr.b2MakeNumberArray)(t.bodies.length), this.m_normals = (0, kr.b2MakeArray)(t.bodies.length, Ns.b2Vec2), this.m_deltas = (0, kr.b2MakeArray)(t.bodies.length, Ns.b2Vec2);
    const i = new l9.b2DistanceJointDef();
    i.stiffness = this.m_stiffness, i.damping = this.m_damping, this.m_targetArea = 0;
    for (let o = 0; o < this.m_bodies.length; ++o) {
      const r = this.m_bodies[o], a = this.m_bodies[(o + 1) % this.m_bodies.length], l = r.GetWorldCenter(), c = a.GetWorldCenter();
      this.m_targetLengths[o] = Ns.b2Vec2.Distance(l, c), this.m_targetArea += Ns.b2Vec2.Cross(l, c), i.Initialize(r, a, l, c), this.m_joints[o] = r.GetWorld().CreateJoint(i);
    }
    this.m_targetArea *= 0.5;
  }
  GetAnchorA(t) {
    return t;
  }
  GetAnchorB(t) {
    return t;
  }
  GetReactionForce(t, e) {
    return e;
  }
  GetReactionTorque(t) {
    return 0;
  }
  SetStiffness(t) {
    this.m_stiffness = t;
    for (const e of this.m_joints)
      e.SetStiffness(t);
  }
  GetStiffness() {
    return this.m_stiffness;
  }
  SetDamping(t) {
    this.m_damping = t;
    for (const e of this.m_joints)
      e.SetDamping(t);
  }
  GetDamping() {
    return this.m_damping;
  }
  InitVelocityConstraints(t) {
    for (let e = 0; e < this.m_bodies.length; ++e) {
      const s = this.m_bodies[(e + this.m_bodies.length - 1) % this.m_bodies.length], i = this.m_bodies[(e + 1) % this.m_bodies.length], o = t.positions[s.m_islandIndex].c, r = t.positions[i.m_islandIndex].c, a = this.m_deltas[e];
      Ns.b2Vec2.Subtract(r, o, a);
    }
    if (t.step.warmStarting) {
      this.m_impulse *= t.step.dtRatio;
      for (let e = 0; e < this.m_bodies.length; ++e) {
        const s = this.m_bodies[e], i = t.velocities[s.m_islandIndex].v, o = this.m_deltas[e];
        i.x += s.m_invMass * o.y * 0.5 * this.m_impulse, i.y += s.m_invMass * -o.x * 0.5 * this.m_impulse;
      }
    } else
      this.m_impulse = 0;
  }
  SolveVelocityConstraints(t) {
    let e = 0, s = 0;
    for (let o = 0; o < this.m_bodies.length; ++o) {
      const r = this.m_bodies[o], a = t.velocities[r.m_islandIndex].v, l = this.m_deltas[o];
      e += l.LengthSquared() / r.GetMass(), s += Ns.b2Vec2.Cross(a, l);
    }
    const i = -2 * s / e;
    this.m_impulse += i;
    for (let o = 0; o < this.m_bodies.length; ++o) {
      const r = this.m_bodies[o], a = t.velocities[r.m_islandIndex].v, l = this.m_deltas[o];
      a.x += r.m_invMass * l.y * 0.5 * i, a.y += r.m_invMass * -l.x * 0.5 * i;
    }
  }
  SolvePositionConstraints(t) {
    let e = 0, s = 0;
    for (let a = 0; a < this.m_bodies.length; ++a) {
      const l = this.m_bodies[a], c = this.m_bodies[(a + 1) % this.m_bodies.length], u = t.positions[l.m_islandIndex].c, m = t.positions[c.m_islandIndex].c, d = Ns.b2Vec2.Subtract(m, u, this.m_delta);
      let f = d.Length();
      f < kr.b2_epsilon && (f = 1), this.m_normals[a].x = d.y / f, this.m_normals[a].y = -d.x / f, e += f, s += Ns.b2Vec2.Cross(u, m);
    }
    s *= 0.5;
    const o = 0.5 * (this.m_targetArea - s) / e;
    let r = !0;
    for (let a = 0; a < this.m_bodies.length; ++a) {
      const l = this.m_bodies[a], c = t.positions[l.m_islandIndex].c, u = (a + 1) % this.m_bodies.length, m = Ns.b2Vec2.Add(this.m_normals[a], this.m_normals[u], this.m_delta);
      m.Scale(o);
      const d = m.LengthSquared();
      d > kr.b2_maxLinearCorrection ** 2 && m.Scale(kr.b2_maxLinearCorrection / Math.sqrt(d)), d > kr.b2_linearSlop ** 2 && (r = !1), c.Add(m);
    }
    return r;
  }
};
h(Qy, "b2AreaJoint");
let w0 = Qy;
wa.b2AreaJoint = w0;
var Sa = {};
Object.defineProperty(Sa, "__esModule", { value: !0 });
Sa.b2FrictionJoint = Sa.b2FrictionJointDef = void 0;
const qe = Fe, S0 = xn, KS = {
  qA: new qe.b2Rot(),
  qB: new qe.b2Rot(),
  lalcA: new qe.b2Vec2(),
  lalcB: new qe.b2Vec2(),
  Cdot: new qe.b2Vec2(),
  impulse: new qe.b2Vec2(),
  oldImpulse: new qe.b2Vec2()
}, t1 = class t1 extends S0.b2JointDef {
  constructor() {
    super(S0.b2JointType.e_frictionJoint), this.localAnchorA = new qe.b2Vec2(), this.localAnchorB = new qe.b2Vec2(), this.maxForce = 0, this.maxTorque = 0;
  }
  Initialize(t, e, s) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(s, this.localAnchorA), this.bodyB.GetLocalPoint(s, this.localAnchorB);
  }
};
h(t1, "b2FrictionJointDef");
let A0 = t1;
Sa.b2FrictionJointDef = A0;
const e1 = class e1 extends S0.b2Joint {
  constructor(t) {
    var e, s;
    super(t), this.m_localAnchorA = new qe.b2Vec2(), this.m_localAnchorB = new qe.b2Vec2(), this.m_linearImpulse = new qe.b2Vec2(), this.m_angularImpulse = 0, this.m_maxForce = 0, this.m_maxTorque = 0, this.m_indexA = 0, this.m_indexB = 0, this.m_rA = new qe.b2Vec2(), this.m_rB = new qe.b2Vec2(), this.m_localCenterA = new qe.b2Vec2(), this.m_localCenterB = new qe.b2Vec2(), this.m_invMassA = 0, this.m_invMassB = 0, this.m_invIA = 0, this.m_invIB = 0, this.m_linearMass = new qe.b2Mat22(), this.m_angularMass = 0, this.m_localAnchorA.Copy(t.localAnchorA), this.m_localAnchorB.Copy(t.localAnchorB), this.m_linearImpulse.SetZero(), this.m_maxForce = (e = t.maxForce) !== null && e !== void 0 ? e : 0, this.m_maxTorque = (s = t.maxTorque) !== null && s !== void 0 ? s : 0;
  }
  InitVelocityConstraints(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    const e = t.positions[this.m_indexA].a, s = t.velocities[this.m_indexA].v;
    let i = t.velocities[this.m_indexA].w;
    const o = t.positions[this.m_indexB].a, r = t.velocities[this.m_indexB].v;
    let a = t.velocities[this.m_indexB].w;
    const { qA: l, qB: c, lalcA: u, lalcB: m } = KS;
    l.Set(e), c.Set(o), qe.b2Rot.MultiplyVec2(l, qe.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, u), this.m_rA), qe.b2Rot.MultiplyVec2(c, qe.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, m), this.m_rB);
    const d = this.m_invMassA, f = this.m_invMassB, p = this.m_invIA, v = this.m_invIB, _ = this.m_linearMass;
    if (_.ex.x = d + f + p * this.m_rA.y * this.m_rA.y + v * this.m_rB.y * this.m_rB.y, _.ex.y = -p * this.m_rA.x * this.m_rA.y - v * this.m_rB.x * this.m_rB.y, _.ey.x = _.ex.y, _.ey.y = d + f + p * this.m_rA.x * this.m_rA.x + v * this.m_rB.x * this.m_rB.x, _.Inverse(), this.m_angularMass = p + v, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), t.step.warmStarting) {
      this.m_linearImpulse.Scale(t.step.dtRatio), this.m_angularImpulse *= t.step.dtRatio;
      const g = this.m_linearImpulse;
      s.SubtractScaled(d, g), i -= p * (qe.b2Vec2.Cross(this.m_rA, g) + this.m_angularImpulse), r.AddScaled(f, g), a += v * (qe.b2Vec2.Cross(this.m_rB, g) + this.m_angularImpulse);
    } else
      this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0;
    t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = a;
  }
  SolveVelocityConstraints(t) {
    const e = t.velocities[this.m_indexA].v;
    let s = t.velocities[this.m_indexA].w;
    const i = t.velocities[this.m_indexB].v;
    let o = t.velocities[this.m_indexB].w;
    const r = this.m_invMassA, a = this.m_invMassB, l = this.m_invIA, c = this.m_invIB, u = t.step.dt;
    {
      const m = o - s;
      let d = -this.m_angularMass * m;
      const f = this.m_angularImpulse, p = u * this.m_maxTorque;
      this.m_angularImpulse = (0, qe.b2Clamp)(this.m_angularImpulse + d, -p, p), d = this.m_angularImpulse - f, s -= l * d, o += c * d;
    }
    {
      const { Cdot: m, impulse: d, oldImpulse: f } = KS;
      qe.b2Vec2.Subtract(qe.b2Vec2.AddCrossScalarVec2(i, o, this.m_rB, qe.b2Vec2.s_t0), qe.b2Vec2.AddCrossScalarVec2(e, s, this.m_rA, qe.b2Vec2.s_t1), m), qe.b2Mat22.MultiplyVec2(this.m_linearMass, m, d).Negate(), f.Copy(this.m_linearImpulse), this.m_linearImpulse.Add(d);
      const p = u * this.m_maxForce;
      this.m_linearImpulse.LengthSquared() > p * p && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Scale(p)), qe.b2Vec2.Subtract(this.m_linearImpulse, f, d), e.SubtractScaled(r, d), s -= l * qe.b2Vec2.Cross(this.m_rA, d), i.AddScaled(a, d), o += c * qe.b2Vec2.Cross(this.m_rB, d);
    }
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = o;
  }
  SolvePositionConstraints(t) {
    return !0;
  }
  GetAnchorA(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t);
  }
  GetAnchorB(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t);
  }
  GetReactionForce(t, e) {
    return e.x = t * this.m_linearImpulse.x, e.y = t * this.m_linearImpulse.y, e;
  }
  GetReactionTorque(t) {
    return t * this.m_angularImpulse;
  }
  GetLocalAnchorA() {
    return this.m_localAnchorA;
  }
  GetLocalAnchorB() {
    return this.m_localAnchorB;
  }
  SetMaxForce(t) {
    this.m_maxForce = t;
  }
  GetMaxForce() {
    return this.m_maxForce;
  }
  SetMaxTorque(t) {
    this.m_maxTorque = t;
  }
  GetMaxTorque() {
    return this.m_maxTorque;
  }
};
h(e1, "b2FrictionJoint");
let M0 = e1;
Sa.b2FrictionJoint = M0;
var Aa = {};
Object.defineProperty(Aa, "__esModule", { value: !0 });
Aa.b2GearJoint = Aa.b2GearJointDef = void 0;
const QS = Xe, Bt = Fe, Ss = xn, ac = {
  qA: new Bt.b2Rot(),
  qB: new Bt.b2Rot(),
  qC: new Bt.b2Rot(),
  qD: new Bt.b2Rot(),
  lalcA: new Bt.b2Vec2(),
  lalcB: new Bt.b2Vec2(),
  lalcC: new Bt.b2Vec2(),
  lalcD: new Bt.b2Vec2(),
  u: new Bt.b2Vec2(),
  rA: new Bt.b2Vec2(),
  rB: new Bt.b2Vec2(),
  rC: new Bt.b2Vec2(),
  rD: new Bt.b2Vec2(),
  JvAC: new Bt.b2Vec2(),
  JvBD: new Bt.b2Vec2()
}, n1 = class n1 extends Ss.b2JointDef {
  constructor() {
    super(Ss.b2JointType.e_gearJoint), this.ratio = 1;
  }
};
h(n1, "b2GearJointDef");
let C0 = n1;
Aa.b2GearJointDef = C0;
const i1 = class i1 extends Ss.b2Joint {
  constructor(t) {
    var e;
    super(t), this.m_typeA = Ss.b2JointType.e_unknownJoint, this.m_typeB = Ss.b2JointType.e_unknownJoint, this.m_localAnchorA = new Bt.b2Vec2(), this.m_localAnchorB = new Bt.b2Vec2(), this.m_localAnchorC = new Bt.b2Vec2(), this.m_localAnchorD = new Bt.b2Vec2(), this.m_localAxisC = new Bt.b2Vec2(), this.m_localAxisD = new Bt.b2Vec2(), this.m_referenceAngleA = 0, this.m_referenceAngleB = 0, this.m_constant = 0, this.m_ratio = 0, this.m_tolerance = 0, this.m_impulse = 0, this.m_indexA = 0, this.m_indexB = 0, this.m_indexC = 0, this.m_indexD = 0, this.m_lcA = new Bt.b2Vec2(), this.m_lcB = new Bt.b2Vec2(), this.m_lcC = new Bt.b2Vec2(), this.m_lcD = new Bt.b2Vec2(), this.m_mA = 0, this.m_mB = 0, this.m_mC = 0, this.m_mD = 0, this.m_iA = 0, this.m_iB = 0, this.m_iC = 0, this.m_iD = 0, this.m_JvAC = new Bt.b2Vec2(), this.m_JvBD = new Bt.b2Vec2(), this.m_JwA = 0, this.m_JwB = 0, this.m_JwC = 0, this.m_JwD = 0, this.m_mass = 0, this.m_joint1 = t.joint1, this.m_joint2 = t.joint2, this.m_typeA = this.m_joint1.GetType(), this.m_typeB = this.m_joint2.GetType();
    let s, i;
    this.m_bodyC = this.m_joint1.GetBodyA(), this.m_bodyA = this.m_joint1.GetBodyB();
    const o = this.m_bodyA.m_xf, r = this.m_bodyA.m_sweep.a, a = this.m_bodyC.m_xf, l = this.m_bodyC.m_sweep.a;
    if (this.m_typeA === Ss.b2JointType.e_revoluteJoint) {
      const f = t.joint1;
      this.m_localAnchorC.Copy(f.m_localAnchorA), this.m_localAnchorA.Copy(f.m_localAnchorB), this.m_referenceAngleA = f.m_referenceAngle, this.m_localAxisC.SetZero(), s = r - l - this.m_referenceAngleA, this.m_tolerance = QS.b2_angularSlop;
    } else {
      const f = t.joint1;
      this.m_localAnchorC.Copy(f.m_localAnchorA), this.m_localAnchorA.Copy(f.m_localAnchorB), this.m_referenceAngleA = f.m_referenceAngle, this.m_localAxisC.Copy(f.m_localXAxisA);
      const p = this.m_localAnchorC, v = Bt.b2Rot.TransposeMultiplyVec2(a.q, Bt.b2Rot.MultiplyVec2(o.q, this.m_localAnchorA, Bt.b2Vec2.s_t0).Add(o.p).Subtract(a.p), Bt.b2Vec2.s_t0);
      s = Bt.b2Vec2.Dot(v.Subtract(p), this.m_localAxisC), this.m_tolerance = QS.b2_linearSlop;
    }
    this.m_bodyD = this.m_joint2.GetBodyA(), this.m_bodyB = this.m_joint2.GetBodyB();
    const c = this.m_bodyB.m_xf, u = this.m_bodyB.m_sweep.a, m = this.m_bodyD.m_xf, d = this.m_bodyD.m_sweep.a;
    if (this.m_typeB === Ss.b2JointType.e_revoluteJoint) {
      const f = t.joint2;
      this.m_localAnchorD.Copy(f.m_localAnchorA), this.m_localAnchorB.Copy(f.m_localAnchorB), this.m_referenceAngleB = f.m_referenceAngle, this.m_localAxisD.SetZero(), i = u - d - this.m_referenceAngleB;
    } else {
      const f = t.joint2;
      this.m_localAnchorD.Copy(f.m_localAnchorA), this.m_localAnchorB.Copy(f.m_localAnchorB), this.m_referenceAngleB = f.m_referenceAngle, this.m_localAxisD.Copy(f.m_localXAxisA);
      const p = this.m_localAnchorD, v = Bt.b2Rot.TransposeMultiplyVec2(m.q, Bt.b2Rot.MultiplyVec2(c.q, this.m_localAnchorB, Bt.b2Vec2.s_t0).Add(c.p).Subtract(m.p), Bt.b2Vec2.s_t0);
      i = Bt.b2Vec2.Dot(v.Subtract(p), this.m_localAxisD);
    }
    this.m_ratio = (e = t.ratio) !== null && e !== void 0 ? e : 1, this.m_constant = s + this.m_ratio * i, this.m_impulse = 0;
  }
  InitVelocityConstraints(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_indexC = this.m_bodyC.m_islandIndex, this.m_indexD = this.m_bodyD.m_islandIndex, this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter), this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter), this.m_mA = this.m_bodyA.m_invMass, this.m_mB = this.m_bodyB.m_invMass, this.m_mC = this.m_bodyC.m_invMass, this.m_mD = this.m_bodyD.m_invMass, this.m_iA = this.m_bodyA.m_invI, this.m_iB = this.m_bodyB.m_invI, this.m_iC = this.m_bodyC.m_invI, this.m_iD = this.m_bodyD.m_invI;
    const e = t.positions[this.m_indexA].a, s = t.velocities[this.m_indexA].v;
    let i = t.velocities[this.m_indexA].w;
    const o = t.positions[this.m_indexB].a, r = t.velocities[this.m_indexB].v;
    let a = t.velocities[this.m_indexB].w;
    const l = t.positions[this.m_indexC].a, c = t.velocities[this.m_indexC].v;
    let u = t.velocities[this.m_indexC].w;
    const m = t.positions[this.m_indexD].a, d = t.velocities[this.m_indexD].v;
    let f = t.velocities[this.m_indexD].w;
    const { qA: p, qB: v, qC: _, qD: g } = ac;
    if (p.Set(e), v.Set(o), _.Set(l), g.Set(m), this.m_mass = 0, this.m_typeA === Ss.b2JointType.e_revoluteJoint)
      this.m_JvAC.SetZero(), this.m_JwA = 1, this.m_JwC = 1, this.m_mass += this.m_iA + this.m_iC;
    else {
      const { u: w, rC: S, rA: x, lalcA: A, lalcC: C } = ac;
      Bt.b2Rot.MultiplyVec2(_, this.m_localAxisC, w), Bt.b2Rot.MultiplyVec2(_, Bt.b2Vec2.Subtract(this.m_localAnchorC, this.m_lcC, C), S), Bt.b2Rot.MultiplyVec2(p, Bt.b2Vec2.Subtract(this.m_localAnchorA, this.m_lcA, A), x), this.m_JvAC.Copy(w), this.m_JwC = Bt.b2Vec2.Cross(S, w), this.m_JwA = Bt.b2Vec2.Cross(x, w), this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
    }
    if (this.m_typeB === Ss.b2JointType.e_revoluteJoint)
      this.m_JvBD.SetZero(), this.m_JwB = this.m_ratio, this.m_JwD = this.m_ratio, this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
    else {
      const { u: w, rB: S, rD: x, lalcB: A, lalcD: C } = ac;
      Bt.b2Rot.MultiplyVec2(g, this.m_localAxisD, w), Bt.b2Rot.MultiplyVec2(g, Bt.b2Vec2.Subtract(this.m_localAnchorD, this.m_lcD, C), x), Bt.b2Rot.MultiplyVec2(v, Bt.b2Vec2.Subtract(this.m_localAnchorB, this.m_lcB, A), S), Bt.b2Vec2.Scale(this.m_ratio, w, this.m_JvBD), this.m_JwD = this.m_ratio * Bt.b2Vec2.Cross(x, w), this.m_JwB = this.m_ratio * Bt.b2Vec2.Cross(S, w), this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
    }
    this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0, t.step.warmStarting ? (s.AddScaled(this.m_mA * this.m_impulse, this.m_JvAC), i += this.m_iA * this.m_impulse * this.m_JwA, r.AddScaled(this.m_mB * this.m_impulse, this.m_JvBD), a += this.m_iB * this.m_impulse * this.m_JwB, c.SubtractScaled(this.m_mC * this.m_impulse, this.m_JvAC), u -= this.m_iC * this.m_impulse * this.m_JwC, d.SubtractScaled(this.m_mD * this.m_impulse, this.m_JvBD), f -= this.m_iD * this.m_impulse * this.m_JwD) : this.m_impulse = 0, t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = a, t.velocities[this.m_indexC].w = u, t.velocities[this.m_indexD].w = f;
  }
  SolveVelocityConstraints(t) {
    const e = t.velocities[this.m_indexA].v;
    let s = t.velocities[this.m_indexA].w;
    const i = t.velocities[this.m_indexB].v;
    let o = t.velocities[this.m_indexB].w;
    const r = t.velocities[this.m_indexC].v;
    let a = t.velocities[this.m_indexC].w;
    const l = t.velocities[this.m_indexD].v;
    let c = t.velocities[this.m_indexD].w, u = Bt.b2Vec2.Dot(this.m_JvAC, Bt.b2Vec2.Subtract(e, r, Bt.b2Vec2.s_t0)) + Bt.b2Vec2.Dot(this.m_JvBD, Bt.b2Vec2.Subtract(i, l, Bt.b2Vec2.s_t0));
    u += this.m_JwA * s - this.m_JwC * a + (this.m_JwB * o - this.m_JwD * c);
    const m = -this.m_mass * u;
    this.m_impulse += m, e.AddScaled(this.m_mA * m, this.m_JvAC), s += this.m_iA * m * this.m_JwA, i.AddScaled(this.m_mB * m, this.m_JvBD), o += this.m_iB * m * this.m_JwB, r.SubtractScaled(this.m_mC * m, this.m_JvAC), a -= this.m_iC * m * this.m_JwC, l.SubtractScaled(this.m_mD * m, this.m_JvBD), c -= this.m_iD * m * this.m_JwD, t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = o, t.velocities[this.m_indexC].w = a, t.velocities[this.m_indexD].w = c;
  }
  SolvePositionConstraints(t) {
    const e = t.positions[this.m_indexA].c;
    let s = t.positions[this.m_indexA].a;
    const i = t.positions[this.m_indexB].c;
    let o = t.positions[this.m_indexB].a;
    const r = t.positions[this.m_indexC].c;
    let a = t.positions[this.m_indexC].a;
    const l = t.positions[this.m_indexD].c;
    let c = t.positions[this.m_indexD].a;
    const { qA: u, qB: m, qC: d, qD: f, JvAC: p, JvBD: v } = ac;
    u.Set(s), m.Set(o), d.Set(a), f.Set(c);
    let _, g, w, S, x, A, C = 0;
    if (this.m_typeA === Ss.b2JointType.e_revoluteJoint)
      p.SetZero(), w = 1, x = 1, C += this.m_iA + this.m_iC, _ = s - a - this.m_referenceAngleA;
    else {
      const { u: b, rC: y, rA: E, lalcC: I, lalcA: B } = ac;
      Bt.b2Rot.MultiplyVec2(d, this.m_localAxisC, b), Bt.b2Rot.MultiplyVec2(d, Bt.b2Vec2.Subtract(this.m_localAnchorC, this.m_lcC, I), y), Bt.b2Rot.MultiplyVec2(u, Bt.b2Vec2.Subtract(this.m_localAnchorA, this.m_lcA, B), E), p.Copy(b), x = Bt.b2Vec2.Cross(y, b), w = Bt.b2Vec2.Cross(E, b), C += this.m_mC + this.m_mA + this.m_iC * x * x + this.m_iA * w * w;
      const D = I, N = Bt.b2Rot.TransposeMultiplyVec2(d, Bt.b2Vec2.Add(E, e, Bt.b2Vec2.s_t0).Subtract(r), Bt.b2Vec2.s_t0);
      _ = Bt.b2Vec2.Dot(Bt.b2Vec2.Subtract(N, D, Bt.b2Vec2.s_t0), this.m_localAxisC);
    }
    if (this.m_typeB === Ss.b2JointType.e_revoluteJoint)
      v.SetZero(), S = this.m_ratio, A = this.m_ratio, C += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD), g = o - c - this.m_referenceAngleB;
    else {
      const { u: b, rD: y, rB: E, lalcD: I, lalcB: B } = ac;
      Bt.b2Rot.MultiplyVec2(f, this.m_localAxisD, b), Bt.b2Rot.MultiplyVec2(f, Bt.b2Vec2.Subtract(this.m_localAnchorD, this.m_lcD, I), y), Bt.b2Rot.MultiplyVec2(m, Bt.b2Vec2.Subtract(this.m_localAnchorB, this.m_lcB, B), E), Bt.b2Vec2.Scale(this.m_ratio, b, v), A = this.m_ratio * Bt.b2Vec2.Cross(y, b), S = this.m_ratio * Bt.b2Vec2.Cross(E, b), C += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * A * A + this.m_iB * S * S;
      const D = I, N = Bt.b2Rot.TransposeMultiplyVec2(f, Bt.b2Vec2.Add(E, i, Bt.b2Vec2.s_t0).Subtract(l), Bt.b2Vec2.s_t0);
      g = Bt.b2Vec2.Dot(N.Subtract(D), this.m_localAxisD);
    }
    const M = _ + this.m_ratio * g - this.m_constant;
    let T = 0;
    return C > 0 && (T = -M / C), e.AddScaled(this.m_mA * T, p), s += this.m_iA * T * w, i.AddScaled(this.m_mB * T, v), o += this.m_iB * T * S, r.SubtractScaled(this.m_mC * T, p), a -= this.m_iC * T * x, l.SubtractScaled(this.m_mD * T, v), c -= this.m_iD * T * A, t.positions[this.m_indexA].a = s, t.positions[this.m_indexB].a = o, t.positions[this.m_indexC].a = a, t.positions[this.m_indexD].a = c, Math.abs(M) < this.m_tolerance;
  }
  GetAnchorA(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t);
  }
  GetAnchorB(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t);
  }
  GetReactionForce(t, e) {
    return Bt.b2Vec2.Scale(t * this.m_impulse, this.m_JvAC, e);
  }
  GetReactionTorque(t) {
    return t * this.m_impulse * this.m_JwA;
  }
  GetJoint1() {
    return this.m_joint1;
  }
  GetJoint2() {
    return this.m_joint2;
  }
  GetRatio() {
    return this.m_ratio;
  }
  SetRatio(t) {
    this.m_ratio = t;
  }
};
h(i1, "b2GearJoint");
let E0 = i1;
Aa.b2GearJoint = E0;
var Ma = {};
Object.defineProperty(Ma, "__esModule", { value: !0 });
Ma.b2MotorJoint = Ma.b2MotorJointDef = void 0;
const ye = Fe, T0 = xn, tA = {
  qA: new ye.b2Rot(),
  qB: new ye.b2Rot(),
  K: new ye.b2Mat22(),
  Cdot: new ye.b2Vec2(),
  impulse: new ye.b2Vec2(),
  oldImpulse: new ye.b2Vec2()
}, s1 = class s1 extends T0.b2JointDef {
  constructor() {
    super(T0.b2JointType.e_motorJoint), this.linearOffset = new ye.b2Vec2(), this.angularOffset = 0, this.maxForce = 1, this.maxTorque = 1, this.correctionFactor = 0.3;
  }
  Initialize(t, e) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(e.GetPosition(), this.linearOffset);
    const s = t.GetAngle(), i = e.GetAngle();
    this.angularOffset = i - s;
  }
};
h(s1, "b2MotorJointDef");
let I0 = s1;
Ma.b2MotorJointDef = I0;
const o1 = class o1 extends T0.b2Joint {
  constructor(t) {
    var e, s, i, o, r;
    super(t), this.m_linearOffset = new ye.b2Vec2(), this.m_linearImpulse = new ye.b2Vec2(), this.m_angularImpulse = 0, this.m_indexA = 0, this.m_indexB = 0, this.m_rA = new ye.b2Vec2(), this.m_rB = new ye.b2Vec2(), this.m_localCenterA = new ye.b2Vec2(), this.m_localCenterB = new ye.b2Vec2(), this.m_linearError = new ye.b2Vec2(), this.m_angularError = 0, this.m_invMassA = 0, this.m_invMassB = 0, this.m_invIA = 0, this.m_invIB = 0, this.m_linearMass = new ye.b2Mat22(), this.m_angularMass = 0, this.m_linearOffset.Copy((e = t.linearOffset) !== null && e !== void 0 ? e : ye.b2Vec2.ZERO), this.m_angularOffset = (s = t.angularOffset) !== null && s !== void 0 ? s : 0, this.m_linearImpulse.SetZero(), this.m_maxForce = (i = t.maxForce) !== null && i !== void 0 ? i : 1, this.m_maxTorque = (o = t.maxTorque) !== null && o !== void 0 ? o : 1, this.m_correctionFactor = (r = t.correctionFactor) !== null && r !== void 0 ? r : 0.3;
  }
  GetAnchorA(t) {
    const e = this.m_bodyA.GetPosition();
    return t.x = e.x, t.y = e.y, t;
  }
  GetAnchorB(t) {
    const e = this.m_bodyB.GetPosition();
    return t.x = e.x, t.y = e.y, t;
  }
  GetReactionForce(t, e) {
    return ye.b2Vec2.Scale(t, this.m_linearImpulse, e);
  }
  GetReactionTorque(t) {
    return t * this.m_angularImpulse;
  }
  SetLinearOffset(t) {
    ye.b2Vec2.Equals(t, this.m_linearOffset) || (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_linearOffset.Copy(t));
  }
  GetLinearOffset() {
    return this.m_linearOffset;
  }
  SetAngularOffset(t) {
    t !== this.m_angularOffset && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_angularOffset = t);
  }
  GetAngularOffset() {
    return this.m_angularOffset;
  }
  SetMaxForce(t) {
    this.m_maxForce = t;
  }
  GetMaxForce() {
    return this.m_maxForce;
  }
  SetMaxTorque(t) {
    this.m_maxTorque = t;
  }
  GetMaxTorque() {
    return this.m_maxTorque;
  }
  GetCorrectionFactor() {
    return this.m_correctionFactor;
  }
  SetCorrectionFactor(t) {
    this.m_correctionFactor = t;
  }
  InitVelocityConstraints(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    const e = t.positions[this.m_indexA].c, s = t.positions[this.m_indexA].a, i = t.velocities[this.m_indexA].v;
    let o = t.velocities[this.m_indexA].w;
    const r = t.positions[this.m_indexB].c, a = t.positions[this.m_indexB].a, l = t.velocities[this.m_indexB].v;
    let c = t.velocities[this.m_indexB].w;
    const { qA: u, qB: m } = tA;
    u.Set(s), m.Set(a);
    const d = ye.b2Rot.MultiplyVec2(u, ye.b2Vec2.Subtract(this.m_linearOffset, this.m_localCenterA, ye.b2Vec2.s_t0), this.m_rA), f = ye.b2Rot.MultiplyVec2(m, ye.b2Vec2.Negate(this.m_localCenterB, ye.b2Vec2.s_t0), this.m_rB), p = this.m_invMassA, v = this.m_invMassB, _ = this.m_invIA, g = this.m_invIB, w = this.m_linearMass;
    if (w.ex.x = p + v + _ * d.y * d.y + g * f.y * f.y, w.ex.y = -_ * d.x * d.y - g * f.x * f.y, w.ey.x = w.ex.y, w.ey.y = p + v + _ * d.x * d.x + g * f.x * f.x, w.Inverse(), this.m_angularMass = _ + g, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), ye.b2Vec2.Subtract(ye.b2Vec2.Add(r, f, ye.b2Vec2.s_t0), ye.b2Vec2.Add(e, d, ye.b2Vec2.s_t1), this.m_linearError), this.m_angularError = a - s - this.m_angularOffset, t.step.warmStarting) {
      this.m_linearImpulse.Scale(t.step.dtRatio), this.m_angularImpulse *= t.step.dtRatio;
      const S = this.m_linearImpulse;
      i.SubtractScaled(p, S), o -= _ * (ye.b2Vec2.Cross(d, S) + this.m_angularImpulse), l.AddScaled(v, S), c += g * (ye.b2Vec2.Cross(f, S) + this.m_angularImpulse);
    } else
      this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0;
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = c;
  }
  SolveVelocityConstraints(t) {
    const e = t.velocities[this.m_indexA].v;
    let s = t.velocities[this.m_indexA].w;
    const i = t.velocities[this.m_indexB].v;
    let o = t.velocities[this.m_indexB].w;
    const r = this.m_invMassA, a = this.m_invMassB, l = this.m_invIA, c = this.m_invIB, u = t.step.dt, m = t.step.inv_dt;
    {
      const d = o - s + m * this.m_correctionFactor * this.m_angularError;
      let f = -this.m_angularMass * d;
      const p = this.m_angularImpulse, v = u * this.m_maxTorque;
      this.m_angularImpulse = (0, ye.b2Clamp)(this.m_angularImpulse + f, -v, v), f = this.m_angularImpulse - p, s -= l * f, o += c * f;
    }
    {
      const { impulse: d, oldImpulse: f, Cdot: p } = tA;
      ye.b2Vec2.AddScaled(ye.b2Vec2.Subtract(ye.b2Vec2.AddCrossScalarVec2(i, o, this.m_rB, ye.b2Vec2.s_t0), ye.b2Vec2.AddCrossScalarVec2(e, s, this.m_rA, ye.b2Vec2.s_t1), ye.b2Vec2.s_t2), m * this.m_correctionFactor, this.m_linearError, p), ye.b2Mat22.MultiplyVec2(this.m_linearMass, p, d).Negate(), f.Copy(this.m_linearImpulse), this.m_linearImpulse.Add(d);
      const v = u * this.m_maxForce;
      this.m_linearImpulse.LengthSquared() > v * v && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Scale(v)), ye.b2Vec2.Subtract(this.m_linearImpulse, f, d), e.SubtractScaled(r, d), s -= l * ye.b2Vec2.Cross(this.m_rA, d), i.AddScaled(a, d), o += c * ye.b2Vec2.Cross(this.m_rB, d);
    }
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = o;
  }
  SolvePositionConstraints(t) {
    return !0;
  }
};
h(o1, "b2MotorJoint");
let B0 = o1;
Ma.b2MotorJoint = B0;
var Ca = {};
Object.defineProperty(Ca, "__esModule", { value: !0 });
Ca.b2MouseJoint = Ca.b2MouseJointDef = void 0;
const ip = Ai, fn = Fe, P0 = xn, Ih = {
  qB: new fn.b2Rot(),
  lalcB: new fn.b2Vec2(),
  Cdot: new fn.b2Vec2(),
  impulse: new fn.b2Vec2(),
  oldImpulse: new fn.b2Vec2(),
  pA: new fn.b2Vec2(),
  pB: new fn.b2Vec2()
}, r1 = class r1 extends P0.b2JointDef {
  constructor() {
    super(P0.b2JointType.e_mouseJoint), this.target = new fn.b2Vec2(), this.maxForce = 0, this.stiffness = 0, this.damping = 0;
  }
};
h(r1, "b2MouseJointDef");
let R0 = r1;
Ca.b2MouseJointDef = R0;
const a1 = class a1 extends P0.b2Joint {
  constructor(t) {
    var e, s, i, o;
    super(t), this.m_localAnchorB = new fn.b2Vec2(), this.m_targetA = new fn.b2Vec2(), this.m_stiffness = 0, this.m_damping = 0, this.m_beta = 0, this.m_impulse = new fn.b2Vec2(), this.m_maxForce = 0, this.m_gamma = 0, this.m_indexB = 0, this.m_rB = new fn.b2Vec2(), this.m_localCenterB = new fn.b2Vec2(), this.m_invMassB = 0, this.m_invIB = 0, this.m_mass = new fn.b2Mat22(), this.m_C = new fn.b2Vec2(), this.m_targetA.Copy((e = t.target) !== null && e !== void 0 ? e : fn.b2Vec2.ZERO), fn.b2Transform.TransposeMultiplyVec2(this.m_bodyB.GetTransform(), this.m_targetA, this.m_localAnchorB), this.m_maxForce = (s = t.maxForce) !== null && s !== void 0 ? s : 0, this.m_stiffness = (i = t.stiffness) !== null && i !== void 0 ? i : 0, this.m_damping = (o = t.damping) !== null && o !== void 0 ? o : 0, this.m_beta = 0, this.m_gamma = 0;
  }
  SetTarget(t) {
    fn.b2Vec2.Equals(t, this.m_targetA) || (this.m_bodyB.SetAwake(!0), this.m_targetA.Copy(t));
  }
  GetTarget() {
    return this.m_targetA;
  }
  SetMaxForce(t) {
    this.m_maxForce = t;
  }
  GetMaxForce() {
    return this.m_maxForce;
  }
  SetStiffness(t) {
    this.m_stiffness = t;
  }
  GetStiffness() {
    return this.m_stiffness;
  }
  SetDamping(t) {
    this.m_damping = t;
  }
  GetDamping() {
    return this.m_damping;
  }
  InitVelocityConstraints(t) {
    this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIB = this.m_bodyB.m_invI;
    const e = t.positions[this.m_indexB].c, s = t.positions[this.m_indexB].a, i = t.velocities[this.m_indexB].v;
    let o = t.velocities[this.m_indexB].w;
    const { qB: r, lalcB: a } = Ih;
    r.Set(s);
    const l = this.m_damping, c = this.m_stiffness, u = t.step.dt;
    this.m_gamma = u * (l + u * c), this.m_gamma !== 0 && (this.m_gamma = 1 / this.m_gamma), this.m_beta = u * c * this.m_gamma, fn.b2Rot.MultiplyVec2(r, fn.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, a), this.m_rB);
    const m = this.m_mass;
    m.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma, m.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y, m.ey.x = m.ex.y, m.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma, m.Inverse(), fn.b2Vec2.Add(e, this.m_rB, this.m_C).Subtract(this.m_targetA), this.m_C.Scale(this.m_beta), o *= Math.max(0, 1 - 0.02 * (60 * t.step.dt)), t.step.warmStarting ? (this.m_impulse.Scale(t.step.dtRatio), i.AddScaled(this.m_invMassB, this.m_impulse), o += this.m_invIB * fn.b2Vec2.Cross(this.m_rB, this.m_impulse)) : this.m_impulse.SetZero(), t.velocities[this.m_indexB].w = o;
  }
  SolveVelocityConstraints(t) {
    const e = t.velocities[this.m_indexB].v;
    let s = t.velocities[this.m_indexB].w;
    const { Cdot: i, impulse: o, oldImpulse: r } = Ih;
    fn.b2Vec2.AddCrossScalarVec2(e, s, this.m_rB, i), fn.b2Mat22.MultiplyVec2(this.m_mass, fn.b2Vec2.Add(i, this.m_C, o).AddScaled(this.m_gamma, this.m_impulse).Negate(), o), r.Copy(this.m_impulse), this.m_impulse.Add(o);
    const a = t.step.dt * this.m_maxForce;
    this.m_impulse.LengthSquared() > a * a && this.m_impulse.Scale(a / this.m_impulse.Length()), fn.b2Vec2.Subtract(this.m_impulse, r, o), e.AddScaled(this.m_invMassB, o), s += this.m_invIB * fn.b2Vec2.Cross(this.m_rB, o), t.velocities[this.m_indexB].w = s;
  }
  SolvePositionConstraints(t) {
    return !0;
  }
  GetAnchorA(t) {
    return t.x = this.m_targetA.x, t.y = this.m_targetA.y, t;
  }
  GetAnchorB(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t);
  }
  GetReactionForce(t, e) {
    return fn.b2Vec2.Scale(t, this.m_impulse, e);
  }
  GetReactionTorque(t) {
    return 0;
  }
  ShiftOrigin(t) {
    this.m_targetA.Subtract(t);
  }
  Draw(t) {
    const e = this.GetAnchorA(Ih.pA), s = this.GetAnchorB(Ih.pB);
    t.DrawPoint(e, 4, ip.debugColors.joint7), t.DrawPoint(s, 4, ip.debugColors.joint7), t.DrawSegment(e, s, ip.debugColors.joint8);
  }
};
h(a1, "b2MouseJoint");
let D0 = a1;
Ca.b2MouseJoint = D0;
var Ea = {};
Object.defineProperty(Ea, "__esModule", { value: !0 });
Ea.b2PrismaticJoint = Ea.b2PrismaticJointDef = void 0;
const sp = Xe, Ur = Ai, st = Fe, V0 = xn, Ui = {
  K3: new st.b2Mat33(),
  K2: new st.b2Mat22(),
  qA: new st.b2Rot(),
  qB: new st.b2Rot(),
  lalcA: new st.b2Vec2(),
  lalcB: new st.b2Vec2(),
  rA: new st.b2Vec2(),
  rB: new st.b2Vec2(),
  GetJointTranslation: {
    pA: new st.b2Vec2(),
    pB: new st.b2Vec2(),
    d: new st.b2Vec2(),
    axis: new st.b2Vec2()
  },
  InitVelocityConstraints: {
    d: new st.b2Vec2(),
    P: new st.b2Vec2()
  },
  SolveVelocityConstraints: {
    P: new st.b2Vec2(),
    df: new st.b2Vec2()
  },
  SolvePositionConstraints: {
    d: new st.b2Vec2(),
    impulse: new st.b2Vec3(),
    impulse1: new st.b2Vec2(),
    P: new st.b2Vec2()
  },
  Draw: {
    p1: new st.b2Vec2(),
    p2: new st.b2Vec2(),
    pA: new st.b2Vec2(),
    pB: new st.b2Vec2(),
    axis: new st.b2Vec2(),
    lower: new st.b2Vec2(),
    upper: new st.b2Vec2(),
    perp: new st.b2Vec2()
  }
}, c1 = class c1 extends V0.b2JointDef {
  constructor() {
    super(V0.b2JointType.e_prismaticJoint), this.localAnchorA = new st.b2Vec2(), this.localAnchorB = new st.b2Vec2(), this.localAxisA = new st.b2Vec2(1, 0), this.referenceAngle = 0, this.enableLimit = !1, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = !1, this.maxMotorForce = 0, this.motorSpeed = 0;
  }
  Initialize(t, e, s, i) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(s, this.localAnchorA), this.bodyB.GetLocalPoint(s, this.localAnchorB), this.bodyA.GetLocalVector(i, this.localAxisA), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
  }
};
h(c1, "b2PrismaticJointDef");
let L0 = c1;
Ea.b2PrismaticJointDef = L0;
const l1 = class l1 extends V0.b2Joint {
  constructor(t) {
    var e, s, i, o, r, a, l, c, u, m;
    super(t), this.m_localAnchorA = new st.b2Vec2(), this.m_localAnchorB = new st.b2Vec2(), this.m_localXAxisA = new st.b2Vec2(), this.m_localYAxisA = new st.b2Vec2(), this.m_referenceAngle = 0, this.m_impulse = new st.b2Vec2(), this.m_motorImpulse = 0, this.m_lowerImpulse = 0, this.m_upperImpulse = 0, this.m_lowerTranslation = 0, this.m_upperTranslation = 0, this.m_maxMotorForce = 0, this.m_motorSpeed = 0, this.m_enableLimit = !1, this.m_enableMotor = !1, this.m_indexA = 0, this.m_indexB = 0, this.m_localCenterA = new st.b2Vec2(), this.m_localCenterB = new st.b2Vec2(), this.m_invMassA = 0, this.m_invMassB = 0, this.m_invIA = 0, this.m_invIB = 0, this.m_axis = new st.b2Vec2(), this.m_perp = new st.b2Vec2(), this.m_s1 = 0, this.m_s2 = 0, this.m_a1 = 0, this.m_a2 = 0, this.m_K = new st.b2Mat22(), this.m_translation = 0, this.m_axialMass = 0, this.m_localAnchorA.Copy((e = t.localAnchorA) !== null && e !== void 0 ? e : st.b2Vec2.ZERO), this.m_localAnchorB.Copy((s = t.localAnchorB) !== null && s !== void 0 ? s : st.b2Vec2.ZERO), st.b2Vec2.Normalize((i = t.localAxisA) !== null && i !== void 0 ? i : st.b2Vec2.UNITX, this.m_localXAxisA), st.b2Vec2.CrossOneVec2(this.m_localXAxisA, this.m_localYAxisA), this.m_referenceAngle = (o = t.referenceAngle) !== null && o !== void 0 ? o : 0, this.m_lowerTranslation = (r = t.lowerTranslation) !== null && r !== void 0 ? r : 0, this.m_upperTranslation = (a = t.upperTranslation) !== null && a !== void 0 ? a : 0, this.m_maxMotorForce = (l = t.maxMotorForce) !== null && l !== void 0 ? l : 0, this.m_motorSpeed = (c = t.motorSpeed) !== null && c !== void 0 ? c : 0, this.m_enableLimit = (u = t.enableLimit) !== null && u !== void 0 ? u : !1, this.m_enableMotor = (m = t.enableMotor) !== null && m !== void 0 ? m : !1;
  }
  InitVelocityConstraints(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    const e = t.positions[this.m_indexA].c, s = t.positions[this.m_indexA].a, i = t.velocities[this.m_indexA].v;
    let o = t.velocities[this.m_indexA].w;
    const r = t.positions[this.m_indexB].c, a = t.positions[this.m_indexB].a, l = t.velocities[this.m_indexB].v;
    let c = t.velocities[this.m_indexB].w;
    const { qA: u, qB: m, lalcA: d, lalcB: f, rA: p, rB: v } = Ui;
    u.Set(s), m.Set(a), st.b2Rot.MultiplyVec2(u, st.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, d), p), st.b2Rot.MultiplyVec2(m, st.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, f), v);
    const _ = st.b2Vec2.Subtract(r, e, Ui.InitVelocityConstraints.d).Add(v).Subtract(p), g = this.m_invMassA, w = this.m_invMassB, S = this.m_invIA, x = this.m_invIB;
    st.b2Rot.MultiplyVec2(u, this.m_localXAxisA, this.m_axis), this.m_a1 = st.b2Vec2.Cross(st.b2Vec2.Add(_, p, st.b2Vec2.s_t0), this.m_axis), this.m_a2 = st.b2Vec2.Cross(v, this.m_axis), this.m_axialMass = g + w + S * this.m_a1 * this.m_a1 + x * this.m_a2 * this.m_a2, this.m_axialMass > 0 && (this.m_axialMass = 1 / this.m_axialMass), st.b2Rot.MultiplyVec2(u, this.m_localYAxisA, this.m_perp), this.m_s1 = st.b2Vec2.Cross(st.b2Vec2.Add(_, p, st.b2Vec2.s_t0), this.m_perp), this.m_s2 = st.b2Vec2.Cross(v, this.m_perp);
    const A = g + w + S * this.m_s1 * this.m_s1 + x * this.m_s2 * this.m_s2, C = S * this.m_s1 + x * this.m_s2;
    let M = S + x;
    if (M === 0 && (M = 1), this.m_K.ex.Set(A, C), this.m_K.ey.Set(C, M), this.m_enableLimit ? this.m_translation = st.b2Vec2.Dot(this.m_axis, _) : (this.m_lowerImpulse = 0, this.m_upperImpulse = 0), this.m_enableMotor || (this.m_motorImpulse = 0), t.step.warmStarting) {
      this.m_impulse.Scale(t.step.dtRatio), this.m_motorImpulse *= t.step.dtRatio, this.m_lowerImpulse *= t.step.dtRatio, this.m_upperImpulse *= t.step.dtRatio;
      const T = this.m_motorImpulse + this.m_lowerImpulse - this.m_upperImpulse, { P: b } = Ui.InitVelocityConstraints;
      st.b2Vec2.Scale(this.m_impulse.x, this.m_perp, b).AddScaled(T, this.m_axis);
      const y = this.m_impulse.x * this.m_s1 + this.m_impulse.y + T * this.m_a1, E = this.m_impulse.x * this.m_s2 + this.m_impulse.y + T * this.m_a2;
      i.SubtractScaled(g, b), o -= S * y, l.AddScaled(w, b), c += x * E;
    } else
      this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerImpulse = 0, this.m_upperImpulse = 0;
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = c;
  }
  SolveVelocityConstraints(t) {
    const e = t.velocities[this.m_indexA].v;
    let s = t.velocities[this.m_indexA].w;
    const i = t.velocities[this.m_indexB].v;
    let o = t.velocities[this.m_indexB].w;
    const r = this.m_invMassA, a = this.m_invMassB, l = this.m_invIA, c = this.m_invIB, { P: u, df: m } = Ui.SolveVelocityConstraints;
    if (this.m_enableMotor) {
      const d = st.b2Vec2.Dot(this.m_axis, st.b2Vec2.Subtract(i, e, st.b2Vec2.s_t0)) + this.m_a2 * o - this.m_a1 * s;
      let f = this.m_axialMass * (this.m_motorSpeed - d);
      const p = this.m_motorImpulse, v = t.step.dt * this.m_maxMotorForce;
      this.m_motorImpulse = (0, st.b2Clamp)(this.m_motorImpulse + f, -v, v), f = this.m_motorImpulse - p, st.b2Vec2.Scale(f, this.m_axis, u);
      const _ = f * this.m_a1, g = f * this.m_a2;
      e.SubtractScaled(r, u), s -= l * _, i.AddScaled(a, u), o += c * g;
    }
    if (this.m_enableLimit) {
      {
        const d = this.m_translation - this.m_lowerTranslation, f = st.b2Vec2.Dot(this.m_axis, st.b2Vec2.Subtract(i, e, st.b2Vec2.s_t0)) + this.m_a2 * o - this.m_a1 * s;
        let p = -this.m_axialMass * (f + Math.max(d, 0) * t.step.inv_dt);
        const v = this.m_lowerImpulse;
        this.m_lowerImpulse = Math.max(this.m_lowerImpulse + p, 0), p = this.m_lowerImpulse - v, st.b2Vec2.Scale(p, this.m_axis, u);
        const _ = p * this.m_a1, g = p * this.m_a2;
        e.SubtractScaled(r, u), s -= l * _, i.AddScaled(a, u), o += c * g;
      }
      {
        const d = this.m_upperTranslation - this.m_translation, f = st.b2Vec2.Dot(this.m_axis, st.b2Vec2.Subtract(e, i, st.b2Vec2.s_t0)) + this.m_a1 * s - this.m_a2 * o;
        let p = -this.m_axialMass * (f + Math.max(d, 0) * t.step.inv_dt);
        const v = this.m_upperImpulse;
        this.m_upperImpulse = Math.max(this.m_upperImpulse + p, 0), p = this.m_upperImpulse - v, st.b2Vec2.Scale(p, this.m_axis, u);
        const _ = p * this.m_a1, g = p * this.m_a2;
        e.AddScaled(r, u), s += l * _, i.SubtractScaled(a, u), o -= c * g;
      }
    }
    {
      const d = st.b2Vec2.Dot(this.m_perp, st.b2Vec2.Subtract(i, e, st.b2Vec2.s_t0)) + this.m_s2 * o - this.m_s1 * s, f = o - s;
      this.m_K.Solve(-d, -f, m), this.m_impulse.Add(m), st.b2Vec2.Scale(m.x, this.m_perp, u);
      const p = m.x * this.m_s1 + m.y, v = m.x * this.m_s2 + m.y;
      e.SubtractScaled(r, u), s -= l * p, i.AddScaled(a, u), o += c * v;
    }
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = o;
  }
  SolvePositionConstraints(t) {
    const e = t.positions[this.m_indexA].c;
    let s = t.positions[this.m_indexA].a;
    const i = t.positions[this.m_indexB].c;
    let o = t.positions[this.m_indexB].a;
    const { qA: r, qB: a, lalcA: l, lalcB: c, rA: u, rB: m } = Ui;
    r.Set(s), a.Set(o);
    const d = this.m_invMassA, f = this.m_invMassB, p = this.m_invIA, v = this.m_invIB, { d: _, impulse: g, P: w } = Ui.SolvePositionConstraints;
    st.b2Rot.MultiplyVec2(r, st.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, l), u), st.b2Rot.MultiplyVec2(a, st.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, c), m), st.b2Vec2.Add(i, m, _).Subtract(e).Subtract(u);
    const S = st.b2Rot.MultiplyVec2(r, this.m_localXAxisA, this.m_axis), x = st.b2Vec2.Cross(st.b2Vec2.Add(_, u, st.b2Vec2.s_t0), S), A = st.b2Vec2.Cross(m, S), C = st.b2Rot.MultiplyVec2(r, this.m_localYAxisA, this.m_perp), M = st.b2Vec2.Cross(st.b2Vec2.Add(_, u, st.b2Vec2.s_t0), C), T = st.b2Vec2.Cross(m, C), b = st.b2Vec2.Dot(C, _), y = o - s - this.m_referenceAngle;
    let E = Math.abs(b);
    const I = Math.abs(y);
    let B = !1, D = 0;
    if (this.m_enableLimit) {
      const G = st.b2Vec2.Dot(S, _);
      Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * sp.b2_linearSlop ? (D = G, E = Math.max(E, Math.abs(G)), B = !0) : G <= this.m_lowerTranslation ? (D = Math.min(G - this.m_lowerTranslation, 0), E = Math.max(E, this.m_lowerTranslation - G), B = !0) : G >= this.m_upperTranslation && (D = Math.max(G - this.m_upperTranslation, 0), E = Math.max(E, G - this.m_upperTranslation), B = !0);
    }
    if (B) {
      const G = d + f + p * M * M + v * T * T, U = p * M + v * T, j = p * M * x + v * T * A;
      let tt = p + v;
      tt === 0 && (tt = 1);
      const K = p * x + v * A, $ = d + f + p * x * x + v * A * A, lt = Ui.K3;
      lt.ex.Set(G, U, j), lt.ey.Set(U, tt, K), lt.ez.Set(j, K, $), lt.Solve33(-b, -y, -D, g);
    } else {
      const G = d + f + p * M * M + v * T * T, U = p * M + v * T;
      let j = p + v;
      j === 0 && (j = 1);
      const tt = Ui.K2;
      tt.ex.Set(G, U), tt.ey.Set(U, j);
      const K = tt.Solve(-b, -y, Ui.SolvePositionConstraints.impulse1);
      g.x = K.x, g.y = K.y, g.z = 0;
    }
    st.b2Vec2.Scale(g.x, C, w).AddScaled(g.z, S);
    const N = g.x * M + g.y + g.z * x, V = g.x * T + g.y + g.z * A;
    return e.SubtractScaled(d, w), s -= p * N, i.AddScaled(f, w), o += v * V, t.positions[this.m_indexA].a = s, t.positions[this.m_indexB].a = o, E <= sp.b2_linearSlop && I <= sp.b2_angularSlop;
  }
  GetAnchorA(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t);
  }
  GetAnchorB(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t);
  }
  GetReactionForce(t, e) {
    const s = this.m_motorImpulse + this.m_lowerImpulse - this.m_upperImpulse;
    return e.x = t * (this.m_impulse.x * this.m_perp.x + s * this.m_axis.x), e.y = t * (this.m_impulse.x * this.m_perp.y + s * this.m_axis.y), e;
  }
  GetReactionTorque(t) {
    return t * this.m_impulse.y;
  }
  GetLocalAnchorA() {
    return this.m_localAnchorA;
  }
  GetLocalAnchorB() {
    return this.m_localAnchorB;
  }
  GetLocalAxisA() {
    return this.m_localXAxisA;
  }
  GetReferenceAngle() {
    return this.m_referenceAngle;
  }
  GetJointTranslation() {
    const { pA: t, pB: e, axis: s, d: i } = Ui.GetJointTranslation;
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t), this.m_bodyB.GetWorldPoint(this.m_localAnchorB, e), st.b2Vec2.Subtract(e, t, i), this.m_bodyA.GetWorldVector(this.m_localXAxisA, s), st.b2Vec2.Dot(i, s);
  }
  GetJointSpeed() {
    const t = this.m_bodyA, e = this.m_bodyB, { lalcA: s, lalcB: i, rA: o, rB: r } = Ui;
    st.b2Rot.MultiplyVec2(t.m_xf.q, st.b2Vec2.Subtract(this.m_localAnchorA, t.m_sweep.localCenter, s), o), st.b2Rot.MultiplyVec2(e.m_xf.q, st.b2Vec2.Subtract(this.m_localAnchorB, e.m_sweep.localCenter, i), r);
    const a = st.b2Vec2.Add(t.m_sweep.c, o, st.b2Vec2.s_t0), l = st.b2Vec2.Add(e.m_sweep.c, r, st.b2Vec2.s_t1), c = st.b2Vec2.Subtract(l, a, st.b2Vec2.s_t2), u = st.b2Rot.MultiplyVec2(t.m_xf.q, this.m_localXAxisA, this.m_axis), m = t.m_linearVelocity, d = e.m_linearVelocity, f = t.m_angularVelocity, p = e.m_angularVelocity;
    return st.b2Vec2.Dot(c, st.b2Vec2.CrossScalarVec2(f, u, st.b2Vec2.s_t0)) + st.b2Vec2.Dot(u, st.b2Vec2.Subtract(st.b2Vec2.AddCrossScalarVec2(d, p, r, st.b2Vec2.s_t0), st.b2Vec2.AddCrossScalarVec2(m, f, o, st.b2Vec2.s_t1), st.b2Vec2.s_t0));
  }
  IsLimitEnabled() {
    return this.m_enableLimit;
  }
  EnableLimit(t) {
    return t !== this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t, this.m_lowerImpulse = 0, this.m_upperImpulse = 0), t;
  }
  GetLowerLimit() {
    return this.m_lowerTranslation;
  }
  GetUpperLimit() {
    return this.m_upperTranslation;
  }
  SetLimits(t, e) {
    (t !== this.m_lowerTranslation || e !== this.m_upperTranslation) && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = t, this.m_upperTranslation = e, this.m_lowerImpulse = 0, this.m_upperImpulse = 0);
  }
  IsMotorEnabled() {
    return this.m_enableMotor;
  }
  EnableMotor(t) {
    return t !== this.m_enableMotor && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t), t;
  }
  SetMotorSpeed(t) {
    return t !== this.m_motorSpeed && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t), t;
  }
  GetMotorSpeed() {
    return this.m_motorSpeed;
  }
  SetMaxMotorForce(t) {
    t !== this.m_maxMotorForce && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = t);
  }
  GetMaxMotorForce() {
    return this.m_maxMotorForce;
  }
  GetMotorForce(t) {
    return t * this.m_motorImpulse;
  }
  Draw(t) {
    const { p1: e, p2: s, pA: i, pB: o, axis: r } = Ui.Draw, a = this.m_bodyA.GetTransform(), l = this.m_bodyB.GetTransform();
    if (st.b2Transform.MultiplyVec2(a, this.m_localAnchorA, i), st.b2Transform.MultiplyVec2(l, this.m_localAnchorB, o), st.b2Rot.MultiplyVec2(a.q, this.m_localXAxisA, r), t.DrawSegment(i, o, Ur.debugColors.joint5), this.m_enableLimit) {
      const { lower: c, upper: u, perp: m } = Ui.Draw;
      st.b2Vec2.AddScaled(i, this.m_lowerTranslation, r, c), st.b2Vec2.AddScaled(i, this.m_upperTranslation, r, u), st.b2Rot.MultiplyVec2(a.q, this.m_localYAxisA, m), t.DrawSegment(c, u, Ur.debugColors.joint1), t.DrawSegment(st.b2Vec2.SubtractScaled(c, 0.5, m, e), st.b2Vec2.AddScaled(c, 0.5, m, s), Ur.debugColors.joint2), t.DrawSegment(st.b2Vec2.SubtractScaled(u, 0.5, m, e), st.b2Vec2.AddScaled(u, 0.5, m, s), Ur.debugColors.joint3);
    } else
      t.DrawSegment(st.b2Vec2.Subtract(i, r, e), st.b2Vec2.Add(i, r, s), Ur.debugColors.joint1);
    t.DrawPoint(i, 5, Ur.debugColors.joint1), t.DrawPoint(o, 5, Ur.debugColors.joint4);
  }
};
h(l1, "b2PrismaticJoint");
let N0 = l1;
Ea.b2PrismaticJoint = N0;
var ko = {};
Object.defineProperty(ko, "__esModule", { value: !0 });
ko.b2PulleyJoint = ko.b2PulleyJointDef = ko.b2_minPulleyLength = void 0;
const pl = Xe, op = Ai, Xt = Fe, z0 = xn;
ko.b2_minPulleyLength = 2;
const tr = {
  qA: new Xt.b2Rot(),
  qB: new Xt.b2Rot(),
  lalcA: new Xt.b2Vec2(),
  lalcB: new Xt.b2Vec2(),
  p: new Xt.b2Vec2(),
  PA: new Xt.b2Vec2(),
  PB: new Xt.b2Vec2(),
  vpA: new Xt.b2Vec2(),
  vpB: new Xt.b2Vec2(),
  pA: new Xt.b2Vec2(),
  pB: new Xt.b2Vec2()
}, u1 = class u1 extends z0.b2JointDef {
  constructor() {
    super(z0.b2JointType.e_pulleyJoint), this.groundAnchorA = new Xt.b2Vec2(-1, 1), this.groundAnchorB = new Xt.b2Vec2(1, 1), this.localAnchorA = new Xt.b2Vec2(-1, 0), this.localAnchorB = new Xt.b2Vec2(1, 0), this.lengthA = 0, this.lengthB = 0, this.ratio = 1, this.collideConnected = !0;
  }
  Initialize(t, e, s, i, o, r, a) {
    this.bodyA = t, this.bodyB = e, this.groundAnchorA.Copy(s), this.groundAnchorB.Copy(i), this.bodyA.GetLocalPoint(o, this.localAnchorA), this.bodyB.GetLocalPoint(r, this.localAnchorB), this.lengthA = Xt.b2Vec2.Distance(o, s), this.lengthB = Xt.b2Vec2.Distance(r, i), this.ratio = a;
  }
};
h(u1, "b2PulleyJointDef");
let k0 = u1;
ko.b2PulleyJointDef = k0;
const u9 = new Xt.b2Vec2(-1, 1), h9 = Xt.b2Vec2.UNITX, d9 = new Xt.b2Vec2(-1, 0), m9 = Xt.b2Vec2.UNITX, h1 = class h1 extends z0.b2Joint {
  constructor(t) {
    var e, s, i, o, r, a, l;
    super(t), this.m_groundAnchorA = new Xt.b2Vec2(), this.m_groundAnchorB = new Xt.b2Vec2(), this.m_lengthA = 0, this.m_lengthB = 0, this.m_localAnchorA = new Xt.b2Vec2(), this.m_localAnchorB = new Xt.b2Vec2(), this.m_constant = 0, this.m_ratio = 0, this.m_impulse = 0, this.m_indexA = 0, this.m_indexB = 0, this.m_uA = new Xt.b2Vec2(), this.m_uB = new Xt.b2Vec2(), this.m_rA = new Xt.b2Vec2(), this.m_rB = new Xt.b2Vec2(), this.m_localCenterA = new Xt.b2Vec2(), this.m_localCenterB = new Xt.b2Vec2(), this.m_invMassA = 0, this.m_invMassB = 0, this.m_invIA = 0, this.m_invIB = 0, this.m_mass = 0, this.m_groundAnchorA.Copy((e = t.groundAnchorA) !== null && e !== void 0 ? e : u9), this.m_groundAnchorB.Copy((s = t.groundAnchorB) !== null && s !== void 0 ? s : h9), this.m_localAnchorA.Copy((i = t.localAnchorA) !== null && i !== void 0 ? i : d9), this.m_localAnchorB.Copy((o = t.localAnchorB) !== null && o !== void 0 ? o : m9), this.m_lengthA = (r = t.lengthA) !== null && r !== void 0 ? r : 0, this.m_lengthB = (a = t.lengthB) !== null && a !== void 0 ? a : 0, this.m_ratio = (l = t.ratio) !== null && l !== void 0 ? l : 1, this.m_constant = this.m_lengthA + this.m_ratio * this.m_lengthB, this.m_impulse = 0;
  }
  InitVelocityConstraints(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    const e = t.positions[this.m_indexA].c, s = t.positions[this.m_indexA].a, i = t.velocities[this.m_indexA].v;
    let o = t.velocities[this.m_indexA].w;
    const r = t.positions[this.m_indexB].c, a = t.positions[this.m_indexB].a, l = t.velocities[this.m_indexB].v;
    let c = t.velocities[this.m_indexB].w;
    const { qA: u, qB: m, lalcA: d, lalcB: f } = tr;
    u.Set(s), m.Set(a), Xt.b2Rot.MultiplyVec2(u, Xt.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, d), this.m_rA), Xt.b2Rot.MultiplyVec2(m, Xt.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, f), this.m_rB), Xt.b2Vec2.Add(e, this.m_rA, this.m_uA).Subtract(this.m_groundAnchorA), Xt.b2Vec2.Add(r, this.m_rB, this.m_uB).Subtract(this.m_groundAnchorB);
    const p = this.m_uA.Length(), v = this.m_uB.Length();
    p > 10 * pl.b2_linearSlop ? this.m_uA.Scale(1 / p) : this.m_uA.SetZero(), v > 10 * pl.b2_linearSlop ? this.m_uB.Scale(1 / v) : this.m_uB.SetZero();
    const _ = Xt.b2Vec2.Cross(this.m_rA, this.m_uA), g = Xt.b2Vec2.Cross(this.m_rB, this.m_uB), w = this.m_invMassA + this.m_invIA * _ * _, S = this.m_invMassB + this.m_invIB * g * g;
    if (this.m_mass = w + this.m_ratio * this.m_ratio * S, this.m_mass > 0 && (this.m_mass = 1 / this.m_mass), t.step.warmStarting) {
      this.m_impulse *= t.step.dtRatio;
      const { PA: x, PB: A } = tr;
      Xt.b2Vec2.Scale(-this.m_impulse, this.m_uA, x), Xt.b2Vec2.Scale(-this.m_ratio * this.m_impulse, this.m_uB, A), i.AddScaled(this.m_invMassA, x), o += this.m_invIA * Xt.b2Vec2.Cross(this.m_rA, x), l.AddScaled(this.m_invMassB, A), c += this.m_invIB * Xt.b2Vec2.Cross(this.m_rB, A);
    } else
      this.m_impulse = 0;
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = c;
  }
  SolveVelocityConstraints(t) {
    const e = t.velocities[this.m_indexA].v;
    let s = t.velocities[this.m_indexA].w;
    const i = t.velocities[this.m_indexB].v;
    let o = t.velocities[this.m_indexB].w;
    const { PA: r, PB: a, vpA: l, vpB: c } = tr;
    Xt.b2Vec2.AddCrossScalarVec2(e, s, this.m_rA, l), Xt.b2Vec2.AddCrossScalarVec2(i, o, this.m_rB, c);
    const u = -Xt.b2Vec2.Dot(this.m_uA, l) - this.m_ratio * Xt.b2Vec2.Dot(this.m_uB, c), m = -this.m_mass * u;
    this.m_impulse += m, Xt.b2Vec2.Scale(-m, this.m_uA, r), Xt.b2Vec2.Scale(-this.m_ratio * m, this.m_uB, a), e.AddScaled(this.m_invMassA, r), s += this.m_invIA * Xt.b2Vec2.Cross(this.m_rA, r), i.AddScaled(this.m_invMassB, a), o += this.m_invIB * Xt.b2Vec2.Cross(this.m_rB, a), t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = o;
  }
  SolvePositionConstraints(t) {
    const e = t.positions[this.m_indexA].c;
    let s = t.positions[this.m_indexA].a;
    const i = t.positions[this.m_indexB].c;
    let o = t.positions[this.m_indexB].a;
    const { qA: r, qB: a, lalcA: l, lalcB: c, PA: u, PB: m } = tr;
    r.Set(s), a.Set(o);
    const d = Xt.b2Rot.MultiplyVec2(r, Xt.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, l), this.m_rA), f = Xt.b2Rot.MultiplyVec2(a, Xt.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, c), this.m_rB), p = Xt.b2Vec2.Add(e, d, this.m_uA).Subtract(this.m_groundAnchorA), v = Xt.b2Vec2.Add(i, f, this.m_uB).Subtract(this.m_groundAnchorB), _ = p.Length(), g = v.Length();
    _ > 10 * pl.b2_linearSlop ? p.Scale(1 / _) : p.SetZero(), g > 10 * pl.b2_linearSlop ? v.Scale(1 / g) : v.SetZero();
    const w = Xt.b2Vec2.Cross(d, p), S = Xt.b2Vec2.Cross(f, v), x = this.m_invMassA + this.m_invIA * w * w, A = this.m_invMassB + this.m_invIB * S * S;
    let C = x + this.m_ratio * this.m_ratio * A;
    C > 0 && (C = 1 / C);
    const M = this.m_constant - _ - this.m_ratio * g, T = Math.abs(M), b = -C * M;
    return Xt.b2Vec2.Scale(-b, p, u), Xt.b2Vec2.Scale(-this.m_ratio * b, v, m), e.AddScaled(this.m_invMassA, u), s += this.m_invIA * Xt.b2Vec2.Cross(d, u), i.AddScaled(this.m_invMassB, m), o += this.m_invIB * Xt.b2Vec2.Cross(f, m), t.positions[this.m_indexA].a = s, t.positions[this.m_indexB].a = o, T < pl.b2_linearSlop;
  }
  GetAnchorA(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t);
  }
  GetAnchorB(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t);
  }
  GetReactionForce(t, e) {
    return e.x = t * this.m_impulse * this.m_uB.x, e.y = t * this.m_impulse * this.m_uB.y, e;
  }
  GetReactionTorque(t) {
    return 0;
  }
  GetGroundAnchorA() {
    return this.m_groundAnchorA;
  }
  GetGroundAnchorB() {
    return this.m_groundAnchorB;
  }
  GetLengthA() {
    return this.m_lengthA;
  }
  GetLengthB() {
    return this.m_lengthB;
  }
  GetRatio() {
    return this.m_ratio;
  }
  GetCurrentLengthA() {
    const t = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, tr.p), e = this.m_groundAnchorA;
    return Xt.b2Vec2.Distance(t, e);
  }
  GetCurrentLengthB() {
    const t = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, tr.p), e = this.m_groundAnchorB;
    return Xt.b2Vec2.Distance(t, e);
  }
  ShiftOrigin(t) {
    this.m_groundAnchorA.Subtract(t), this.m_groundAnchorB.Subtract(t);
  }
  Draw(t) {
    const e = this.GetAnchorA(tr.pA), s = this.GetAnchorB(tr.pB), i = this.GetGroundAnchorA(), o = this.GetGroundAnchorB();
    t.DrawSegment(i, e, op.debugColors.joint6), t.DrawSegment(o, s, op.debugColors.joint6), t.DrawSegment(i, o, op.debugColors.joint6);
  }
};
h(h1, "b2PulleyJoint");
let U0 = h1;
ko.b2PulleyJoint = U0;
var Ta = {};
Object.defineProperty(Ta, "__esModule", { value: !0 });
Ta.b2RevoluteJoint = Ta.b2RevoluteJointDef = void 0;
const vo = Xe, bo = Ai, ae = Fe, O0 = xn, Or = {
  qA: new ae.b2Rot(),
  qB: new ae.b2Rot(),
  lalcA: new ae.b2Vec2(),
  lalcB: new ae.b2Vec2(),
  P: new ae.b2Vec2(),
  Cdot: new ae.b2Vec2(),
  C: new ae.b2Vec2(),
  impulse: new ae.b2Vec2(),
  p2: new ae.b2Vec2(),
  r: new ae.b2Vec2(),
  pA: new ae.b2Vec2(),
  pB: new ae.b2Vec2(),
  rlo: new ae.b2Vec2(),
  rhi: new ae.b2Vec2()
}, d1 = class d1 extends O0.b2JointDef {
  constructor() {
    super(O0.b2JointType.e_revoluteJoint), this.localAnchorA = new ae.b2Vec2(), this.localAnchorB = new ae.b2Vec2(), this.referenceAngle = 0, this.enableLimit = !1, this.lowerAngle = 0, this.upperAngle = 0, this.enableMotor = !1, this.motorSpeed = 0, this.maxMotorTorque = 0;
  }
  Initialize(t, e, s) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(s, this.localAnchorA), this.bodyB.GetLocalPoint(s, this.localAnchorB), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
  }
};
h(d1, "b2RevoluteJointDef");
let $0 = d1;
Ta.b2RevoluteJointDef = $0;
const m1 = class m1 extends O0.b2Joint {
  constructor(t) {
    var e, s, i, o, r, a, l, c, u;
    super(t), this.m_localAnchorA = new ae.b2Vec2(), this.m_localAnchorB = new ae.b2Vec2(), this.m_impulse = new ae.b2Vec2(), this.m_motorImpulse = 0, this.m_lowerImpulse = 0, this.m_upperImpulse = 0, this.m_enableMotor = !1, this.m_maxMotorTorque = 0, this.m_motorSpeed = 0, this.m_enableLimit = !1, this.m_referenceAngle = 0, this.m_lowerAngle = 0, this.m_upperAngle = 0, this.m_indexA = 0, this.m_indexB = 0, this.m_rA = new ae.b2Vec2(), this.m_rB = new ae.b2Vec2(), this.m_localCenterA = new ae.b2Vec2(), this.m_localCenterB = new ae.b2Vec2(), this.m_invMassA = 0, this.m_invMassB = 0, this.m_invIA = 0, this.m_invIB = 0, this.m_K = new ae.b2Mat22(), this.m_angle = 0, this.m_axialMass = 0, this.m_localAnchorA.Copy((e = t.localAnchorA) !== null && e !== void 0 ? e : ae.b2Vec2.ZERO), this.m_localAnchorB.Copy((s = t.localAnchorB) !== null && s !== void 0 ? s : ae.b2Vec2.ZERO), this.m_referenceAngle = (i = t.referenceAngle) !== null && i !== void 0 ? i : 0, this.m_impulse.SetZero(), this.m_lowerAngle = (o = t.lowerAngle) !== null && o !== void 0 ? o : 0, this.m_upperAngle = (r = t.upperAngle) !== null && r !== void 0 ? r : 0, this.m_maxMotorTorque = (a = t.maxMotorTorque) !== null && a !== void 0 ? a : 0, this.m_motorSpeed = (l = t.motorSpeed) !== null && l !== void 0 ? l : 0, this.m_enableLimit = (c = t.enableLimit) !== null && c !== void 0 ? c : !1, this.m_enableMotor = (u = t.enableMotor) !== null && u !== void 0 ? u : !1;
  }
  InitVelocityConstraints(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    const e = t.positions[this.m_indexA].a, s = t.velocities[this.m_indexA].v;
    let i = t.velocities[this.m_indexA].w;
    const o = t.positions[this.m_indexB].a, r = t.velocities[this.m_indexB].v;
    let a = t.velocities[this.m_indexB].w;
    const { qA: l, qB: c, lalcA: u, lalcB: m } = Or;
    l.Set(e), c.Set(o), ae.b2Rot.MultiplyVec2(l, ae.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, u), this.m_rA), ae.b2Rot.MultiplyVec2(c, ae.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, m), this.m_rB);
    const d = this.m_invMassA, f = this.m_invMassB, p = this.m_invIA, v = this.m_invIB;
    this.m_K.ex.x = d + f + this.m_rA.y * this.m_rA.y * p + this.m_rB.y * this.m_rB.y * v, this.m_K.ey.x = -this.m_rA.y * this.m_rA.x * p - this.m_rB.y * this.m_rB.x * v, this.m_K.ex.y = this.m_K.ey.x, this.m_K.ey.y = d + f + this.m_rA.x * this.m_rA.x * p + this.m_rB.x * this.m_rB.x * v, this.m_axialMass = p + v;
    let _;
    if (this.m_axialMass > 0 ? (this.m_axialMass = 1 / this.m_axialMass, _ = !1) : _ = !0, this.m_angle = o - e - this.m_referenceAngle, (this.m_enableLimit === !1 || _) && (this.m_lowerImpulse = 0, this.m_upperImpulse = 0), (this.m_enableMotor === !1 || _) && (this.m_motorImpulse = 0), t.step.warmStarting) {
      this.m_impulse.Scale(t.step.dtRatio), this.m_motorImpulse *= t.step.dtRatio, this.m_lowerImpulse *= t.step.dtRatio, this.m_upperImpulse *= t.step.dtRatio;
      const g = this.m_motorImpulse + this.m_lowerImpulse - this.m_upperImpulse, w = Or.P.Set(this.m_impulse.x, this.m_impulse.y);
      s.SubtractScaled(d, w), i -= p * (ae.b2Vec2.Cross(this.m_rA, w) + g), r.AddScaled(f, w), a += v * (ae.b2Vec2.Cross(this.m_rB, w) + g);
    } else
      this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerImpulse = 0, this.m_upperImpulse = 0;
    t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = a;
  }
  SolveVelocityConstraints(t) {
    const e = t.velocities[this.m_indexA].v;
    let s = t.velocities[this.m_indexA].w;
    const i = t.velocities[this.m_indexB].v;
    let o = t.velocities[this.m_indexB].w;
    const r = this.m_invMassA, a = this.m_invMassB, l = this.m_invIA, c = this.m_invIB, u = l + c === 0;
    if (this.m_enableMotor && !u) {
      const m = o - s - this.m_motorSpeed;
      let d = -this.m_axialMass * m;
      const f = this.m_motorImpulse, p = t.step.dt * this.m_maxMotorTorque;
      this.m_motorImpulse = (0, ae.b2Clamp)(this.m_motorImpulse + d, -p, p), d = this.m_motorImpulse - f, s -= l * d, o += c * d;
    }
    if (this.m_enableLimit && !u) {
      {
        const m = this.m_angle - this.m_lowerAngle, d = o - s;
        let f = -this.m_axialMass * (d + Math.max(m, 0) * t.step.inv_dt);
        const p = this.m_lowerImpulse;
        this.m_lowerImpulse = Math.max(this.m_lowerImpulse + f, 0), f = this.m_lowerImpulse - p, s -= l * f, o += c * f;
      }
      {
        const m = this.m_upperAngle - this.m_angle, d = s - o;
        let f = -this.m_axialMass * (d + Math.max(m, 0) * t.step.inv_dt);
        const p = this.m_upperImpulse;
        this.m_upperImpulse = Math.max(this.m_upperImpulse + f, 0), f = this.m_upperImpulse - p, s += l * f, o -= c * f;
      }
    }
    {
      const { Cdot: m, impulse: d } = Or;
      ae.b2Vec2.Subtract(ae.b2Vec2.AddCrossScalarVec2(i, o, this.m_rB, ae.b2Vec2.s_t0), ae.b2Vec2.AddCrossScalarVec2(e, s, this.m_rA, ae.b2Vec2.s_t1), m), this.m_K.Solve(-m.x, -m.y, d), this.m_impulse.x += d.x, this.m_impulse.y += d.y, e.SubtractScaled(r, d), s -= l * ae.b2Vec2.Cross(this.m_rA, d), i.AddScaled(a, d), o += c * ae.b2Vec2.Cross(this.m_rB, d);
    }
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = o;
  }
  SolvePositionConstraints(t) {
    const e = t.positions[this.m_indexA].c;
    let s = t.positions[this.m_indexA].a;
    const i = t.positions[this.m_indexB].c;
    let o = t.positions[this.m_indexB].a;
    const { qA: r, qB: a, lalcA: l, lalcB: c, impulse: u } = Or;
    r.Set(s), a.Set(o);
    let m = 0, d = 0;
    const f = this.m_invIA + this.m_invIB === 0;
    if (this.m_enableLimit && !f) {
      const p = o - s - this.m_referenceAngle;
      let v = 0;
      Math.abs(this.m_upperAngle - this.m_lowerAngle) < 2 * vo.b2_angularSlop ? v = (0, ae.b2Clamp)(p - this.m_lowerAngle, -vo.b2_maxAngularCorrection, vo.b2_maxAngularCorrection) : p <= this.m_lowerAngle ? v = (0, ae.b2Clamp)(p - this.m_lowerAngle + vo.b2_angularSlop, -vo.b2_maxAngularCorrection, 0) : p >= this.m_upperAngle && (v = (0, ae.b2Clamp)(p - this.m_upperAngle - vo.b2_angularSlop, 0, vo.b2_maxAngularCorrection));
      const _ = -this.m_axialMass * v;
      s -= this.m_invIA * _, o += this.m_invIB * _, m = Math.abs(v);
    }
    {
      r.Set(s), a.Set(o);
      const p = ae.b2Rot.MultiplyVec2(r, ae.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, l), this.m_rA), v = ae.b2Rot.MultiplyVec2(a, ae.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, c), this.m_rB), _ = ae.b2Vec2.Add(i, v, Or.C).Subtract(e).Subtract(p);
      d = _.Length();
      const g = this.m_invMassA, w = this.m_invMassB, S = this.m_invIA, x = this.m_invIB, A = this.m_K;
      A.ex.x = g + w + S * p.y * p.y + x * v.y * v.y, A.ex.y = -S * p.x * p.y - x * v.x * v.y, A.ey.x = A.ex.y, A.ey.y = g + w + S * p.x * p.x + x * v.x * v.x, A.Solve(_.x, _.y, u).Negate(), e.SubtractScaled(g, u), s -= S * ae.b2Vec2.Cross(p, u), i.AddScaled(w, u), o += x * ae.b2Vec2.Cross(v, u);
    }
    return t.positions[this.m_indexA].a = s, t.positions[this.m_indexB].a = o, d <= vo.b2_linearSlop && m <= vo.b2_angularSlop;
  }
  GetAnchorA(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t);
  }
  GetAnchorB(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t);
  }
  GetReactionForce(t, e) {
    return e.x = t * this.m_impulse.x, e.y = t * this.m_impulse.y, e;
  }
  GetReactionTorque(t) {
    return t * (this.m_motorImpulse + this.m_lowerImpulse - this.m_upperImpulse);
  }
  GetLocalAnchorA() {
    return this.m_localAnchorA;
  }
  GetLocalAnchorB() {
    return this.m_localAnchorB;
  }
  GetReferenceAngle() {
    return this.m_referenceAngle;
  }
  GetJointAngle() {
    return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
  }
  GetJointSpeed() {
    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
  }
  IsMotorEnabled() {
    return this.m_enableMotor;
  }
  EnableMotor(t) {
    return t !== this.m_enableMotor && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t), t;
  }
  GetMotorTorque(t) {
    return t * this.m_motorImpulse;
  }
  GetMotorSpeed() {
    return this.m_motorSpeed;
  }
  SetMaxMotorTorque(t) {
    t !== this.m_maxMotorTorque && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorTorque = t);
  }
  GetMaxMotorTorque() {
    return this.m_maxMotorTorque;
  }
  IsLimitEnabled() {
    return this.m_enableLimit;
  }
  EnableLimit(t) {
    return t !== this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t, this.m_lowerImpulse = 0, this.m_upperImpulse = 0), t;
  }
  GetLowerLimit() {
    return this.m_lowerAngle;
  }
  GetUpperLimit() {
    return this.m_upperAngle;
  }
  SetLimits(t, e) {
    (t !== this.m_lowerAngle || e !== this.m_upperAngle) && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerImpulse = 0, this.m_upperImpulse = 0, this.m_lowerAngle = t, this.m_upperAngle = e);
  }
  SetMotorSpeed(t) {
    return t !== this.m_motorSpeed && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t), t;
  }
  Draw(t) {
    const { p2: e, r: s, pA: i, pB: o } = Or, r = this.m_bodyA.GetTransform(), a = this.m_bodyB.GetTransform();
    ae.b2Transform.MultiplyVec2(r, this.m_localAnchorA, i), ae.b2Transform.MultiplyVec2(a, this.m_localAnchorB, o), t.DrawPoint(i, 5, bo.debugColors.joint4), t.DrawPoint(o, 5, bo.debugColors.joint5);
    const l = this.m_bodyA.GetAngle(), u = this.m_bodyB.GetAngle() - l - this.m_referenceAngle, m = 0.5;
    if (s.Set(Math.cos(u), Math.sin(u)).Scale(m), t.DrawSegment(o, ae.b2Vec2.Add(o, s, e), bo.debugColors.joint1), t.DrawCircle(o, m, bo.debugColors.joint1), this.m_enableLimit) {
      const { rlo: d, rhi: f } = Or;
      d.Set(Math.cos(this.m_lowerAngle), Math.sin(this.m_lowerAngle)).Scale(m), f.Set(Math.cos(this.m_upperAngle), Math.sin(this.m_upperAngle)).Scale(m), t.DrawSegment(o, ae.b2Vec2.Add(o, d, e), bo.debugColors.joint2), t.DrawSegment(o, ae.b2Vec2.Add(o, f, e), bo.debugColors.joint3);
    }
    t.DrawSegment(r.p, i, bo.debugColors.joint6), t.DrawSegment(i, o, bo.debugColors.joint6), t.DrawSegment(a.p, o, bo.debugColors.joint6);
  }
};
h(m1, "b2RevoluteJoint");
let F0 = m1;
Ta.b2RevoluteJoint = F0;
var Ia = {};
Object.defineProperty(Ia, "__esModule", { value: !0 });
Ia.b2WeldJoint = Ia.b2WeldJointDef = void 0;
const eA = Xe, Jt = Fe, G0 = xn, cc = {
  qA: new Jt.b2Rot(),
  qB: new Jt.b2Rot(),
  rA: new Jt.b2Vec2(),
  rB: new Jt.b2Vec2(),
  lalcA: new Jt.b2Vec2(),
  lalcB: new Jt.b2Vec2(),
  K: new Jt.b2Mat33(),
  P: new Jt.b2Vec2(),
  Cdot1: new Jt.b2Vec3(),
  impulse1: new Jt.b2Vec2(),
  impulse: new Jt.b2Vec3(),
  C1: new Jt.b2Vec2(),
  C: new Jt.b2Vec3()
}, f1 = class f1 extends G0.b2JointDef {
  constructor() {
    super(G0.b2JointType.e_weldJoint), this.localAnchorA = new Jt.b2Vec2(), this.localAnchorB = new Jt.b2Vec2(), this.referenceAngle = 0, this.stiffness = 0, this.damping = 0;
  }
  Initialize(t, e, s) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(s, this.localAnchorA), this.bodyB.GetLocalPoint(s, this.localAnchorB), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
  }
};
h(f1, "b2WeldJointDef");
let H0 = f1;
Ia.b2WeldJointDef = H0;
const p1 = class p1 extends G0.b2Joint {
  constructor(t) {
    var e, s, i, o, r;
    super(t), this.m_stiffness = 0, this.m_damping = 0, this.m_bias = 0, this.m_localAnchorA = new Jt.b2Vec2(), this.m_localAnchorB = new Jt.b2Vec2(), this.m_referenceAngle = 0, this.m_gamma = 0, this.m_impulse = new Jt.b2Vec3(), this.m_indexA = 0, this.m_indexB = 0, this.m_rA = new Jt.b2Vec2(), this.m_rB = new Jt.b2Vec2(), this.m_localCenterA = new Jt.b2Vec2(), this.m_localCenterB = new Jt.b2Vec2(), this.m_invMassA = 0, this.m_invMassB = 0, this.m_invIA = 0, this.m_invIB = 0, this.m_mass = new Jt.b2Mat33(), this.m_localAnchorA.Copy((e = t.localAnchorA) !== null && e !== void 0 ? e : Jt.b2Vec2.ZERO), this.m_localAnchorB.Copy((s = t.localAnchorB) !== null && s !== void 0 ? s : Jt.b2Vec2.ZERO), this.m_referenceAngle = (i = t.referenceAngle) !== null && i !== void 0 ? i : 0, this.m_stiffness = (o = t.stiffness) !== null && o !== void 0 ? o : 0, this.m_damping = (r = t.damping) !== null && r !== void 0 ? r : 0;
  }
  InitVelocityConstraints(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    const e = t.positions[this.m_indexA].a, s = t.velocities[this.m_indexA].v;
    let i = t.velocities[this.m_indexA].w;
    const o = t.positions[this.m_indexB].a, r = t.velocities[this.m_indexB].v;
    let a = t.velocities[this.m_indexB].w;
    const { qA: l, qB: c, lalcA: u, lalcB: m, K: d } = cc;
    l.Set(e), c.Set(o), Jt.b2Rot.MultiplyVec2(l, Jt.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, u), this.m_rA), Jt.b2Rot.MultiplyVec2(c, Jt.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, m), this.m_rB);
    const f = this.m_invMassA, p = this.m_invMassB, v = this.m_invIA, _ = this.m_invIB;
    if (d.ex.x = f + p + this.m_rA.y * this.m_rA.y * v + this.m_rB.y * this.m_rB.y * _, d.ey.x = -this.m_rA.y * this.m_rA.x * v - this.m_rB.y * this.m_rB.x * _, d.ez.x = -this.m_rA.y * v - this.m_rB.y * _, d.ex.y = d.ey.x, d.ey.y = f + p + this.m_rA.x * this.m_rA.x * v + this.m_rB.x * this.m_rB.x * _, d.ez.y = this.m_rA.x * v + this.m_rB.x * _, d.ex.z = d.ez.x, d.ey.z = d.ez.y, d.ez.z = v + _, this.m_stiffness > 0) {
      d.GetInverse22(this.m_mass);
      let g = v + _;
      const w = o - e - this.m_referenceAngle, S = this.m_damping, x = this.m_stiffness, A = t.step.dt;
      this.m_gamma = A * (S + A * x), this.m_gamma = this.m_gamma !== 0 ? 1 / this.m_gamma : 0, this.m_bias = w * A * x * this.m_gamma, g += this.m_gamma, this.m_mass.ez.z = g !== 0 ? 1 / g : 0;
    } else d.ez.z === 0 ? (d.GetInverse22(this.m_mass), this.m_gamma = 0, this.m_bias = 0) : (d.GetSymInverse33(this.m_mass), this.m_gamma = 0, this.m_bias = 0);
    if (t.step.warmStarting) {
      this.m_impulse.Scale(t.step.dtRatio);
      const { P: g } = cc;
      g.Copy(this.m_impulse), s.SubtractScaled(f, g), i -= v * (Jt.b2Vec2.Cross(this.m_rA, g) + this.m_impulse.z), r.AddScaled(p, g), a += _ * (Jt.b2Vec2.Cross(this.m_rB, g) + this.m_impulse.z);
    } else
      this.m_impulse.SetZero();
    t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = a;
  }
  SolveVelocityConstraints(t) {
    const e = t.velocities[this.m_indexA].v;
    let s = t.velocities[this.m_indexA].w;
    const i = t.velocities[this.m_indexB].v;
    let o = t.velocities[this.m_indexB].w;
    const r = this.m_invMassA, a = this.m_invMassB, l = this.m_invIA, c = this.m_invIB;
    if (this.m_stiffness > 0) {
      const u = o - s, m = -this.m_mass.ez.z * (u + this.m_bias + this.m_gamma * this.m_impulse.z);
      this.m_impulse.z += m, s -= l * m, o += c * m;
      const { Cdot1: d, impulse1: f } = cc;
      Jt.b2Vec2.Subtract(Jt.b2Vec2.AddCrossScalarVec2(i, o, this.m_rB, Jt.b2Vec2.s_t0), Jt.b2Vec2.AddCrossScalarVec2(e, s, this.m_rA, Jt.b2Vec2.s_t1), d), Jt.b2Mat33.MultiplyVec2(this.m_mass, d, f).Negate(), this.m_impulse.x += f.x, this.m_impulse.y += f.y;
      const p = f;
      e.SubtractScaled(r, p), s -= l * Jt.b2Vec2.Cross(this.m_rA, p), i.AddScaled(a, p), o += c * Jt.b2Vec2.Cross(this.m_rB, p);
    } else {
      const { Cdot1: u, impulse: m, P: d } = cc;
      Jt.b2Vec2.Subtract(Jt.b2Vec2.AddCrossScalarVec2(i, o, this.m_rB, Jt.b2Vec2.s_t0), Jt.b2Vec2.AddCrossScalarVec2(e, s, this.m_rA, Jt.b2Vec2.s_t1), u), u.z = o - s, Jt.b2Mat33.MultiplyVec3(this.m_mass, u, m).Negate(), this.m_impulse.Add(m), d.Set(m.x, m.y), e.SubtractScaled(r, d), s -= l * (Jt.b2Vec2.Cross(this.m_rA, d) + m.z), i.AddScaled(a, d), o += c * (Jt.b2Vec2.Cross(this.m_rB, d) + m.z);
    }
    t.velocities[this.m_indexA].w = s, t.velocities[this.m_indexB].w = o;
  }
  SolvePositionConstraints(t) {
    const e = t.positions[this.m_indexA].c;
    let s = t.positions[this.m_indexA].a;
    const i = t.positions[this.m_indexB].c;
    let o = t.positions[this.m_indexB].a;
    const { qA: r, qB: a, lalcA: l, lalcB: c, K: u, C1: m, P: d, rA: f, rB: p } = cc;
    r.Set(s), a.Set(o);
    const v = this.m_invMassA, _ = this.m_invMassB, g = this.m_invIA, w = this.m_invIB;
    Jt.b2Rot.MultiplyVec2(r, Jt.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, l), f), Jt.b2Rot.MultiplyVec2(a, Jt.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, c), p);
    let S, x;
    if (u.ex.x = v + _ + f.y * f.y * g + p.y * p.y * w, u.ey.x = -f.y * f.x * g - p.y * p.x * w, u.ez.x = -f.y * g - p.y * w, u.ex.y = u.ey.x, u.ey.y = v + _ + f.x * f.x * g + p.x * p.x * w, u.ez.y = f.x * g + p.x * w, u.ex.z = u.ez.x, u.ey.z = u.ez.y, u.ez.z = g + w, this.m_stiffness > 0)
      Jt.b2Vec2.Add(i, p, m).Subtract(e).Subtract(f), S = m.Length(), x = 0, u.Solve22(m.x, m.y, d).Negate(), e.SubtractScaled(v, d), s -= g * Jt.b2Vec2.Cross(f, d), i.AddScaled(_, d), o += w * Jt.b2Vec2.Cross(p, d);
    else {
      Jt.b2Vec2.Add(i, p, m).Subtract(e).Subtract(f), Jt.b2Vec2.Subtract(Jt.b2Vec2.Add(i, p, Jt.b2Vec2.s_t0), Jt.b2Vec2.Add(e, f, Jt.b2Vec2.s_t1), m);
      const A = o - s - this.m_referenceAngle;
      S = m.Length(), x = Math.abs(A);
      const { impulse: C, C: M } = cc;
      M.Set(m.x, m.y, A), u.ez.z > 0 ? u.Solve33(M.x, M.y, M.z, C).Negate() : (u.Solve22(m.x, m.y, C).Negate(), C.z = 0), d.Copy(C), e.SubtractScaled(v, d), s -= g * (Jt.b2Vec2.Cross(f, d) + C.z), i.AddScaled(_, d), o += w * (Jt.b2Vec2.Cross(p, d) + C.z);
    }
    return t.positions[this.m_indexA].a = s, t.positions[this.m_indexB].a = o, S <= eA.b2_linearSlop && x <= eA.b2_angularSlop;
  }
  GetAnchorA(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t);
  }
  GetAnchorB(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t);
  }
  GetReactionForce(t, e) {
    return e.x = t * this.m_impulse.x, e.y = t * this.m_impulse.y, e;
  }
  GetReactionTorque(t) {
    return t * this.m_impulse.z;
  }
  GetLocalAnchorA() {
    return this.m_localAnchorA;
  }
  GetLocalAnchorB() {
    return this.m_localAnchorB;
  }
  GetReferenceAngle() {
    return this.m_referenceAngle;
  }
  SetStiffness(t) {
    this.m_stiffness = t;
  }
  GetStiffness() {
    return this.m_stiffness;
  }
  SetDamping(t) {
    this.m_damping = t;
  }
  GetDamping() {
    return this.m_damping;
  }
};
h(p1, "b2WeldJoint");
let j0 = p1;
Ia.b2WeldJoint = j0;
var Ba = {};
Object.defineProperty(Ba, "__esModule", { value: !0 });
Ba.b2WheelJoint = Ba.b2WheelJointDef = void 0;
const nA = Xe, rt = Fe, W0 = xn, $r = Ai, er = {
  qA: new rt.b2Rot(),
  qB: new rt.b2Rot(),
  lalcA: new rt.b2Vec2(),
  lalcB: new rt.b2Vec2(),
  rA: new rt.b2Vec2(),
  rB: new rt.b2Vec2(),
  d: new rt.b2Vec2(),
  P: new rt.b2Vec2(),
  ay: new rt.b2Vec2(),
  pA: new rt.b2Vec2(),
  pB: new rt.b2Vec2(),
  axis: new rt.b2Vec2(),
  Draw: {
    p1: new rt.b2Vec2(),
    p2: new rt.b2Vec2(),
    pA: new rt.b2Vec2(),
    pB: new rt.b2Vec2(),
    axis: new rt.b2Vec2(),
    lower: new rt.b2Vec2(),
    upper: new rt.b2Vec2(),
    perp: new rt.b2Vec2()
  }
}, _1 = class _1 extends W0.b2JointDef {
  constructor() {
    super(W0.b2JointType.e_wheelJoint), this.localAnchorA = new rt.b2Vec2(), this.localAnchorB = new rt.b2Vec2(), this.localAxisA = new rt.b2Vec2(1, 0), this.enableLimit = !1, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = !1, this.maxMotorTorque = 0, this.motorSpeed = 0, this.stiffness = 0, this.damping = 0;
  }
  Initialize(t, e, s, i) {
    this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(s, this.localAnchorA), this.bodyB.GetLocalPoint(s, this.localAnchorB), this.bodyA.GetLocalVector(i, this.localAxisA);
  }
};
h(_1, "b2WheelJointDef");
let q0 = _1;
Ba.b2WheelJointDef = q0;
const g1 = class g1 extends W0.b2Joint {
  constructor(t) {
    var e, s, i, o, r, a, l, c, u, m, d;
    super(t), this.m_localAnchorA = new rt.b2Vec2(), this.m_localAnchorB = new rt.b2Vec2(), this.m_localXAxisA = new rt.b2Vec2(), this.m_localYAxisA = new rt.b2Vec2(), this.m_impulse = 0, this.m_motorImpulse = 0, this.m_springImpulse = 0, this.m_lowerImpulse = 0, this.m_upperImpulse = 0, this.m_translation = 0, this.m_lowerTranslation = 0, this.m_upperTranslation = 0, this.m_maxMotorTorque = 0, this.m_motorSpeed = 0, this.m_enableLimit = !1, this.m_enableMotor = !1, this.m_stiffness = 0, this.m_damping = 0, this.m_indexA = 0, this.m_indexB = 0, this.m_localCenterA = new rt.b2Vec2(), this.m_localCenterB = new rt.b2Vec2(), this.m_invMassA = 0, this.m_invMassB = 0, this.m_invIA = 0, this.m_invIB = 0, this.m_ax = new rt.b2Vec2(), this.m_ay = new rt.b2Vec2(), this.m_sAx = 0, this.m_sBx = 0, this.m_sAy = 0, this.m_sBy = 0, this.m_mass = 0, this.m_motorMass = 0, this.m_axialMass = 0, this.m_springMass = 0, this.m_bias = 0, this.m_gamma = 0, this.m_localAnchorA.Copy((e = t.localAnchorA) !== null && e !== void 0 ? e : rt.b2Vec2.ZERO), this.m_localAnchorB.Copy((s = t.localAnchorB) !== null && s !== void 0 ? s : rt.b2Vec2.ZERO), this.m_localXAxisA.Copy((i = t.localAxisA) !== null && i !== void 0 ? i : rt.b2Vec2.UNITX), rt.b2Vec2.CrossOneVec2(this.m_localXAxisA, this.m_localYAxisA), this.m_lowerTranslation = (o = t.lowerTranslation) !== null && o !== void 0 ? o : 0, this.m_upperTranslation = (r = t.upperTranslation) !== null && r !== void 0 ? r : 0, this.m_enableLimit = (a = t.enableLimit) !== null && a !== void 0 ? a : !1, this.m_maxMotorTorque = (l = t.maxMotorTorque) !== null && l !== void 0 ? l : 0, this.m_motorSpeed = (c = t.motorSpeed) !== null && c !== void 0 ? c : 0, this.m_enableMotor = (u = t.enableMotor) !== null && u !== void 0 ? u : !1, this.m_ax.SetZero(), this.m_ay.SetZero(), this.m_stiffness = (m = t.stiffness) !== null && m !== void 0 ? m : 0, this.m_damping = (d = t.damping) !== null && d !== void 0 ? d : 0;
  }
  GetMotorSpeed() {
    return this.m_motorSpeed;
  }
  GetMaxMotorTorque() {
    return this.m_maxMotorTorque;
  }
  SetStiffness(t) {
    this.m_stiffness = t;
  }
  GetStiffness() {
    return this.m_stiffness;
  }
  SetDamping(t) {
    this.m_damping = t;
  }
  GetDamping() {
    return this.m_damping;
  }
  InitVelocityConstraints(t) {
    this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI;
    const e = this.m_invMassA, s = this.m_invMassB, i = this.m_invIA, o = this.m_invIB, r = t.positions[this.m_indexA].c, a = t.positions[this.m_indexA].a, l = t.velocities[this.m_indexA].v;
    let c = t.velocities[this.m_indexA].w;
    const u = t.positions[this.m_indexB].c, m = t.positions[this.m_indexB].a, d = t.velocities[this.m_indexB].v;
    let f = t.velocities[this.m_indexB].w;
    const { qA: p, qB: v, lalcA: _, lalcB: g, rA: w, rB: S, d: x } = er;
    p.Set(a), v.Set(m), rt.b2Rot.MultiplyVec2(p, rt.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, _), w), rt.b2Rot.MultiplyVec2(v, rt.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, g), S), rt.b2Vec2.Add(u, S, x).Subtract(r).Subtract(w), rt.b2Rot.MultiplyVec2(p, this.m_localYAxisA, this.m_ay), this.m_sAy = rt.b2Vec2.Cross(rt.b2Vec2.Add(x, w, rt.b2Vec2.s_t0), this.m_ay), this.m_sBy = rt.b2Vec2.Cross(S, this.m_ay), this.m_mass = e + s + i * this.m_sAy * this.m_sAy + o * this.m_sBy * this.m_sBy, this.m_mass > 0 && (this.m_mass = 1 / this.m_mass), rt.b2Rot.MultiplyVec2(p, this.m_localXAxisA, this.m_ax), this.m_sAx = rt.b2Vec2.Cross(rt.b2Vec2.Add(x, w, rt.b2Vec2.s_t0), this.m_ax), this.m_sBx = rt.b2Vec2.Cross(S, this.m_ax);
    const A = e + s + i * this.m_sAx * this.m_sAx + o * this.m_sBx * this.m_sBx;
    if (A > 0 ? this.m_axialMass = 1 / A : this.m_axialMass = 0, this.m_springMass = 0, this.m_bias = 0, this.m_gamma = 0, this.m_stiffness > 0 && A > 0) {
      this.m_springMass = 1 / A;
      const C = rt.b2Vec2.Dot(x, this.m_ax), M = t.step.dt;
      this.m_gamma = M * (this.m_damping + M * this.m_stiffness), this.m_gamma > 0 && (this.m_gamma = 1 / this.m_gamma), this.m_bias = C * M * this.m_stiffness * this.m_gamma, this.m_springMass = A + this.m_gamma, this.m_springMass > 0 && (this.m_springMass = 1 / this.m_springMass);
    } else
      this.m_springImpulse = 0;
    if (this.m_enableLimit ? this.m_translation = rt.b2Vec2.Dot(this.m_ax, x) : (this.m_lowerImpulse = 0, this.m_upperImpulse = 0), this.m_enableMotor ? (this.m_motorMass = i + o, this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass)) : (this.m_motorMass = 0, this.m_motorImpulse = 0), t.step.warmStarting) {
      this.m_impulse *= t.step.dtRatio, this.m_springImpulse *= t.step.dtRatio, this.m_motorImpulse *= t.step.dtRatio;
      const C = this.m_springImpulse + this.m_lowerImpulse - this.m_upperImpulse, { P: M } = er;
      rt.b2Vec2.Scale(this.m_impulse, this.m_ay, M).AddScaled(C, this.m_ax);
      const T = this.m_impulse * this.m_sAy + C * this.m_sAx + this.m_motorImpulse, b = this.m_impulse * this.m_sBy + C * this.m_sBx + this.m_motorImpulse;
      l.SubtractScaled(this.m_invMassA, M), c -= this.m_invIA * T, d.AddScaled(this.m_invMassB, M), f += this.m_invIB * b;
    } else
      this.m_impulse = 0, this.m_springImpulse = 0, this.m_motorImpulse = 0, this.m_lowerImpulse = 0, this.m_upperImpulse = 0;
    t.velocities[this.m_indexA].w = c, t.velocities[this.m_indexB].w = f;
  }
  SolveVelocityConstraints(t) {
    const e = this.m_invMassA, s = this.m_invMassB, i = this.m_invIA, o = this.m_invIB, r = t.velocities[this.m_indexA].v;
    let a = t.velocities[this.m_indexA].w;
    const l = t.velocities[this.m_indexB].v;
    let c = t.velocities[this.m_indexB].w;
    const { P: u } = er;
    {
      const m = rt.b2Vec2.Dot(this.m_ax, rt.b2Vec2.Subtract(l, r, rt.b2Vec2.s_t0)) + this.m_sBx * c - this.m_sAx * a, d = -this.m_springMass * (m + this.m_bias + this.m_gamma * this.m_springImpulse);
      this.m_springImpulse += d, rt.b2Vec2.Scale(d, this.m_ax, u);
      const f = d * this.m_sAx, p = d * this.m_sBx;
      r.SubtractScaled(e, u), a -= i * f, l.AddScaled(s, u), c += o * p;
    }
    {
      const m = c - a - this.m_motorSpeed;
      let d = -this.m_motorMass * m;
      const f = this.m_motorImpulse, p = t.step.dt * this.m_maxMotorTorque;
      this.m_motorImpulse = (0, rt.b2Clamp)(this.m_motorImpulse + d, -p, p), d = this.m_motorImpulse - f, a -= i * d, c += o * d;
    }
    if (this.m_enableLimit) {
      {
        const m = this.m_translation - this.m_lowerTranslation, d = rt.b2Vec2.Dot(this.m_ax, rt.b2Vec2.Subtract(l, r, rt.b2Vec2.s_t0)) + this.m_sBx * c - this.m_sAx * a;
        let f = -this.m_axialMass * (d + Math.max(m, 0) * t.step.inv_dt);
        const p = this.m_lowerImpulse;
        this.m_lowerImpulse = Math.max(this.m_lowerImpulse + f, 0), f = this.m_lowerImpulse - p, rt.b2Vec2.Scale(f, this.m_ax, u);
        const v = f * this.m_sAx, _ = f * this.m_sBx;
        r.SubtractScaled(e, u), a -= i * v, l.AddScaled(s, u), c += o * _;
      }
      {
        const m = this.m_upperTranslation - this.m_translation, d = rt.b2Vec2.Dot(this.m_ax, rt.b2Vec2.Subtract(r, l, rt.b2Vec2.s_t0)) + this.m_sAx * a - this.m_sBx * c;
        let f = -this.m_axialMass * (d + Math.max(m, 0) * t.step.inv_dt);
        const p = this.m_upperImpulse;
        this.m_upperImpulse = Math.max(this.m_upperImpulse + f, 0), f = this.m_upperImpulse - p, rt.b2Vec2.Scale(f, this.m_ax, u);
        const v = f * this.m_sAx, _ = f * this.m_sBx;
        r.AddScaled(e, u), a += i * v, l.SubtractScaled(s, u), c -= o * _;
      }
    }
    {
      const m = rt.b2Vec2.Dot(this.m_ay, rt.b2Vec2.Subtract(l, r, rt.b2Vec2.s_t0)) + this.m_sBy * c - this.m_sAy * a, d = -this.m_mass * m;
      this.m_impulse += d, rt.b2Vec2.Scale(d, this.m_ay, u);
      const f = d * this.m_sAy, p = d * this.m_sBy;
      r.SubtractScaled(e, u), a -= i * f, l.AddScaled(s, u), c += o * p;
    }
    t.velocities[this.m_indexA].w = a, t.velocities[this.m_indexB].w = c;
  }
  SolvePositionConstraints(t) {
    const e = t.positions[this.m_indexA].c;
    let s = t.positions[this.m_indexA].a;
    const i = t.positions[this.m_indexB].c;
    let o = t.positions[this.m_indexB].a, r = 0;
    const { qA: a, qB: l, lalcA: c, lalcB: u, rA: m, rB: d, d: f, P: p, ay: v } = er;
    if (this.m_enableLimit) {
      a.Set(s), l.Set(o), rt.b2Rot.MultiplyVec2(a, rt.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, c), m), rt.b2Rot.MultiplyVec2(l, rt.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, u), d), rt.b2Vec2.Subtract(i, e, f).Add(d).Subtract(m);
      const _ = rt.b2Rot.MultiplyVec2(a, this.m_localXAxisA, this.m_ax), g = rt.b2Vec2.Cross(rt.b2Vec2.Add(f, m, rt.b2Vec2.s_t0), this.m_ax), w = rt.b2Vec2.Cross(d, this.m_ax);
      let S = 0;
      const x = rt.b2Vec2.Dot(_, f);
      if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * nA.b2_linearSlop ? S = x : x <= this.m_lowerTranslation ? S = Math.min(x - this.m_lowerTranslation, 0) : x >= this.m_upperTranslation && (S = Math.max(x - this.m_upperTranslation, 0)), S !== 0) {
        const A = this.m_invMassA + this.m_invMassB + this.m_invIA * g * g + this.m_invIB * w * w;
        let C = 0;
        A !== 0 && (C = -S / A), rt.b2Vec2.Scale(C, _, p);
        const M = C * g, T = C * w;
        e.SubtractScaled(this.m_invMassA, p), s -= this.m_invIA * M, i.AddScaled(this.m_invMassB, p), o += this.m_invIB * T, r = Math.abs(S);
      }
    }
    {
      a.Set(s), l.Set(o), rt.b2Rot.MultiplyVec2(a, rt.b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA, c), m), rt.b2Rot.MultiplyVec2(l, rt.b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB, u), d), rt.b2Vec2.Subtract(i, e, f).Add(d).Subtract(m), rt.b2Rot.MultiplyVec2(a, this.m_localYAxisA, v);
      const _ = rt.b2Vec2.Cross(rt.b2Vec2.Add(f, m, rt.b2Vec2.s_t0), v), g = rt.b2Vec2.Cross(d, v), w = rt.b2Vec2.Dot(f, v), S = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
      let x = 0;
      S !== 0 && (x = -w / S), rt.b2Vec2.Scale(x, v, p);
      const A = x * _, C = x * g;
      e.SubtractScaled(this.m_invMassA, p), s -= this.m_invIA * A, i.AddScaled(this.m_invMassB, p), o += this.m_invIB * C, r = Math.max(r, Math.abs(w));
    }
    return t.positions[this.m_indexA].a = s, t.positions[this.m_indexB].a = o, r <= nA.b2_linearSlop;
  }
  GetAnchorA(t) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t);
  }
  GetAnchorB(t) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t);
  }
  GetReactionForce(t, e) {
    const s = this.m_springImpulse + this.m_lowerImpulse - this.m_upperImpulse;
    return e.x = t * (this.m_impulse * this.m_ay.x + s * this.m_ax.x), e.y = t * (this.m_impulse * this.m_ay.y + s * this.m_ax.y), e;
  }
  GetReactionTorque(t) {
    return t * this.m_motorImpulse;
  }
  GetLocalAnchorA() {
    return this.m_localAnchorA;
  }
  GetLocalAnchorB() {
    return this.m_localAnchorB;
  }
  GetLocalAxisA() {
    return this.m_localXAxisA;
  }
  GetJointTranslation() {
    const t = this.m_bodyA, e = this.m_bodyB, { pA: s, pB: i, d: o, axis: r } = er;
    return t.GetWorldPoint(this.m_localAnchorA, s), e.GetWorldPoint(this.m_localAnchorB, i), rt.b2Vec2.Subtract(i, s, o), t.GetWorldVector(this.m_localXAxisA, r), rt.b2Vec2.Dot(o, r);
  }
  GetJointLinearSpeed() {
    const t = this.m_bodyA, e = this.m_bodyB, { rA: s, rB: i, lalcA: o, lalcB: r, axis: a } = er;
    rt.b2Rot.MultiplyVec2(t.m_xf.q, rt.b2Vec2.Subtract(this.m_localAnchorA, t.m_sweep.localCenter, o), s), rt.b2Rot.MultiplyVec2(e.m_xf.q, rt.b2Vec2.Subtract(this.m_localAnchorB, e.m_sweep.localCenter, r), i);
    const l = rt.b2Vec2.Add(t.m_sweep.c, s, rt.b2Vec2.s_t0), c = rt.b2Vec2.Add(e.m_sweep.c, i, rt.b2Vec2.s_t1), u = rt.b2Vec2.Subtract(c, l, rt.b2Vec2.s_t2);
    rt.b2Rot.MultiplyVec2(t.m_xf.q, this.m_localXAxisA, a);
    const m = t.m_linearVelocity, d = e.m_linearVelocity, f = t.m_angularVelocity, p = e.m_angularVelocity;
    return rt.b2Vec2.Dot(u, rt.b2Vec2.CrossScalarVec2(f, a, rt.b2Vec2.s_t0)) + rt.b2Vec2.Dot(a, rt.b2Vec2.AddCrossScalarVec2(d, p, i, rt.b2Vec2.s_t0).Subtract(m).Subtract(rt.b2Vec2.CrossScalarVec2(f, s, rt.b2Vec2.s_t1)));
  }
  GetJointAngle() {
    return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a;
  }
  GetJointAngularSpeed() {
    const t = this.m_bodyA.m_angularVelocity;
    return this.m_bodyB.m_angularVelocity - t;
  }
  IsMotorEnabled() {
    return this.m_enableMotor;
  }
  EnableMotor(t) {
    return t !== this.m_enableMotor && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t), t;
  }
  SetMotorSpeed(t) {
    return t !== this.m_motorSpeed && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t), t;
  }
  SetMaxMotorTorque(t) {
    t !== this.m_maxMotorTorque && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorTorque = t);
  }
  GetMotorTorque(t) {
    return t * this.m_motorImpulse;
  }
  IsLimitEnabled() {
    return this.m_enableLimit;
  }
  EnableLimit(t) {
    return t !== this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t, this.m_lowerImpulse = 0, this.m_upperImpulse = 0), t;
  }
  GetLowerLimit() {
    return this.m_lowerTranslation;
  }
  GetUpperLimit() {
    return this.m_upperTranslation;
  }
  SetLimits(t, e) {
    (t !== this.m_lowerTranslation || e !== this.m_upperTranslation) && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = t, this.m_upperTranslation = e, this.m_lowerImpulse = 0, this.m_upperImpulse = 0);
  }
  Draw(t) {
    const { p1: e, p2: s, pA: i, pB: o, axis: r } = er.Draw, a = this.m_bodyA.GetTransform(), l = this.m_bodyB.GetTransform();
    if (rt.b2Transform.MultiplyVec2(a, this.m_localAnchorA, i), rt.b2Transform.MultiplyVec2(l, this.m_localAnchorB, o), rt.b2Rot.MultiplyVec2(a.q, this.m_localXAxisA, r), t.DrawSegment(i, o, $r.debugColors.joint5), this.m_enableLimit) {
      const { lower: c, upper: u, perp: m } = er.Draw;
      rt.b2Vec2.AddScaled(i, this.m_lowerTranslation, r, c), rt.b2Vec2.AddScaled(i, this.m_upperTranslation, r, u), rt.b2Rot.MultiplyVec2(a.q, this.m_localYAxisA, m), t.DrawSegment(c, u, $r.debugColors.joint1), t.DrawSegment(rt.b2Vec2.SubtractScaled(c, 0.5, m, e), rt.b2Vec2.AddScaled(c, 0.5, m, s), $r.debugColors.joint2), t.DrawSegment(rt.b2Vec2.SubtractScaled(u, 0.5, m, e), rt.b2Vec2.AddScaled(u, 0.5, m, s), $r.debugColors.joint3);
    } else
      t.DrawSegment(rt.b2Vec2.Subtract(i, r, e), rt.b2Vec2.Add(i, r, s), $r.debugColors.joint1);
    t.DrawPoint(i, 5, $r.debugColors.joint1), t.DrawPoint(o, 5, $r.debugColors.joint4);
  }
};
h(g1, "b2WheelJoint");
let X0 = g1;
Ba.b2WheelJoint = X0;
var Ou = {}, $u = {}, Xm = {}, Yn = {};
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.b2Contact = Yn.b2ContactEdge = Yn.b2MixRestitutionThreshold = Yn.b2MixRestitution = Yn.b2MixFriction = void 0;
const iA = Xe, rp = ge;
function Z0(n, t) {
  return Math.sqrt(n * t);
}
h(Z0, "b2MixFriction");
Yn.b2MixFriction = Z0;
function Y0(n, t) {
  return n > t ? n : t;
}
h(Y0, "b2MixRestitution");
Yn.b2MixRestitution = Y0;
function J0(n, t) {
  return n < t ? n : t;
}
h(J0, "b2MixRestitutionThreshold");
Yn.b2MixRestitutionThreshold = J0;
const v1 = class v1 {
  get other() {
    return (0, iA.b2Assert)(this.m_other !== null), this.m_other;
  }
  set other(t) {
    (0, iA.b2Assert)(this.m_other === null), this.m_other = t;
  }
  constructor(t) {
    this.m_other = null, this.prev = null, this.next = null, this.contact = t;
  }
  Reset() {
    this.m_other = null, this.prev = null, this.next = null;
  }
};
h(v1, "b2ContactEdge");
let gu = v1;
Yn.b2ContactEdge = gu;
const b1 = class b1 {
  constructor() {
    this.m_islandFlag = !1, this.m_touchingFlag = !1, this.m_enabledFlag = !1, this.m_filterFlag = !1, this.m_bulletHitFlag = !1, this.m_toiFlag = !1, this.m_prev = null, this.m_next = null, this.m_nodeA = new gu(this), this.m_nodeB = new gu(this), this.m_indexA = 0, this.m_indexB = 0, this.m_manifold = new rp.b2Manifold(), this.m_toiCount = 0, this.m_toi = 0, this.m_friction = 0, this.m_restitution = 0, this.m_restitutionThreshold = 0, this.m_tangentSpeed = 0, this.m_oldManifold = new rp.b2Manifold();
  }
  GetManifold() {
    return this.m_manifold;
  }
  GetWorldManifold(t) {
    const e = this.m_fixtureA.GetBody(), s = this.m_fixtureB.GetBody(), i = this.GetShapeA(), o = this.GetShapeB();
    t.Initialize(this.m_manifold, e.GetTransform(), i.m_radius, s.GetTransform(), o.m_radius);
  }
  IsTouching() {
    return this.m_touchingFlag;
  }
  SetEnabled(t) {
    this.m_enabledFlag = t;
  }
  IsEnabled() {
    return this.m_enabledFlag;
  }
  GetNext() {
    return this.m_next;
  }
  GetFixtureA() {
    return this.m_fixtureA;
  }
  GetChildIndexA() {
    return this.m_indexA;
  }
  GetShapeA() {
    return this.m_fixtureA.GetShape();
  }
  GetFixtureB() {
    return this.m_fixtureB;
  }
  GetChildIndexB() {
    return this.m_indexB;
  }
  GetShapeB() {
    return this.m_fixtureB.GetShape();
  }
  FlagForFiltering() {
    this.m_filterFlag = !0;
  }
  SetFriction(t) {
    this.m_friction = t;
  }
  GetFriction() {
    return this.m_friction;
  }
  ResetFriction() {
    this.m_friction = Z0(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
  }
  SetRestitution(t) {
    this.m_restitution = t;
  }
  GetRestitution() {
    return this.m_restitution;
  }
  ResetRestitution() {
    this.m_restitution = Y0(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
  }
  SetRestitutionThreshold(t) {
    this.m_restitutionThreshold = t;
  }
  GetRestitutionThreshold() {
    return this.m_restitutionThreshold;
  }
  ResetRestitutionThreshold() {
    this.m_restitutionThreshold = J0(this.m_fixtureA.m_restitutionThreshold, this.m_fixtureB.m_restitutionThreshold);
  }
  SetTangentSpeed(t) {
    this.m_tangentSpeed = t;
  }
  GetTangentSpeed() {
    return this.m_tangentSpeed;
  }
  Reset(t, e, s, i) {
    this.m_islandFlag = !1, this.m_touchingFlag = !1, this.m_enabledFlag = !0, this.m_filterFlag = !1, this.m_bulletHitFlag = !1, this.m_toiFlag = !1, this.m_fixtureA = t, this.m_fixtureB = s, this.m_indexA = e, this.m_indexB = i, this.m_manifold.pointCount = 0, this.m_prev = null, this.m_next = null, this.m_nodeA.Reset(), this.m_nodeB.Reset(), this.m_toiCount = 0, this.m_friction = Z0(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction), this.m_restitution = Y0(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution), this.m_restitutionThreshold = J0(this.m_fixtureA.m_restitutionThreshold, this.m_fixtureB.m_restitutionThreshold);
  }
  Update(t) {
    const e = this.m_oldManifold;
    this.m_oldManifold = this.m_manifold, this.m_manifold = e, this.m_enabledFlag = !0;
    let s = !1;
    const i = this.m_touchingFlag, o = this.m_fixtureA.IsSensor(), r = this.m_fixtureB.IsSensor(), a = o || r, l = this.m_fixtureA.GetBody(), c = this.m_fixtureB.GetBody(), u = l.GetTransform(), m = c.GetTransform();
    if (a) {
      const d = this.GetShapeA(), f = this.GetShapeB();
      s = (0, rp.b2TestOverlap)(d, this.m_indexA, f, this.m_indexB, u, m), this.m_manifold.pointCount = 0;
    } else {
      this.Evaluate(this.m_manifold, u, m), s = this.m_manifold.pointCount > 0;
      for (let d = 0; d < this.m_manifold.pointCount; ++d) {
        const f = this.m_manifold.points[d];
        f.normalImpulse = 0, f.tangentImpulse = 0;
        const p = f.id;
        for (let v = 0; v < this.m_oldManifold.pointCount; ++v) {
          const _ = this.m_oldManifold.points[v];
          if (_.id.key === p.key) {
            f.normalImpulse = _.normalImpulse, f.tangentImpulse = _.tangentImpulse;
            break;
          }
        }
      }
      s !== i && (l.SetAwake(!0), c.SetAwake(!0));
    }
    this.m_touchingFlag = s, !i && s && t && t.BeginContact(this), i && !s && t && t.EndContact(this), !a && s && t && t.PreSolve(this, this.m_oldManifold);
  }
};
h(b1, "b2Contact");
let K0 = b1;
Yn.b2Contact = K0;
Object.defineProperty(Xm, "__esModule", { value: !0 });
Xm.b2CircleContact = void 0;
const f9 = Sr, p9 = Yn, y1 = class y1 extends p9.b2Contact {
  Evaluate(t, e, s) {
    (0, f9.b2CollideCircles)(t, this.GetShapeA(), e, this.GetShapeB(), s);
  }
};
h(y1, "b2CircleContact");
let Q0 = y1;
Xm.b2CircleContact = Q0;
var Zm = {};
Object.defineProperty(Zm, "__esModule", { value: !0 });
Zm.b2PolygonContact = void 0;
const _9 = Uu, g9 = Yn, x1 = class x1 extends g9.b2Contact {
  Evaluate(t, e, s) {
    (0, _9.b2CollidePolygons)(t, this.GetShapeA(), e, this.GetShapeB(), s);
  }
};
h(x1, "b2PolygonContact");
let tg = x1;
Zm.b2PolygonContact = tg;
var Ym = {};
Object.defineProperty(Ym, "__esModule", { value: !0 });
Ym.b2PolygonAndCircleContact = void 0;
const v9 = Sr, b9 = Yn, w1 = class w1 extends b9.b2Contact {
  Evaluate(t, e, s) {
    (0, v9.b2CollidePolygonAndCircle)(t, this.GetShapeA(), e, this.GetShapeB(), s);
  }
};
h(w1, "b2PolygonAndCircleContact");
let eg = w1;
Ym.b2PolygonAndCircleContact = eg;
var Jm = {};
Object.defineProperty(Jm, "__esModule", { value: !0 });
Jm.b2EdgeAndCircleContact = void 0;
const y9 = eo, x9 = Yn, S1 = class S1 extends x9.b2Contact {
  Evaluate(t, e, s) {
    (0, y9.b2CollideEdgeAndCircle)(t, this.GetShapeA(), e, this.GetShapeB(), s);
  }
};
h(S1, "b2EdgeAndCircleContact");
let ng = S1;
Jm.b2EdgeAndCircleContact = ng;
var Km = {};
Object.defineProperty(Km, "__esModule", { value: !0 });
Km.b2EdgeAndPolygonContact = void 0;
const w9 = eo, S9 = Yn, A1 = class A1 extends S9.b2Contact {
  Evaluate(t, e, s) {
    (0, w9.b2CollideEdgeAndPolygon)(t, this.GetShapeA(), e, this.GetShapeB(), s);
  }
};
h(A1, "b2EdgeAndPolygonContact");
let ig = A1;
Km.b2EdgeAndPolygonContact = ig;
var Qm = {};
Object.defineProperty(Qm, "__esModule", { value: !0 });
Qm.b2ChainAndCircleContact = void 0;
const A9 = eo, M9 = Ua, C9 = Yn, fm = class fm extends C9.b2Contact {
  Evaluate(t, e, s) {
    const i = fm.Evaluate_s_edge;
    this.GetShapeA().GetChildEdge(i, this.m_indexA), (0, A9.b2CollideEdgeAndCircle)(t, i, e, this.GetShapeB(), s);
  }
};
h(fm, "b2ChainAndCircleContact");
let Dd = fm;
Qm.b2ChainAndCircleContact = Dd;
Dd.Evaluate_s_edge = new M9.b2EdgeShape();
var tf = {};
Object.defineProperty(tf, "__esModule", { value: !0 });
tf.b2ChainAndPolygonContact = void 0;
const E9 = eo, T9 = Ua, I9 = Yn, pm = class pm extends I9.b2Contact {
  Evaluate(t, e, s) {
    const i = pm.Evaluate_s_edge;
    this.GetShapeA().GetChildEdge(i, this.m_indexA), (0, E9.b2CollideEdgeAndPolygon)(t, i, e, this.GetShapeB(), s);
  }
};
h(pm, "b2ChainAndPolygonContact");
let Vd = pm;
tf.b2ChainAndPolygonContact = Vd;
Vd.Evaluate_s_edge = new T9.b2EdgeShape();
Object.defineProperty($u, "__esModule", { value: !0 });
$u.b2ContactFactory = void 0;
const ni = wi, B9 = Xm, P9 = Zm, R9 = Ym, D9 = Jm, V9 = Km, L9 = Qm, N9 = tf, M1 = class M1 {
  constructor() {
    const t = new Array(ni.b2ShapeType.e_typeCount);
    for (let e = 0; e < ni.b2ShapeType.e_typeCount; e++)
      t[e] = new Array(ni.b2ShapeType.e_typeCount);
    this.m_registers = t, this.AddType(B9.b2CircleContact, ni.b2ShapeType.e_circle, ni.b2ShapeType.e_circle), this.AddType(R9.b2PolygonAndCircleContact, ni.b2ShapeType.e_polygon, ni.b2ShapeType.e_circle), this.AddType(P9.b2PolygonContact, ni.b2ShapeType.e_polygon, ni.b2ShapeType.e_polygon), this.AddType(D9.b2EdgeAndCircleContact, ni.b2ShapeType.e_edge, ni.b2ShapeType.e_circle), this.AddType(V9.b2EdgeAndPolygonContact, ni.b2ShapeType.e_edge, ni.b2ShapeType.e_polygon), this.AddType(L9.b2ChainAndCircleContact, ni.b2ShapeType.e_chain, ni.b2ShapeType.e_circle), this.AddType(N9.b2ChainAndPolygonContact, ni.b2ShapeType.e_chain, ni.b2ShapeType.e_polygon);
  }
  AddType(t, e, s) {
    const i = [], o = /* @__PURE__ */ h((r) => {
      i.push(r);
    }, "destroyFcn");
    this.m_registers[e][s] = {
      createFcn(r, a, l, c) {
        var u;
        const m = (u = i.pop()) !== null && u !== void 0 ? u : new t();
        return m.Reset(r, a, l, c), m;
      },
      destroyFcn: o
    }, e !== s && (this.m_registers[s][e] = {
      createFcn(r, a, l, c) {
        var u;
        const m = (u = i.pop()) !== null && u !== void 0 ? u : new t();
        return m.Reset(l, c, r, a), m;
      },
      destroyFcn: o
    });
  }
  Create(t, e, s, i) {
    const o = t.GetType(), r = s.GetType(), a = this.m_registers[o][r];
    return a ? a.createFcn(t, e, s, i) : null;
  }
  Destroy(t) {
    const e = t.m_fixtureA.GetType(), s = t.m_fixtureB.GetType(), i = this.m_registers[e][s];
    i == null || i.destroyFcn(t);
  }
};
h(M1, "b2ContactFactory");
let sg = M1;
$u.b2ContactFactory = sg;
var us = {};
Object.defineProperty(us, "__esModule", { value: !0 });
us.b2ContactListener = us.b2ContactImpulse = us.b2ContactFilter = us.b2DestructionListener = void 0;
const Bh = Xe, C1 = class C1 {
  SayGoodbyeJoint(t) {
  }
  SayGoodbyeFixture(t) {
  }
};
h(C1, "b2DestructionListener");
let og = C1;
us.b2DestructionListener = og;
const E1 = class E1 {
  ShouldCollide(t, e) {
    const s = t.GetFilterData(), i = e.GetFilterData();
    return s.groupIndex === i.groupIndex && s.groupIndex !== 0 ? s.groupIndex > 0 : (s.maskBits & i.categoryBits) !== 0 && (s.categoryBits & i.maskBits) !== 0;
  }
};
h(E1, "b2ContactFilter");
let vu = E1;
us.b2ContactFilter = vu;
vu.b2_defaultFilter = new vu();
const T1 = class T1 {
  constructor() {
    this.normalImpulses = (0, Bh.b2MakeNumberArray)(Bh.b2_maxManifoldPoints), this.tangentImpulses = (0, Bh.b2MakeNumberArray)(Bh.b2_maxManifoldPoints), this.count = 0;
  }
};
h(T1, "b2ContactImpulse");
let rg = T1;
us.b2ContactImpulse = rg;
const I1 = class I1 {
  BeginContact(t) {
  }
  EndContact(t) {
  }
  PreSolve(t, e) {
  }
  PostSolve(t, e) {
  }
};
h(I1, "b2ContactListener");
let bu = I1;
us.b2ContactListener = bu;
bu.b2_defaultListener = new bu();
Object.defineProperty(Ou, "__esModule", { value: !0 });
Ou.b2ContactManager = void 0;
const z9 = ku, k9 = $u, sA = to, oA = us, B1 = class B1 {
  constructor() {
    this.m_broadPhase = new z9.b2BroadPhase(), this.m_contactList = null, this.m_contactCount = 0, this.m_contactFilter = oA.b2ContactFilter.b2_defaultFilter, this.m_contactListener = oA.b2ContactListener.b2_defaultListener, this.m_contactFactory = new k9.b2ContactFactory(), this.AddPair = (t, e) => {
      let s = t.fixture, i = e.fixture, o = t.childIndex, r = e.childIndex, a = s.GetBody(), l = i.GetBody();
      if (a === l)
        return;
      let c = l.GetContactList();
      for (; c; ) {
        if (c.other === a) {
          const m = c.contact.GetFixtureA(), d = c.contact.GetFixtureB(), f = c.contact.GetChildIndexA(), p = c.contact.GetChildIndexB();
          if (m === s && d === i && f === o && p === r || m === i && d === s && f === r && p === o)
            return;
        }
        c = c.next;
      }
      if (l.ShouldCollide(a) === !1 || this.m_contactFilter && !this.m_contactFilter.ShouldCollide(s, i))
        return;
      const u = this.m_contactFactory.Create(s, o, i, r);
      u !== null && (s = u.GetFixtureA(), i = u.GetFixtureB(), o = u.GetChildIndexA(), r = u.GetChildIndexB(), a = s.m_body, l = i.m_body, u.m_prev = null, u.m_next = this.m_contactList, this.m_contactList !== null && (this.m_contactList.m_prev = u), this.m_contactList = u, u.m_nodeA.other = l, u.m_nodeA.prev = null, u.m_nodeA.next = a.m_contactList, a.m_contactList !== null && (a.m_contactList.prev = u.m_nodeA), a.m_contactList = u.m_nodeA, u.m_nodeB.other = a, u.m_nodeB.prev = null, u.m_nodeB.next = l.m_contactList, l.m_contactList !== null && (l.m_contactList.prev = u.m_nodeB), l.m_contactList = u.m_nodeB, ++this.m_contactCount);
    };
  }
  FindNewContacts() {
    this.m_broadPhase.UpdatePairs(this.AddPair);
  }
  Destroy(t) {
    const e = t.GetFixtureA(), s = t.GetFixtureB(), i = e.GetBody(), o = s.GetBody();
    this.m_contactListener && t.IsTouching() && this.m_contactListener.EndContact(t), t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_contactList && (this.m_contactList = t.m_next), t.m_nodeA.prev && (t.m_nodeA.prev.next = t.m_nodeA.next), t.m_nodeA.next && (t.m_nodeA.next.prev = t.m_nodeA.prev), t.m_nodeA === i.m_contactList && (i.m_contactList = t.m_nodeA.next), t.m_nodeB.prev && (t.m_nodeB.prev.next = t.m_nodeB.next), t.m_nodeB.next && (t.m_nodeB.next.prev = t.m_nodeB.prev), t.m_nodeB === o.m_contactList && (o.m_contactList = t.m_nodeB.next), t.m_manifold.pointCount > 0 && !e.IsSensor() && !s.IsSensor() && (e.GetBody().SetAwake(!0), s.GetBody().SetAwake(!0)), this.m_contactFactory.Destroy(t), --this.m_contactCount;
  }
  Collide() {
    let t = this.m_contactList;
    for (; t; ) {
      const e = t.GetFixtureA(), s = t.GetFixtureB(), i = t.GetChildIndexA(), o = t.GetChildIndexB(), r = e.GetBody(), a = s.GetBody();
      if (t.m_filterFlag) {
        if (!a.ShouldCollide(r) || this.m_contactFilter && !this.m_contactFilter.ShouldCollide(e, s)) {
          const f = t;
          t = f.m_next, this.Destroy(f);
          continue;
        }
        t.m_filterFlag = !1;
      }
      const l = r.IsAwake() && r.m_type !== sA.b2BodyType.b2_staticBody, c = a.IsAwake() && a.m_type !== sA.b2BodyType.b2_staticBody;
      if (!l && !c) {
        t = t.m_next;
        continue;
      }
      const u = e.m_proxies[i].treeNode, m = s.m_proxies[o].treeNode;
      if (!u.aabb.TestOverlap(m.aabb)) {
        const f = t;
        t = f.m_next, this.Destroy(f);
        continue;
      }
      t.Update(this.m_contactListener), t = t.m_next;
    }
  }
};
h(B1, "b2ContactManager");
let ag = B1;
Ou.b2ContactManager = ag;
var ef = {}, qi = {}, xi = {};
Object.defineProperty(xi, "__esModule", { value: !0 });
xi.b2SolverData = xi.b2Velocity = xi.b2Position = xi.b2TimeStep = xi.b2Profile = void 0;
const cI = Fe, P1 = class P1 {
  constructor() {
    this.step = 0, this.collide = 0, this.solve = 0, this.solveInit = 0, this.solveVelocity = 0, this.solvePosition = 0, this.broadphase = 0, this.solveTOI = 0;
  }
  Reset() {
    return this.step = 0, this.collide = 0, this.solve = 0, this.solveInit = 0, this.solveVelocity = 0, this.solvePosition = 0, this.broadphase = 0, this.solveTOI = 0, this;
  }
};
h(P1, "b2Profile");
let cg = P1;
xi.b2Profile = cg;
const _m = class _m {
  constructor() {
    this.dt = 0, this.inv_dt = 0, this.dtRatio = 0, this.config = {
      velocityIterations: 0,
      positionIterations: 0
    }, this.warmStarting = !1;
  }
  static Create() {
    return new _m();
  }
  Copy(t) {
    return this.dt = t.dt, this.inv_dt = t.inv_dt, this.dtRatio = t.dtRatio, this.config = {
      ...t.config
    }, this.warmStarting = t.warmStarting, this;
  }
};
h(_m, "b2TimeStep");
let Ld = _m;
xi.b2TimeStep = Ld;
const R1 = class R1 {
  constructor() {
    this.c = new cI.b2Vec2(), this.a = 0;
  }
};
h(R1, "b2Position");
let lg = R1;
xi.b2Position = lg;
const D1 = class D1 {
  constructor() {
    this.v = new cI.b2Vec2(), this.w = 0;
  }
};
h(D1, "b2Velocity");
let ug = D1;
xi.b2Velocity = ug;
const V1 = class V1 {
  constructor() {
    this.step = Ld.Create();
  }
};
h(V1, "b2SolverData");
let hg = V1;
xi.b2SolverData = hg;
Object.defineProperty(qi, "__esModule", { value: !0 });
qi.b2ContactSolver = qi.b2ContactSolverDef = qi.b2ContactVelocityConstraint = qi.b2GetBlockSolve = qi.b2SetBlockSolve = void 0;
const Ei = Xe, H = Fe, kl = ge, lI = xi;
let Nd = !0;
function U9(n) {
  Nd = n;
}
h(U9, "b2SetBlockSolve");
qi.b2SetBlockSolve = U9;
function O9() {
  return Nd;
}
h(O9, "b2GetBlockSolve");
qi.b2GetBlockSolve = O9;
const L1 = class L1 {
  constructor() {
    this.rA = new H.b2Vec2(), this.rB = new H.b2Vec2(), this.normalImpulse = 0, this.tangentImpulse = 0, this.normalMass = 0, this.tangentMass = 0, this.velocityBias = 0;
  }
};
h(L1, "b2VelocityConstraintPoint");
let dg = L1;
const N1 = class N1 {
  constructor() {
    this.points = (0, Ei.b2MakeArray)(Ei.b2_maxManifoldPoints, dg), this.normal = new H.b2Vec2(), this.tangent = new H.b2Vec2(), this.normalMass = new H.b2Mat22(), this.K = new H.b2Mat22(), this.indexA = 0, this.indexB = 0, this.invMassA = 0, this.invMassB = 0, this.invIA = 0, this.invIB = 0, this.friction = 0, this.restitution = 0, this.threshold = 0, this.tangentSpeed = 0, this.pointCount = 0, this.contactIndex = 0;
  }
};
h(N1, "b2ContactVelocityConstraint");
let yu = N1;
qi.b2ContactVelocityConstraint = yu;
const z1 = class z1 {
  constructor() {
    this.localPoints = (0, Ei.b2MakeArray)(Ei.b2_maxManifoldPoints, H.b2Vec2), this.localNormal = new H.b2Vec2(), this.localPoint = new H.b2Vec2(), this.indexA = 0, this.indexB = 0, this.invMassA = 0, this.invMassB = 0, this.localCenterA = new H.b2Vec2(), this.localCenterB = new H.b2Vec2(), this.invIA = 0, this.invIB = 0, this.type = kl.b2ManifoldType.e_circles, this.radiusA = 0, this.radiusB = 0, this.pointCount = 0;
  }
};
h(z1, "b2ContactPositionConstraint");
let zd = z1;
const k1 = class k1 {
  constructor() {
    this.step = lI.b2TimeStep.Create(), this.count = 0;
  }
};
h(k1, "b2ContactSolverDef");
let mg = k1;
qi.b2ContactSolverDef = mg;
const Qr = class Qr {
  constructor() {
    this.normal = new H.b2Vec2(), this.point = new H.b2Vec2(), this.separation = 0;
  }
  Initialize(t, e, s, i) {
    const o = Qr.Initialize_s_pointA, r = Qr.Initialize_s_pointB, a = Qr.Initialize_s_planePoint, l = Qr.Initialize_s_clipPoint;
    switch (t.type) {
      case kl.b2ManifoldType.e_circles:
        H.b2Transform.MultiplyVec2(e, t.localPoint, o), H.b2Transform.MultiplyVec2(s, t.localPoints[0], r), H.b2Vec2.Subtract(r, o, this.normal).Normalize(), H.b2Vec2.Mid(o, r, this.point), this.separation = H.b2Vec2.Dot(H.b2Vec2.Subtract(r, o, H.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB;
        break;
      case kl.b2ManifoldType.e_faceA:
        H.b2Rot.MultiplyVec2(e.q, t.localNormal, this.normal), H.b2Transform.MultiplyVec2(e, t.localPoint, a), H.b2Transform.MultiplyVec2(s, t.localPoints[i], l), this.separation = H.b2Vec2.Dot(H.b2Vec2.Subtract(l, a, H.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB, this.point.Copy(l);
        break;
      case kl.b2ManifoldType.e_faceB:
        H.b2Rot.MultiplyVec2(s.q, t.localNormal, this.normal), H.b2Transform.MultiplyVec2(s, t.localPoint, a), H.b2Transform.MultiplyVec2(e, t.localPoints[i], l), this.separation = H.b2Vec2.Dot(H.b2Vec2.Subtract(l, a, H.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB, this.point.Copy(l), this.normal.Negate();
        break;
    }
  }
};
h(Qr, "b2PositionSolverManifold");
let Cr = Qr;
Cr.Initialize_s_pointA = new H.b2Vec2();
Cr.Initialize_s_pointB = new H.b2Vec2();
Cr.Initialize_s_planePoint = new H.b2Vec2();
Cr.Initialize_s_clipPoint = new H.b2Vec2();
const sn = class sn {
  constructor() {
    this.m_step = lI.b2TimeStep.Create(), this.m_positionConstraints = (0, Ei.b2MakeArray)(1024, zd), this.m_velocityConstraints = (0, Ei.b2MakeArray)(1024, yu), this.m_count = 0;
  }
  Initialize(t) {
    if (this.m_step.Copy(t.step), this.m_count = t.count, this.m_positionConstraints.length < this.m_count) {
      const e = Math.max(this.m_positionConstraints.length * 2, this.m_count);
      for (; this.m_positionConstraints.length < e; )
        this.m_positionConstraints[this.m_positionConstraints.length] = new zd();
    }
    if (this.m_velocityConstraints.length < this.m_count) {
      const e = Math.max(this.m_velocityConstraints.length * 2, this.m_count);
      for (; this.m_velocityConstraints.length < e; )
        this.m_velocityConstraints[this.m_velocityConstraints.length] = new yu();
    }
    this.m_positions = t.positions, this.m_velocities = t.velocities, this.m_contacts = t.contacts;
    for (let e = 0; e < this.m_count; ++e) {
      const s = this.m_contacts[e], i = s.m_fixtureA, o = s.m_fixtureB, r = i.GetShape(), a = o.GetShape(), l = r.m_radius, c = a.m_radius, u = i.GetBody(), m = o.GetBody(), d = s.GetManifold(), { pointCount: f } = d, p = this.m_velocityConstraints[e];
      p.friction = s.m_friction, p.restitution = s.m_restitution, p.threshold = s.m_restitutionThreshold, p.tangentSpeed = s.m_tangentSpeed, p.indexA = u.m_islandIndex, p.indexB = m.m_islandIndex, p.invMassA = u.m_invMass, p.invMassB = m.m_invMass, p.invIA = u.m_invI, p.invIB = m.m_invI, p.contactIndex = e, p.pointCount = f, p.K.SetZero(), p.normalMass.SetZero();
      const v = this.m_positionConstraints[e];
      v.indexA = u.m_islandIndex, v.indexB = m.m_islandIndex, v.invMassA = u.m_invMass, v.invMassB = m.m_invMass, v.localCenterA.Copy(u.m_sweep.localCenter), v.localCenterB.Copy(m.m_sweep.localCenter), v.invIA = u.m_invI, v.invIB = m.m_invI, v.localNormal.Copy(d.localNormal), v.localPoint.Copy(d.localPoint), v.pointCount = f, v.radiusA = l, v.radiusB = c, v.type = d.type;
      for (let _ = 0; _ < f; ++_) {
        const g = d.points[_], w = p.points[_];
        this.m_step.warmStarting ? (w.normalImpulse = this.m_step.dtRatio * g.normalImpulse, w.tangentImpulse = this.m_step.dtRatio * g.tangentImpulse) : (w.normalImpulse = 0, w.tangentImpulse = 0), w.rA.SetZero(), w.rB.SetZero(), w.normalMass = 0, w.tangentMass = 0, w.velocityBias = 0, v.localPoints[_].Copy(g.localPoint);
      }
    }
    return this;
  }
  InitializeVelocityConstraints() {
    const t = sn.InitializeVelocityConstraints_s_xfA, e = sn.InitializeVelocityConstraints_s_xfB, s = sn.InitializeVelocityConstraints_s_worldManifold, i = 1e3;
    for (let o = 0; o < this.m_count; ++o) {
      const r = this.m_velocityConstraints[o], a = this.m_positionConstraints[o], { radiusA: l, radiusB: c, localCenterA: u, localCenterB: m } = a, d = this.m_contacts[r.contactIndex].GetManifold(), { indexA: f, indexB: p, tangent: v, pointCount: _ } = r, g = r.invMassA, w = r.invMassB, S = r.invIA, x = r.invIB, A = this.m_positions[f].c, C = this.m_positions[f].a, M = this.m_velocities[f].v, T = this.m_velocities[f].w, b = this.m_positions[p].c, y = this.m_positions[p].a, E = this.m_velocities[p].v, I = this.m_velocities[p].w;
      t.q.Set(C), e.q.Set(y), H.b2Vec2.Subtract(A, H.b2Rot.MultiplyVec2(t.q, u, H.b2Vec2.s_t0), t.p), H.b2Vec2.Subtract(b, H.b2Rot.MultiplyVec2(e.q, m, H.b2Vec2.s_t0), e.p), s.Initialize(d, t, l, e, c), r.normal.Copy(s.normal), H.b2Vec2.CrossVec2One(r.normal, v);
      for (let B = 0; B < _; ++B) {
        const D = r.points[B];
        H.b2Vec2.Subtract(s.points[B], A, D.rA), H.b2Vec2.Subtract(s.points[B], b, D.rB);
        const N = H.b2Vec2.Cross(D.rA, r.normal), V = H.b2Vec2.Cross(D.rB, r.normal), G = g + w + S * N * N + x * V * V;
        D.normalMass = G > 0 ? 1 / G : 0;
        const U = H.b2Vec2.Cross(D.rA, v), j = H.b2Vec2.Cross(D.rB, v), tt = g + w + S * U * U + x * j * j;
        D.tangentMass = tt > 0 ? 1 / tt : 0, D.velocityBias = 0;
        const K = H.b2Vec2.Dot(r.normal, H.b2Vec2.Subtract(H.b2Vec2.AddCrossScalarVec2(E, I, D.rB, H.b2Vec2.s_t0), H.b2Vec2.AddCrossScalarVec2(M, T, D.rA, H.b2Vec2.s_t1), H.b2Vec2.s_t0));
        K < -r.threshold && (D.velocityBias = -r.restitution * K);
      }
      if (r.pointCount === 2 && Nd) {
        const B = r.points[0], D = r.points[1], N = H.b2Vec2.Cross(B.rA, r.normal), V = H.b2Vec2.Cross(B.rB, r.normal), G = H.b2Vec2.Cross(D.rA, r.normal), U = H.b2Vec2.Cross(D.rB, r.normal), j = g + w + S * N * N + x * V * V, tt = g + w + S * G * G + x * U * U, K = g + w + S * N * G + x * V * U;
        j * j < i * (j * tt - K * K) ? (r.K.ex.Set(j, K), r.K.ey.Set(K, tt), r.K.GetInverse(r.normalMass)) : r.pointCount = 1;
      }
    }
  }
  WarmStart() {
    const t = sn.WarmStart_s_P;
    for (let e = 0; e < this.m_count; ++e) {
      const s = this.m_velocityConstraints[e], { indexA: i, indexB: o, pointCount: r, normal: a, tangent: l } = s, c = s.invMassA, u = s.invIA, m = s.invMassB, d = s.invIB, f = this.m_velocities[i].v;
      let p = this.m_velocities[i].w;
      const v = this.m_velocities[o].v;
      let _ = this.m_velocities[o].w;
      for (let g = 0; g < r; ++g) {
        const w = s.points[g];
        H.b2Vec2.Add(H.b2Vec2.Scale(w.normalImpulse, a, H.b2Vec2.s_t0), H.b2Vec2.Scale(w.tangentImpulse, l, H.b2Vec2.s_t1), t), p -= u * H.b2Vec2.Cross(w.rA, t), f.SubtractScaled(c, t), _ += d * H.b2Vec2.Cross(w.rB, t), v.AddScaled(m, t);
      }
      this.m_velocities[i].w = p, this.m_velocities[o].w = _;
    }
  }
  SolveVelocityConstraints() {
    const t = sn.SolveVelocityConstraints_s_dv, e = sn.SolveVelocityConstraints_s_dv1, s = sn.SolveVelocityConstraints_s_dv2, i = sn.SolveVelocityConstraints_s_P, o = sn.SolveVelocityConstraints_s_a, r = sn.SolveVelocityConstraints_s_b, a = sn.SolveVelocityConstraints_s_x, l = sn.SolveVelocityConstraints_s_d, c = sn.SolveVelocityConstraints_s_P1, u = sn.SolveVelocityConstraints_s_P2, m = sn.SolveVelocityConstraints_s_P1P2;
    for (let d = 0; d < this.m_count; ++d) {
      const f = this.m_velocityConstraints[d], { indexA: p, indexB: v, pointCount: _, normal: g, tangent: w, friction: S } = f, x = f.invMassA, A = f.invIA, C = f.invMassB, M = f.invIB, T = this.m_velocities[p].v;
      let b = this.m_velocities[p].w;
      const y = this.m_velocities[v].v;
      let E = this.m_velocities[v].w;
      for (let I = 0; I < _; ++I) {
        const B = f.points[I];
        H.b2Vec2.Subtract(H.b2Vec2.AddCrossScalarVec2(y, E, B.rB, H.b2Vec2.s_t0), H.b2Vec2.AddCrossScalarVec2(T, b, B.rA, H.b2Vec2.s_t1), t);
        const D = H.b2Vec2.Dot(t, w) - f.tangentSpeed;
        let N = B.tangentMass * -D;
        const V = S * B.normalImpulse, G = (0, H.b2Clamp)(B.tangentImpulse + N, -V, V);
        N = G - B.tangentImpulse, B.tangentImpulse = G, H.b2Vec2.Scale(N, w, i), T.SubtractScaled(x, i), b -= A * H.b2Vec2.Cross(B.rA, i), y.AddScaled(C, i), E += M * H.b2Vec2.Cross(B.rB, i);
      }
      if (f.pointCount === 1 || Nd === !1)
        for (let I = 0; I < _; ++I) {
          const B = f.points[I];
          H.b2Vec2.Subtract(H.b2Vec2.AddCrossScalarVec2(y, E, B.rB, H.b2Vec2.s_t0), H.b2Vec2.AddCrossScalarVec2(T, b, B.rA, H.b2Vec2.s_t1), t);
          const D = H.b2Vec2.Dot(t, g);
          let N = -B.normalMass * (D - B.velocityBias);
          const V = Math.max(B.normalImpulse + N, 0);
          N = V - B.normalImpulse, B.normalImpulse = V, H.b2Vec2.Scale(N, g, i), T.SubtractScaled(x, i), b -= A * H.b2Vec2.Cross(B.rA, i), y.AddScaled(C, i), E += M * H.b2Vec2.Cross(B.rB, i);
        }
      else {
        const I = f.points[0], B = f.points[1];
        o.Set(I.normalImpulse, B.normalImpulse), H.b2Vec2.Subtract(H.b2Vec2.AddCrossScalarVec2(y, E, I.rB, H.b2Vec2.s_t0), H.b2Vec2.AddCrossScalarVec2(T, b, I.rA, H.b2Vec2.s_t1), e), H.b2Vec2.Subtract(H.b2Vec2.AddCrossScalarVec2(y, E, B.rB, H.b2Vec2.s_t0), H.b2Vec2.AddCrossScalarVec2(T, b, B.rA, H.b2Vec2.s_t1), s);
        let D = H.b2Vec2.Dot(e, g), N = H.b2Vec2.Dot(s, g);
        for (r.x = D - I.velocityBias, r.y = N - B.velocityBias, r.Subtract(H.b2Mat22.MultiplyVec2(f.K, o, H.b2Vec2.s_t0)); ; ) {
          if (H.b2Mat22.MultiplyVec2(f.normalMass, r, a).Negate(), a.x >= 0 && a.y >= 0) {
            H.b2Vec2.Subtract(a, o, l), H.b2Vec2.Scale(l.x, g, c), H.b2Vec2.Scale(l.y, g, u), H.b2Vec2.Add(c, u, m), T.SubtractScaled(x, m), b -= A * (H.b2Vec2.Cross(I.rA, c) + H.b2Vec2.Cross(B.rA, u)), y.AddScaled(C, m), E += M * (H.b2Vec2.Cross(I.rB, c) + H.b2Vec2.Cross(B.rB, u)), I.normalImpulse = a.x, B.normalImpulse = a.y;
            break;
          }
          if (a.x = -I.normalMass * r.x, a.y = 0, D = 0, N = f.K.ex.y * a.x + r.y, a.x >= 0 && N >= 0) {
            H.b2Vec2.Subtract(a, o, l), H.b2Vec2.Scale(l.x, g, c), H.b2Vec2.Scale(l.y, g, u), H.b2Vec2.Add(c, u, m), T.SubtractScaled(x, m), b -= A * (H.b2Vec2.Cross(I.rA, c) + H.b2Vec2.Cross(B.rA, u)), y.AddScaled(C, m), E += M * (H.b2Vec2.Cross(I.rB, c) + H.b2Vec2.Cross(B.rB, u)), I.normalImpulse = a.x, B.normalImpulse = a.y;
            break;
          }
          if (a.x = 0, a.y = -B.normalMass * r.y, D = f.K.ey.x * a.y + r.x, N = 0, a.y >= 0 && D >= 0) {
            H.b2Vec2.Subtract(a, o, l), H.b2Vec2.Scale(l.x, g, c), H.b2Vec2.Scale(l.y, g, u), H.b2Vec2.Add(c, u, m), T.SubtractScaled(x, m), b -= A * (H.b2Vec2.Cross(I.rA, c) + H.b2Vec2.Cross(B.rA, u)), y.AddScaled(C, m), E += M * (H.b2Vec2.Cross(I.rB, c) + H.b2Vec2.Cross(B.rB, u)), I.normalImpulse = a.x, B.normalImpulse = a.y;
            break;
          }
          if (a.x = 0, a.y = 0, D = r.x, N = r.y, D >= 0 && N >= 0) {
            H.b2Vec2.Subtract(a, o, l), H.b2Vec2.Scale(l.x, g, c), H.b2Vec2.Scale(l.y, g, u), H.b2Vec2.Add(c, u, m), T.SubtractScaled(x, m), b -= A * (H.b2Vec2.Cross(I.rA, c) + H.b2Vec2.Cross(B.rA, u)), y.AddScaled(C, m), E += M * (H.b2Vec2.Cross(I.rB, c) + H.b2Vec2.Cross(B.rB, u)), I.normalImpulse = a.x, B.normalImpulse = a.y;
            break;
          }
          break;
        }
      }
      this.m_velocities[p].w = b, this.m_velocities[v].w = E;
    }
  }
  StoreImpulses() {
    for (let t = 0; t < this.m_count; ++t) {
      const e = this.m_velocityConstraints[t], s = this.m_contacts[e.contactIndex].GetManifold();
      for (let i = 0; i < e.pointCount; ++i)
        s.points[i].normalImpulse = e.points[i].normalImpulse, s.points[i].tangentImpulse = e.points[i].tangentImpulse;
    }
  }
  SolvePositionConstraints() {
    const t = sn.SolvePositionConstraints_s_xfA, e = sn.SolvePositionConstraints_s_xfB, s = sn.SolvePositionConstraints_s_psm, i = sn.SolvePositionConstraints_s_rA, o = sn.SolvePositionConstraints_s_rB, r = sn.SolvePositionConstraints_s_P;
    let a = 0;
    for (let l = 0; l < this.m_count; ++l) {
      const c = this.m_positionConstraints[l], { indexA: u, indexB: m, localCenterA: d, localCenterB: f, pointCount: p } = c, v = c.invMassA, _ = c.invIA, g = c.invMassB, w = c.invIB, S = this.m_positions[u].c;
      let x = this.m_positions[u].a;
      const A = this.m_positions[m].c;
      let C = this.m_positions[m].a;
      for (let M = 0; M < p; ++M) {
        t.q.Set(x), e.q.Set(C), H.b2Vec2.Subtract(S, H.b2Rot.MultiplyVec2(t.q, d, H.b2Vec2.s_t0), t.p), H.b2Vec2.Subtract(A, H.b2Rot.MultiplyVec2(e.q, f, H.b2Vec2.s_t0), e.p), s.Initialize(c, t, e, M);
        const { normal: T, point: b, separation: y } = s;
        H.b2Vec2.Subtract(b, S, i), H.b2Vec2.Subtract(b, A, o), a = Math.min(a, y);
        const E = (0, H.b2Clamp)(Ei.b2_baumgarte * (y + Ei.b2_linearSlop), -Ei.b2_maxLinearCorrection, 0), I = H.b2Vec2.Cross(i, T), B = H.b2Vec2.Cross(o, T), D = v + g + _ * I * I + w * B * B, N = D > 0 ? -E / D : 0;
        H.b2Vec2.Scale(N, T, r), S.SubtractScaled(v, r), x -= _ * H.b2Vec2.Cross(i, r), A.AddScaled(g, r), C += w * H.b2Vec2.Cross(o, r);
      }
      this.m_positions[u].c.Copy(S), this.m_positions[u].a = x, this.m_positions[m].c.Copy(A), this.m_positions[m].a = C;
    }
    return a >= -3 * Ei.b2_linearSlop;
  }
  SolveTOIPositionConstraints(t, e) {
    const s = sn.SolveTOIPositionConstraints_s_xfA, i = sn.SolveTOIPositionConstraints_s_xfB, o = sn.SolveTOIPositionConstraints_s_psm, r = sn.SolveTOIPositionConstraints_s_rA, a = sn.SolveTOIPositionConstraints_s_rB, l = sn.SolveTOIPositionConstraints_s_P;
    let c = 0;
    for (let u = 0; u < this.m_count; ++u) {
      const m = this.m_positionConstraints[u], { indexA: d, indexB: f, localCenterA: p, localCenterB: v, pointCount: _ } = m;
      let g = 0, w = 0;
      (d === t || d === e) && (g = m.invMassA, w = m.invIA);
      let S = 0, x = 0;
      (f === t || f === e) && (S = m.invMassB, x = m.invIB);
      const A = this.m_positions[d].c;
      let C = this.m_positions[d].a;
      const M = this.m_positions[f].c;
      let T = this.m_positions[f].a;
      for (let b = 0; b < _; ++b) {
        s.q.Set(C), i.q.Set(T), H.b2Vec2.Subtract(A, H.b2Rot.MultiplyVec2(s.q, p, H.b2Vec2.s_t0), s.p), H.b2Vec2.Subtract(M, H.b2Rot.MultiplyVec2(i.q, v, H.b2Vec2.s_t0), i.p), o.Initialize(m, s, i, b);
        const { normal: y, point: E, separation: I } = o;
        H.b2Vec2.Subtract(E, A, r), H.b2Vec2.Subtract(E, M, a), c = Math.min(c, I);
        const B = (0, H.b2Clamp)(Ei.b2_toiBaumgarte * (I + Ei.b2_linearSlop), -Ei.b2_maxLinearCorrection, 0), D = H.b2Vec2.Cross(r, y), N = H.b2Vec2.Cross(a, y), V = g + S + w * D * D + x * N * N, G = V > 0 ? -B / V : 0;
        H.b2Vec2.Scale(G, y, l), A.SubtractScaled(g, l), C -= w * H.b2Vec2.Cross(r, l), M.AddScaled(S, l), T += x * H.b2Vec2.Cross(a, l);
      }
      this.m_positions[d].a = C, this.m_positions[f].a = T;
    }
    return c >= -1.5 * Ei.b2_linearSlop;
  }
};
h(sn, "b2ContactSolver");
let ln = sn;
qi.b2ContactSolver = ln;
ln.InitializeVelocityConstraints_s_xfA = new H.b2Transform();
ln.InitializeVelocityConstraints_s_xfB = new H.b2Transform();
ln.InitializeVelocityConstraints_s_worldManifold = new kl.b2WorldManifold();
ln.WarmStart_s_P = new H.b2Vec2();
ln.SolveVelocityConstraints_s_dv = new H.b2Vec2();
ln.SolveVelocityConstraints_s_dv1 = new H.b2Vec2();
ln.SolveVelocityConstraints_s_dv2 = new H.b2Vec2();
ln.SolveVelocityConstraints_s_P = new H.b2Vec2();
ln.SolveVelocityConstraints_s_a = new H.b2Vec2();
ln.SolveVelocityConstraints_s_b = new H.b2Vec2();
ln.SolveVelocityConstraints_s_x = new H.b2Vec2();
ln.SolveVelocityConstraints_s_d = new H.b2Vec2();
ln.SolveVelocityConstraints_s_P1 = new H.b2Vec2();
ln.SolveVelocityConstraints_s_P2 = new H.b2Vec2();
ln.SolveVelocityConstraints_s_P1P2 = new H.b2Vec2();
ln.SolvePositionConstraints_s_xfA = new H.b2Transform();
ln.SolvePositionConstraints_s_xfB = new H.b2Transform();
ln.SolvePositionConstraints_s_psm = new Cr();
ln.SolvePositionConstraints_s_rA = new H.b2Vec2();
ln.SolvePositionConstraints_s_rB = new H.b2Vec2();
ln.SolvePositionConstraints_s_P = new H.b2Vec2();
ln.SolveTOIPositionConstraints_s_xfA = new H.b2Transform();
ln.SolveTOIPositionConstraints_s_xfB = new H.b2Transform();
ln.SolveTOIPositionConstraints_s_psm = new Cr();
ln.SolveTOIPositionConstraints_s_rA = new H.b2Vec2();
ln.SolveTOIPositionConstraints_s_rB = new H.b2Vec2();
ln.SolveTOIPositionConstraints_s_P = new H.b2Vec2();
Object.defineProperty(ef, "__esModule", { value: !0 });
ef.b2Island = void 0;
const ci = Xe, dc = Fe, $9 = ka, uI = qi, rA = to, Ml = xi, F9 = us, is = class is {
  constructor(t, e, s, i) {
    this.m_bodyCount = 0, this.m_jointCount = 0, this.m_contactCount = 0, this.m_bodyCapacity = t, this.m_listener = i, this.m_bodies = new Array(t), this.m_contacts = new Array(e), this.m_joints = new Array(s), this.m_velocities = (0, ci.b2MakeArray)(t, Ml.b2Velocity), this.m_positions = (0, ci.b2MakeArray)(t, Ml.b2Position), this.Resize(t);
  }
  Resize(t) {
    for (; this.m_bodyCapacity < t; )
      this.m_velocities[this.m_bodyCapacity] = new Ml.b2Velocity(), this.m_positions[this.m_bodyCapacity] = new Ml.b2Position(), this.m_bodyCapacity++;
  }
  Clear() {
    this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0;
  }
  AddBody(t) {
    t.m_islandIndex = this.m_bodyCount, this.m_bodies[this.m_bodyCount] = t, ++this.m_bodyCount;
  }
  AddContact(t) {
    this.m_contacts[this.m_contactCount++] = t;
  }
  AddJoint(t) {
    this.m_joints[this.m_jointCount++] = t;
  }
  Solve(t, e, s, i) {
    const o = is.s_timer.Reset(), r = e.dt;
    for (let m = 0; m < this.m_bodyCount; ++m) {
      const d = this.m_bodies[m];
      this.m_positions[m].c.Copy(d.m_sweep.c);
      const { a: f } = d.m_sweep, p = this.m_velocities[m].v.Copy(d.m_linearVelocity);
      let v = d.m_angularVelocity;
      d.m_sweep.c0.Copy(d.m_sweep.c), d.m_sweep.a0 = d.m_sweep.a, d.m_type === rA.b2BodyType.b2_dynamicBody && (p.x += r * d.m_invMass * (d.m_gravityScale * d.m_mass * s.x + d.m_force.x), p.y += r * d.m_invMass * (d.m_gravityScale * d.m_mass * s.y + d.m_force.y), v += r * d.m_invI * d.m_torque, p.Scale(1 / (1 + r * d.m_linearDamping)), v *= 1 / (1 + r * d.m_angularDamping)), this.m_positions[m].a = f, this.m_velocities[m].w = v;
    }
    o.Reset();
    const a = is.s_solverData;
    a.step.Copy(e), a.positions = this.m_positions, a.velocities = this.m_velocities;
    const l = is.s_contactSolverDef;
    l.step.Copy(e), l.contacts = this.m_contacts, l.count = this.m_contactCount, l.positions = this.m_positions, l.velocities = this.m_velocities;
    const c = is.s_contactSolver.Initialize(l);
    c.InitializeVelocityConstraints(), e.warmStarting && c.WarmStart();
    for (let m = 0; m < this.m_jointCount; ++m)
      this.m_joints[m].InitVelocityConstraints(a);
    t.solveInit = o.GetMilliseconds(), o.Reset();
    for (let m = 0; m < e.config.velocityIterations; ++m) {
      for (let d = 0; d < this.m_jointCount; ++d)
        this.m_joints[d].SolveVelocityConstraints(a);
      c.SolveVelocityConstraints();
    }
    c.StoreImpulses(), t.solveVelocity = o.GetMilliseconds();
    for (let m = 0; m < this.m_bodyCount; ++m) {
      const { c: d } = this.m_positions[m];
      let { a: f } = this.m_positions[m];
      const { v: p } = this.m_velocities[m];
      let { w: v } = this.m_velocities[m];
      const _ = dc.b2Vec2.Scale(r, p, is.s_translation);
      if (dc.b2Vec2.Dot(_, _) > ci.b2_maxTranslationSquared) {
        const w = ci.b2_maxTranslation / _.Length();
        p.Scale(w);
      }
      const g = r * v;
      if (g * g > ci.b2_maxRotationSquared) {
        const w = ci.b2_maxRotation / Math.abs(g);
        v *= w;
      }
      d.AddScaled(r, p), f += r * v, this.m_positions[m].a = f, this.m_velocities[m].w = v;
    }
    o.Reset();
    let u = !1;
    for (let m = 0; m < e.config.positionIterations; ++m) {
      const d = c.SolvePositionConstraints();
      let f = !0;
      for (let p = 0; p < this.m_jointCount; ++p) {
        const v = this.m_joints[p].SolvePositionConstraints(a);
        f = f && v;
      }
      if (d && f) {
        u = !0;
        break;
      }
    }
    for (let m = 0; m < this.m_bodyCount; ++m) {
      const d = this.m_bodies[m];
      d.m_sweep.c.Copy(this.m_positions[m].c), d.m_sweep.a = this.m_positions[m].a, d.m_linearVelocity.Copy(this.m_velocities[m].v), d.m_angularVelocity = this.m_velocities[m].w, d.SynchronizeTransform();
    }
    if (t.solvePosition = o.GetMilliseconds(), this.Report(c.m_velocityConstraints), i) {
      let m = ci.b2_maxFloat;
      const d = ci.b2_linearSleepTolerance * ci.b2_linearSleepTolerance, f = ci.b2_angularSleepTolerance * ci.b2_angularSleepTolerance;
      for (let p = 0; p < this.m_bodyCount; ++p) {
        const v = this.m_bodies[p];
        v.GetType() !== rA.b2BodyType.b2_staticBody && (!v.m_autoSleepFlag || v.m_angularVelocity * v.m_angularVelocity > f || dc.b2Vec2.Dot(v.m_linearVelocity, v.m_linearVelocity) > d ? (v.m_sleepTime = 0, m = 0) : (v.m_sleepTime += r, m = Math.min(m, v.m_sleepTime)));
      }
      if (m >= ci.b2_timeToSleep && u)
        for (let p = 0; p < this.m_bodyCount; ++p)
          this.m_bodies[p].SetAwake(!1);
    }
  }
  SolveTOI(t, e, s) {
    for (let a = 0; a < this.m_bodyCount; ++a) {
      const l = this.m_bodies[a];
      this.m_positions[a].c.Copy(l.m_sweep.c), this.m_positions[a].a = l.m_sweep.a, this.m_velocities[a].v.Copy(l.m_linearVelocity), this.m_velocities[a].w = l.m_angularVelocity;
    }
    const i = is.s_contactSolverDef;
    i.contacts = this.m_contacts, i.count = this.m_contactCount, i.step.Copy(t), i.positions = this.m_positions, i.velocities = this.m_velocities;
    const o = is.s_contactSolver.Initialize(i);
    for (let a = 0; a < t.config.positionIterations && !o.SolveTOIPositionConstraints(e, s); ++a)
      ;
    this.m_bodies[e].m_sweep.c0.Copy(this.m_positions[e].c), this.m_bodies[e].m_sweep.a0 = this.m_positions[e].a, this.m_bodies[s].m_sweep.c0.Copy(this.m_positions[s].c), this.m_bodies[s].m_sweep.a0 = this.m_positions[s].a, o.InitializeVelocityConstraints();
    for (let a = 0; a < t.config.velocityIterations; ++a)
      o.SolveVelocityConstraints();
    const r = t.dt;
    for (let a = 0; a < this.m_bodyCount; ++a) {
      const { c: l } = this.m_positions[a];
      let { a: c } = this.m_positions[a];
      const { v: u } = this.m_velocities[a];
      let { w: m } = this.m_velocities[a];
      const d = dc.b2Vec2.Scale(r, u, is.s_translation);
      if (dc.b2Vec2.Dot(d, d) > ci.b2_maxTranslationSquared) {
        const v = ci.b2_maxTranslation / d.Length();
        u.Scale(v);
      }
      const f = r * m;
      if (f * f > ci.b2_maxRotationSquared) {
        const v = ci.b2_maxRotation / Math.abs(f);
        m *= v;
      }
      l.AddScaled(r, u), c += r * m, this.m_positions[a].a = c, this.m_velocities[a].w = m;
      const p = this.m_bodies[a];
      p.m_sweep.c.Copy(l), p.m_sweep.a = c, p.m_linearVelocity.Copy(u), p.m_angularVelocity = m, p.SynchronizeTransform();
    }
    this.Report(o.m_velocityConstraints);
  }
  Report(t) {
    for (let e = 0; e < this.m_contactCount; ++e) {
      const s = this.m_contacts[e], i = t[e], o = is.s_impulse;
      o.count = i.pointCount;
      for (let r = 0; r < i.pointCount; ++r)
        o.normalImpulses[r] = i.points[r].normalImpulse, o.tangentImpulses[r] = i.points[r].tangentImpulse;
      this.m_listener.PostSolve(s, o);
    }
  }
};
h(is, "b2Island");
let Ho = is;
ef.b2Island = Ho;
Ho.s_timer = new $9.b2Timer();
Ho.s_solverData = new Ml.b2SolverData();
Ho.s_contactSolverDef = new uI.b2ContactSolverDef();
Ho.s_contactSolver = new uI.b2ContactSolver();
Ho.s_translation = new dc.b2Vec2();
Ho.s_impulse = new F9.b2ContactImpulse();
Object.defineProperty(qm, "__esModule", { value: !0 });
qm.b2World = void 0;
const li = Xe, Fu = Fe, q2 = ka, nf = ge, kd = Gm, ys = xn, G9 = wa, H9 = Mr, j9 = Sa, W9 = Aa, q9 = Ma, X9 = Ca, Z9 = Ea, Y9 = ko, J9 = Ta, K9 = Ia, Q9 = Ba, Oi = to, t7 = Ou, e7 = ef, Ud = xi, Fn = class Fn {
  constructor(t) {
    this.m_contactManager = new t7.b2ContactManager(), this.m_bodyList = null, this.m_jointList = null, this.m_bodyCount = 0, this.m_jointCount = 0, this.m_gravity = new Fu.b2Vec2(), this.m_allowSleep = !0, this.m_destructionListener = null, this.m_inv_dt0 = 0, this.m_newContacts = !1, this.m_locked = !1, this.m_clearForces = !0, this.m_warmStarting = !0, this.m_continuousPhysics = !0, this.m_subStepping = !1, this.m_stepComplete = !0, this.m_profile = new Ud.b2Profile(), this.m_island = new e7.b2Island(2 * li.b2_maxTOIContacts, li.b2_maxTOIContacts, 0, this.m_contactManager.m_contactListener), this.s_stack = [], this.m_gravity.Copy(t);
  }
  static Create(t) {
    return new Fn(t);
  }
  SetDestructionListener(t) {
    this.m_destructionListener = t;
  }
  GetDestructionListener() {
    return this.m_destructionListener;
  }
  SetContactFilter(t) {
    this.m_contactManager.m_contactFilter = t;
  }
  SetContactListener(t) {
    this.m_contactManager.m_contactListener = t, this.m_island.m_listener = t;
  }
  CreateBody(t = {}) {
    (0, li.b2Assert)(!this.IsLocked());
    const e = new Oi.b2Body(t, this);
    return e.m_prev = null, e.m_next = this.m_bodyList, this.m_bodyList && (this.m_bodyList.m_prev = e), this.m_bodyList = e, ++this.m_bodyCount, e;
  }
  DestroyBody(t) {
    var e, s;
    (0, li.b2Assert)(!this.IsLocked());
    let i = t.m_jointList;
    for (; i; ) {
      const l = i;
      i = i.next, (e = this.m_destructionListener) === null || e === void 0 || e.SayGoodbyeJoint(l.joint), this.DestroyJoint(l.joint), t.m_jointList = i;
    }
    t.m_jointList = null;
    let o = t.m_contactList;
    for (; o; ) {
      const l = o;
      o = o.next, this.m_contactManager.Destroy(l.contact);
    }
    t.m_contactList = null;
    const r = this.m_contactManager.m_broadPhase;
    let a = t.m_fixtureList;
    for (; a; ) {
      const l = a;
      a = a.m_next, (s = this.m_destructionListener) === null || s === void 0 || s.SayGoodbyeFixture(l), l.DestroyProxies(r), t.m_fixtureList = a, t.m_fixtureCount -= 1;
    }
    t.m_fixtureList = null, t.m_fixtureCount = 0, t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_bodyList && (this.m_bodyList = t.m_next), --this.m_bodyCount;
  }
  static Joint_Create(t) {
    switch (t.type) {
      case ys.b2JointType.e_distanceJoint:
        return new H9.b2DistanceJoint(t);
      case ys.b2JointType.e_mouseJoint:
        return new X9.b2MouseJoint(t);
      case ys.b2JointType.e_prismaticJoint:
        return new Z9.b2PrismaticJoint(t);
      case ys.b2JointType.e_revoluteJoint:
        return new J9.b2RevoluteJoint(t);
      case ys.b2JointType.e_pulleyJoint:
        return new Y9.b2PulleyJoint(t);
      case ys.b2JointType.e_gearJoint:
        return new W9.b2GearJoint(t);
      case ys.b2JointType.e_wheelJoint:
        return new Q9.b2WheelJoint(t);
      case ys.b2JointType.e_weldJoint:
        return new K9.b2WeldJoint(t);
      case ys.b2JointType.e_frictionJoint:
        return new j9.b2FrictionJoint(t);
      case ys.b2JointType.e_motorJoint:
        return new q9.b2MotorJoint(t);
      case ys.b2JointType.e_areaJoint:
        return new G9.b2AreaJoint(t);
    }
    throw new Error();
  }
  CreateJoint(t) {
    (0, li.b2Assert)(!this.IsLocked());
    const e = Fn.Joint_Create(t);
    e.m_prev = null, e.m_next = this.m_jointList, this.m_jointList && (this.m_jointList.m_prev = e), this.m_jointList = e, ++this.m_jointCount, e.m_edgeA.prev = null, e.m_edgeA.next = e.m_bodyA.m_jointList, e.m_bodyA.m_jointList && (e.m_bodyA.m_jointList.prev = e.m_edgeA), e.m_bodyA.m_jointList = e.m_edgeA, e.m_edgeB.prev = null, e.m_edgeB.next = e.m_bodyB.m_jointList, e.m_bodyB.m_jointList && (e.m_bodyB.m_jointList.prev = e.m_edgeB), e.m_bodyB.m_jointList = e.m_edgeB;
    const s = e.m_bodyA, i = e.m_bodyB;
    if (!t.collideConnected) {
      let o = i.GetContactList();
      for (; o; )
        o.other === s && o.contact.FlagForFiltering(), o = o.next;
    }
    return e;
  }
  DestroyJoint(t) {
    (0, li.b2Assert)(!this.IsLocked()), t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_jointList && (this.m_jointList = t.m_next);
    const e = t.m_bodyA, s = t.m_bodyB, i = t.m_collideConnected;
    if (e.SetAwake(!0), s.SetAwake(!0), t.m_edgeA.prev && (t.m_edgeA.prev.next = t.m_edgeA.next), t.m_edgeA.next && (t.m_edgeA.next.prev = t.m_edgeA.prev), t.m_edgeA === e.m_jointList && (e.m_jointList = t.m_edgeA.next), t.m_edgeA.prev = null, t.m_edgeA.next = null, t.m_edgeB.prev && (t.m_edgeB.prev.next = t.m_edgeB.next), t.m_edgeB.next && (t.m_edgeB.next.prev = t.m_edgeB.prev), t.m_edgeB === s.m_jointList && (s.m_jointList = t.m_edgeB.next), t.m_edgeB.prev = null, t.m_edgeB.next = null, --this.m_jointCount, !i) {
      let o = s.GetContactList();
      for (; o; )
        o.other === e && o.contact.FlagForFiltering(), o = o.next;
    }
  }
  Step(t, e) {
    const s = Fn.Step_s_stepTimer.Reset();
    this.m_newContacts && (this.m_contactManager.FindNewContacts(), this.m_newContacts = !1), this.m_locked = !0;
    const i = Fn.Step_s_step;
    i.dt = t, i.config = {
      ...e
    }, t > 0 ? i.inv_dt = 1 / t : i.inv_dt = 0, i.dtRatio = this.m_inv_dt0 * t, i.warmStarting = this.m_warmStarting;
    {
      const o = Fn.Step_s_timer.Reset();
      this.m_contactManager.Collide(), this.m_profile.collide = o.GetMilliseconds();
    }
    if (this.m_stepComplete && i.dt > 0) {
      const o = Fn.Step_s_timer.Reset();
      this.Solve(i), this.m_profile.solve = o.GetMilliseconds();
    }
    if (this.m_continuousPhysics && i.dt > 0) {
      const o = Fn.Step_s_timer.Reset();
      this.SolveTOI(i), this.m_profile.solveTOI = o.GetMilliseconds();
    }
    i.dt > 0 && (this.m_inv_dt0 = i.inv_dt), this.m_clearForces && this.ClearForces(), this.m_locked = !1, this.m_profile.step = s.GetMilliseconds();
  }
  ClearForces() {
    for (let t = this.m_bodyList; t; t = t.GetNext())
      t.m_force.SetZero(), t.m_torque = 0;
  }
  QueryAABB(t, e) {
    this.m_contactManager.m_broadPhase.Query(t, (s) => {
      const i = (0, li.b2Verify)(s.userData);
      return e(i.fixture);
    });
  }
  QueryAllAABB(t, e = []) {
    return this.QueryAABB(t, (s) => (e.push(s), !0)), e;
  }
  QueryPointAABB(t, e) {
    this.m_contactManager.m_broadPhase.QueryPoint(t, (s) => {
      const i = (0, li.b2Verify)(s.userData);
      return e(i.fixture);
    });
  }
  QueryAllPointAABB(t, e = []) {
    return this.QueryPointAABB(t, (s) => (e.push(s), !0)), e;
  }
  QueryFixtureShape(t, e, s, i) {
    const o = Fn.QueryFixtureShape_s_aabb;
    t.ComputeAABB(o, s, e), this.m_contactManager.m_broadPhase.Query(o, (r) => {
      const a = (0, li.b2Verify)(r.userData), { fixture: l } = a;
      return !(0, nf.b2TestOverlap)(t, e, l.GetShape(), a.childIndex, s, l.GetBody().GetTransform()) || i(l);
    });
  }
  QueryAllFixtureShape(t, e, s, i = []) {
    return this.QueryFixtureShape(t, e, s, (o) => (i.push(o), !0)), i;
  }
  QueryFixturePoint(t, e) {
    this.m_contactManager.m_broadPhase.QueryPoint(t, (s) => {
      const i = (0, li.b2Verify)(s.userData), { fixture: o } = i;
      return !o.TestPoint(t) || e(o);
    });
  }
  QueryAllFixturePoint(t, e = []) {
    return this.QueryFixturePoint(t, (s) => (e.push(s), !0)), e;
  }
  RayCast(t, e, s) {
    const i = Fn.RayCast_s_input;
    i.maxFraction = 1, i.p1.Copy(t), i.p2.Copy(e), this.m_contactManager.m_broadPhase.RayCast(i, (o, r) => {
      const a = (0, li.b2Verify)(r.userData), { fixture: l } = a, c = a.childIndex, u = Fn.RayCast_s_output;
      if (l.RayCast(u, o, c)) {
        const { fraction: d } = u, f = Fn.RayCast_s_point;
        return f.Set((1 - d) * t.x + d * e.x, (1 - d) * t.y + d * e.y), s(l, f, u.normal, d);
      }
      return o.maxFraction;
    });
  }
  RayCastOne(t, e) {
    let s = null, i = 1;
    return this.RayCast(t, e, (o, r, a, l) => (l < i && (i = l, s = o), i)), s;
  }
  RayCastAll(t, e, s = []) {
    return this.RayCast(t, e, (i) => (s.push(i), 1)), s;
  }
  GetBodyList() {
    return this.m_bodyList;
  }
  GetJointList() {
    return this.m_jointList;
  }
  GetContactList() {
    return this.m_contactManager.m_contactList;
  }
  SetAllowSleeping(t) {
    if (t !== this.m_allowSleep && (this.m_allowSleep = t, !this.m_allowSleep))
      for (let e = this.m_bodyList; e; e = e.m_next)
        e.SetAwake(!0);
  }
  GetAllowSleeping() {
    return this.m_allowSleep;
  }
  SetWarmStarting(t) {
    this.m_warmStarting = t;
  }
  GetWarmStarting() {
    return this.m_warmStarting;
  }
  SetContinuousPhysics(t) {
    this.m_continuousPhysics = t;
  }
  GetContinuousPhysics() {
    return this.m_continuousPhysics;
  }
  SetSubStepping(t) {
    this.m_subStepping = t;
  }
  GetSubStepping() {
    return this.m_subStepping;
  }
  GetProxyCount() {
    return this.m_contactManager.m_broadPhase.GetProxyCount();
  }
  GetBodyCount() {
    return this.m_bodyCount;
  }
  GetJointCount() {
    return this.m_jointCount;
  }
  GetContactCount() {
    return this.m_contactManager.m_contactCount;
  }
  GetTreeHeight() {
    return this.m_contactManager.m_broadPhase.GetTreeHeight();
  }
  GetTreeBalance() {
    return this.m_contactManager.m_broadPhase.GetTreeBalance();
  }
  GetTreeQuality() {
    return this.m_contactManager.m_broadPhase.GetTreeQuality();
  }
  SetGravity(t) {
    this.m_gravity.Copy(t);
  }
  GetGravity() {
    return this.m_gravity;
  }
  IsLocked() {
    return this.m_locked;
  }
  SetAutoClearForces(t) {
    this.m_clearForces = t;
  }
  GetAutoClearForces() {
    return this.m_clearForces;
  }
  ShiftOrigin(t) {
    (0, li.b2Assert)(!this.IsLocked());
    for (let e = this.m_bodyList; e; e = e.m_next)
      e.m_xf.p.Subtract(t), e.m_sweep.c0.Subtract(t), e.m_sweep.c.Subtract(t);
    for (let e = this.m_jointList; e; e = e.m_next)
      e.ShiftOrigin(t);
    this.m_contactManager.m_broadPhase.ShiftOrigin(t);
  }
  GetContactManager() {
    return this.m_contactManager;
  }
  GetProfile() {
    return this.m_profile;
  }
  Solve(t) {
    this.m_profile.solveInit = 0, this.m_profile.solveVelocity = 0, this.m_profile.solvePosition = 0;
    const e = this.m_island;
    e.Resize(this.m_bodyCount), e.Clear();
    for (let o = this.m_bodyList; o; o = o.m_next)
      o.m_islandFlag = !1;
    for (let o = this.m_contactManager.m_contactList; o; o = o.m_next)
      o.m_islandFlag = !1;
    for (let o = this.m_jointList; o; o = o.m_next)
      o.m_islandFlag = !1;
    const s = this.s_stack;
    for (let o = this.m_bodyList; o; o = o.m_next) {
      if (o.m_islandFlag || !o.IsAwake() || !o.IsEnabled() || o.GetType() === Oi.b2BodyType.b2_staticBody)
        continue;
      e.Clear();
      let r = 0;
      for (s[r++] = o, o.m_islandFlag = !0; r > 0; ) {
        const l = s[--r];
        if ((0, li.b2Assert)(l !== null), e.AddBody(l), l.GetType() !== Oi.b2BodyType.b2_staticBody) {
          l.m_awakeFlag = !0;
          for (let c = l.m_contactList; c; c = c.next) {
            const { contact: u } = c;
            if (u.m_islandFlag || !u.IsEnabled() || !u.IsTouching())
              continue;
            const m = u.m_fixtureA.m_isSensor, d = u.m_fixtureB.m_isSensor;
            if (m || d)
              continue;
            e.AddContact(u), u.m_islandFlag = !0;
            const { other: f } = c;
            f.m_islandFlag || (s[r++] = f, f.m_islandFlag = !0);
          }
          for (let c = l.m_jointList; c; c = c.next) {
            if (c.joint.m_islandFlag)
              continue;
            const { other: u } = c;
            u.IsEnabled() && (e.AddJoint(c.joint), c.joint.m_islandFlag = !0, !u.m_islandFlag && (s[r++] = u, u.m_islandFlag = !0));
          }
        }
      }
      const a = new Ud.b2Profile();
      e.Solve(a, t, this.m_gravity, this.m_allowSleep), this.m_profile.solveInit += a.solveInit, this.m_profile.solveVelocity += a.solveVelocity, this.m_profile.solvePosition += a.solvePosition;
      for (let l = 0; l < e.m_bodyCount; ++l) {
        const c = e.m_bodies[l];
        c.GetType() === Oi.b2BodyType.b2_staticBody && (c.m_islandFlag = !1);
      }
    }
    for (let o = 0; o < s.length && s[o]; ++o)
      s[o] = null;
    const i = new q2.b2Timer();
    for (let o = this.m_bodyList; o; o = o.m_next)
      o.m_islandFlag && o.GetType() !== Oi.b2BodyType.b2_staticBody && o.SynchronizeFixtures();
    this.m_contactManager.FindNewContacts(), this.m_profile.broadphase = i.GetMilliseconds();
  }
  SolveTOI(t) {
    const e = this.m_island;
    if (e.Clear(), this.m_stepComplete) {
      for (let s = this.m_bodyList; s; s = s.m_next)
        s.m_islandFlag = !1, s.m_sweep.alpha0 = 0;
      for (let s = this.m_contactManager.m_contactList; s; s = s.m_next)
        s.m_toiFlag = !1, s.m_islandFlag = !1, s.m_toiCount = 0, s.m_toi = 1;
    }
    for (; ; ) {
      let s = null, i = 1;
      for (let d = this.m_contactManager.m_contactList; d; d = d.m_next) {
        if (!d.IsEnabled() || d.m_toiCount > li.b2_maxSubSteps)
          continue;
        let f = 1;
        if (d.m_toiFlag)
          f = d.m_toi;
        else {
          const p = d.GetFixtureA(), v = d.GetFixtureB();
          if (p.IsSensor() || v.IsSensor())
            continue;
          const _ = p.GetBody(), g = v.GetBody(), w = _.m_type, S = g.m_type, x = _.IsAwake() && w !== Oi.b2BodyType.b2_staticBody, A = g.IsAwake() && S !== Oi.b2BodyType.b2_staticBody;
          if (!x && !A)
            continue;
          const C = _.IsBullet() || w !== Oi.b2BodyType.b2_dynamicBody, M = g.IsBullet() || S !== Oi.b2BodyType.b2_dynamicBody;
          if (!C && !M)
            continue;
          let { alpha0: T } = _.m_sweep;
          _.m_sweep.alpha0 < g.m_sweep.alpha0 ? (T = g.m_sweep.alpha0, _.m_sweep.Advance(T)) : g.m_sweep.alpha0 < _.m_sweep.alpha0 && (T = _.m_sweep.alpha0, g.m_sweep.Advance(T));
          const b = d.GetChildIndexA(), y = d.GetChildIndexB(), E = Fn.SolveTOI_s_toi_input;
          E.proxyA.SetShape(p.GetShape(), b), E.proxyB.SetShape(v.GetShape(), y), E.sweepA.Copy(_.m_sweep), E.sweepB.Copy(g.m_sweep), E.tMax = 1;
          const I = Fn.SolveTOI_s_toi_output;
          (0, kd.b2TimeOfImpact)(I, E);
          const B = I.t;
          I.state === kd.b2TOIOutputState.e_touching ? f = Math.min(T + (1 - T) * B, 1) : f = 1, d.m_toi = f, d.m_toiFlag = !0;
        }
        f < i && (s = d, i = f);
      }
      if (s === null || 1 - 10 * li.b2_epsilon < i) {
        this.m_stepComplete = !0;
        break;
      }
      const o = s.GetFixtureA(), r = s.GetFixtureB(), a = o.GetBody(), l = r.GetBody(), c = Fn.SolveTOI_s_backup1.Copy(a.m_sweep), u = Fn.SolveTOI_s_backup2.Copy(l.m_sweep);
      if (a.Advance(i), l.Advance(i), s.Update(this.m_contactManager.m_contactListener), s.m_toiFlag = !1, ++s.m_toiCount, !s.IsEnabled() || !s.IsTouching()) {
        s.SetEnabled(!1), a.m_sweep.Copy(c), l.m_sweep.Copy(u), a.SynchronizeTransform(), l.SynchronizeTransform();
        continue;
      }
      a.SetAwake(!0), l.SetAwake(!0), e.Clear(), e.AddBody(a), e.AddBody(l), e.AddContact(s), a.m_islandFlag = !0, l.m_islandFlag = !0, s.m_islandFlag = !0;
      for (let d = 0; d < 2; ++d) {
        const f = d === 0 ? a : l;
        if (f.m_type === Oi.b2BodyType.b2_dynamicBody)
          for (let p = f.m_contactList; p && !(e.m_bodyCount === e.m_bodyCapacity || e.m_contactCount === li.b2_maxTOIContacts); p = p.next) {
            const { contact: v } = p;
            if (v.m_islandFlag)
              continue;
            const { other: _ } = p;
            if (_.m_type === Oi.b2BodyType.b2_dynamicBody && !f.IsBullet() && !_.IsBullet())
              continue;
            const g = v.m_fixtureA.m_isSensor, w = v.m_fixtureB.m_isSensor;
            if (g || w)
              continue;
            const S = Fn.SolveTOI_s_backup.Copy(_.m_sweep);
            if (_.m_islandFlag || _.Advance(i), v.Update(this.m_contactManager.m_contactListener), !v.IsEnabled()) {
              _.m_sweep.Copy(S), _.SynchronizeTransform();
              continue;
            }
            if (!v.IsTouching()) {
              _.m_sweep.Copy(S), _.SynchronizeTransform();
              continue;
            }
            v.m_islandFlag = !0, e.AddContact(v), !_.m_islandFlag && (_.m_islandFlag = !0, _.m_type !== Oi.b2BodyType.b2_staticBody && _.SetAwake(!0), e.AddBody(_));
          }
      }
      const m = Fn.SolveTOI_s_subStep;
      m.dt = (1 - i) * t.dt, m.inv_dt = 1 / m.dt, m.dtRatio = 1, m.config = {
        ...t.config,
        positionIterations: 20
      }, m.warmStarting = !1, e.SolveTOI(m, a.m_islandIndex, l.m_islandIndex);
      for (let d = 0; d < e.m_bodyCount; ++d) {
        const f = e.m_bodies[d];
        if (f.m_islandFlag = !1, f.m_type === Oi.b2BodyType.b2_dynamicBody) {
          f.SynchronizeFixtures();
          for (let p = f.m_contactList; p; p = p.next)
            p.contact.m_toiFlag = !1, p.contact.m_islandFlag = !1;
        }
      }
      if (this.m_contactManager.FindNewContacts(), this.m_subStepping) {
        this.m_stepComplete = !1;
        break;
      }
    }
  }
};
h(Fn, "b2World");
let fi = Fn;
qm.b2World = fi;
fi.Step_s_step = Ud.b2TimeStep.Create();
fi.Step_s_stepTimer = new q2.b2Timer();
fi.Step_s_timer = new q2.b2Timer();
fi.QueryFixtureShape_s_aabb = new nf.b2AABB();
fi.RayCast_s_input = new nf.b2RayCastInput();
fi.RayCast_s_output = new nf.b2RayCastOutput();
fi.RayCast_s_point = new Fu.b2Vec2();
fi.SolveTOI_s_subStep = Ud.b2TimeStep.Create();
fi.SolveTOI_s_backup = new Fu.b2Sweep();
fi.SolveTOI_s_backup1 = new Fu.b2Sweep();
fi.SolveTOI_s_backup2 = new Fu.b2Sweep();
fi.SolveTOI_s_toi_input = new kd.b2TOIInput();
fi.SolveTOI_s_toi_output = new kd.b2TOIOutput();
var Gs = {};
Object.defineProperty(Gs, "__esModule", { value: !0 });
Gs.b2Rope = Gs.b2RopeTuning = Gs.b2BendingModel = Gs.b2StretchingModel = void 0;
const lc = Xe, _l = Ai, yt = Fe, yo = {
  J1: new yt.b2Vec2(),
  J2: new yt.b2Vec2(),
  J3: new yt.b2Vec2(),
  r: new yt.b2Vec2(),
  e1: new yt.b2Vec2(),
  e2: new yt.b2Vec2(),
  Jd1: new yt.b2Vec2(),
  Jd2: new yt.b2Vec2(),
  d: new yt.b2Vec2(),
  u: new yt.b2Vec2(),
  dp1: new yt.b2Vec2(),
  dp2: new yt.b2Vec2(),
  dp3: new yt.b2Vec2(),
  d1: new yt.b2Vec2(),
  d2: new yt.b2Vec2(),
  dHat: new yt.b2Vec2()
};
var xu;
(function(n) {
  n[n.b2_pbdStretchingModel = 0] = "b2_pbdStretchingModel", n[n.b2_xpbdStretchingModel = 1] = "b2_xpbdStretchingModel";
})(xu || (Gs.b2StretchingModel = xu = {}));
var Eo;
(function(n) {
  n[n.b2_springAngleBendingModel = 0] = "b2_springAngleBendingModel", n[n.b2_pbdAngleBendingModel = 1] = "b2_pbdAngleBendingModel", n[n.b2_xpbdAngleBendingModel = 2] = "b2_xpbdAngleBendingModel", n[n.b2_pbdDistanceBendingModel = 3] = "b2_pbdDistanceBendingModel", n[n.b2_pbdHeightBendingModel = 4] = "b2_pbdHeightBendingModel", n[n.b2_pbdTriangleBendingModel = 5] = "b2_pbdTriangleBendingModel";
})(Eo || (Gs.b2BendingModel = Eo = {}));
const U1 = class U1 {
  constructor() {
    this.stretchingModel = xu.b2_pbdStretchingModel, this.bendingModel = Eo.b2_pbdAngleBendingModel, this.damping = 0, this.stretchStiffness = 1, this.stretchHertz = 1, this.stretchDamping = 0, this.bendStiffness = 0.5, this.bendHertz = 1, this.bendDamping = 0, this.isometric = !1, this.fixedEffectiveMass = !1, this.warmStart = !1;
  }
  Copy(t) {
    return this.stretchingModel = t.stretchingModel, this.bendingModel = t.bendingModel, this.damping = t.damping, this.stretchStiffness = t.stretchStiffness, this.stretchHertz = t.stretchHertz, this.stretchDamping = t.stretchDamping, this.bendStiffness = t.bendStiffness, this.bendHertz = t.bendHertz, this.bendDamping = t.bendDamping, this.isometric = t.isometric, this.fixedEffectiveMass = t.fixedEffectiveMass, this.warmStart = t.warmStart, this;
  }
};
h(U1, "b2RopeTuning");
let Od = U1;
Gs.b2RopeTuning = Od;
const O1 = class O1 {
  constructor() {
    this.i1 = 0, this.i2 = 0, this.invMass1 = 0, this.invMass2 = 0, this.L = 0, this.lambda = 0, this.spring = 0, this.damper = 0;
  }
};
h(O1, "b2RopeStretch");
let fg = O1;
const $1 = class $1 {
  constructor() {
    this.i1 = 0, this.i2 = 0, this.i3 = 0, this.invMass1 = 0, this.invMass2 = 0, this.invMass3 = 0, this.invEffectiveMass = 0, this.lambda = 0, this.L1 = 0, this.L2 = 0, this.alpha1 = 0, this.alpha2 = 0, this.spring = 0, this.damper = 0;
  }
};
h($1, "b2RopeBend");
let pg = $1;
const F1 = class F1 {
  constructor(t) {
    this.m_position = new yt.b2Vec2(), this.m_count = 0, this.m_stretchCount = 0, this.m_bendCount = 0, this.m_gravity = new yt.b2Vec2(), this.m_tuning = new Od(), (0, lc.b2Assert)(t.vertices.length >= 3), this.m_position.Copy(t.position), this.m_count = t.vertices.length, this.m_bindPositions = (0, lc.b2MakeArray)(this.m_count, yt.b2Vec2), this.m_ps = (0, lc.b2MakeArray)(this.m_count, yt.b2Vec2), this.m_p0s = (0, lc.b2MakeArray)(this.m_count, yt.b2Vec2), this.m_vs = (0, lc.b2MakeArray)(this.m_count, yt.b2Vec2), this.m_invMasses = (0, lc.b2MakeNumberArray)(this.m_count);
    for (let c = 0; c < this.m_count; ++c) {
      this.m_bindPositions[c].Copy(t.vertices[c]), yt.b2Vec2.Add(t.vertices[c], this.m_position, this.m_ps[c]), yt.b2Vec2.Add(t.vertices[c], this.m_position, this.m_p0s[c]), this.m_vs[c].SetZero();
      const u = t.masses[c];
      u > 0 ? this.m_invMasses[c] = 1 / u : this.m_invMasses[c] = 0;
    }
    this.m_stretchCount = this.m_count - 1, this.m_bendCount = this.m_count - 2, this.m_stretchConstraints = new Array(this.m_stretchCount);
    for (let c = 0; c < this.m_stretchCount; c++)
      this.m_stretchConstraints[c] = new fg();
    this.m_bendConstraints = new Array(this.m_bendCount);
    for (let c = 0; c < this.m_bendCount; c++)
      this.m_bendConstraints[c] = new pg();
    for (let c = 0; c < this.m_stretchCount; ++c) {
      const u = this.m_stretchConstraints[c], m = this.m_ps[c], d = this.m_ps[c + 1];
      u.i1 = c, u.i2 = c + 1, u.L = yt.b2Vec2.Distance(m, d), u.invMass1 = this.m_invMasses[c], u.invMass2 = this.m_invMasses[c + 1], u.lambda = 0, u.damper = 0, u.spring = 0;
    }
    const { J1: e, J2: s, r: i, e1: o, e2: r, Jd1: a, Jd2: l } = yo;
    for (let c = 0; c < this.m_bendCount; ++c) {
      const u = this.m_bendConstraints[c], m = this.m_ps[c], d = this.m_ps[c + 1], f = this.m_ps[c + 2];
      u.i1 = c, u.i2 = c + 1, u.i3 = c + 2, u.invMass1 = this.m_invMasses[c], u.invMass2 = this.m_invMasses[c + 1], u.invMass3 = this.m_invMasses[c + 2], u.invEffectiveMass = 0, u.L1 = yt.b2Vec2.Distance(m, d), u.L2 = yt.b2Vec2.Distance(d, f), u.lambda = 0, yt.b2Vec2.Subtract(d, m, o), yt.b2Vec2.Subtract(f, d, r);
      const p = o.LengthSquared(), v = r.LengthSquared();
      if (p * v === 0)
        continue;
      yt.b2Vec2.Skew(o, a).Scale(-1 / p), yt.b2Vec2.Skew(r, l).Scale(1 / v), yt.b2Vec2.Negate(a, e), yt.b2Vec2.Subtract(a, l, s);
      const _ = l;
      u.invEffectiveMass = u.invMass1 * yt.b2Vec2.Dot(e, e) + u.invMass2 * yt.b2Vec2.Dot(s, s) + u.invMass3 * yt.b2Vec2.Dot(_, _), yt.b2Vec2.Subtract(f, m, i);
      const g = i.LengthSquared();
      g !== 0 && (u.alpha1 = yt.b2Vec2.Dot(r, i) / g, u.alpha2 = yt.b2Vec2.Dot(o, i) / g);
    }
    this.m_gravity.Copy(t.gravity), this.SetTuning(t.tuning);
  }
  SetTuning(t) {
    this.m_tuning.Copy(t);
    const e = 2 * Math.PI * this.m_tuning.bendHertz;
    for (let i = 0; i < this.m_bendCount; ++i) {
      const o = this.m_bendConstraints[i], r = o.L1 * o.L1, a = o.L2 * o.L2;
      if (r * a === 0) {
        o.spring = 0, o.damper = 0;
        continue;
      }
      const l = 1 / o.L1 + 1 / o.L2, c = o.invMass1 / r + o.invMass2 * l * l + o.invMass3 / a;
      if (c === 0) {
        o.spring = 0, o.damper = 0;
        continue;
      }
      const u = 1 / c;
      o.spring = u * e * e, o.damper = 2 * u * this.m_tuning.bendDamping * e;
    }
    const s = 2 * Math.PI * this.m_tuning.stretchHertz;
    for (let i = 0; i < this.m_stretchCount; ++i) {
      const o = this.m_stretchConstraints[i], r = o.invMass1 + o.invMass2;
      if (r === 0)
        continue;
      const a = 1 / r;
      o.spring = a * s * s, o.damper = 2 * a * this.m_tuning.stretchDamping * s;
    }
  }
  Step(t, e, s) {
    if (t === 0)
      return;
    const i = 1 / t, o = Math.exp(-t * this.m_tuning.damping);
    for (let r = 0; r < this.m_count; ++r)
      this.m_invMasses[r] > 0 ? (this.m_vs[r].Scale(o), this.m_vs[r].AddScaled(t, this.m_gravity)) : (this.m_vs[r].x = i * (this.m_bindPositions[r].x + s.x - this.m_p0s[r].x), this.m_vs[r].y = i * (this.m_bindPositions[r].y + s.y - this.m_p0s[r].y));
    this.m_tuning.bendingModel === Eo.b2_springAngleBendingModel && this.ApplyBendForces(t);
    for (let r = 0; r < this.m_bendCount; ++r)
      this.m_bendConstraints[r].lambda = 0;
    for (let r = 0; r < this.m_stretchCount; ++r)
      this.m_stretchConstraints[r].lambda = 0;
    for (let r = 0; r < this.m_count; ++r)
      this.m_ps[r].AddScaled(t, this.m_vs[r]);
    for (let r = 0; r < e; ++r)
      this.m_tuning.bendingModel === Eo.b2_pbdAngleBendingModel ? this.SolveBend_PBD_Angle() : this.m_tuning.bendingModel === Eo.b2_xpbdAngleBendingModel ? this.SolveBend_XPBD_Angle(t) : this.m_tuning.bendingModel === Eo.b2_pbdDistanceBendingModel ? this.SolveBend_PBD_Distance() : this.m_tuning.bendingModel === Eo.b2_pbdHeightBendingModel ? this.SolveBend_PBD_Height() : this.m_tuning.bendingModel === Eo.b2_pbdTriangleBendingModel && this.SolveBend_PBD_Triangle(), this.m_tuning.stretchingModel === xu.b2_pbdStretchingModel ? this.SolveStretch_PBD() : this.m_tuning.stretchingModel === xu.b2_xpbdStretchingModel && this.SolveStretch_XPBD(t);
    for (let r = 0; r < this.m_count; ++r)
      this.m_vs[r].x = i * (this.m_ps[r].x - this.m_p0s[r].x), this.m_vs[r].y = i * (this.m_ps[r].y - this.m_p0s[r].y), this.m_p0s[r].Copy(this.m_ps[r]);
  }
  Reset(t) {
    this.m_position.Copy(t);
    for (let e = 0; e < this.m_count; ++e)
      yt.b2Vec2.Add(this.m_bindPositions[e], this.m_position, this.m_ps[e]), this.m_p0s[e].Copy(this.m_ps[e]), this.m_vs[e].SetZero();
    for (let e = 0; e < this.m_bendCount; ++e)
      this.m_bendConstraints[e].lambda = 0;
    for (let e = 0; e < this.m_stretchCount; ++e)
      this.m_stretchConstraints[e].lambda = 0;
  }
  SolveStretch_PBD() {
    const t = this.m_tuning.stretchStiffness, { d: e } = yo;
    for (let s = 0; s < this.m_stretchCount; ++s) {
      const i = this.m_stretchConstraints[s], o = this.m_ps[i.i1], r = this.m_ps[i.i2];
      yt.b2Vec2.Subtract(r, o, e);
      const a = e.Normalize(), l = i.invMass1 + i.invMass2;
      if (l === 0)
        continue;
      const c = i.invMass1 / l, u = i.invMass2 / l;
      o.SubtractScaled(t * c * (i.L - a), e), r.AddScaled(t * u * (i.L - a), e);
    }
  }
  SolveStretch_XPBD(t) {
    const { dp1: e, dp2: s, u: i, J1: o } = yo;
    for (let r = 0; r < this.m_stretchCount; ++r) {
      const a = this.m_stretchConstraints[r], l = this.m_ps[a.i1], c = this.m_ps[a.i2];
      yt.b2Vec2.Subtract(l, this.m_p0s[a.i1], e), yt.b2Vec2.Subtract(c, this.m_p0s[a.i2], s), yt.b2Vec2.Subtract(c, l, i);
      const u = i.Normalize();
      yt.b2Vec2.Negate(i, o);
      const m = i, d = a.invMass1 + a.invMass2;
      if (d === 0)
        continue;
      const f = 1 / (a.spring * t * t), p = t * t * a.damper, v = f * p / t, _ = u - a.L, g = yt.b2Vec2.Dot(o, e) + yt.b2Vec2.Dot(m, s), w = _ + f * a.lambda + v * g, S = (1 + v) * d + f, x = -w / S;
      l.AddScaled(a.invMass1 * x, o), c.AddScaled(a.invMass2 * x, m), a.lambda += x;
    }
  }
  SolveBend_PBD_Angle() {
    const t = this.m_tuning.bendStiffness, { Jd1: e, Jd2: s, J1: i, J2: o, d1: r, d2: a } = yo;
    for (let l = 0; l < this.m_bendCount; ++l) {
      const c = this.m_bendConstraints[l], u = this.m_ps[c.i1], m = this.m_ps[c.i2], d = this.m_ps[c.i3];
      yt.b2Vec2.Subtract(m, u, r), yt.b2Vec2.Subtract(d, m, a);
      const f = yt.b2Vec2.Cross(r, a), p = yt.b2Vec2.Dot(r, a), v = Math.atan2(f, p);
      let _, g;
      if (this.m_tuning.isometric ? (_ = c.L1 * c.L1, g = c.L2 * c.L2) : (_ = r.LengthSquared(), g = a.LengthSquared()), _ * g === 0)
        continue;
      yt.b2Vec2.Skew(r, e).Scale(-1 / _), yt.b2Vec2.Skew(a, s).Scale(1 / g), yt.b2Vec2.Negate(e, i), yt.b2Vec2.Subtract(e, s, o);
      const w = s;
      let S;
      this.m_tuning.fixedEffectiveMass ? S = c.invEffectiveMass : S = c.invMass1 * yt.b2Vec2.Dot(i, i) + c.invMass2 * yt.b2Vec2.Dot(o, o) + c.invMass3 * yt.b2Vec2.Dot(w, w), S === 0 && (S = c.invEffectiveMass);
      const x = -t * v / S;
      u.AddScaled(c.invMass1 * x, i), m.AddScaled(c.invMass2 * x, o), d.AddScaled(c.invMass3 * x, w);
    }
  }
  SolveBend_XPBD_Angle(t) {
    const { dp1: e, dp2: s, dp3: i, d1: o, d2: r, Jd1: a, Jd2: l, J1: c, J2: u } = yo;
    for (let m = 0; m < this.m_bendCount; ++m) {
      const d = this.m_bendConstraints[m], f = this.m_ps[d.i1], p = this.m_ps[d.i2], v = this.m_ps[d.i3];
      yt.b2Vec2.Subtract(f, this.m_p0s[d.i1], e), yt.b2Vec2.Subtract(p, this.m_p0s[d.i2], s), yt.b2Vec2.Subtract(v, this.m_p0s[d.i3], i), yt.b2Vec2.Subtract(p, f, o), yt.b2Vec2.Subtract(v, p, r);
      let _, g;
      if (this.m_tuning.isometric ? (_ = d.L1 * d.L1, g = d.L2 * d.L2) : (_ = o.LengthSquared(), g = r.LengthSquared()), _ * g === 0)
        continue;
      const w = yt.b2Vec2.Cross(o, r), S = yt.b2Vec2.Dot(o, r), x = Math.atan2(w, S);
      yt.b2Vec2.Skew(o, a).Scale(-1 / _), yt.b2Vec2.Skew(r, l).Scale(1 / g), yt.b2Vec2.Negate(a, c), yt.b2Vec2.Subtract(a, l, u);
      const A = l;
      let C;
      if (this.m_tuning.fixedEffectiveMass ? C = d.invEffectiveMass : C = d.invMass1 * yt.b2Vec2.Dot(c, c) + d.invMass2 * yt.b2Vec2.Dot(u, u) + d.invMass3 * yt.b2Vec2.Dot(A, A), C === 0)
        continue;
      const M = 1 / (d.spring * t * t), T = t * t * d.damper, b = M * T / t, y = x, E = yt.b2Vec2.Dot(c, e) + yt.b2Vec2.Dot(u, s) + yt.b2Vec2.Dot(A, i), I = y + M * d.lambda + b * E, B = (1 + b) * C + M, D = -I / B;
      f.AddScaled(d.invMass1 * D, c), p.AddScaled(d.invMass2 * D, u), v.AddScaled(d.invMass3 * D, A), d.lambda += D;
    }
  }
  SolveBend_PBD_Distance() {
    const t = this.m_tuning.bendStiffness, { d: e } = yo;
    for (let s = 0; s < this.m_bendCount; ++s) {
      const i = this.m_bendConstraints[s], { i1: o } = i, r = i.i3, a = this.m_ps[o], l = this.m_ps[r];
      yt.b2Vec2.Subtract(l, a, e);
      const c = e.Normalize(), u = i.invMass1 + i.invMass3;
      if (u === 0)
        continue;
      const m = i.invMass1 / u, d = i.invMass3 / u;
      a.SubtractScaled(t * m * (i.L1 + i.L2 - c), e), l.AddScaled(t * d * (i.L1 + i.L2 - c), e);
    }
  }
  SolveBend_PBD_Height() {
    const t = this.m_tuning.bendStiffness, { dHat: e, J1: s, J2: i, J3: o, d: r } = yo;
    for (let a = 0; a < this.m_bendCount; ++a) {
      const l = this.m_bendConstraints[a], c = this.m_ps[l.i1], u = this.m_ps[l.i2], m = this.m_ps[l.i3];
      r.x = l.alpha1 * c.x + l.alpha2 * m.x - u.x, r.y = l.alpha1 * c.y + l.alpha2 * m.y - u.y;
      const d = r.Length();
      if (d === 0)
        continue;
      yt.b2Vec2.Scale(1 / d, r, e), yt.b2Vec2.Scale(l.alpha1, e, s), yt.b2Vec2.Negate(e, i), yt.b2Vec2.Scale(l.alpha2, e, o);
      const f = l.invMass1 * l.alpha1 * l.alpha1 + l.invMass2 + l.invMass3 * l.alpha2 * l.alpha2;
      if (f === 0)
        continue;
      const p = d, v = 1 / f, _ = -t * v * p;
      c.AddScaled(l.invMass1 * _, s), u.AddScaled(l.invMass2 * _, i), m.AddScaled(l.invMass3 * _, o);
    }
  }
  SolveBend_PBD_Triangle() {
    const t = this.m_tuning.bendStiffness, { d: e } = yo;
    for (let s = 0; s < this.m_bendCount; ++s) {
      const i = this.m_bendConstraints[s], o = this.m_ps[i.i1], r = this.m_ps[i.i2], a = this.m_ps[i.i3], l = i.invMass1, c = i.invMass2, u = i.invMass3, m = l + u + 2 * c, d = t / m;
      e.x = r.x - 1 / 3 * (o.x + r.x + a.x), e.y = r.y - 1 / 3 * (o.y + r.y + a.y), o.AddScaled(2 * l * d, e), r.AddScaled(-4 * c * d, e), a.AddScaled(2 * u * d, e);
    }
  }
  ApplyBendForces(t) {
    const e = 2 * Math.PI * this.m_tuning.bendHertz, { d1: s, d2: i, Jd1: o, Jd2: r, J1: a, J2: l } = yo;
    for (let c = 0; c < this.m_bendCount; ++c) {
      const u = this.m_bendConstraints[c], m = this.m_ps[u.i1], d = this.m_ps[u.i2], f = this.m_ps[u.i3], p = this.m_vs[u.i1], v = this.m_vs[u.i2], _ = this.m_vs[u.i3];
      yt.b2Vec2.Subtract(d, m, s), yt.b2Vec2.Subtract(f, d, i);
      let g, w;
      if (this.m_tuning.isometric ? (g = u.L1 * u.L1, w = u.L2 * u.L2) : (g = s.LengthSquared(), w = i.LengthSquared()), g * w === 0)
        continue;
      const S = yt.b2Vec2.Cross(s, i), x = yt.b2Vec2.Dot(s, i), A = Math.atan2(S, x);
      yt.b2Vec2.Skew(s, o).Scale(-1 / g), yt.b2Vec2.Skew(i, r).Scale(1 / w), yt.b2Vec2.Negate(o, a), yt.b2Vec2.Subtract(o, r, l);
      const C = r;
      let M;
      if (this.m_tuning.fixedEffectiveMass ? M = u.invEffectiveMass : M = u.invMass1 * yt.b2Vec2.Dot(a, a) + u.invMass2 * yt.b2Vec2.Dot(l, l) + u.invMass3 * yt.b2Vec2.Dot(C, C), M === 0)
        continue;
      const T = 1 / M, b = T * e * e, y = 2 * T * this.m_tuning.bendDamping * e, E = A, I = yt.b2Vec2.Dot(a, p) + yt.b2Vec2.Dot(l, v) + yt.b2Vec2.Dot(C, _), B = -t * (b * E + y * I);
      this.m_vs[u.i1].AddScaled(u.invMass1 * B, a), this.m_vs[u.i2].AddScaled(u.invMass2 * B, l), this.m_vs[u.i3].AddScaled(u.invMass3 * B, C);
    }
  }
  Draw(t) {
    for (let s = 0; s < this.m_count - 1; ++s) {
      t.DrawSegment(this.m_ps[s], this.m_ps[s + 1], _l.debugColors.rope);
      const i = this.m_invMasses[s] > 0 ? _l.debugColors.ropePointD : _l.debugColors.ropePointG;
      t.DrawPoint(this.m_ps[s], 5, i);
    }
    const e = this.m_invMasses[this.m_count - 1] > 0 ? _l.debugColors.ropePointD : _l.debugColors.ropePointG;
    t.DrawPoint(this.m_ps[this.m_count - 1], 5, e);
  }
};
h(F1, "b2Rope");
let _g = F1;
Gs.b2Rope = _g;
(function(n) {
  var t = Ch && Ch.__createBinding || (Object.create ? function(r, a, l, c) {
    c === void 0 && (c = l);
    var u = Object.getOwnPropertyDescriptor(a, l);
    (!u || ("get" in u ? !a.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: /* @__PURE__ */ h(function() {
      return a[l];
    }, "get") }), Object.defineProperty(r, c, u);
  } : function(r, a, l, c) {
    c === void 0 && (c = l), r[c] = a[l];
  }), e = Ch && Ch.__exportStar || function(r, a) {
    for (var l in r) l !== "default" && !Object.prototype.hasOwnProperty.call(a, l) && t(a, r, l);
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), n.b2GetBlockSolve = n.b2SetBlockSolve = n.b2World = n.b2BodyType = n.b2Body = void 0, e(Xe, n), e(ps, n), e(Fe, n), e(Ai, n), e(Ti, n), e(ka, n), e(Fm, n), e(aI, n), e(ge, n), e(zu, n), e(ku, n), e(xa, n), e(Gm, n), e(Sr, n), e(Uu, n), e(eo, n), e(wi, n), e(Hm, n), e(jm, n), e(Ua, n), e(Wm, n), e(Om, n);
  var s = to;
  Object.defineProperty(n, "b2Body", { enumerable: !0, get: /* @__PURE__ */ h(function() {
    return s.b2Body;
  }, "get") }), Object.defineProperty(n, "b2BodyType", { enumerable: !0, get: /* @__PURE__ */ h(function() {
    return s.b2BodyType;
  }, "get") });
  var i = qm;
  Object.defineProperty(n, "b2World", { enumerable: !0, get: /* @__PURE__ */ h(function() {
    return i.b2World;
  }, "get") }), e(us, n), e(xi, n), e(Ou, n), e(Yn, n), e($u, n);
  var o = qi;
  Object.defineProperty(n, "b2SetBlockSolve", { enumerable: !0, get: /* @__PURE__ */ h(function() {
    return o.b2SetBlockSolve;
  }, "get") }), Object.defineProperty(n, "b2GetBlockSolve", { enumerable: !0, get: /* @__PURE__ */ h(function() {
    return o.b2GetBlockSolve;
  }, "get") }), e(xn, n), e(wa, n), e(Mr, n), e(Sa, n), e(Aa, n), e(Ma, n), e(Ca, n), e(Ea, n), e(ko, n), e(Ta, n), e(Ia, n), e(Ba, n), e(Gs, n);
})($i);
za($i);
const ui = 2, G1 = class G1 extends e0 {
  constructor() {
    super(...arguments), this.world = null, this.bodies = /* @__PURE__ */ new Map(), this.bodyData = /* @__PURE__ */ new Map(), this.bodyToEid = /* @__PURE__ */ new Map();
  }
  initialize(t) {
    const e = t / ui, s = new $i.b2Vec2(0, -e);
    this.world = $i.b2World.Create(s);
    const i = new $i.b2ContactListener();
    i.BeginContact = (o) => {
      const r = o.GetFixtureA(), a = o.GetFixtureB(), l = r.GetBody(), c = a.GetBody(), u = this.bodyToEid.get(l), m = this.bodyToEid.get(c);
      if (u !== void 0 && m !== void 0) {
        const d = r.IsSensor(), f = a.IsSensor();
        Hi.emit("physics:collision:begin", {
          eidA: u,
          eidB: m,
          isSensorA: d,
          isSensorB: f
        }), d && Hi.emit("physics:sensor:enter", { sensorEid: u, otherEid: m }), f && Hi.emit("physics:sensor:enter", { sensorEid: m, otherEid: u });
      }
    }, i.EndContact = (o) => {
      const r = o.GetFixtureA(), a = o.GetFixtureB(), l = r.GetBody(), c = a.GetBody(), u = this.bodyToEid.get(l), m = this.bodyToEid.get(c);
      if (u !== void 0 && m !== void 0) {
        const d = r.IsSensor(), f = a.IsSensor();
        Hi.emit("physics:collision:end", {
          eidA: u,
          eidB: m,
          isSensorA: d,
          isSensorB: f
        }), d && Hi.emit("physics:sensor:exit", { sensorEid: u, otherEid: m }), f && Hi.emit("physics:sensor:exit", { sensorEid: m, otherEid: u });
      }
    }, this.world.SetContactListener(i), console.log(`🎮 Box2D initialized with gravity: ${t} units/s² (${e.toFixed(2)} m/s²)`);
  }
  createBody(t) {
    var l, c, u, m, d, f, p, v, _, g, w, S;
    if (!this.world) throw new Error("Physics engine not initialized");
    const e = this.nextBodyId++, s = {
      type: t.isStatic ? $i.b2BodyType.b2_staticBody : $i.b2BodyType.b2_dynamicBody,
      position: new $i.b2Vec2(t.x / ui, t.y / ui),
      angle: (l = t.rotation) != null ? l : 0,
      bullet: (c = t.bullet) != null ? c : !t.isStatic,
      fixedRotation: (u = t.fixedRotation) != null ? u : !1
    }, i = this.world.CreateBody(s);
    let o;
    if (t.shape === "circle") {
      const x = (m = t.radius) != null ? m : 0.5;
      o = new $i.b2CircleShape(), o.m_radius = x / ui;
    } else {
      const x = (d = t.width) != null ? d : 1, A = (f = t.height) != null ? f : 1;
      o = new $i.b2PolygonShape(), o.SetAsBox(
        x / ui / 2,
        A / ui / 2
      );
    }
    const r = {
      shape: o,
      density: (p = t.density) != null ? p : 1,
      friction: (v = t.friction) != null ? v : 0.3,
      restitution: (_ = t.restitution) != null ? _ : 0,
      isSensor: (g = t.isSensor) != null ? g : !1
    };
    i.CreateFixture(r), this.bodies.set(e, i);
    const a = {
      id: e,
      position: { x: t.x, y: t.y },
      rotation: (w = t.rotation) != null ? w : 0,
      velocity: { x: 0, y: 0 },
      angularVelocity: 0,
      isStatic: (S = t.isStatic) != null ? S : !1
    };
    return this.bodyData.set(e, a), a;
  }
  setEntityMapping(t, e) {
    const s = this.bodies.get(t);
    s && this.bodyToEid.set(s, e);
  }
  destroyBody(t) {
    if (!this.world) return;
    const e = this.bodies.get(t.id);
    e && (this.world.DestroyBody(e), this.bodies.delete(t.id), this.bodyData.delete(t.id));
  }
  getBody(t) {
    return this.bodyData.get(t);
  }
  applyForce(t, e, s) {
    const i = this.bodies.get(t.id);
    if (!i) return;
    const o = new $i.b2Vec2(
      e / ui,
      s / ui
    );
    i.ApplyForceToCenter(o, !0);
  }
  applyImpulse(t, e, s) {
    const i = this.bodies.get(t.id);
    if (!i) return;
    const o = new $i.b2Vec2(
      e / ui,
      s / ui
    );
    i.ApplyLinearImpulseToCenter(o, !0);
  }
  setVelocity(t, e, s) {
    const i = this.bodies.get(t.id);
    i && i.SetLinearVelocity(new $i.b2Vec2(
      e / ui,
      s / ui
    ));
  }
  setAngularVelocity(t, e) {
    const s = this.bodies.get(t.id);
    s && s.SetAngularVelocity(e);
  }
  step(t) {
    if (!this.world) return;
    const e = 1 / 60;
    this.world.Step(e, {
      velocityIterations: 10,
      positionIterations: 8
    });
    for (const [s, i] of this.bodies) {
      const o = this.bodyData.get(s);
      if (!o) continue;
      const r = i.GetPosition(), a = i.GetLinearVelocity();
      o.position.x = r.x * ui, o.position.y = r.y * ui, o.rotation = i.GetAngle(), o.velocity.x = a.x * ui, o.velocity.y = a.y * ui, o.angularVelocity = i.GetAngularVelocity();
    }
  }
  getAllBodies() {
    return Array.from(this.bodyData.values());
  }
};
h(G1, "Box2DPhysicsEngine");
let gg = G1;
const n7 = new hn().with(ue).with(Vo);
function i7(n, t) {
  t.step(n.time.delta);
  const e = n7._compile().base(n);
  for (const s of e) {
    const i = Vo.bodyId[s];
    if (Vo.isStatic[s]) continue;
    const r = t.getBody(i);
    if (!r) continue;
    ue.assign(s, {
      x: r.position.x,
      y: r.position.y,
      rotation: r.rotation
    }), Zi(n, Pt.component, s) || wn(n, Pt.component, s);
    const a = ue.read(s);
    Pt.component.x[s] = r.position.x, Pt.component.y[s] = r.position.y, Pt.component.rotation[s] = r.rotation, Pt.component.sx[s] = a.sx, Pt.component.sy[s] = a.sy;
  }
}
h(i7, "physicsSystem");
const s7 = new hn().with(ne).with(os);
function o7(n, t) {
  t.step(n.time.delta);
  const e = s7._compile().base(n);
  for (const s of e) {
    const i = os.bodyId[s];
    if (os.bodyType[s] === 1) continue;
    const r = t.getBody(i);
    if (!r) continue;
    ne.component.x[s] = r.position.x, ne.component.y[s] = r.position.y, ne.component.z[s] = r.position.z;
    const a = r.quaternion, l = 2 * (a.w * a.x + a.y * a.z), c = 1 - 2 * (a.x * a.x + a.y * a.y);
    ne.component.rotationX[s] = Math.atan2(l, c);
    const u = 2 * (a.w * a.y - a.z * a.x);
    ne.component.rotationY[s] = Math.asin(Math.max(-1, Math.min(1, u)));
    const m = 2 * (a.w * a.z + a.x * a.y), d = 1 - 2 * (a.y * a.y + a.z * a.z);
    ne.component.rotationZ[s] = Math.atan2(m, d), ne.component.quatX[s] = a.x, ne.component.quatY[s] = a.y, ne.component.quatZ[s] = a.z, ne.component.quatW[s] = a.w;
  }
}
h(o7, "physicsSystem3D");
const r7 = new hn().with(ne).with(Ue);
function a7(n, t) {
  const e = r7._compile().base(n);
  for (const s of e) {
    const i = Ue.bodyId[s], o = t.getBody(i);
    if (!o) continue;
    c7(s, t), Ue.jumpRequested[s] && (l7(s, t), Ue.jumpRequested[s] = 0), ne.component.x[s] = o.position.x, ne.component.y[s] = o.position.y, ne.component.z[s] = o.position.z;
    const r = o.quaternion;
    ne.component.quatX[s] = r.x, ne.component.quatY[s] = r.y, ne.component.quatZ[s] = r.z, ne.component.quatW[s] = r.w;
  }
}
h(a7, "characterControllerSystem3D");
function c7(n, t) {
  const e = Ue.bodyId[n], s = t.getBody(e);
  if (!s) return;
  const i = Ue.groundDistance[n];
  Ue.radius[n];
  const o = Ue.height[n], r = {
    x: s.position.x,
    y: s.position.y - o / 2,
    z: s.position.z
  }, a = {
    x: r.x,
    y: r.y - i,
    z: r.z
  }, l = t.raycast(r, a);
  Ue.wasGrounded[n] = Ue.isGrounded[n], Ue.isGrounded[n] = l !== null ? 1 : 0;
}
h(c7, "updateGroundDetection");
function l7(n, t) {
  const e = Ue.isGrounded[n], s = Ue.bodyId[n], i = Ue.jumpForce[n];
  if (console.log("🦘 Jump requested!", { eid: n, isGrounded: !!e, jumpForce: i }), !e) {
    console.log("❌ Jump failed: not grounded");
    return;
  }
  const o = t.getVelocity(s);
  console.log("⬆️ Velocity BEFORE jump:", o), t.applyImpulse(s, {
    x: 0,
    y: i,
    z: 0
  });
  const r = t.getVelocity(s);
  console.log("⬆️ Velocity AFTER jump:", r), console.log("✅ Jump executed with force:", i);
}
h(l7, "executeJump");
const H1 = class H1 {
  constructor(t, e) {
    this.name = t, this.type = e, this._isPaused = !1, this._isMounted = !1, this.root = document.createElement("section"), this.root.classList.add("scene"), this.root.dataset.type = e;
  }
  setBackgroundColor(t) {
    this.root.style.backgroundColor = t, this.root.dataset.isOpaque = String(IV(t));
  }
  get isMounted() {
    return this._isMounted;
  }
  pause() {
    this._isPaused = !0;
  }
  resume() {
    this._isPaused = !1;
  }
  get isPaused() {
    return this._isPaused;
  }
};
h(H1, "Scene");
let wu = H1;
const Ul = globalThis, $d = Ul.trustedTypes, aA = $d ? $d.createPolicy("lit-html", { createHTML: /* @__PURE__ */ h((n) => n, "createHTML") }) : void 0, hI = "$lit$", lr = `lit$${Math.random().toFixed(9).slice(2)}$`, dI = "?" + lr, u7 = `<${dI}>`, Pa = document, Su = /* @__PURE__ */ h(() => Pa.createComment(""), "l"), Au = /* @__PURE__ */ h((n) => n === null || typeof n != "object" && typeof n != "function", "c$2"), X2 = Array.isArray, h7 = /* @__PURE__ */ h((n) => X2(n) || typeof (n == null ? void 0 : n[Symbol.iterator]) == "function", "u$2"), ap = `[ 	
\f\r]`, gl = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, cA = /-->/g, lA = />/g, Fr = RegExp(`>|${ap}(?:([^\\s"'>=/]+)(${ap}*=${ap}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), uA = /'/g, hA = /"/g, mI = /^(?:script|style|textarea|title)$/i, d7 = /* @__PURE__ */ h((n) => (t, ...e) => ({ _$litType$: n, strings: t, values: e }), "y"), jn = d7(1), Ra = Symbol.for("lit-noChange"), zn = Symbol.for("lit-nothing"), dA = /* @__PURE__ */ new WeakMap(), aa = Pa.createTreeWalker(Pa, 129);
function fI(n, t) {
  if (!X2(n) || !n.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return aA !== void 0 ? aA.createHTML(t) : t;
}
h(fI, "P");
const m7 = /* @__PURE__ */ h((n, t) => {
  const e = n.length - 1, s = [];
  let i, o = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", r = gl;
  for (let a = 0; a < e; a++) {
    const l = n[a];
    let c, u, m = -1, d = 0;
    for (; d < l.length && (r.lastIndex = d, u = r.exec(l), u !== null); ) d = r.lastIndex, r === gl ? u[1] === "!--" ? r = cA : u[1] !== void 0 ? r = lA : u[2] !== void 0 ? (mI.test(u[2]) && (i = RegExp("</" + u[2], "g")), r = Fr) : u[3] !== void 0 && (r = Fr) : r === Fr ? u[0] === ">" ? (r = i != null ? i : gl, m = -1) : u[1] === void 0 ? m = -2 : (m = r.lastIndex - u[2].length, c = u[1], r = u[3] === void 0 ? Fr : u[3] === '"' ? hA : uA) : r === hA || r === uA ? r = Fr : r === cA || r === lA ? r = gl : (r = Fr, i = void 0);
    const f = r === Fr && n[a + 1].startsWith("/>") ? " " : "";
    o += r === gl ? l + u7 : m >= 0 ? (s.push(c), l.slice(0, m) + hI + l.slice(m) + lr + f) : l + lr + (m === -2 ? a : f);
  }
  return [fI(n, o + (n[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), s];
}, "V"), gm = class gm {
  constructor({ strings: t, _$litType$: e }, s) {
    let i;
    this.parts = [];
    let o = 0, r = 0;
    const a = t.length - 1, l = this.parts, [c, u] = m7(t, e);
    if (this.el = gm.createElement(c, s), aa.currentNode = this.el.content, e === 2 || e === 3) {
      const m = this.el.content.firstChild;
      m.replaceWith(...m.childNodes);
    }
    for (; (i = aa.nextNode()) !== null && l.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes()) for (const m of i.getAttributeNames()) if (m.endsWith(hI)) {
          const d = u[r++], f = i.getAttribute(m).split(lr), p = /([.?@])?(.*)/.exec(d);
          l.push({ type: 1, index: o, name: p[2], strings: f, ctor: p[1] === "." ? vg : p[1] === "?" ? bg : p[1] === "@" ? yg : Zc }), i.removeAttribute(m);
        } else m.startsWith(lr) && (l.push({ type: 6, index: o }), i.removeAttribute(m));
        if (mI.test(i.tagName)) {
          const m = i.textContent.split(lr), d = m.length - 1;
          if (d > 0) {
            i.textContent = $d ? $d.emptyScript : "";
            for (let f = 0; f < d; f++) i.append(m[f], Su()), aa.nextNode(), l.push({ type: 2, index: ++o });
            i.append(m[d], Su());
          }
        }
      } else if (i.nodeType === 8) if (i.data === dI) l.push({ type: 2, index: o });
      else {
        let m = -1;
        for (; (m = i.data.indexOf(lr, m + 1)) !== -1; ) l.push({ type: 7, index: o }), m += lr.length - 1;
      }
      o++;
    }
  }
  static createElement(t, e) {
    const s = Pa.createElement("template");
    return s.innerHTML = t, s;
  }
};
h(gm, "N");
let Mu = gm;
function qc(n, t, e = n, s) {
  var r, a, l;
  if (t === Ra) return t;
  let i = s !== void 0 ? (r = e._$Co) == null ? void 0 : r[s] : e._$Cl;
  const o = Au(t) ? void 0 : t._$litDirective$;
  return (i == null ? void 0 : i.constructor) !== o && ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1), o === void 0 ? i = void 0 : (i = new o(n), i._$AT(n, e, s)), s !== void 0 ? ((l = e._$Co) != null ? l : e._$Co = [])[s] = i : e._$Cl = i), i !== void 0 && (t = qc(n, i._$AS(n, t.values), i, s)), t;
}
h(qc, "S");
var Bc;
let f7 = (Bc = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    var c;
    const { el: { content: e }, parts: s } = this._$AD, i = ((c = t == null ? void 0 : t.creationScope) != null ? c : Pa).importNode(e, !0);
    aa.currentNode = i;
    let o = aa.nextNode(), r = 0, a = 0, l = s[0];
    for (; l !== void 0; ) {
      if (r === l.index) {
        let u;
        l.type === 2 ? u = new Xc(o, o.nextSibling, this, t) : l.type === 1 ? u = new l.ctor(o, l.name, l.strings, this, t) : l.type === 6 && (u = new xg(o, this, t)), this._$AV.push(u), l = s[++a];
      }
      r !== (l == null ? void 0 : l.index) && (o = aa.nextNode(), r++);
    }
    return aa.currentNode = Pa, i;
  }
  p(t) {
    let e = 0;
    for (const s of this._$AV) s !== void 0 && (s.strings !== void 0 ? (s._$AI(t, s, e), e += s.strings.length - 2) : s._$AI(t[e])), e++;
  }
}, h(Bc, "M"), Bc);
const vm = class vm {
  get _$AU() {
    var t, e;
    return (e = (t = this._$AM) == null ? void 0 : t._$AU) != null ? e : this._$Cv;
  }
  constructor(t, e, s, i) {
    var o;
    this.type = 2, this._$AH = zn, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = s, this.options = i, this._$Cv = (o = i == null ? void 0 : i.isConnected) != null ? o : !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = qc(this, t, e), Au(t) ? t === zn || t == null || t === "" ? (this._$AH !== zn && this._$AR(), this._$AH = zn) : t !== this._$AH && t !== Ra && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : h7(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== zn && Au(this._$AH) ? this._$AA.nextSibling.data = t : this.T(Pa.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var o;
    const { values: e, _$litType$: s } = t, i = typeof s == "number" ? this._$AC(t) : (s.el === void 0 && (s.el = Mu.createElement(fI(s.h, s.h[0]), this.options)), s);
    if (((o = this._$AH) == null ? void 0 : o._$AD) === i) this._$AH.p(e);
    else {
      const r = new f7(i, this), a = r.u(this.options);
      r.p(e), this.T(a), this._$AH = r;
    }
  }
  _$AC(t) {
    let e = dA.get(t.strings);
    return e === void 0 && dA.set(t.strings, e = new Mu(t)), e;
  }
  k(t) {
    X2(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let s, i = 0;
    for (const o of t) i === e.length ? e.push(s = new vm(this.O(Su()), this.O(Su()), this, this.options)) : s = e[i], s._$AI(o), i++;
    i < e.length && (this._$AR(s && s._$AB.nextSibling, i), e.length = i);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var s;
    for ((s = this._$AP) == null ? void 0 : s.call(this, !1, !0, e); t !== this._$AB; ) {
      const i = t.nextSibling;
      t.remove(), t = i;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
};
h(vm, "R");
let Xc = vm;
const j1 = class j1 {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, s, i, o) {
    this.type = 1, this._$AH = zn, this._$AN = void 0, this.element = t, this.name = e, this._$AM = i, this.options = o, s.length > 2 || s[0] !== "" || s[1] !== "" ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = zn;
  }
  _$AI(t, e = this, s, i) {
    const o = this.strings;
    let r = !1;
    if (o === void 0) t = qc(this, t, e, 0), r = !Au(t) || t !== this._$AH && t !== Ra, r && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = o[0], l = 0; l < o.length - 1; l++) c = qc(this, a[s + l], e, l), c === Ra && (c = this._$AH[l]), r || (r = !Au(c) || c !== this._$AH[l]), c === zn ? t = zn : t !== zn && (t += (c != null ? c : "") + o[l + 1]), this._$AH[l] = c;
    }
    r && !i && this.j(t);
  }
  j(t) {
    t === zn ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t != null ? t : "");
  }
};
h(j1, "k");
let Zc = j1;
const W1 = class W1 extends Zc {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === zn ? void 0 : t;
  }
};
h(W1, "H");
let vg = W1;
const q1 = class q1 extends Zc {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== zn);
  }
};
h(q1, "I");
let bg = q1;
const X1 = class X1 extends Zc {
  constructor(t, e, s, i, o) {
    super(t, e, s, i, o), this.type = 5;
  }
  _$AI(t, e = this) {
    var r;
    if ((t = (r = qc(this, t, e, 0)) != null ? r : zn) === Ra) return;
    const s = this._$AH, i = t === zn && s !== zn || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, o = t !== zn && (s === zn || i);
    i && this.element.removeEventListener(this.name, this, s), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e, s;
    typeof this._$AH == "function" ? this._$AH.call((s = (e = this.options) == null ? void 0 : e.host) != null ? s : this.element, t) : this._$AH.handleEvent(t);
  }
};
h(X1, "L");
let yg = X1;
const Z1 = class Z1 {
  constructor(t, e, s) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = s;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    qc(this, t);
  }
};
h(Z1, "z");
let xg = Z1;
const p7 = { I: Xc }, cp = Ul.litHtmlPolyfillSupport;
var bA;
cp == null || cp(Mu, Xc), ((bA = Ul.litHtmlVersions) != null ? bA : Ul.litHtmlVersions = []).push("3.3.1");
const Mc = /* @__PURE__ */ h((n, t, e) => {
  const s = t;
  let i = s._$litPart$;
  return i === void 0 && (s._$litPart$ = i = new Xc(t.insertBefore(Su(), null), null, void 0, {})), i._$AI(n), i;
}, "B"), Z2 = { ATTRIBUTE: 1, CHILD: 2 }, Y2 = /* @__PURE__ */ h((n) => (...t) => ({ _$litDirective$: n, values: t }), "e$2"), Y1 = class Y1 {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, s) {
    this._$Ct = t, this._$AM = e, this._$Ci = s;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
h(Y1, "i");
let Cu = Y1;
const _7 = Y2(class extends Cu {
  constructor(n) {
    var t;
    if (super(n), n.type !== Z2.ATTRIBUTE || n.name !== "class" || ((t = n.strings) == null ? void 0 : t.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(n) {
    return " " + Object.keys(n).filter((t) => n[t]).join(" ") + " ";
  }
  update(n, [t]) {
    var s, i;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), n.strings !== void 0 && (this.nt = new Set(n.strings.join(" ").split(/\s/).filter((o) => o !== "")));
      for (const o in t) t[o] && !((s = this.nt) != null && s.has(o)) && this.st.add(o);
      return this.render(t);
    }
    const e = n.element.classList;
    for (const o of this.st) o in t || (e.remove(o), this.st.delete(o));
    for (const o in t) {
      const r = !!t[o];
      r === this.st.has(o) || (i = this.nt) != null && i.has(o) || (r ? (e.add(o), this.st.add(o)) : (e.remove(o), this.st.delete(o)));
    }
    return Ra;
  }
}), { I: g7 } = p7, v7 = /* @__PURE__ */ h((n) => n.strings === void 0, "f$1"), mA = /* @__PURE__ */ h(() => document.createComment(""), "r$1"), vl = /* @__PURE__ */ h((n, t, e) => {
  var o;
  const s = n._$AA.parentNode, i = t === void 0 ? n._$AB : t._$AA;
  if (e === void 0) {
    const r = s.insertBefore(mA(), i), a = s.insertBefore(mA(), i);
    e = new g7(r, a, n, n.options);
  } else {
    const r = e._$AB.nextSibling, a = e._$AM, l = a !== n;
    if (l) {
      let c;
      (o = e._$AQ) == null || o.call(e, n), e._$AM = n, e._$AP !== void 0 && (c = n._$AU) !== a._$AU && e._$AP(c);
    }
    if (r !== i || l) {
      let c = e._$AA;
      for (; c !== r; ) {
        const u = c.nextSibling;
        s.insertBefore(c, i), c = u;
      }
    }
  }
  return e;
}, "s$1"), Gr = /* @__PURE__ */ h((n, t, e = n) => (n._$AI(t, e), n), "v"), b7 = {}, y7 = /* @__PURE__ */ h((n, t = b7) => n._$AH = t, "m"), x7 = /* @__PURE__ */ h((n) => n._$AH, "p"), lp = /* @__PURE__ */ h((n) => {
  n._$AR(), n._$AA.remove();
}, "M"), Ol = /* @__PURE__ */ h((n, t) => {
  var s;
  const e = n._$AN;
  if (e === void 0) return !1;
  for (const i of e) (s = i._$AO) == null || s.call(i, t, !1), Ol(i, t);
  return !0;
}, "s"), Fd = /* @__PURE__ */ h((n) => {
  let t, e;
  do {
    if ((t = n._$AM) === void 0) break;
    e = t._$AN, e.delete(n), n = t;
  } while ((e == null ? void 0 : e.size) === 0);
}, "o$1"), pI = /* @__PURE__ */ h((n) => {
  for (let t; t = n._$AM; n = t) {
    let e = t._$AN;
    if (e === void 0) t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(n)) break;
    e.add(n), A7(t);
  }
}, "r");
function w7(n) {
  this._$AN !== void 0 ? (Fd(this), this._$AM = n, pI(this)) : this._$AM = n;
}
h(w7, "h$1");
function S7(n, t = !1, e = 0) {
  const s = this._$AH, i = this._$AN;
  if (i !== void 0 && i.size !== 0) if (t) if (Array.isArray(s)) for (let o = e; o < s.length; o++) Ol(s[o], !1), Fd(s[o]);
  else s != null && (Ol(s, !1), Fd(s));
  else Ol(this, n);
}
h(S7, "n$1");
const A7 = /* @__PURE__ */ h((n) => {
  var t, e;
  n.type == Z2.CHILD && ((t = n._$AP) != null || (n._$AP = S7), (e = n._$AQ) != null || (n._$AQ = w7));
}, "c$1"), J1 = class J1 extends Cu {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, s) {
    super._$AT(t, e, s), pI(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    var s, i;
    t !== this.isConnected && (this.isConnected = t, t ? (s = this.reconnected) == null || s.call(this) : (i = this.disconnected) == null || i.call(this)), e && (Ol(this, t), Fd(this));
  }
  setValue(t) {
    if (v7(this._$Ct)) this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
h(J1, "f");
let wg = J1;
const up = /* @__PURE__ */ h(() => new Sg(), "e"), K1 = class K1 {
};
h(K1, "h");
let Sg = K1;
const hp = /* @__PURE__ */ new WeakMap(), fA = Y2(class extends wg {
  render(n) {
    return zn;
  }
  update(n, [t]) {
    var s;
    const e = t !== this.G;
    return e && this.G !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.G = t, this.ht = (s = n.options) == null ? void 0 : s.host, this.rt(this.ct = n.element)), zn;
  }
  rt(n) {
    var t;
    if (this.isConnected || (n = void 0), typeof this.G == "function") {
      const e = (t = this.ht) != null ? t : globalThis;
      let s = hp.get(e);
      s === void 0 && (s = /* @__PURE__ */ new WeakMap(), hp.set(e, s)), s.get(this.G) !== void 0 && this.G.call(this.ht, void 0), s.set(this.G, n), n !== void 0 && this.G.call(this.ht, n);
    } else this.G.value = n;
  }
  get lt() {
    var n, t, e;
    return typeof this.G == "function" ? (t = hp.get((n = this.ht) != null ? n : globalThis)) == null ? void 0 : t.get(this.G) : (e = this.G) == null ? void 0 : e.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
function Ph(n, t, e, s = "number", i, o) {
  var r;
  return s === "checkbox" ? jn`
      <div class="field">
        <label>${n}</label>
        <input
          type="checkbox"
          .checked=${!!t}
          @change=${(a) => {
    const l = a.target;
    e(l.checked);
  }}
          @keydown=${(a) => a.stopPropagation()}
          @keyup=${(a) => a.stopPropagation()}
          @keypress=${(a) => a.stopPropagation()}
        />
      </div>
    ` : s === "text" ? jn`
      <div class="field">
        <label>${n}</label>
        <input
          type="text"
          .value=${String(t != null ? t : "")}
          @input=${(a) => {
    const l = a.target;
    e(l.value);
  }}
          @keydown=${(a) => a.stopPropagation()}
          @keyup=${(a) => a.stopPropagation()}
          @keypress=${(a) => a.stopPropagation()}
        />
      </div>
    ` : s === "select" ? jn`
      <div class="field">
        <label>${n}</label>
        <select
          ${fA(i)}
          .value=${String(t != null ? t : (r = o == null ? void 0 : o[0]) != null ? r : "")}
          @change=${(a) => {
    const l = a.target;
    e(l.value);
  }}
          @keydown=${(a) => a.stopPropagation()}
          @keyup=${(a) => a.stopPropagation()}
          @keypress=${(a) => a.stopPropagation()}
        >
          ${(o != null ? o : []).map((a) => jn`<option value=${a}>${a}</option>`)}
        </select>
      </div>
    ` : jn`
    <div class="field">
      <label
        ${fA(i)}
        style="cursor: ew-resize; user-select: none;"
      >
        ${n}
      </label>
      <input
        type="number"
        .value=${(typeof t == "number" ? t : Number(t != null ? t : 0)).toFixed(2)}
        step="0.1"
        @input=${(a) => {
    const l = a.target, c = parseFloat(l.value);
    isNaN(c) || e(c);
  }}
        @keydown=${(a) => a.stopPropagation()}
        @keyup=${(a) => a.stopPropagation()}
        @keypress=${(a) => a.stopPropagation()}
      />
    </div>
  `;
}
h(Ph, "renderField");
function xs(n, t) {
  return jn`
    <div class="field readonly">
      <label>${n}</label>
      <span class="value">
        ${typeof t == "number" ? t.toFixed(2) : String(t)}
      </span>
    </div>
  `;
}
h(xs, "renderReadOnlyField");
function bl(n, t) {
  return jn`
    <div class="component-section">
      <div class="component-header">${n}</div>
      <div class="component-fields">
        ${t}
      </div>
    </div>
  `;
}
h(bl, "renderComponentSection");
function _I(n, t, e, s) {
  const o = n.children.length > 0 ? "▼" : "·", a = {
    "tree-node": !0,
    selected: e === n.eid
  };
  return jn`
    <div>
      <div
        class=${_7(a)}
        style="padding-left: ${t * 16 + 8}px"
        @click=${(l) => {
    l.stopPropagation(), s(n.eid);
  }}
      >
        <span class="entity-name">${o} ${n.name}</span>
        ${n.components.length > 0 ? jn`
              <span class="component-badges">
                ${n.components.map(
    (l) => jn`<span class="badge">${l}</span>`
  )}
              </span>
            ` : zn}
      </div>
      ${n.children.map((l) => _I(l, t + 1, e, s))}
    </div>
  `;
}
h(_I, "renderTreeNode");
function M7(n, t, e) {
  const s = /* @__PURE__ */ h((i) => {
    i.preventDefault();
    const o = i.clientX, r = parseFloat(t.value), a = 0.1, l = /* @__PURE__ */ h((u) => {
      const m = u.clientX - o, d = r + m * a;
      t.value = d.toFixed(2), e(d);
    }, "onMouseMove"), c = /* @__PURE__ */ h(() => {
      document.removeEventListener("mousemove", l), document.removeEventListener("mouseup", c);
    }, "onMouseUp");
    document.addEventListener("mousemove", l), document.addEventListener("mouseup", c);
  }, "onMouseDown");
  n.addEventListener("mousedown", s);
}
h(M7, "makeLabelDraggable");
const pA = /* @__PURE__ */ h((n, t, e) => {
  const s = /* @__PURE__ */ new Map();
  for (let i = t; i <= e; i++) s.set(n[i], i);
  return s;
}, "u"), C7 = Y2(class extends Cu {
  constructor(n) {
    if (super(n), n.type !== Z2.CHILD) throw Error("repeat() can only be used in text expressions");
  }
  dt(n, t, e) {
    let s;
    e === void 0 ? e = t : t !== void 0 && (s = t);
    const i = [], o = [];
    let r = 0;
    for (const a of n) i[r] = s ? s(a, r) : r, o[r] = e(a, r), r++;
    return { values: o, keys: i };
  }
  render(n, t, e) {
    return this.dt(n, t, e).values;
  }
  update(n, [t, e, s]) {
    var v;
    const i = x7(n), { values: o, keys: r } = this.dt(t, e, s);
    if (!Array.isArray(i)) return this.ut = r, o;
    const a = (v = this.ut) != null ? v : this.ut = [], l = [];
    let c, u, m = 0, d = i.length - 1, f = 0, p = o.length - 1;
    for (; m <= d && f <= p; ) if (i[m] === null) m++;
    else if (i[d] === null) d--;
    else if (a[m] === r[f]) l[f] = Gr(i[m], o[f]), m++, f++;
    else if (a[d] === r[p]) l[p] = Gr(i[d], o[p]), d--, p--;
    else if (a[m] === r[p]) l[p] = Gr(i[m], o[p]), vl(n, l[p + 1], i[m]), m++, p--;
    else if (a[d] === r[f]) l[f] = Gr(i[d], o[f]), vl(n, i[m], i[d]), d--, f++;
    else if (c === void 0 && (c = pA(r, f, p), u = pA(a, m, d)), c.has(a[m])) if (c.has(a[d])) {
      const _ = u.get(r[f]), g = _ !== void 0 ? i[_] : null;
      if (g === null) {
        const w = vl(n, i[m]);
        Gr(w, o[f]), l[f] = w;
      } else l[f] = Gr(g, o[f]), vl(n, i[m], g), i[_] = null;
      f++;
    } else lp(i[d]), d--;
    else lp(i[m]), m++;
    for (; f <= p; ) {
      const _ = vl(n, l[p + 1]);
      Gr(_, o[f]), l[f++] = _;
    }
    for (; m <= d; ) {
      const _ = i[m++];
      _ !== null && lp(_);
    }
    return this.ut = r, y7(n, l), Ra;
  }
}), E7 = new hn().with(ue), T7 = new hn().with(ne), Q1 = class Q1 {
  constructor() {
    this.container = null, this.selectedEntity = null, this.activeScene = null, this.onEntitySelect = null;
  }
  initialize(t) {
    this.onEntitySelect = t, this.createPanel();
  }
  setActiveScene(t) {
    this.activeScene = t;
  }
  setSelectedEntity(t) {
    this.selectedEntity = t;
  }
  createPanel() {
    const t = document.createElement("aside");
    t.id = "scene-tree", t.innerHTML = `
      <nav class="panel-header">
        <h3>Scene Hierarchy</h3>
        <button class="refresh-btn" title="Refresh">↻</button>
      </nav>
      <div class="tree-container"></div>
    `, document.body.appendChild(t), this.container = t.querySelector(".tree-container"), t.querySelector(".refresh-btn").addEventListener("click", () => this.refresh());
  }
  refresh() {
    if (!this.container) return;
    if (!this.activeScene) {
      const s = jn`<div class="empty-tree">No scene active</div>`;
      Mc(s, this.container);
      return;
    }
    const t = this.buildEntityTree();
    if (t.length === 0) {
      const s = jn`<div class="empty-tree">No entities in scene</div>`;
      Mc(s, this.container);
      return;
    }
    const e = jn`
      ${C7(
      t,
      (s) => s.eid,
      (s) => _I(s, 0, this.selectedEntity, (i) => this.selectEntity(i))
    )}
    `;
    Mc(e, this.container);
  }
  buildEntityTree() {
    if (!this.activeScene) return [];
    const t = this.activeScene.world, i = (this.activeScene.type === "3d" ? T7 : E7)._compile().base(t), o = /* @__PURE__ */ new Map(), r = [];
    for (const l of i)
      if (Zi(t, ti.component, l)) {
        const c = ti.component.parentEid[l];
        o.has(c) || o.set(c, []), o.get(c).push(l);
      } else
        r.push(l);
    const a = /* @__PURE__ */ h((l) => {
      const c = this.getEntityName(l), u = (o.get(l) || []).map(a), m = this.getEntityComponents(l);
      return { eid: l, name: c, children: u, components: m };
    }, "buildNode");
    return r.map(a);
  }
  getEntityName(t) {
    if (!this.activeScene) return `Entity ${t}`;
    for (const [e, s] of this.activeScene.nameToEid.entries())
      if (s === t) return e;
    return `Entity ${t}`;
  }
  getEntityComponents(t) {
    if (!this.activeScene) return [];
    const e = this.activeScene.world, s = [];
    for (const i of hi.list())
      Zi(e, i.component, t) && s.push(i.name);
    return s;
  }
  selectEntity(t) {
    this.selectedEntity = t, this.refresh(), this.onEntitySelect && this.onEntitySelect(t);
  }
};
h(Q1, "Hierarchy");
let Ag = Q1;
const tx = class tx {
  constructor() {
    this.container = null, this.activeScene = null;
  }
  initialize() {
    this.createPanel();
  }
  setActiveScene(t) {
    this.activeScene = t;
  }
  createPanel() {
    const t = document.createElement("aside");
    t.id = "entity-inspector", t.innerHTML = `
      <nav class="panel-header">
        <h3>Inspector</h3>
      </nav>
      <div class="inspector-content"></div>
    `, document.body.appendChild(t), this.container = t.querySelector(".inspector-content"), this.clear();
  }
  clear() {
    if (!this.container) return;
    const t = jn`<div class="no-selection">No entity selected</div>`;
    Mc(t, this.container);
  }
  update(t) {
    if (!this.container || !this.activeScene) return;
    const e = this.activeScene.world, s = this.getEntityComponents(t), i = jn`
      <div class="inspector-header">
        <div class="entity-id">Entity ID: ${t}</div>
        <div class="entity-name">${this.getEntityName(t)}</div>
      </div>
      ${s.length === 0 ? jn`<div class="no-components">No components</div>` : s.map((o) => this.createComponentInspector(o, t, e))}
    `;
    Mc(i, this.container), requestAnimationFrame(() => {
      this.setupDraggableLabels();
    });
  }
  getEntityName(t) {
    if (!this.activeScene) return `Entity ${t}`;
    for (const [e, s] of this.activeScene.nameToEid.entries())
      if (s === t) return e;
    return `Entity ${t}`;
  }
  getEntityComponents(t) {
    if (!this.activeScene) return [];
    const e = this.activeScene.world, s = [];
    for (const i of hi.list())
      Zi(e, i.component, t) && s.push(i.name);
    return s;
  }
  createComponentInspector(t, e, s) {
    const i = hi.get(t);
    if (!i)
      return bl(t, [
        jn`<div class="field-info">Unknown component</div>`
      ]);
    if (t === "RigidBody" && this.activeScene instanceof ur) {
      const a = this.activeScene.bodyRegistry.get(e);
      if (a) {
        const l = [
          xs("position.x", a.position.x),
          xs("position.y", a.position.y),
          xs("rotation", a.rotation),
          xs("velocity.x", a.velocity.x),
          xs("velocity.y", a.velocity.y),
          xs("angularVelocity", a.angularVelocity),
          xs("isStatic", a.isStatic ? "true" : "false")
        ];
        return a.mass !== void 0 && l.push(xs("mass", a.mass)), a.friction !== void 0 && l.push(xs("friction", a.friction)), a.restitution !== void 0 && l.push(xs("restitution", a.restitution)), bl(t, l);
      }
      return bl(t, [
        jn`<div class="field-info">No physics body found</div>`
      ]);
    }
    if (!i.fields)
      return bl(t, [
        jn`<div class="field-info">No editable fields</div>`
      ]);
    const o = hi.read(t, e), r = i.fields.map((a) => {
      var l, c;
      switch (a.variant) {
        case "scalar":
          return Ph(
            a.name,
            (l = o[a.name]) != null ? l : 0,
            (u) => hi.assign(t, e, { [a.name]: u }),
            "number",
            up()
          );
        case "boolean":
          return Ph(
            a.name,
            !!o[a.name],
            (u) => hi.assign(t, e, { [a.name]: u }),
            "checkbox"
          );
        case "enum":
          return Ph(
            a.name,
            o[a.name],
            (u) => hi.assign(t, e, { [a.name]: u }),
            "select",
            up(),
            a.options
          );
        case "color":
          return Ph(
            a.name,
            (c = o[a.name]) != null ? c : "#ffffff",
            (u) => hi.assign(t, e, { [a.name]: u }),
            "text",
            up()
          );
        case "array":
          return xs(a.name, "—");
      }
    });
    return bl(t, r);
  }
  setupDraggableLabels() {
    var r, a;
    if (!this.container) return;
    const t = Array.from(this.container.querySelectorAll(".component-section"));
    let e = null, s = null, i = null;
    for (const l of t) {
      const c = l.querySelector(".component-header");
      if (((r = c == null ? void 0 : c.textContent) == null ? void 0 : r.trim()) === "Transform") {
        e = l;
        const m = Array.from(l.querySelectorAll(".field"));
        for (const d of m) {
          const f = d.querySelector("label"), p = d.querySelector('input[type="number"]'), v = (a = f == null ? void 0 : f.textContent) == null ? void 0 : a.trim();
          v === "sx" && (s = p), v === "sy" && (i = p);
        }
        break;
      }
    }
    this.container.querySelectorAll(".field:not(.readonly)").forEach((l) => {
      var v;
      const c = l.querySelector("label"), u = l.querySelector('input[type="number"]');
      if (!c || !u) return;
      const m = !!e && e.contains(l), d = (v = c.textContent) == null ? void 0 : v.trim(), f = m && (d === "sx" || d === "sy");
      let p = /* @__PURE__ */ h((_) => {
        u.value = _.toFixed(2), u.dispatchEvent(new Event("input", { bubbles: !0 }));
      }, "onChange");
      f && s && i && (p = /* @__PURE__ */ h((_) => {
        s.value = _.toFixed(2), i.value = _.toFixed(2), s.dispatchEvent(new Event("input", { bubbles: !0 })), i.dispatchEvent(new Event("input", { bubbles: !0 }));
      }, "onChange")), M7(c, u, p);
    });
  }
};
h(tx, "Inspector");
let Mg = tx;
const Ao = class Ao {
  static initialize(t) {
    this.game = t, this.hierarchy.initialize((e) => this.selectEntity(e)), this.inspector.initialize(), this.createGameHeader(), this.loadSavedSizes(), this.createDragHandles(), setTimeout(() => this.refreshAll(), 100);
  }
  static notifySceneChange() {
    if (!this.game) return;
    const t = this.activeScene;
    this.findActiveScene(), this.activeScene !== t && (this.hierarchy.setActiveScene(this.activeScene), this.inspector.setActiveScene(this.activeScene), this.hierarchy.refresh(), this.inspector.clear(), this.selectedEntity = null);
  }
  static notifyEntityChange() {
    this.game && (this.hierarchy.refresh(), this.selectedEntity !== null && this.inspector.update(this.selectedEntity));
  }
  static refreshAll() {
    this.findActiveScene(), this.hierarchy.setActiveScene(this.activeScene), this.inspector.setActiveScene(this.activeScene), this.hierarchy.refresh(), this.selectedEntity !== null && this.inspector.update(this.selectedEntity);
  }
  static findActiveScene() {
    this.game && (this.activeScene = this.game.sceneManager.getActiveCanvasScene());
  }
  static selectEntity(t) {
    this.selectedEntity = t, this.hierarchy.setSelectedEntity(t), this.hierarchy.refresh(), this.inspector.update(t);
  }
  static createGameHeader() {
    if (!this.game) return;
    const t = document.createElement("nav");
    t.id = "game-header", this.game.container.appendChild(t), this.renderGameHeader();
  }
  static renderGameHeader() {
    if (!this.game) return;
    const t = document.getElementById("game-header");
    if (!t) return;
    const e = this.game.sceneManager.isActiveScenePaused(), s = jn`
      <button id="play-pause-btn" @click=${() => this.togglePlayPause()}>
        ${e ? "▶" : "⏸"}
      </button>
    `;
    Mc(s, t);
  }
  static togglePlayPause() {
    if (!this.game) return;
    const t = this.game.sceneManager;
    t.isActiveScenePaused() ? t.resumeActiveScene() : t.pauseActiveScene(), this.renderGameHeader();
  }
  static loadSavedSizes() {
    const t = localStorage.getItem("editor-aside-size"), e = localStorage.getItem("editor-tree-size-h"), s = localStorage.getItem("editor-inspector-size-h"), i = localStorage.getItem("editor-tree-size-v"), o = localStorage.getItem("editor-inspector-size-v");
    t && this.setCSSVariable("--aside-size", t), e && this.setCSSVariable("--tree-size-h", e), s && this.setCSSVariable("--inspector-size-h", s), i && this.setCSSVariable("--tree-size-v", i), o && this.setCSSVariable("--inspector-size-v", o);
  }
  static saveSizes() {
    const t = getComputedStyle(document.body).getPropertyValue("--aside-size"), e = getComputedStyle(document.body).getPropertyValue("--tree-size-h"), s = getComputedStyle(document.body).getPropertyValue("--inspector-size-h"), i = getComputedStyle(document.body).getPropertyValue("--tree-size-v"), o = getComputedStyle(document.body).getPropertyValue("--inspector-size-v");
    localStorage.setItem("editor-aside-size", t.trim()), localStorage.setItem("editor-tree-size-h", e.trim()), localStorage.setItem("editor-inspector-size-h", s.trim()), localStorage.setItem("editor-tree-size-v", i.trim()), localStorage.setItem("editor-inspector-size-v", o.trim());
  }
  static createDragHandles() {
    const t = document.getElementById("app"), e = document.getElementById("scene-tree");
    !t || !e || (t.addEventListener("mousedown", (s) => {
      const i = t.getBoundingClientRect();
      this.getLayout() === "horizontal" ? s.clientX >= i.right - 3 && s.clientX <= i.right + 3 && this.onDragStart(s, "aside") : s.clientY >= i.bottom - 3 && s.clientY <= i.bottom + 3 && this.onDragStart(s, "aside");
    }), e.addEventListener("mousedown", (s) => {
      const i = e.getBoundingClientRect();
      this.getLayout() === "horizontal" ? s.clientY >= i.bottom - 3 && s.clientY <= i.bottom + 3 && this.onDragStart(s, "panels") : s.clientX >= i.right - 3 && s.clientX <= i.right + 3 && this.onDragStart(s, "panels");
    }));
  }
  static onDragStart(t, e) {
    if (t.preventDefault(), this.dragState.isDragging = !0, this.dragState.handleType = e, this.dragState.startPos = e === "aside" ? this.getLayout() === "horizontal" ? t.clientX : t.clientY : this.getLayout() === "horizontal" ? t.clientY : t.clientX, e === "aside") {
      const o = getComputedStyle(document.body).getPropertyValue("--aside-size");
      this.dragState.startValue = parseInt(o);
    } else {
      const r = this.getLayout() === "horizontal" ? "--tree-size-h" : "--tree-size-v", a = getComputedStyle(document.body).getPropertyValue(r);
      this.dragState.startValue = parseFloat(a);
    }
    const s = /* @__PURE__ */ h((o) => this.onDrag(o), "onMouseMove"), i = /* @__PURE__ */ h((o) => {
      this.onDragEnd(o), document.removeEventListener("mousemove", s), document.removeEventListener("mouseup", i);
    }, "onMouseUp");
    document.addEventListener("mousemove", s), document.addEventListener("mouseup", i);
  }
  static onDrag(t) {
    if (!this.dragState.isDragging) return;
    const e = this.getLayout();
    if (this.dragState.handleType === "aside") {
      const s = e === "horizontal" ? t.clientX : t.clientY, i = this.dragState.startPos - s, o = Math.max(300, Math.min(800, this.dragState.startValue + i));
      this.setCSSVariable("--aside-size", `${o}px`);
    } else {
      const i = (e === "horizontal" ? t.clientY : t.clientX) - this.dragState.startPos, o = document.getElementById("scene-tree"), r = document.getElementById("entity-inspector");
      if (!o || !r) return;
      const a = o.getBoundingClientRect(), l = r.getBoundingClientRect(), c = e === "horizontal" ? a.height + l.height : a.width + l.width, u = i / c, m = Math.max(0.1, Math.min(0.9, this.dragState.startValue + u)), d = Math.max(0.1, Math.min(0.9, 1 - m));
      e === "horizontal" ? (this.setCSSVariable("--tree-size-h", `${m.toFixed(5)}fr`), this.setCSSVariable("--inspector-size-h", `${d.toFixed(5)}fr`)) : (this.setCSSVariable("--tree-size-v", `${m.toFixed(5)}fr`), this.setCSSVariable("--inspector-size-v", `${d.toFixed(5)}fr`));
    }
  }
  static onDragEnd(t) {
    this.dragState.isDragging && (this.dragState.isDragging = !1, this.dragState.handleType = null, this.saveSizes(), Dn.handleScreenResize());
  }
  static setCSSVariable(t, e) {
    document.body.style.setProperty(t, e);
  }
  static getLayout() {
    return document.body.getAttribute("data-editor-layout") || "horizontal";
  }
};
h(Ao, "Editor"), Ao.game = null, Ao.hierarchy = new Ag(), Ao.inspector = new Mg(), Ao.selectedEntity = null, Ao.activeScene = null, Ao.dragState = {
  isDragging: !1,
  handleType: null,
  startPos: 0,
  startValue: 0
};
let Eu = Ao;
const ex = class ex extends wu {
  constructor(t, e, s, i, o) {
    super(t, e), this.nameToEid = /* @__PURE__ */ new Map(), this.customSystems = [], this.spriteAnimationSets = [], this.tweenRegistry = [], this.skeletonRegistry = [], this.skeletalAnimationSets = [], this.skinnedMeshRegistry = [], this.deformedMeshes = /* @__PURE__ */ new Map(), this.useEditor = i, this.assetManager = o, this.clearColor = s, this.setBackgroundColor(s), this.canvas = document.createElement("canvas"), this.canvas.addEventListener("contextmenu", (r) => r.preventDefault()), this.root.appendChild(this.canvas), this.world = eB(), this.world.time = { delta: 0, then: performance.now() }, this.inputManager = new Ig(this.canvas, this.world), this._hierarchySystem = p3();
  }
  mount(t, e) {
    t.appendChild(this.root), this._isMounted = !0, Dn.sizeCanvas(this.canvas);
  }
  unmount() {
    this.root.parentElement && this.root.parentElement.removeChild(this.root), this._isMounted = !1;
  }
  update(t, e) {
    var o;
    const s = !this._isPaused, i = performance.now();
    if (this.world.time.delta = s ? e : 0, this.world.time.then = i, s && this.tick(t, e, i), (o = this._hierarchySystem) == null || o.call(this, this), s)
      for (const r of this.customSystems)
        r(this, e);
    this.inputManager.reset();
  }
  getEntityByName(t) {
    return this.nameToEid.get(t);
  }
  addEntity() {
    return Io(this.world);
  }
  removeEntity(t) {
    CA(this.world, t);
  }
  addComponentToEntity(t, e) {
    const s = "component" in t ? t.component : t;
    wn(this.world, s, e);
  }
  removeComponentFromEntity(t, e) {
    const s = "component" in t ? t.component : t;
    QI(this.world, s, e);
  }
  doesEntityHaveComponent(t, e) {
    const s = "component" in e ? e.component : e;
    return Zi(this.world, s, t);
  }
  query(t) {
    const e = t._compile();
    return e.hasEntered && e.enter ? e.enter(this.world) : e.hasExited && e.exit ? e.exit(this.world) : e.base(this.world);
  }
  instantiateTemplate(t, e) {
    const s = ha.get(t);
    if (!s) throw new Error(`Template "${t}" not found`);
    const { success: i, error: o, data: r } = s.paramsSchema.safeParse(e != null ? e : {});
    if (!i) throw new Error(`Invalid template parameters: ${JSON.stringify(o.issues)}`);
    const a = ha.getNextInstanceNumber(t), l = s.entities.map(
      (c) => this.createEntityFromDefinition(
        sI(c, r),
        c.name ? `${c.name} Instance (${a})` : void 0
      )
    );
    return Eu.notifyEntityChange(), l;
  }
  createEntityFromDefinition(t, e, s) {
    var c, u, m;
    const i = Io(this.world), o = (c = e != null ? e : t.name) != null ? c : null;
    o && (this.nameToEid.has(o) && console.warn(`Entity name "${o}" already exists. Names should be unique.`), this.nameToEid.set(o, i));
    let r;
    const a = [];
    for (const d of t.components)
      if (d.type === "Child") {
        const f = d.attributes || {};
        r = f["parent-name"] || f.parentName;
      } else
        a.push(d);
    for (const d of a) {
      if (!hi.get(d.type)) {
        console.warn(`Unknown component type: ${d.type}`);
        continue;
      }
      hi.addFromAuthoring(d.type, this, i, (u = d.attributes) != null ? u : {});
    }
    const l = r != null ? r : s;
    if (l && o) {
      const d = this.nameToEid.get(l);
      d !== void 0 ? (wn(this.world, ti.component, i), ti.component.parentEid[i] = d) : console.warn(`❌ Parent entity not found: "${l}" for child "${o}"`);
    }
    for (const d of (m = t.children) != null ? m : []) {
      const f = d.name === null ? void 0 : e ? `${d.name} Instance (${ha.getNextInstanceNumber(d.name)})` : d.name;
      this.createEntityFromDefinition(d, f, o != null ? o : void 0);
    }
    return i;
  }
};
h(ex, "CanvasScene");
let Tu = ex;
const nx = class nx extends Tu {
  constructor(t, e, s = !1, i) {
    var a, l, c;
    super(t, "2d", e.backgroundColor, s, i), this.bodyRegistry = /* @__PURE__ */ new Map();
    const o = this.canvas.getContext("2d");
    if (!o) throw new Error("Failed to get 2D context");
    this.ctx = o;
    const r = this.calculateDefaultBounds();
    this.gameBoundsWidth = (a = e.gameBoundsWidth) != null ? a : r.width, this.gameBoundsHeight = (l = e.gameBoundsHeight) != null ? l : r.height, this.gravity = (c = e.gravity) != null ? c : 0, this.physicsEngine = new gg(), this.physicsEngine.initialize(this.gravity), hi.registerCustom({
      name: "RigidBody",
      component: Vo,
      authoringSchema: GV,
      onAdd: HV
    }), e.hasCamera || this.addDefaultCamera();
  }
  addPhysicsBody(t, e) {
    this.bodyRegistry.set(t, e), Vo.bodyId[t] = e.id, "setEntityMapping" in this.physicsEngine && this.physicsEngine.setEntityMapping(e.id, t);
  }
  calculateDefaultBounds() {
    return {
      width: Math.ceil(Dn.worldViewWidth),
      height: Math.ceil(Dn.worldViewHeight)
    };
  }
  addDefaultCamera() {
    const t = Io(this.world);
    wn(this.world, ue, t);
    const e = Dn.worldViewWidth / this.gameBoundsWidth, s = Dn.worldViewHeight / this.gameBoundsHeight, i = Math.max(e, s);
    return ue.assign(t, {
      x: this.gameBoundsWidth / 2,
      y: this.gameBoundsHeight / 2,
      rotation: 0,
      sx: i,
      sy: i
    }), wn(this.world, Zn, t), PN(t), t;
  }
  tick(t, e, s) {
    Q5(this.world, t, s), C8(this.world, e), T8(this, e), B3(this, e), D5(this, e), I5(this, e), L5(this, e, this.gravity), i7(this.world, this.physicsEngine);
  }
  draw(t) {
    J5(this), F5(this, this.ctx, this.clearColor, t, this.useEditor);
  }
};
h(nx, "Canvas2DScene");
let ur = nx;
const gI = new hn().with(ne).with(gn);
let _A = !1;
function I7(n) {
  const t = n.query(gI);
  !_A && n.canvas && (B7(n.canvas, n.world), _A = !0);
  for (const e of t) {
    const s = gn.targetEid[e];
    if (s === 0 || s === void 0) continue;
    ne.read(e);
    const i = ne.read(s), o = ne.read(s), r = gn.distance[e], a = gn.height[e], l = gn.mode[e], c = gn.followRotation[e] === 1;
    let u = gn.yawOffset[e], m = gn.pitchOffset[e], d = u;
    c && (d = (o.rotationY || 0) - Math.PI + u), l === 1 && (d += Math.PI);
    const f = m, p = i.x + r * Math.sin(d) * Math.cos(f), v = i.y + a + r * Math.sin(f), _ = i.z + r * Math.cos(d) * Math.cos(f), g = i.x, w = i.y + 0.75, S = i.z, x = g - p, A = w - v, C = S - _, M = Math.sqrt(x * x + C * C), T = -Math.atan2(A, M), b = Math.atan2(x, C);
    ne.assign(e, {
      x: p,
      y: v,
      z: _,
      rotationX: T,
      rotationY: b,
      rotationZ: 0
    });
  }
}
h(I7, "cameraFollowSystem3D");
function B7(n, t) {
  let e = null, s = 0, i = 0;
  n.addEventListener("mousedown", (o) => {
    const r = gI._compile().base(t);
    for (const a of r)
      if (gn.mouseControl[a] === 1) {
        e = a, gn.isDragging[a] = 1, s = o.clientX, i = o.clientY, o.preventDefault();
        break;
      }
  }), document.addEventListener("mousemove", (o) => {
    if (e === null) return;
    const r = o.clientX - s, a = o.clientY - i;
    gn.yawOffset[e] -= r * 5e-3, gn.pitchOffset[e] += a * 5e-3;
    const l = gn.pitchOffset[e];
    gn.pitchOffset[e] = Math.max(-Math.PI / 3, Math.min(Math.PI / 6, l)), s = o.clientX, i = o.clientY, o.preventDefault();
  }), document.addEventListener("mouseup", () => {
    e !== null && (gn.isDragging[e] = 0, e = null);
  }), console.log("🖱️ Camera mouse controls enabled");
}
h(B7, "setupMouseControls");
const P7 = new hn().with(ne).with(na);
function R7(n) {
  const t = n.query(P7);
  for (const e of t) {
    const s = n.inputManager.getAxis2D("Move"), i = s.y, o = s.x, a = ne.read(e).rotationY || 0, l = na.turnSpeed[e];
    if (Math.abs(o) > 0.01) {
      const c = -o * l * (n.world.time.delta / 1e3);
      ne.assign(e, {
        rotationY: a + c
      });
    }
    if (Zi(n.world, Ue, e)) {
      if (Math.abs(i) > 0.01) {
        const u = ne.read(e).rotationY || 0, m = Math.sin(u) * i, d = Math.cos(u) * i;
        n.physics.moveCharacter(e, m, d);
      } else
        n.physics.moveCharacter(e, 0, 0);
      n.inputManager.isActionPressed("Jump") && n.physics.jumpCharacter(e);
    }
  }
}
h(R7, "tankControllerSystem");
const ix = class ix extends Tu {
  constructor(t, e, s = !1, i) {
    var r;
    super(t, "3d", e.backgroundColor, s, i), this.bodyRegistry = /* @__PURE__ */ new Map();
    const o = (r = e.gravity) != null ? r : -9.81;
    this.physicsEngine = new kp({
      gravity: { x: 0, y: o, z: 0 }
    }), this.physics = new Cg(this), console.log("✅ Canvas3DScene initialized:", t, "entities:", this.nameToEid.size);
  }
  mount(t, e) {
    console.log("📦 Canvas3DScene mounting:", this.name), console.log("  - Systems attached:", this.customSystems.length), super.mount(t, e), console.log("✅ Canvas3DScene mounted, canvas:", this.canvas), console.log("  - Canvas size:", this.canvas.width, "x", this.canvas.height);
  }
  addPhysicsBody(t, e) {
    this.bodyRegistry.set(t, e), os.bodyId[t] = e;
  }
  addDefaultCamera() {
    return 0;
  }
  tick(t, e, s) {
    o7(this.world, this.physicsEngine), a7(this.world, this.physicsEngine), R7(this), I7(this);
  }
  draw(t) {
    const e = { canvas: this.canvas };
    c8(this, e, this.clearColor);
  }
};
h(ix, "Canvas3DScene");
let gc = ix;
const sx = class sx {
  constructor(t) {
    this.scene = t;
  }
  moveCharacter(t, e, s) {
    const i = Ue.bodyId[t];
    if (!i) return;
    const o = this.scene.physicsEngine.getBody(i);
    if (!o) return;
    const r = Ue.moveSpeed[t], a = Ue.isGrounded[t], l = Ue.airControl[t], c = a ? 1 : l, u = e * r * c, m = s * r * c;
    this.scene.physicsEngine.setVelocity(i, {
      x: u,
      y: o.velocity.y,
      z: m
    });
  }
  jumpCharacter(t) {
    const e = Ue.bodyId[t];
    if (console.log("🎯 jumpCharacter called:", { eid: t, bodyId: e, hasBodyId: !!e }), !e) {
      console.error("❌ No CharacterController3D bodyId for eid", t);
      return;
    }
    Ue.jumpRequested[t] = 1, console.log("✅ Jump request flag set to 1");
  }
  isGrounded(t) {
    return Ue.isGrounded[t] === 1;
  }
  getVelocity(t) {
    const e = Ue.bodyId[t];
    return e ? this.scene.physicsEngine.getVelocity(e) : null;
  }
};
h(sx, "Physics3DHelpers");
let Cg = sx;
const ox = class ox extends wu {
  constructor(t, e = []) {
    super(t, "composite"), this.children = [], e.forEach((s) => this.push(s));
  }
  mountChild(t, e) {
    t.mount(this.root, this.sceneManager), t.root.classList.add("scene"), t.root.style.zIndex = String(e);
  }
  push(t) {
    this.children.push(t), this._isMounted && (this.mountChild(t, this.children.length - 1), this.reconcileSuspension());
  }
  pop() {
    if (this.children.length <= 1) return console.warn("Must have at least one child to pop scene");
    const t = this.children.pop();
    return t != null && t.isMounted && t.unmount(), this.reconcileSuspension(), t;
  }
  mount(t, e) {
    this.sceneManager = e, t.appendChild(this.root), this.children.forEach((s, i) => this.mountChild(s, i)), this._isMounted = !0, this.reconcileSuspension();
  }
  unmount() {
    this.children.forEach((t) => t.unmount()), this.root.parentElement && this.root.parentElement.removeChild(this.root), this._isMounted = !1;
  }
  update(t, e) {
    this.children.forEach((s) => s.update(t, e));
  }
  draw(t) {
    this.children.forEach((e) => e.draw(t));
  }
  reconcileSuspension() {
    let t = !1;
    for (let e = this.children.length - 1; e >= 0; e--) {
      const s = this.children[e];
      if (s.type === "ui") {
        s.suspendBehind && (t = !0), s.resume();
        continue;
      }
      if (s.type === "2d" || s.type === "3d") {
        t ? s.pause() : s.resume();
        continue;
      }
      s.type === "composite" && (t ? s.pause() : s.resume());
    }
    Eu.notifySceneChange();
  }
  pause() {
    super.pause(), this.applyPauseToDescendants(!0);
  }
  resume() {
    super.resume(), this.applyPauseToDescendants(!1);
  }
  applyPauseToDescendants(t) {
    for (const e of this.children) {
      if (e.type === "2d" || e.type === "3d") {
        t ? e.pause() : e.resume();
        continue;
      }
      e.type === "composite" && (t ? e.pause() : e.resume());
    }
  }
};
h(ox, "CompositeScene");
let Zr = ox;
const D7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="48" d="M112 268 256 412 400 268"></path><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="48" d="M256 392 256 100"></path></svg>', V7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="48" d="M244 400 100 256 244 112"></path><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="48" d="M120 256 412 256"></path></svg>', L7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="48" d="M268 112 412 256 268 400"></path><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="48" d="M392 256 100 256"></path></svg>', N7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="48" d="M112 244 256 100 400 244"></path><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="48" d="M256 120 256 412"></path></svg>', z7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="m98 190.06 139.78 163.12a24 24 0 0 0 36.44 0L414 190.06c13.34-15.57 2.28-39.62-18.22-39.62h-279.6c-20.5 0-31.56 24.05-18.18 39.62Z"></path></svg>', k7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M321.94 98 158.82 237.78a24 24 0 0 0 0 36.44L321.94 414c15.57 13.34 39.62 2.28 39.62-18.22v-279.6c0-20.5-24.05-31.56-39.62-18.18Z"></path></svg>', U7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="m190.06 414 163.12-139.78a24 24 0 0 0 0-36.44L190.06 98c-15.57-13.34-39.62-2.28-39.62 18.22v279.6c0 20.5 24.05 31.56 39.62 18.18Z"></path></svg>', O7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M414 321.94 274.22 158.82a24 24 0 0 0-36.44 0L98 321.94c-13.34 15.57-2.28 39.62 18.22 39.62h279.6c20.5 0 31.56-24.05 18.18-39.62Z"></path></svg>', $7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="m289.94 256 95-95A24 24 0 0 0 351 127l-95 95-95-95a24 24 0 0 0-34 34l95 95-95 95a24 24 0 1 0 34 34l95-95 95 95a24 24 0 0 0 34-34Z"></path></svg>', F7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M256 232A24 24 0 1 0 256 280 24 24 0 1 0 256 232z"></path><path d="M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48Zm105.07 113.33-46.88 117.2a64 64 0 0 1-35.66 35.66l-117.2 46.88a8 8 0 0 1-10.4-10.4l46.88-117.2a64 64 0 0 1 35.66-35.66l117.2-46.88a8 8 0 0 1 10.4 10.4Z"></path></svg>', G7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" id="icons" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M121.72 32a4 4 0 0 0-3.72 5.56l2.3 5.43 40.7 94.9a4 4 0 0 0 6.88.82L243 38.4a4 4 0 0 0-3.2-6.4ZM419.93 58.06l-41.28 96.37a4 4 0 0 0 3.68 5.57h101a4 4 0 0 0 3.4-6.11L427 57.53a4 4 0 0 0-7.07.53ZM85 57.57l-59.71 96.32a4 4 0 0 0 3.4 6.11h101a4 4 0 0 0 3.67-5.58L92 58.1a4 4 0 0 0-7-.53ZM393.27 32H267.82a1.94 1.94 0 0 0-1.56 3.11l79.92 106.46a1.94 1.94 0 0 0 3.34-.4L391.6 43l3.4-8.34a1.92 1.92 0 0 0-1.7-2.66ZM239 448l-89.43-253.49A3.78 3.78 0 0 0 146 192H25.7a3.72 3.72 0 0 0-2.95 6l216 279.81a5.06 5.06 0 0 0 6.39 1.37 5 5 0 0 0 2.39-6.08ZM486.3 192H366a3.75 3.75 0 0 0-3.54 2.51l-98.2 278.16a5.21 5.21 0 0 0 2.42 6.31 5.22 5.22 0 0 0 6.61-1.39L489.25 198a3.72 3.72 0 0 0-2.95-6ZM259.2 78.93l56 74.67a4 4 0 0 1-3.2 6.4H200a4 4 0 0 1-3.2-6.4l56-74.67a4 4 0 0 1 6.4 0Zm-7 310.31-67.7-191.91a4 4 0 0 1 3.77-5.33h135.46a4 4 0 0 1 3.77 5.33l-67.73 191.91a4 4 0 0 1-7.54 0Z"></path></svg>', H7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M414.39 97.74A224 224 0 1 0 97.61 414.52 224 224 0 1 0 414.39 97.74ZM64 256.13a191.63 191.63 0 0 1 6.7-50.31c7.34 15.8 18 29.45 25.25 45.66 9.37 20.84 34.53 15.06 45.64 33.32 9.86 16.21-.67 36.71 6.71 53.67 5.36 12.31 18 15 26.72 24 8.91 9.08 8.72 21.52 10.08 33.36a305.36 305.36 0 0 0 7.45 41.27c0 .1 0 .21.08.31C117.8 411.13 64 339.8 64 256.13Zm192 192a193.12 193.12 0 0 1-32-2.68c.11-2.71.16-5.24.43-7 2.43-15.9 10.39-31.45 21.13-43.35 10.61-11.74 25.15-19.68 34.11-33 8.78-13 11.41-30.5 7.79-45.69-5.33-22.44-35.82-29.93-52.26-42.1-9.45-7-17.86-17.82-30.27-18.7-5.72-.4-10.51.83-16.18-.63-5.2-1.35-9.28-4.15-14.82-3.42-10.35 1.36-16.88 12.42-28 10.92-10.55-1.41-21.42-13.76-23.82-23.81-3.08-12.92 7.14-17.11 18.09-18.26 4.57-.48 9.7-1 14.09.68 5.78 2.14 8.51 7.8 13.7 10.66 9.73 5.34 11.7-3.19 10.21-11.83-2.23-12.94-4.83-18.21 6.71-27.12 8-6.14 14.84-10.58 13.56-21.61-.76-6.48-4.31-9.41-1-15.86 2.51-4.91 9.4-9.34 13.89-12.27 11.59-7.56 49.65-7 34.1-28.16-4.57-6.21-13-17.31-21-18.83-10-1.89-14.44 9.27-21.41 14.19-7.2 5.09-21.22 10.87-28.43 3-9.7-10.59 6.43-14.06 10-21.46 1.65-3.45 0-8.24-2.78-12.75q5.41-2.28 11-4.23a15.6 15.6 0 0 0 8 3c6.69.44 13-3.18 18.84 1.38 6.48 5 11.15 11.32 19.75 12.88 8.32 1.51 17.13-3.34 19.19-11.86 1.25-5.18 0-10.65-1.2-16a190.83 190.83 0 0 1 105 32.21c-2-.76-4.39-.67-7.34.7-6.07 2.82-14.67 10-15.38 17.12-.81 8.08 11.11 9.22 16.77 9.22 8.5 0 17.11-3.8 14.37-13.62-1.19-4.26-2.81-8.69-5.42-11.37a193.27 193.27 0 0 1 18 14.14c-.09.09-.18.17-.27.27-5.76 6-12.45 10.75-16.39 18.05-2.78 5.14-5.91 7.58-11.54 8.91-3.1.73-6.64 1-9.24 3.08-7.24 5.7-3.12 19.4 3.74 23.51 8.67 5.19 21.53 2.75 28.07-4.66 5.11-5.8 8.12-15.87 17.31-15.86a15.4 15.4 0 0 1 10.82 4.41c3.8 3.94 3.05 7.62 3.86 12.54 1.43 8.74 9.14 4 13.83-.41a192.12 192.12 0 0 1 9.24 18.77c-5.16 7.43-9.26 15.53-21.67 6.87-7.43-5.19-12-12.72-21.33-15.06-8.15-2-16.5.08-24.55 1.47-9.15 1.59-20 2.29-26.94 9.22-6.71 6.68-10.26 15.62-17.4 22.33-13.81 13-19.64 27.19-10.7 45.57 8.6 17.67 26.59 27.26 46 26 19.07-1.27 38.88-12.33 38.33 15.38-.2 9.81 1.85 16.6 4.86 25.71 2.79 8.4 2.6 16.54 3.24 25.21a158 158 0 0 0 4.74 30.07A191.75 191.75 0 0 1 256 448.13Z"></path></svg>', j7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="m481.29 229.47-188.87-113a30.54 30.54 0 0 0-31.09-.39 33.74 33.74 0 0 0-16.76 29.47v79.05L63.85 116.44a30.54 30.54 0 0 0-31.09-.39A33.74 33.74 0 0 0 16 145.52v221A33.74 33.74 0 0 0 32.76 396a30.54 30.54 0 0 0 31.09-.39L244.57 287.4v79.08A33.74 33.74 0 0 0 261.33 396a30.54 30.54 0 0 0 31.09-.39l188.87-113a31.27 31.27 0 0 0 0-53Z"></path></svg>', W7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M80 480a16 16 0 0 1-16-16V68.13a24 24 0 0 1 11.9-20.72C88 40.38 112.38 32 160 32c37.21 0 78.83 14.71 115.55 27.68C305.12 70.13 333.05 80 352 80a183.84 183.84 0 0 0 71-14.5 18 18 0 0 1 25 16.58v219.36a20 20 0 0 1-12 18.31c-8.71 3.81-40.51 16.25-84 16.25-24.14 0-54.38-7.14-86.39-14.71C229.63 312.79 192.43 304 160 304c-36.87 0-55.74 5.58-64 9.11V464a16 16 0 0 1-16 16Z"></path></svg>', q7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M394.23 197.56a300.43 300.43 0 0 0-53.37-90C301.2 61.65 249.05 32 208 32a16 16 0 0 0-15.48 20c13.87 53-14.88 97.07-45.31 143.72C122 234.36 96 274.27 96 320c0 88.22 71.78 160 160 160s160-71.78 160-160c0-43.3-7.32-84.49-21.77-122.44Zm-105.9 221.13C278 429.69 265.05 432 256 432s-22-2.31-32.33-13.31S208 390.24 208 368c0-25.14 8.82-44.28 17.34-62.78 4.95-10.74 10-21.67 13-33.37a8 8 0 0 1 12.49-4.51A126.48 126.48 0 0 1 275 292c18.17 24 29 52.42 29 76 0 22.24-5.42 39.77-15.67 50.69Z"></path></svg>', X7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M483.13 245.38C461.92 149.49 430 98.31 382.65 84.33A107.13 107.13 0 0 0 352 80c-13.71 0-25.65 3.34-38.28 6.88C298.5 91.15 281.21 96 256 96s-42.51-4.84-57.76-9.11C185.6 83.34 173.67 80 160 80a115.74 115.74 0 0 0-31.73 4.32c-47.1 13.92-79 65.08-100.52 161C4.61 348.54 16 413.71 59.69 428.83a56.62 56.62 0 0 0 18.64 3.22c29.93 0 53.93-24.93 70.33-45.34 18.53-23.1 40.22-34.82 107.34-34.82 59.95 0 84.76 8.13 106.19 34.82 13.47 16.78 26.2 28.52 38.9 35.91 16.89 9.82 33.77 12 50.16 6.37 25.82-8.81 40.62-32.1 44-69.24 2.57-28.48-1.39-65.89-12.12-114.37ZM208 240h-32v32a16 16 0 0 1-32 0v-32h-32a16 16 0 0 1 0-32h32v-32a16 16 0 0 1 32 0v32h32a16 16 0 0 1 0 32Zm84 4a20 20 0 1 1 20-20 20 20 0 0 1-20 20Zm44 44a20 20 0 1 1 20-19.95A20 20 0 0 1 336 288Zm0-88a20 20 0 1 1 20-20 20 20 0 0 1-20 20Zm44 44a20 20 0 1 1 20-20 20 20 0 0 1-20 20Z"></path></svg>', Z7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M464 249.93a10.58 10.58 0 0 0-9.36-9.94L429 235.84a5.42 5.42 0 0 1-4.5-4.67c-.49-3.15-1-6.42-1.7-9.52a5.52 5.52 0 0 1 2.63-5.85l22.78-12.65a10.35 10.35 0 0 0 5-12.83l-3.95-10.9a10.32 10.32 0 0 0-12.13-6.51l-25.55 5a5.51 5.51 0 0 1-5.82-2.81c-1.49-2.79-3.11-5.63-4.8-8.42a5.6 5.6 0 0 1 .44-6.5l17-19.64a10.42 10.42 0 0 0 .39-13.76l-7.42-8.91a10.24 10.24 0 0 0-13.58-2l-22.37 13.43a5.39 5.39 0 0 1-6.39-.63c-2.47-2.17-5-4.26-7.37-6.19a5.45 5.45 0 0 1-1.72-6.21l9.26-24.4a10.35 10.35 0 0 0-4.31-13.07l-10.09-5.89a10.3 10.3 0 0 0-13.45 2.83L325 96.28a4.6 4.6 0 0 1-5.6 1.72c-.61-.25-5.77-2.36-9.78-3.7a5.42 5.42 0 0 1-3.74-5.23l.39-26.07a10.48 10.48 0 0 0-8.57-10.88l-11.45-2a10.45 10.45 0 0 0-11.75 7.17L266 82.1a5.46 5.46 0 0 1-5.36 3.65h-9.75a5.5 5.5 0 0 1-5.3-3.67l-8.46-24.67a10.46 10.46 0 0 0-11.77-7.25l-11.47 2a10.46 10.46 0 0 0-8.56 10.79l.4 26.16a5.45 5.45 0 0 1-3.86 5.25c-2.29.89-7.26 2.79-9.52 3.63-2 .72-4.18-.07-5.94-2.1l-16.26-20A10.3 10.3 0 0 0 156.69 73l-10.06 5.83A10.36 10.36 0 0 0 142.31 92l9.25 24.34a5.54 5.54 0 0 1-1.7 6.23c-2.43 2-4.92 4-7.4 6.22a5.38 5.38 0 0 1-6.35.64L114 115.74a10.4 10.4 0 0 0-13.61 2L93 126.63a10.31 10.31 0 0 0 .37 13.75L110.45 160a5.42 5.42 0 0 1 .45 6.45c-1.71 2.72-3.34 5.58-4.82 8.44a5.53 5.53 0 0 1-5.86 2.82l-25.51-4.93a10.34 10.34 0 0 0-12.14 6.51l-4 10.88a10.38 10.38 0 0 0 5 12.85l22.78 12.65a5.39 5.39 0 0 1 2.65 5.92l-.24 1.27c-.52 2.79-1 5.43-1.46 8.24a5.48 5.48 0 0 1-4.46 4.64l-25.69 4.15A10.42 10.42 0 0 0 48 250.16v11.58A10.26 10.26 0 0 0 57.16 272l25.68 4.14a5.41 5.41 0 0 1 4.5 4.67c.49 3.16 1 6.42 1.7 9.52a5.52 5.52 0 0 1-2.63 5.85l-22.77 12.67a10.35 10.35 0 0 0-5 12.83l4 10.9a10.33 10.33 0 0 0 12.13 6.51l25.55-4.95a5.49 5.49 0 0 1 5.82 2.81c1.5 2.8 3.11 5.63 4.8 8.42a5.58 5.58 0 0 1-.44 6.5l-17 19.63a10.41 10.41 0 0 0-.5 13.77l7.41 8.91a10.23 10.23 0 0 0 13.58 2l22.37-13.43a5.39 5.39 0 0 1 6.39.63c2.48 2.17 5 4.26 7.37 6.19a5.47 5.47 0 0 1 1.73 6.21l-9.27 24.4a10.35 10.35 0 0 0 4.31 13.07l10.11 5.84a10.3 10.3 0 0 0 13.45-2.82L187 415.92c1.4-1.73 3.6-2.5 5.23-1.84 3.48 1.44 5.81 2.25 9.94 3.63a5.44 5.44 0 0 1 3.75 5.23l-.4 26.05a10.5 10.5 0 0 0 8.57 10.88l11.45 2a10.43 10.43 0 0 0 11.75-7.17l8.5-24.77a5.45 5.45 0 0 1 5.36-3.65h9.75a5.49 5.49 0 0 1 5.3 3.67l8.47 24.67a10.48 10.48 0 0 0 10 7.41 9.74 9.74 0 0 0 1.78-.16l11.47-2a10.46 10.46 0 0 0 8.56-10.79l-.4-26.16a5.43 5.43 0 0 1 3.75-5.2c3.84-1.29 6.54-2.33 8.91-3.25l.6-.23c3.1-1.07 4.6.23 5.47 1.31l16.75 20.63A10.3 10.3 0 0 0 355 439l10.07-5.83a10.35 10.35 0 0 0 4.31-13.1l-9.24-24.34a5.52 5.52 0 0 1 1.69-6.23c2.43-2 4.92-4 7.4-6.22a5.39 5.39 0 0 1 6.38-.62l22.39 13.4a10.39 10.39 0 0 0 13.61-2l7.4-8.9a10.31 10.31 0 0 0-.37-13.75l-17.06-19.67a5.42 5.42 0 0 1-.45-6.45c1.71-2.71 3.34-5.57 4.82-8.44a5.55 5.55 0 0 1 5.86-2.82l25.48 4.97a10.34 10.34 0 0 0 12.14-6.51l3.95-10.88a10.37 10.37 0 0 0-5-12.84l-22.8-12.67a5.4 5.4 0 0 1-2.61-5.89l.24-1.27c.52-2.79 1-5.43 1.46-8.24a5.48 5.48 0 0 1 4.46-4.64l25.69-4.14a10.43 10.43 0 0 0 9.18-10.28v-11.71Zm-282.45 94a15.8 15.8 0 0 1-25.47 2.66 135.06 135.06 0 0 1 .42-181.65 15.81 15.81 0 0 1 25.5 2.77l45.65 80.35a15.85 15.85 0 0 1 0 15.74ZM256 391.11a134.75 134.75 0 0 1-28.31-3 15.81 15.81 0 0 1-10.23-23.36l46-80a15.79 15.79 0 0 1 13.7-7.93h92.14a15.8 15.8 0 0 1 15.1 20.53c-17.49 54.32-68.4 93.76-128.4 93.76Zm7.51-163.9L218 147.07a15.81 15.81 0 0 1 10.31-23.3 134 134 0 0 1 27.69-2.88c60 0 110.91 39.44 128.37 93.79a15.8 15.8 0 0 1-15.1 20.53h-92a15.78 15.78 0 0 1-13.76-8Z"></path></svg>', Y7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M79.2 211.44c15.52-8.82 34.91-2.28 43.31 13.68l41.38 84.41a7 7 0 0 0 8.93 3.43 7 7 0 0 0 4.41-6.52V72c0-13.91 12.85-24 26.77-24s26 10.09 26 24v156.64A11.24 11.24 0 0 0 240.79 240 11 11 0 0 0 252 229V24c0-13.91 10.94-24 24.86-24S302 10.09 302 24v204.64A11.24 11.24 0 0 0 312.79 240 11 11 0 0 0 324 229V56c0-13.91 12.08-24 26-24s26 11.09 26 25v187.64A11.24 11.24 0 0 0 386.79 256 11 11 0 0 0 398 245V120c0-13.91 11.08-24 25-24s25.12 10.22 25 24v216c0 117.41-72 176-160 176h-16c-88 0-115.71-39.6-136-88L67.33 255c-6.66-18-3.64-34.75 11.87-43.56Z"></path></svg>', J7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M352.92 80C288 80 256 144 256 144s-32-64-96.92-64c-52.76 0-94.54 44.14-95.08 96.81-1.1 109.33 86.73 187.08 183 252.42a16 16 0 0 0 18 0c96.26-65.34 184.09-143.09 183-252.42-.54-52.67-42.32-96.81-95.08-96.81Z"></path></svg>', K7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M256 448a32 32 0 0 1-18-5.57c-78.59-53.35-112.62-89.93-131.39-112.8-40-48.75-59.15-98.8-58.61-153C48.63 114.52 98.46 64 159.08 64c44.08 0 74.61 24.83 92.39 45.51a6 6 0 0 0 9.06 0C278.31 88.81 308.84 64 352.92 64c60.62 0 110.45 50.52 111.08 112.64.54 54.21-18.63 104.26-58.61 153-18.77 22.87-52.8 59.45-131.39 112.8a32 32 0 0 1-18 5.56Z"></path></svg>', Q7 = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M352.92 64c-48.09 0-80 29.54-96.92 51-16.88-21.49-48.83-51-96.92-51C98.46 64 48.63 114.54 48 176.65c-.54 54.21 18.63 104.27 58.61 153 18.77 22.88 52.8 59.46 131.39 112.81a31.84 31.84 0 0 0 36 0c78.59-53.35 112.62-89.93 131.39-112.81 40-48.74 59.15-98.8 58.61-153C463.37 114.54 413.54 64 352.92 64ZM256 416V207.58c0-19.63 5.23-38.76 14.21-56.22a1.19 1.19 0 0 1 .08-.16 123 123 0 0 1 21.77-28.51C310.19 105 330.66 96 352.92 96c43.15 0 78.62 36.32 79.07 81C433 281.61 343.63 356.51 256 416Z"></path></svg>', tH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M261.56 101.28a8 8 0 0 0-11.06 0L66.4 277.15a8 8 0 0 0-2.47 5.79L63.9 448a32 32 0 0 0 32 32H192a16 16 0 0 0 16-16V328a8 8 0 0 1 8-8h80a8 8 0 0 1 8 8v136a16 16 0 0 0 16 16h96.06a32 32 0 0 0 32-32V282.94a8 8 0 0 0-2.47-5.79Z"></path><path d="m490.91 244.15-74.8-71.56V64a16 16 0 0 0-16-16h-48a16 16 0 0 0-16 16v32l-57.92-55.38C272.77 35.14 264.71 32 256 32c-8.68 0-16.72 3.14-22.14 8.63l-212.7 203.5c-6.22 6-7 15.87-1.34 22.37A16 16 0 0 0 43 267.56L250.5 69.28a8 8 0 0 1 11.06 0l207.52 198.28a16 16 0 0 0 22.59-.44c6.14-6.36 5.63-16.86-.76-22.97Z"></path></svg>', eH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M415.7 427.13c-8.74-76.89-43.83-108.76-69.46-132C328.52 279 320 270.61 320 256c0-14.41 8.49-22.64 26.16-38.44 25.93-23.17 61.44-54.91 69.56-132.84a47 47 0 0 0-12-36.26A50.3 50.3 0 0 0 366.39 32H145.61a50.34 50.34 0 0 0-37.39 16.46 47.05 47.05 0 0 0-11.94 36.26c8.09 77.68 43.47 109.19 69.3 132.19C183.42 232.8 192 241.09 192 256c0 15.1-8.6 23.56-26.5 39.75-25.5 23.1-60.5 54.73-69.2 131.38a46.59 46.59 0 0 0 11.7 36.2A50.44 50.44 0 0 0 145.61 480h220.78A50.44 50.44 0 0 0 404 463.33a46.59 46.59 0 0 0 11.7-36.2ZM343.3 432H169.13c-15.6 0-20-18-9.06-29.16C186.55 376 240 356.78 240 326V224c0-19.85-38-35-61.51-67.2-3.88-5.31-3.49-12.8 6.37-12.8h142.73c8.41 0 10.22 7.43 6.4 12.75C310.82 189 272 204.05 272 224v102c0 30.53 55.71 47 80.4 76.87 9.95 12.04 6.47 29.13-9.1 29.13Z"></path></svg>', nH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="48" d="M256 256s-48-96-126-96c-54.12 0-98 43-98 96s43.88 96 98 96c30 0 56.45-13.18 78-32M256 256s48 96 126 96c54.12 0 98-43 98-96s-43.88-96-98-96c-29.37 0-56.66 13.75-78 32"></path></svg>', iH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448ZM248 315.85l-51.79-51.79a2 2 0 0 0-3.39 1.69 64.11 64.11 0 0 0 53.49 53.49 2 2 0 0 0 1.69-3.39ZM264 196.15 315.87 248a2 2 0 0 0 3.4-1.69 64.13 64.13 0 0 0-53.55-53.55 2 2 0 0 0-1.72 3.39Z"></path><path d="M491 273.36a32.2 32.2 0 0 0-.1-34.76c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.68 96a226.54 226.54 0 0 0-71.82 11.79 4 4 0 0 0-1.56 6.63l47.24 47.24a4 4 0 0 0 3.82 1.05 96 96 0 0 1 116 116 4 4 0 0 0 1.05 3.81l67.95 68a4 4 0 0 0 5.4.24 343.81 343.81 0 0 0 67.24-77.4ZM256 352a96 96 0 0 1-93.3-118.63 4 4 0 0 0-1.05-3.81l-66.84-66.87a4 4 0 0 0-5.41-.23c-24.39 20.81-47 46.13-67.67 75.72a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.39 76.14 98.28 100.65C162.06 402 207.92 416 255.68 416a238.22 238.22 0 0 0 72.64-11.55 4 4 0 0 0 1.61-6.64l-47.47-47.46a4 4 0 0 0-3.81-1.05A96 96 0 0 1 256 352Z"></path></svg>', sH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M218.1 167.17c0 13 0 25.6 4.1 37.4-43.1 50.6-156.9 184.3-167.5 194.5a20.17 20.17 0 0 0-6.7 15c0 8.5 5.2 16.7 9.6 21.3 6.6 6.9 34.8 33 40 28 15.4-15 18.5-19 24.8-25.2 9.5-9.3-1-28.3 2.3-36s6.8-9.2 12.5-10.4 15.8 2.9 23.7 3c8.3.1 12.8-3.4 19-9.2 5-4.6 8.6-8.9 8.7-15.6.2-9-12.8-20.9-3.1-30.4s23.7 6.2 34 5 22.8-15.5 24.1-21.6-11.7-21.8-9.7-30.7c.7-3 6.8-10 11.4-11s25 6.9 29.6 5.9c5.6-1.2 12.1-7.1 17.4-10.4 15.5 6.7 29.6 9.4 47.7 9.4 68.5 0 124-53.4 124-119.2S408.5 48 340 48s-121.9 53.37-121.9 119.17ZM400 144a32 32 0 1 1-32-32 32 32 0 0 1 32 32Z"></path></svg>', oH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M208 432h-48a16 16 0 0 1-16-16V96a16 16 0 0 1 16-16h48a16 16 0 0 1 16 16v320a16 16 0 0 1-16 16ZM352 432h-48a16 16 0 0 1-16-16V96a16 16 0 0 1 16-16h48a16 16 0 0 1 16 16v320a16 16 0 0 1-16 16Z"></path></svg>', rH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M133 440a35.37 35.37 0 0 1-17.5-4.67c-12-6.8-19.46-20-19.46-34.33V111c0-14.37 7.46-27.53 19.46-34.33a35.13 35.13 0 0 1 35.77.45l247.85 148.36a36 36 0 0 1 0 61l-247.89 148.4A35.5 35.5 0 0 1 133 440Z"></path></svg>', aH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path fill="none" stroke="currentColor" d="M200 144h40v-40a40 40 0 1 0-40 40ZM352 104a40 40 0 0 0-80 0v40h40a40 40 0 0 0 40-40Z"></path><path d="M80 416a64 64 0 0 0 64 64h92a4 4 0 0 0 4-4V292a4 4 0 0 0-4-4H88a8 8 0 0 0-8 8ZM240 252V144h32v108a4 4 0 0 0 4 4h140a47.93 47.93 0 0 0 16-2.75A48.09 48.09 0 0 0 464 208v-16a48 48 0 0 0-48-48h-40.54a2 2 0 0 1-1.7-3A72 72 0 0 0 256 58.82 72 72 0 0 0 138.24 141a2 2 0 0 1-1.7 3H96a48 48 0 0 0-48 48v16a48.09 48.09 0 0 0 32 45.25A47.93 47.93 0 0 0 96 256h140a4 4 0 0 0 4-4Zm32-148a40 40 0 1 1 40 40h-40Zm-74.86-39.9A40 40 0 0 1 240 104v40h-40a40 40 0 0 1-2.86-79.89ZM276 480h92a64 64 0 0 0 64-64V296a8 8 0 0 0-8-8H276a4 4 0 0 0-4 4v184a4 4 0 0 0 4 4Z"></path></svg>', cH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="m30.71 229.47 188.87-113a30.54 30.54 0 0 1 31.09-.39 33.74 33.74 0 0 1 16.76 29.47v79.05l180.72-108.16a30.54 30.54 0 0 1 31.09-.39A33.74 33.74 0 0 1 496 145.52v221A33.73 33.73 0 0 1 479.24 396a30.54 30.54 0 0 1-31.09-.39L267.43 287.4v79.08A33.73 33.73 0 0 1 250.67 396a30.54 30.54 0 0 1-31.09-.39l-188.87-113a31.27 31.27 0 0 1 0-53Z"></path></svg>', lH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M328.85 156.79a26.69 26.69 0 1 0 18.88 7.81 26.6 26.6 0 0 0-18.88-7.81Z"></path><path d="M477.44 50.06a.29.29 0 0 1 0-.09 20.4 20.4 0 0 0-15.13-15.3c-29.8-7.27-76.68.48-128.63 21.28-52.36 21-101.42 52-134.58 85.22A320.7 320.7 0 0 0 169.55 175c-22.33-1-42 2.18-58.57 9.41-57.74 25.41-74.23 90.44-78.62 117.14a25 25 0 0 0 27.19 29h.13l64.32-7.02c.08.82.17 1.57.24 2.26a34.36 34.36 0 0 0 9.9 20.72l31.39 31.41a34.27 34.27 0 0 0 20.71 9.91l2.15.23-7 64.24v.13A25 25 0 0 0 206 480a25.25 25.25 0 0 0 4.15-.34C237 475.34 302 459.05 327.34 401c7.17-16.46 10.34-36.05 9.45-58.34a314.78 314.78 0 0 0 33.95-29.55c33.43-33.26 64.53-81.92 85.31-133.52 20.69-51.36 28.48-98.59 21.39-129.53ZM370.38 224.94a58.77 58.77 0 1 1 0-83.07 58.3 58.3 0 0 1 0 83.07Z"></path><path d="M161.93 386.44a16 16 0 0 0-11 2.67c-6.39 4.37-12.81 8.69-19.29 12.9-13.11 8.52-28.79-6.44-21-20l12.15-21a16 16 0 0 0-15.16-24.91A61.25 61.25 0 0 0 72 353.56c-3.66 3.67-14.79 14.81-20.78 57.26A357.94 357.94 0 0 0 48 447.59 16 16 0 0 0 64 464h.4a359.87 359.87 0 0 0 36.8-3.2c42.47-6 53.61-17.14 57.27-20.8a60.49 60.49 0 0 0 17.39-35.74 16 16 0 0 0-13.93-17.82Z"></path></svg>', uH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="m465.94 119.76-73.7-73.7A47.68 47.68 0 0 0 358.3 32H96a64 64 0 0 0-64 64v320a64 64 0 0 0 64 64h320a64 64 0 0 0 64-64V153.7a47.68 47.68 0 0 0-14.06-33.94ZM120 112h176a8 8 0 0 1 8 8v48a8 8 0 0 1-8 8H120a8 8 0 0 1-8-8v-48a8 8 0 0 1 8-8Zm139.75 319.91a80 80 0 1 1 76.16-76.16 80.06 80.06 0 0 1-76.16 76.16Z"></path><path d="M256 304A48 48 0 1 0 256 400 48 48 0 1 0 256 304z"></path></svg>', hH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="m476.59 227.05-.16-.07L49.35 49.84A23.56 23.56 0 0 0 27.14 52 24.65 24.65 0 0 0 16 72.59v113.29a24 24 0 0 0 19.52 23.57l232.93 43.07a4 4 0 0 1 0 7.86L35.53 303.45A24 24 0 0 0 16 327v113.31A23.57 23.57 0 0 0 26.59 460a23.94 23.94 0 0 0 13.22 4 24.55 24.55 0 0 0 9.52-1.93L476.4 285.94l.19-.09a32 32 0 0 0 0-58.8Z"></path></svg>', dH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M479.07 111.35a16 16 0 0 0-13.15-14.75C379.89 81.18 343.69 69.12 266 34.16c-7.76-2.89-12.57-2.84-20 0-77.69 35-113.89 47-199.92 62.44a16 16 0 0 0-13.15 14.75c-3.85 61.1 4.34 118 24.36 169.15a348.86 348.86 0 0 0 71.43 112.41c44.67 47.43 94.2 75.12 119.74 85.6a20 20 0 0 0 15.11 0c27-10.92 74.69-37.82 119.71-85.62a348.86 348.86 0 0 0 71.43-112.39c20.02-51.14 28.21-108.05 24.36-169.15Z"></path></svg>', mH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M402 76.94C362.61 37.63 310.78 16 256 16h-.37A208 208 0 0 0 48 224v100.67A79.62 79.62 0 0 0 98.29 399l23.71 9.42a15.92 15.92 0 0 1 9.75 11.72l10 50.13A32.09 32.09 0 0 0 173.12 496H184a8 8 0 0 0 8-8v-39.55c0-8.61 6.62-16 15.23-16.43A16 16 0 0 1 224 448v40a8 8 0 0 0 8 8 8 8 0 0 0 8-8v-39.55c0-8.61 6.62-16 15.23-16.43A16 16 0 0 1 272 448v40a8 8 0 0 0 8 8 8 8 0 0 0 8-8v-39.55c0-8.61 6.62-16 15.23-16.43A16 16 0 0 1 320 448v40a8 8 0 0 0 8 8h10.88a32.09 32.09 0 0 0 31.38-25.72l10-50.14a16 16 0 0 1 9.74-11.72l23.71-9.42A79.62 79.62 0 0 0 464 324.67v-99c0-56-22-108.81-62-148.73ZM171.66 335.88a56 56 0 1 1 52.22-52.22 56 56 0 0 1-52.22 52.22ZM281 397.25a16.37 16.37 0 0 1-9.3 2.75h-31.4a16.37 16.37 0 0 1-9.28-2.75 16 16 0 0 1-6.6-16.9l15.91-47.6C243 326 247.25 321 254 320.13c8.26-1 14 2.87 17.61 12.22l16 48a16 16 0 0 1-6.61 16.9Zm66.68-61.37a56 56 0 1 1 52.22-52.22 56 56 0 0 1-52.24 52.22Z"></path></svg>', fH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M425.7 118.25A240 240 0 0 0 76.32 447l.18.2c.33.35.64.71 1 1.05.74.84 1.58 1.79 2.57 2.78a41.17 41.17 0 0 0 60.36-.42 157.13 157.13 0 0 1 231.26 0 41.18 41.18 0 0 0 60.65.06l3.21-3.5.18-.2a239.93 239.93 0 0 0-10-328.76ZM240 128a16 16 0 0 1 32 0v32a16 16 0 0 1-32 0ZM128 304H96a16 16 0 0 1 0-32h32a16 16 0 0 1 0 32Zm48.8-95.2a16 16 0 0 1-22.62 0l-22.63-22.62a16 16 0 0 1 22.63-22.63l22.62 22.63a16 16 0 0 1 0 22.62Zm149.3 23.1-47.5 75.5a31 31 0 0 1-7 7 30.11 30.11 0 0 1-35-49l75.5-47.5a10.23 10.23 0 0 1 11.7 0 10.06 10.06 0 0 1 2.3 14Zm31.72-23.1a16 16 0 0 1-22.62-22.62l22.62-22.63a16 16 0 0 1 22.63 22.63Zm65.88 227.6ZM416 304h-32a16 16 0 0 1 0-32h32a16 16 0 0 1 0 32Z"></path></svg>', pH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="32" d="M480 208H308L256 48l-52 160H32l140 96-54 160 138-100 138 100-54-160Z"></path></svg>', _H = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M394 480a16 16 0 0 1-9.39-3L256 383.76 127.39 477a16 16 0 0 1-24.55-18.08L153 310.35 23 221.2a16 16 0 0 1 9-29.2h160.38l48.4-148.95a16 16 0 0 1 30.44 0l48.4 149H480a16 16 0 0 1 9.05 29.2L359 310.35l50.13 148.53A16 16 0 0 1 394 480Z"></path></svg>', gH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="32" d="M480 208H308L256 48l-52 160H32l140 96-54 160 138-100 138 100-54-160Z"></path><path d="M256 48 256 364 118 464 172 304 32 208 204 208 256 48z"></path></svg>', vH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M392 432H120a40 40 0 0 1-40-40V120a40 40 0 0 1 40-40h272a40 40 0 0 1 40 40v272a40 40 0 0 1-40 40Z"></path></svg>', bH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M107.56 250a16 16 0 0 0-21.85-5.86L36 272.81a39.71 39.71 0 0 0-18.8 24.91 40.9 40.9 0 0 0 4.55 30.35l4.36 7.54a40 40 0 0 0 54.62 14.62l49.67-28.63a16 16 0 0 0 5.87-21.86Z"></path><path d="M382.84 440.8 288.72 254a2 2 0 0 1 .79-2.63l8.3-4.79a16 16 0 0 0 5.86-21.86l-47.53-82.33a16 16 0 0 0-21.86-5.87l-86.38 49.8a39.73 39.73 0 0 0-18.65 24.28 34.82 34.82 0 0 0-1.37 9.76c.06 7.6 9.2 22.7 18.12 38.28 9.59 16.75 19.24 33.88 26.34 38.15 4.52 2.72 12.5 4.9 19.21 4.9h.84l-79.32 171.6a16 16 0 1 0 29.05 13.42l93.68-202.65a7.94 7.94 0 0 1 3.26-3.57l19.21-11.08a2 2 0 0 1 2.78.84l93.21 185a16 16 0 0 0 28.58-14.4ZM490.21 115.74 444.09 36a40.08 40.08 0 0 0-54.63-14.62l-93.34 53.78a39.69 39.69 0 0 0-18.65 24.28 32.76 32.76 0 0 0-1.27 13.25c1.74 12.62 13 30.4 26.41 53.89 13.58 23.73 28.91 50.48 36.93 56.27a40.18 40.18 0 0 0 23.18 7.37 39.77 39.77 0 0 0 19.92-5.34L476 171.07a39.72 39.72 0 0 0 18.79-24.84 41 41 0 0 0-4.58-30.49Z"></path></svg>', yH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path fill="none" stroke="currentColor" d="M296 64h-80a7.91 7.91 0 0 0-8 8v24h96V72a7.91 7.91 0 0 0-8-8Z"></path><path d="M432 96h-96V72a40 40 0 0 0-40-40h-80a40 40 0 0 0-40 40v24H80a16 16 0 0 0 0 32h17l19 304.92c1.42 26.85 22 47.08 48 47.08h184c26.13 0 46.3-19.78 48-47l19-305h17a16 16 0 0 0 0-32ZM192.57 416H192a16 16 0 0 1-16-15.43l-8-224a16 16 0 1 1 32-1.14l8 224A16 16 0 0 1 192.57 416ZM272 400a16 16 0 0 1-32 0V176a16 16 0 0 1 32 0Zm32-304h-96V72a7.91 7.91 0 0 1 8-8h80a7.91 7.91 0 0 1 8 8Zm32 304.57A16 16 0 0 1 320 416h-.58A16 16 0 0 1 304 399.43l8-224a16 16 0 1 1 32 1.14Z"></path></svg>', xH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M256 192A64 64 0 1 0 256 320 64 64 0 1 0 256 192z"></path><path d="M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96c-42.52 0-84.33 12.15-124.27 36.11-40.73 24.43-77.63 60.12-109.68 106.07a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416c46.71 0 93.81-14.43 136.2-41.72 38.46-24.77 72.72-59.66 99.08-100.92a32.2 32.2 0 0 0-.1-34.76ZM256 352a96 96 0 1 1 96-96 96.11 96.11 0 0 1-96 96Z"></path></svg>', wH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M265.12 60.12a12 12 0 0 0-18.23 0C215.23 97.15 112 225.17 112 320c0 88.37 55.64 144 144 144s144-55.63 144-144c0-94.83-103.23-222.85-134.88-259.88ZM272 412a12 12 0 0 1-11.34-16 11.89 11.89 0 0 1 11.41-8A60.06 60.06 0 0 0 332 328.07a11.89 11.89 0 0 1 8-11.41A12 12 0 0 1 356 328a84.09 84.09 0 0 1-84 84Z"></path></svg>', SH = '<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible; color: currentcolor;"><path d="M469.54 120.52a16 16 0 0 0-25.54-4L382.56 178a16.12 16.12 0 0 1-22.63 0l-26.56-26.6a16 16 0 0 1 0-22.63l61.18-61.19a16 16 0 0 0-4.78-25.92C343.56 21 285.88 31.78 249.51 67.88c-30.9 30.68-40.11 78.62-25.25 131.53a15.89 15.89 0 0 1-4.49 16L53.29 367.46a64.17 64.17 0 1 0 90.6 90.64l153.68-166.85a15.9 15.9 0 0 1 15.77-4.57 179.3 179.3 0 0 0 46.22 6.37c33.4 0 62.71-10.81 83.85-31.64 39.15-38.57 45.12-103.99 26.13-140.89ZM99.48 447.15a32 32 0 1 1 28.34-28.35 32 32 0 0 1-28.34 28.35Z"></path></svg>', gA = /* @__PURE__ */ Object.assign({
  "./icons/ArrowDown.svg": D7,
  "./icons/ArrowLeft.svg": V7,
  "./icons/ArrowRight.svg": L7,
  "./icons/ArrowUp.svg": N7,
  "./icons/CaretDown.svg": z7,
  "./icons/CaretLeft.svg": k7,
  "./icons/CaretRight.svg": U7,
  "./icons/CaretUp.svg": O7,
  "./icons/Close.svg": $7,
  "./icons/Compass.svg": F7,
  "./icons/Diamond.svg": G7,
  "./icons/Earth.svg": H7,
  "./icons/FastForward.svg": j7,
  "./icons/Flag.svg": W7,
  "./icons/Flame.svg": q7,
  "./icons/GameController.svg": X7,
  "./icons/Gear.svg": Z7,
  "./icons/Hand.svg": Y7,
  "./icons/HeartEmpty.svg": J7,
  "./icons/HeartFull.svg": K7,
  "./icons/HeartHalf.svg": Q7,
  "./icons/Home.svg": tH,
  "./icons/HourGlass.svg": eH,
  "./icons/Infinity.svg": nH,
  "./icons/Invisible.svg": iH,
  "./icons/Key.svg": sH,
  "./icons/Pause.svg": oH,
  "./icons/Play.svg": rH,
  "./icons/Present.svg": aH,
  "./icons/Rewind.svg": cH,
  "./icons/Rocket.svg": lH,
  "./icons/Save.svg": uH,
  "./icons/Send.svg": hH,
  "./icons/Shield.svg": dH,
  "./icons/Skull.svg": mH,
  "./icons/Speedometer.svg": fH,
  "./icons/StarEmpty.svg": pH,
  "./icons/StarFull.svg": _H,
  "./icons/StarHalf.svg": gH,
  "./icons/Stop.svg": vH,
  "./icons/Telescipe.svg": bH,
  "./icons/Trash.svg": yH,
  "./icons/Visible.svg": xH,
  "./icons/Water.svg": wH,
  "./icons/Wrench.svg": SH
}), J2 = {};
for (const n in gA) {
  const t = n.replace("./icons/", "").replace(".svg", "");
  J2[t] = gA[n];
}
function AH(n) {
  return J2[n];
}
h(AH, "getIcon");
function MH() {
  return Object.keys(J2).sort();
}
h(MH, "getAvailableIcons");
function CH(n) {
  n.querySelectorAll("[data-icon]").forEach((e) => {
    const s = e.getAttribute("data-icon");
    if (!s) return;
    const i = AH(s);
    if (!i) {
      console.warn(`[Icons] Icon "${s}" not found. Available: ${MH().join(", ")}`);
      return;
    }
    const o = document.createElement("span"), r = e.getAttribute("data-icon-class");
    o.className = r ? `icon ${r}` : "icon w-6 h-6", o.innerHTML = i, e.insertBefore(o, e.firstChild), e.removeAttribute("data-icon");
  });
}
h(CH, "injectIcons");
const rx = class rx extends wu {
  constructor(t, e) {
    super(t, "ui"), this.cleanupFunctions = [], this.backgroundColor = e.backgroundColor, this.setBackgroundColor(this.backgroundColor), this.html = e.html, this.style = e.style, this.suspendBehind = e.suspendBehind, this.scripts = e.scripts;
  }
  mount(t, e) {
    var s, i;
    if (this.style) {
      const o = document.createElement("style");
      o.textContent = this.style, this.root.appendChild(o);
    }
    this.root.innerHTML += this.html, CH(this.root), t.appendChild(this.root), this._isMounted = !0, this.discoverAndRegisterVirtualControls(), this.cleanupFunctions = (i = (s = this.scripts) == null ? void 0 : s.map((o) => {
      try {
        const a = new Function(
          "root",
          "sceneManager",
          "EventBus",
          "GlobalState",
          o
        )(this.root, e, Hi, Cp);
        return typeof a == "function" ? a : () => {
        };
      } catch (r) {
        return console.error(`[UIScene] Error executing script in scene "${this.name}":`, r), () => {
        };
      }
    })) != null ? i : [];
  }
  discoverAndRegisterVirtualControls() {
    this.root.querySelectorAll(".joystick-zone").forEach((t) => {
      t.id && jc.attachJoystickById(t.id, t);
    }), this.root.querySelectorAll(".dpad").forEach((t) => {
      t.id && No.attachDPad(`#${t.id}`, t);
    }), this.root.querySelectorAll(".virtual-button").forEach((t) => {
      t.id && Xi.attachButton(`#${t.id}`, t);
    });
  }
  unmount() {
    this.cleanupFunctions.forEach((t) => {
      try {
        t();
      } catch (e) {
        console.error(`[UIScene] Error during cleanup in scene "${this.name}":`, e);
      }
    }), this.cleanupFunctions = [], this.unregisterVirtualControls(), this.root.parentElement && this.root.parentElement.removeChild(this.root), this._isMounted = !1;
  }
  unregisterVirtualControls() {
    this.root.querySelectorAll(".joystick-zone").forEach((t) => {
      t.id && jc.detachJoystick(t.id);
    }), this.root.querySelectorAll(".dpad").forEach((t) => {
      t.id && No.detachDPad(`#${t.id}`);
    }), this.root.querySelectorAll(".virtual-button").forEach((t) => {
      t.id && Xi.detachButton(`#${t.id}`);
    });
  }
  update(t, e) {
  }
  draw(t) {
  }
};
h(rx, "UIScene");
let Eg = rx;
const ax = class ax {
  constructor(t, e, s, i, o) {
    this.systems = s, this.useEditor = i, this.assetManager = o, this.scenePool = /* @__PURE__ */ new Map(), this.pausedScene = null, this.sceneDefinitions = new Map(t.map((r) => [r.name, r])), this.rootScene = new Zr("Root"), this.rootScene.push(this.getOrCreateScene(e)), window.pushScene = (r) => this.pushScene(r), window.popScene = () => this.popScene();
  }
  createSceneFromDef(t) {
    if (t.type === "2d") {
      const e = new ur(t.name, t, this.useEditor, this.assetManager), s = e.nameToEid, i = /* @__PURE__ */ h((r) => {
        var l;
        const a = Io(e.world);
        r.name && (s.has(r.name) && console.warn(`Entity name "${r.name}" already exists. Names should be unique.`), s.set(r.name, a));
        for (const c of (l = r.children) != null ? l : []) i(c);
      }, "createAll");
      for (const r of t.entities) i(r);
      const o = /* @__PURE__ */ h((r, a) => {
        var d, f;
        const l = r.name ? s.get(r.name) : Io(e.world);
        let c;
        const u = [];
        for (const p of r.components)
          if (p.type === "Child") {
            const v = p.attributes || {};
            c = v["parent-name"] || v.parentName;
          } else
            u.push(p);
        for (const p of u) EH(e, l, p);
        const m = c != null ? c : a;
        if (m && r.name) {
          const p = s.get(m);
          p !== void 0 ? (wn(e.world, ti.component, l), ti.component.parentEid[l] = p) : console.warn(`❌ Parent entity not found: "${m}" for child "${r.name}"`);
        }
        for (const p of (d = r.children) != null ? d : []) o(p, (f = r.name) != null ? f : a);
      }, "addAll");
      for (const r of t.entities) o(r);
      return e.customSystems.push(...this.systems), e;
    }
    if (t.type === "3d") {
      const e = new gc(t.name, t, this.useEditor, this.assetManager), s = e.nameToEid, i = /* @__PURE__ */ h((r) => {
        var l;
        const a = Io(e.world);
        r.name && (s.has(r.name) && console.warn(`Entity name "${r.name}" already exists. Names should be unique.`), s.set(r.name, a), console.log(`✅ Registered entity: ${r.name} -> ${a}`));
        for (const c of (l = r.children) != null ? l : []) i(c);
      }, "createAll");
      for (const r of t.entities) i(r);
      console.log("📋 Entity name map:", Array.from(s.entries()));
      const o = /* @__PURE__ */ h((r, a) => {
        var d, f;
        const l = r.name ? s.get(r.name) : Io(e.world);
        let c;
        const u = [];
        for (const p of r.components)
          if (p.type === "Child") {
            const v = p.attributes || {};
            c = v["parent-name"] || v.parentName;
          } else
            u.push(p);
        for (const p of u) TH(e, l, p);
        const m = c != null ? c : a;
        if (m && r.name) {
          const p = s.get(m);
          p !== void 0 ? (wn(e.world, ti.component, l), ti.component.parentEid[l] = p) : console.warn(`Parent entity not found: ${m}`);
        }
        for (const p of (d = r.children) != null ? d : []) o(p, (f = r.name) != null ? f : a);
      }, "addAll");
      for (const r of t.entities) o(r);
      return e.customSystems.push(...this.systems), console.log(`✅ Attached ${this.systems.length} systems to 3D scene ${e.name}`), e;
    }
    return t.type === "ui" ? new Eg(t.name, t) : new Zr(
      t.name,
      t.children.map((e) => this.createSceneFromDef(e))
    );
  }
  instantiateScene(t) {
    var i, o;
    const e = this.sceneDefinitions.get(t);
    if (!e) throw new Error(`Scene "${t}" not found in registry`);
    console.log("🎬 Instantiating scene:", t, "type:", e.type);
    const s = this.createSceneFromDef(e);
    return console.log("✅ Scene instantiated, nameToEid size:", (o = (i = s.nameToEid) == null ? void 0 : i.size) != null ? o : "N/A"), s;
  }
  getOrCreateScene(t) {
    const e = this.scenePool.get(t);
    if (e && e.length > 0) {
      console.log("♻️ Reusing scene from pool:", t);
      const s = e.pop();
      return (s instanceof gc || s instanceof ur) && (s.customSystems.length = 0, s.customSystems.push(...this.systems), console.log(`✅ Re-attached ${this.systems.length} systems to reused scene ${s.name}`)), s;
    }
    return console.log("🆕 Creating new scene:", t), this.instantiateScene(t);
  }
  pushScene(t) {
    const e = this.getOrCreateScene(t);
    this.rootScene.push(e);
  }
  popScene() {
    var e;
    const t = this.rootScene.pop();
    if (t) {
      const s = (e = this.scenePool.get(t.name)) != null ? e : [];
      s.push(t), this.scenePool.set(t.name, s);
    }
  }
  mount(t) {
    this.rootScene.mount(t, this);
  }
  update(t, e) {
    this.rootScene.update(t, e);
  }
  draw(t) {
    this.rootScene.draw(t);
  }
  getActiveCanvasScene() {
    const t = /* @__PURE__ */ h((e) => {
      if (e instanceof ur || e instanceof gc) return e;
      if (e instanceof Zr)
        for (const s of e.children) {
          const i = t(s);
          if (i) return i;
        }
      return null;
    }, "findCanvas");
    return t(this.rootScene);
  }
  getActiveCanvas2DScene() {
    const t = /* @__PURE__ */ h((e) => {
      if (e instanceof ur) return e;
      if (e instanceof Zr)
        for (const s of e.children) {
          const i = t(s);
          if (i) return i;
        }
      return null;
    }, "findCanvas2D");
    return t(this.rootScene);
  }
  getActiveCanvas3DScene() {
    const t = /* @__PURE__ */ h((e) => {
      if (e instanceof gc) return e;
      if (e instanceof Zr)
        for (const s of e.children) {
          const i = t(s);
          if (i) return i;
        }
      return null;
    }, "findCanvas3D");
    return t(this.rootScene);
  }
  pauseActiveScene() {
    const t = this.getActiveCanvasScene();
    t && this.pausedScene !== t && (t.pause(), this.pausedScene = t);
  }
  resumeActiveScene() {
    this.pausedScene && (this.pausedScene.resume(), this.pausedScene = null);
  }
  isActiveScenePaused() {
    return !!this.pausedScene;
  }
};
h(ax, "SceneManager");
let Tg = ax;
function EH(n, t, e) {
  var i;
  if (!hi.get(e.type)) {
    console.warn(`Unknown component type: ${e.type}`);
    return;
  }
  hi.addFromAuthoring(e.type, n, t, (i = e.attributes) != null ? i : {});
}
h(EH, "addComponentByType");
function TH(n, t, e) {
  var i, o, r, a, l;
  if (!hi.get(e.type)) {
    console.warn(`Unknown component type: ${e.type}`);
    return;
  }
  if (e.type === "Collider3D" && e.attributes) {
    const c = e.attributes;
    if (c.shape && !c.shapeType) {
      const u = {
        box: 0,
        sphere: 1,
        cylinder: 2,
        capsule: 3,
        plane: 4
      };
      c.shapeType = (i = u[c.shape]) != null ? i : 0;
    }
    c.halfExtents && typeof c.halfExtents == "object" && (c.halfExtentX = c.halfExtents.x, c.halfExtentY = c.halfExtents.y, c.halfExtentZ = c.halfExtents.z, delete c.halfExtents), c.offset && typeof c.offset == "object" && (c.offsetX = (o = c.offset.x) != null ? o : 0, c.offsetY = (r = c.offset.y) != null ? r : 0, c.offsetZ = (a = c.offset.z) != null ? a : 0, delete c.offset);
  }
  hi.addFromAuthoring(e.type, n, t, (l = e.attributes) != null ? l : {});
}
h(TH, "addComponentByType3D");
async function hj(n, t, e, s) {
  var N, V, G, U, j, tt, K, $, lt, gt, _t, Y, it;
  if (n.is3D)
    throw new Error("Cannot bake 3D skeletal animations to sprite sheets. Use runtime skeletal rendering for 3D.");
  if (s.totalFrames < 1)
    throw new Error("totalFrames must be at least 1");
  if (t.duration <= 0)
    throw new Error("Animation duration must be greater than 0");
  console.log(`🎬 Baking skeletal animation "${t.name}" to sprite sheet...`), console.log(`   Skeleton: ${n.name}`), console.log(`   Frames: ${s.totalFrames}`), console.log(`   Frame size (world units): ${s.frameWidth}×${s.frameHeight}`);
  const i = 32, o = Math.ceil(s.frameWidth * i), r = Math.ceil(s.frameHeight * i);
  console.log(`   Frame size (pixels): ${o}×${r}`);
  let a = !0;
  try {
    Dn.aspectRatio;
  } catch {
    a = !1;
  }
  if (!a) {
    const J = document.createElement("div");
    J.style.width = `${o}px`, J.style.height = `${r}px`, J.style.position = "absolute", J.style.visibility = "hidden", document.body.appendChild(J);
    const dt = o / r;
    Dn.initialize(J, dt), setTimeout(() => document.body.removeChild(J), 0);
  }
  const l = new nu(), c = new ur(
    "_baking_temp",
    {
      type: "2d",
      name: "_baking_temp",
      firstScene: !0,
      backgroundColor: (N = s.backgroundColor) != null ? N : "rgba(0,0,0,0)",
      gravity: 0,
      gameBoundsWidth: s.frameWidth,
      gameBoundsHeight: s.frameHeight,
      templates: [],
      entities: [],
      hasCamera: !0
    },
    !1,
    l
  ), u = Io(c.world);
  wn(c.world, ue, u), ue.assign(u, { x: 0, y: 0, z: 0, rotation: 0, sx: 1, sy: 1 }), wn(c.world, Pt, u), Pt.component.x[u] = 0, Pt.component.y[u] = 0, Pt.component.z[u] = 0, Pt.component.rotation[u] = 0, Pt.component.sx[u] = 1, Pt.component.sy[u] = 1;
  let m = 1 / 0, d = 1 / 0, f = -1 / 0, p = -1 / 0;
  const v = Math.max(8, s.totalFrames);
  for (let J = 0; J < v; J++) {
    const dt = J / v * t.duration;
    for (const vt of e) {
      const Nt = n.bones.find((wt) => wt.name === vt.boneName);
      if (!Nt) continue;
      const _e = t.tracks.find((wt) => wt.boneName === vt.boneName);
      let k = (V = Nt.x) != null ? V : 0, te = (G = Nt.y) != null ? G : 0;
      if (_e) {
        const wt = Up(_e, dt);
        wt && (k = (U = wt.x) != null ? U : k, te = (j = wt.y) != null ? j : te);
      }
      const It = vt.width / 2, ut = vt.height / 2, bt = (tt = vt.offsetX) != null ? tt : 0, Ft = (K = vt.offsetY) != null ? K : 0;
      m = Math.min(m, k + bt - It), d = Math.min(d, te + Ft - ut), f = Math.max(f, k + bt + It), p = Math.max(p, te + Ft + ut);
    }
  }
  const _ = f - m || 1, g = p - d || 1, w = (m + f) / 2, S = (d + p) / 2, x = 0.7, A = s.frameWidth * x / _, C = s.frameHeight * x / g, M = Math.min(A, C);
  console.log(`   Skeleton bounds (animated): ${_.toFixed(2)} × ${g.toFixed(2)} world units`), console.log(`   Frame size: ${s.frameWidth} × ${s.frameHeight} world units`), console.log(`   Scale factor: ${M.toFixed(2)}x`), console.log(`   Center offset: (${w.toFixed(2)}, ${S.toFixed(2)})`), ue.assign(u, {
    sx: M,
    sy: M,
    x: -w * M,
    y: -S * M
  }), Pt.component.sx[u] = M, Pt.component.sy[u] = M, Pt.component.x[u] = -w * M, Pt.component.y[u] = -S * M, A3(c, u, {
    name: n.name,
    renderMode: n.renderMode,
    is3D: n.is3D,
    bones: n.bones
  }), S3(c, u, {
    animations: [t],
    defaultAnimation: t.name,
    blendTime: 0
  });
  for (const J of e) {
    const dt = KN(c, u, J.boneName);
    if (!dt) {
      console.warn(`Bone "${J.boneName}" not found in skeleton, skipping sprite attachment`);
      continue;
    }
    const vt = Io(c.world);
    wn(c.world, ue, vt), ue.assign(vt, {
      x: ($ = J.offsetX) != null ? $ : 0,
      y: (lt = J.offsetY) != null ? lt : 0,
      z: (gt = J.offsetZ) != null ? gt : 0,
      rotation: (_t = J.rotation) != null ? _t : 0,
      sx: 1,
      sy: 1
    }), wn(c.world, ti, vt), ti.component.parentEid[vt] = dt, wn(c.world, Pt, vt);
    const Nt = `_baking_sprite_${J.boneName}_${Date.now()}`;
    l.generateProceduralSprite(
      Nt,
      J.drawFn,
      J.width,
      J.height
    ), C3(c, vt, {
      assetKey: Nt,
      width: J.width,
      height: J.height,
      totalFrames: 1,
      fps: 1,
      isLooping: !1,
      isPlaying: !1,
      alpha: 1,
      isVisible: !0,
      flipX: !1,
      flipY: !1,
      tintStrength: 0,
      frameOffsetX: 0,
      frameOffsetY: 0,
      anchorX: (Y = J.anchorX) != null ? Y : 0.5,
      anchorY: (it = J.anchorY) != null ? it : 0.5
    });
  }
  const T = p3(), b = document.createElement("canvas");
  b.width = o * s.totalFrames, b.height = r;
  const y = b.getContext("2d");
  if (!y)
    throw new Error("Failed to create sprite sheet canvas context");
  s.backgroundColor && s.backgroundColor !== "rgba(0,0,0,0)" && (y.fillStyle = s.backgroundColor, y.fillRect(0, 0, b.width, b.height));
  const E = t.duration / s.totalFrames, I = [];
  for (let J = 0; J < s.totalFrames; J++) {
    const dt = J * E;
    console.log(`   Rendering frame ${J + 1}/${s.totalFrames} (t=${dt.toFixed(3)}s)`);
    const vt = document.createElement("canvas");
    vt.width = o, vt.height = r;
    const Nt = vt.getContext("2d");
    if (!Nt)
      throw new Error("Failed to create frame canvas context");
    if (Gt.animationTime[u] = dt, Gt.isPlaying[u] = 1, B3(c, 0), T(c), J === 0) {
      const _e = ue.read(u);
      console.log(`   Frame 0 skeleton at: (${_e.x}, ${_e.y})`);
    }
    IH(c, Nt, o, r), I.push(vt);
  }
  let B = o, D = r;
  if (s.autoFit) {
    const J = BH(I);
    if (J) {
      B = Math.ceil(J.width), D = Math.ceil(J.height), console.log(`   Auto-fit: ${o}×${r} → ${B}×${D}`), b.width = B * s.totalFrames, b.height = D, s.backgroundColor && s.backgroundColor !== "rgba(0,0,0,0)" && (y.fillStyle = s.backgroundColor, y.fillRect(0, 0, b.width, b.height));
      for (let dt = 0; dt < I.length; dt++)
        y.drawImage(
          I[dt],
          J.x,
          J.y,
          J.width,
          J.height,
          dt * B,
          0,
          B,
          D
        );
    } else
      for (let dt = 0; dt < I.length; dt++)
        y.drawImage(I[dt], dt * o, 0);
  } else
    for (let J = 0; J < I.length; J++)
      y.drawImage(I[J], J * o, 0);
  return console.log("✅ Baking complete!"), {
    canvas: b,
    frameWidth: B,
    frameHeight: D,
    totalFrames: s.totalFrames,
    actualWidth: s.autoFit ? B : void 0,
    actualHeight: s.autoFit ? D : void 0
  };
}
h(hj, "bakeSkeletalAnimationToSpriteSheet");
function IH(n, t, e, s) {
  var r, a, l, c, u, m;
  t.clearRect(0, 0, e, s), t.setTransform(1, 0, 0, -1, e / 2, s / 2);
  const i = [], o = 1e3;
  for (let d = 0; d < o; d++)
    Zi(n.world, ht, d) && Zi(n.world, Pt, d) && i.push(d);
  i.sort((d, f) => {
    var _, g;
    const p = (_ = Pt.component.z[d]) != null ? _ : 0, v = (g = Pt.component.z[f]) != null ? g : 0;
    return p - v;
  });
  for (const d of i) {
    const f = (r = Pt.component.x[d]) != null ? r : 0, p = (a = Pt.component.y[d]) != null ? a : 0, v = (l = Pt.component.rotation[d]) != null ? l : 0, _ = (c = Pt.component.sx[d]) != null ? c : 1, g = (u = Pt.component.sy[d]) != null ? u : 1, w = ht.assetId[d], S = ht.width[d], x = ht.height[d], A = ht.anchorX[d], C = ht.anchorY[d];
    if (!w) continue;
    const M = (m = n.assetManager) == null ? void 0 : m.getAssetById(w);
    M && (t.save(), t.translate(f, p), t.rotate(v), t.scale(_, g), M.type === "canvas" && M.data instanceof HTMLCanvasElement && t.drawImage(
      M.data,
      -S * A,
      -x * C,
      S,
      x
    ), t.restore());
  }
}
h(IH, "renderFrameToCanvas");
function BH(n) {
  if (n.length === 0) return null;
  let t = 1 / 0, e = 1 / 0, s = -1 / 0, i = -1 / 0;
  for (const o of n) {
    const r = o.getContext("2d");
    if (!r) continue;
    const l = r.getImageData(0, 0, o.width, o.height).data;
    for (let c = 0; c < o.height; c++)
      for (let u = 0; u < o.width; u++) {
        const m = (c * o.width + u) * 4;
        l[m + 3] > 0 && (t = Math.min(t, u), e = Math.min(e, c), s = Math.max(s, u), i = Math.max(i, c));
      }
  }
  return t === 1 / 0 || e === 1 / 0 ? null : {
    x: t,
    y: e,
    width: s - t + 1,
    height: i - e + 1
  };
}
h(BH, "calculateContentBounds");
const cx = class cx {
  constructor(t) {
    this.rightKeys = /* @__PURE__ */ new Set(), this.leftKeys = /* @__PURE__ */ new Set(), this.upKeys = /* @__PURE__ */ new Set(), this.downKeys = /* @__PURE__ */ new Set(), this.joystickSelector = null, this.dpadSelector = null, this.rawValue = { x: 0, y: 0 }, this.smoothValue = { x: 0, y: 0 }, this.smoothSpeed = 0.15, this._name = t;
  }
  bindWASD() {
    return this.upKeys.add("w"), this.downKeys.add("s"), this.leftKeys.add("a"), this.rightKeys.add("d"), this;
  }
  bindArrowKeys() {
    return this.upKeys.add("ArrowUp"), this.downKeys.add("ArrowDown"), this.leftKeys.add("ArrowLeft"), this.rightKeys.add("ArrowRight"), this;
  }
  bindJoystick(t) {
    return this.joystickSelector = t, this;
  }
  bindVirtualDPad(t) {
    return this.dpadSelector = t, this;
  }
  setSmoothSpeed(t) {
    return this.smoothSpeed = Math.max(1e-3, t), this;
  }
  update(t) {
    let e = 0, s = 0;
    for (const a of this.rightKeys)
      if (Nn.isKeyDown(a)) {
        e += 1;
        break;
      }
    for (const a of this.leftKeys)
      if (Nn.isKeyDown(a)) {
        e -= 1;
        break;
      }
    for (const a of this.upKeys)
      if (Nn.isKeyDown(a)) {
        s += 1;
        break;
      }
    for (const a of this.downKeys)
      if (Nn.isKeyDown(a)) {
        s -= 1;
        break;
      }
    if (this.joystickSelector) {
      const a = jc.getJoystickValue(this.joystickSelector);
      a && Math.sqrt(a.x ** 2 + a.y ** 2) > 0.1 && (e = a.x, s = a.y);
    }
    if (this.dpadSelector) {
      const a = Xi.isDown(`${this.dpadSelector} .dpad-up`), l = Xi.isDown(`${this.dpadSelector} .dpad-down`), c = Xi.isDown(`${this.dpadSelector} .dpad-left`), u = Xi.isDown(`${this.dpadSelector} .dpad-right`);
      (a || l || c || u) && (e = (u ? 1 : 0) + (c ? -1 : 0), s = (a ? 1 : 0) + (l ? -1 : 0));
    }
    const i = Math.sqrt(e ** 2 + s ** 2);
    i > 1 && (e /= i, s /= i), this.rawValue = { x: e, y: s };
    const o = t / 1e3, r = Math.min(1, o / this.smoothSpeed);
    this.smoothValue.x = Q_(this.smoothValue.x, e, r), this.smoothValue.y = Q_(this.smoothValue.y, s, r), Math.abs(this.smoothValue.x) < 0.01 && (this.smoothValue.x = 0), Math.abs(this.smoothValue.y) < 0.01 && (this.smoothValue.y = 0);
  }
  get name() {
    return this._name;
  }
  get raw() {
    return { ...this.rawValue };
  }
  get smooth() {
    return { ...this.smoothValue };
  }
};
h(cx, "Axis2DBinding");
let Gd = cx;
const lx = class lx {
  constructor(t) {
    this.positiveKeys = /* @__PURE__ */ new Set(), this.negativeKeys = /* @__PURE__ */ new Set(), this.positiveButtons = /* @__PURE__ */ new Set(), this.negativeButtons = /* @__PURE__ */ new Set(), this.rawValue = 0, this.smoothValue = 0, this.smoothSpeed = 0.15, this.mouseButtonStates = /* @__PURE__ */ new Map(), this._name = t;
  }
  bindKeys(t, e) {
    return this.negativeKeys.add(t), this.positiveKeys.add(e), this;
  }
  bindButtons(t, e) {
    return t !== null && this.negativeButtons.add(t), e !== null && this.positiveButtons.add(e), this;
  }
  setSmoothSpeed(t) {
    return this.smoothSpeed = Math.max(1e-3, t), this;
  }
  updateWithMouseState(t, e) {
    this.mouseButtonStates = t;
    let s = !1;
    for (const d of this.positiveKeys)
      if (Nn.isKeyDown(d)) {
        s = !0;
        break;
      }
    let i = !1;
    for (const d of this.negativeKeys)
      if (Nn.isKeyDown(d)) {
        i = !0;
        break;
      }
    let o = !1;
    for (const d of this.positiveButtons)
      if (Xi.isDown(d)) {
        o = !0;
        break;
      }
    let r = !1;
    for (const d of this.negativeButtons)
      if (Xi.isDown(d)) {
        r = !0;
        break;
      }
    const c = (s || o ? 1 : 0) + (i || r ? -1 : 0);
    this.rawValue = c;
    const u = e / 1e3, m = Math.min(1, u / this.smoothSpeed);
    this.smoothValue = Q_(this.smoothValue, c, m), Math.abs(this.smoothValue) < 0.01 && (this.smoothValue = 0);
  }
  get name() {
    return this._name;
  }
  get raw() {
    return this.rawValue;
  }
  get smooth() {
    return this.smoothValue;
  }
};
h(lx, "AxisBinding");
let Hd = lx;
const jl = class jl {
  static register(t) {
    t instanceof Hd ? this.axes.set(t.name, t) : t instanceof Gd && this.axes2D.set(t.name, t);
  }
  static get(t) {
    return this.axes.get(t);
  }
  static get2D(t) {
    return this.axes2D.get(t);
  }
  static update(t, e) {
    Xi.update(), No.update();
    for (const s of this.axes.values())
      s.updateWithMouseState(e, t);
    for (const s of this.axes2D.values())
      s.update(t);
  }
  static reset() {
    this.axes.clear(), this.axes2D.clear(), jc.cleanup(), Xi.cleanup(), No.cleanup();
  }
  static getRaw(t) {
    const e = this.axes.get(t);
    return e ? e.raw : (console.warn(`[AxisManager] Axis "${t}" not found. Did you forget to createAxis()?`), 0);
  }
  static getSmooth(t) {
    const e = this.axes.get(t);
    return e ? e.smooth : (console.warn(`[AxisManager] Axis "${t}" not found. Did you forget to createAxis()?`), 0);
  }
  static get2DRaw(t) {
    const e = this.axes2D.get(t);
    return e ? e.raw : (console.warn(`[AxisManager] Axis2D "${t}" not found. Did you forget to createAxis2D()?`), { x: 0, y: 0 });
  }
  static get2DSmooth(t) {
    const e = this.axes2D.get(t);
    return e ? e.smooth : (console.warn(`[AxisManager] Axis2D "${t}" not found. Did you forget to createAxis2D()?`), { x: 0, y: 0 });
  }
};
h(jl, "AxisManager"), jl.axes = /* @__PURE__ */ new Map(), jl.axes2D = /* @__PURE__ */ new Map();
let To = jl;
const PH = new hn().with(ue).with(Zn), ux = class ux {
  constructor(t, e) {
    this.buttons = /* @__PURE__ */ new Map(), this.justPressed = /* @__PURE__ */ new Set(), this.justReleased = /* @__PURE__ */ new Set(), this.screenX = 0, this.screenY = 0, this.worldX = 0, this.worldY = 0, this.lastUpdateTime = performance.now(), this.canvas = t, this.world = e, t.addEventListener("mousedown", (s) => this.handleMouseDown(s)), t.addEventListener("mouseup", (s) => this.handleMouseUp(s)), t.addEventListener("mousemove", (s) => this.handleMouseMove(s)), t.addEventListener("mouseleave", () => this.handleMouseLeave());
  }
  handleMouseDown(t) {
    this.buttons.get(t.button) || this.justPressed.add(t.button), this.buttons.set(t.button, !0), this.updateMousePosition(t);
  }
  handleMouseUp(t) {
    this.buttons.set(t.button, !1), this.justReleased.add(t.button), this.updateMousePosition(t);
  }
  handleMouseMove(t) {
    this.updateMousePosition(t);
  }
  handleMouseLeave() {
    this.buttons.clear(), this.justPressed.clear(), this.justReleased.clear();
  }
  updateMousePosition(t) {
    const e = this.canvas.getBoundingClientRect();
    this.screenX = t.clientX - e.left, this.screenY = t.clientY - e.top;
    const [s, i] = this.screenToWorld(this.screenX, this.screenY);
    this.worldX = s, this.worldY = i;
  }
  screenToWorld(t, e) {
    var u, m, d, f, p, v, _, g;
    const s = PH._compile().base(this.world).filter((w) => (Zn.component.isActive[w] | 0) === 1).sort((w, S) => (Zn.component.zOrder[S] | 0) - (Zn.component.zOrder[w] | 0));
    for (const w of s) {
      const S = {
        x: (u = Zn.component.viewportX[w]) != null ? u : 0,
        y: (m = Zn.component.viewportY[w]) != null ? m : 0,
        width: (d = Zn.component.viewportWidth[w]) != null ? d : 1,
        height: (f = Zn.component.viewportHeight[w]) != null ? f : 1
      }, x = t / (this.canvas.width / (window.devicePixelRatio || 1)), A = 1 - e / (this.canvas.height / (window.devicePixelRatio || 1));
      if (!(x >= S.x && x <= S.x + S.width && A >= S.y && A <= S.y + S.height)) continue;
      const M = ue.read(w), T = {
        worldX: (p = M.x) != null ? p : 0,
        worldY: (v = M.y) != null ? v : 0,
        scaleX: (_ = M.sx) != null ? _ : 1,
        scaleY: (g = M.sy) != null ? g : 1
      }, b = E5(
        { x: t, y: e },
        T,
        S,
        Dn.worldViewWidth,
        Dn.worldViewHeight,
        this.canvas.width / (window.devicePixelRatio || 1),
        this.canvas.height / (window.devicePixelRatio || 1)
      );
      return [b.x, b.y];
    }
    const i = window.devicePixelRatio || 1, o = Dn.canvasPixelWidth / Dn.worldViewWidth, r = t * i, a = e * i, l = r - this.canvas.width / 2, c = a - this.canvas.height / 2;
    return [l / o, c / o];
  }
  getWorldPosition() {
    return { x: this.worldX, y: this.worldY };
  }
  getScreenPosition() {
    return { x: this.screenX, y: this.screenY };
  }
  isButtonDown(t = 0) {
    var e;
    return (e = this.buttons.get(t)) != null ? e : !1;
  }
  isButtonPressed(t = 0) {
    return this.justPressed.has(t);
  }
  isButtonReleased(t = 0) {
    return this.justReleased.has(t);
  }
  isEntityClicked(t, e = 0) {
    return this.isButtonPressed(e) && (qs.component.width[t] && WN(t, this.worldX, this.worldY) || Ln.component.radius[t] && VN(t, this.worldX, this.worldY)) || !1;
  }
  isKeyDown(t) {
    return Nn.isKeyDown(t);
  }
  isKeyPressed(t) {
    return Nn.isKeyPressed(t);
  }
  isKeyReleased(t) {
    return Nn.isKeyReleased(t);
  }
  isActionPressed(t) {
    return cr.isPressed(t);
  }
  isActionDown(t) {
    return cr.isDown(t);
  }
  isActionReleased(t) {
    return cr.isReleased(t);
  }
  getActionHoldDuration(t) {
    return cr.getHoldDuration(t);
  }
  getAxisRaw(t) {
    return To.getRaw(t);
  }
  getAxis(t) {
    return To.getSmooth(t);
  }
  getAxis2DRaw(t) {
    return To.get2DRaw(t);
  }
  getAxis2D(t) {
    return To.get2DSmooth(t);
  }
  reset() {
    this.justPressed.clear(), this.justReleased.clear();
    const t = performance.now(), e = t - this.lastUpdateTime;
    this.lastUpdateTime = t, cr.update(e, this.buttons, this.justPressed, this.justReleased), To.update(e, this.buttons);
  }
};
h(ux, "InputManager");
let Ig = ux;
const hx = class hx {
  constructor(t) {
    this.keys = /* @__PURE__ */ new Set(), this.mouseButtons = /* @__PURE__ */ new Set(), this.virtualButtons = /* @__PURE__ */ new Set(), this.wasDownLastFrame = !1, this.downThisFrame = !1, this.pressedThisFrame = !1, this.releasedThisFrame = !1, this.holdStartTime = 0, this.currentHoldDuration = 0, this.mouseButtonStates = /* @__PURE__ */ new Map(), this.mouseJustPressed = /* @__PURE__ */ new Set(), this.mouseJustReleased = /* @__PURE__ */ new Set(), this._name = t;
  }
  bindKey(t) {
    return this.keys.add(t), this;
  }
  bindMouseButton(t) {
    return this.mouseButtons.add(t), this;
  }
  bindVirtualButton(t) {
    return this.virtualButtons.add(t), this;
  }
  updateWithMouseState(t, e, s, i) {
    this.mouseButtonStates = t, this.mouseJustPressed = e, this.mouseJustReleased = s, this.wasDownLastFrame = this.downThisFrame;
    let o = !1;
    for (const l of this.keys)
      if (Nn.isKeyDown(l)) {
        o = !0;
        break;
      }
    let r = !1;
    for (const l of this.mouseButtons)
      if (this.mouseButtonStates.get(l)) {
        r = !0;
        break;
      }
    let a = !1;
    for (const l of this.virtualButtons)
      if (Xi.isDown(l)) {
        a = !0;
        break;
      }
    this.downThisFrame = o || r || a, this.pressedThisFrame = this.downThisFrame && !this.wasDownLastFrame, this.releasedThisFrame = !this.downThisFrame && this.wasDownLastFrame, this.pressedThisFrame ? (this.holdStartTime = performance.now(), this.currentHoldDuration = 0) : this.downThisFrame ? this.currentHoldDuration = performance.now() - this.holdStartTime : this.currentHoldDuration = 0;
  }
  get pressed() {
    return this.pressedThisFrame;
  }
  get down() {
    return this.downThisFrame;
  }
  get released() {
    return this.releasedThisFrame;
  }
  get holdDuration() {
    return this.currentHoldDuration;
  }
  get name() {
    return this._name;
  }
};
h(hx, "ActionBinding");
let Bg = hx;
const RH = function(n) {
  const t = {
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&apos;": "'",
    "&quot;": '"'
  }, e = "@", s = "#";
  return n.fromXML = i;
  function i(d, f) {
    return u(o(d), f);
  }
  function o(d) {
    const f = String.prototype.split.call(d, /<([^!<>?](?:'[\S\s]*?'|"[\S\s]*?"|[^'"<>])*|!(?:--[\S\s]*?--|\[[^\[\]'"<>]+\[[\S\s]*?]]|DOCTYPE[^\[<>]*?\[[\S\s]*?]|(?:ENTITY[^"<>]*?"[\S\s]*?")?[\S\s]*?)|\?[\S\s]*?\?)>/), p = f.length, v = { f: [] };
    let _ = v;
    const g = [];
    for (let A = 0; A < p; ) {
      const C = f[A++];
      C && x(C);
      const M = f[A++];
      M && w(M);
    }
    return v;
    function w(A) {
      const C = A.length, M = A[0];
      if (M === "/") {
        const T = A.replace(/^\/|[\s\/].*$/g, "").toLowerCase();
        for (; g.length; ) {
          const b = _.n && _.n.toLowerCase();
          if (_ = g.pop(), b === T) break;
        }
      } else if (M === "?")
        S({ n: "?", r: A.substr(1, C - 2) });
      else if (M === "!")
        A.substr(1, 7) === "[CDATA[" && A.substr(-2) === "]]" ? x(A.substr(8, C - 10)) : S({ n: "!", r: A.substr(1) });
      else {
        const T = r(A);
        S(T), A[C - 1] === "/" ? T.c = 1 : (g.push(_), _ = T);
      }
    }
    function S(A) {
      _.f.push(A);
    }
    function x(A) {
      A = l(A), A && S(c(A));
    }
  }
  function r(d) {
    const f = { f: [] };
    d = d.replace(/\s*\/?$/, "");
    const p = d.search(/[\s='"\/]/);
    return p < 0 ? f.n = d : (f.n = d.substr(0, p), f.t = d.substr(p)), f;
  }
  function a(d, f) {
    if (!d.t) return;
    const p = d.t.split(/([^\s='"]+(?:\s*=\s*(?:'[\S\s]*?'|"[\S\s]*?"|[^\s'"]*))?)/), v = p.length;
    let _, g;
    for (let w = 0; w < v; w++) {
      let S = l(p[w]);
      if (!S) continue;
      _ || (_ = {});
      const x = S.indexOf("=");
      if (x < 0)
        S = e + S, g = null;
      else {
        g = S.substr(x + 1).replace(/^\s+/, ""), S = e + S.substr(0, x).replace(/\s+$/, "");
        const A = g[0], C = g[g.length - 1];
        A === C && (A === "'" || A === '"') && (g = g.substr(1, g.length - 2)), g = c(g);
      }
      f && (g = f(S, g)), m(_, S, g);
    }
    return _;
  }
  function l(d) {
    return d && d.replace(/^\s+|\s+$/g, "");
  }
  function c(d) {
    return d.replace(/(&(?:lt|gt|amp|apos|quot|#(?:\d{1,6}|x[0-9a-fA-F]{1,5}));)/g, function(f) {
      if (f[1] === "#") {
        const p = f[2] === "x" ? parseInt(f.substr(3), 16) : parseInt(f.substr(2), 10);
        if (p > -1) return String.fromCharCode(p);
      }
      return t[f] || f;
    });
  }
  function u(d, f) {
    if (typeof d == "string") return d;
    const p = d.r;
    if (p) return p;
    const v = a(d, f);
    let _;
    const g = d.f, w = g.length;
    if (v || w > 1)
      _ = v || {}, g.forEach(function(S) {
        typeof S == "string" ? m(_, s, S) : m(_, S.n, u(S, f));
      });
    else if (w) {
      const S = g[0];
      if (_ = u(S, f), S.n) {
        const x = {};
        x[S.n] = _, _ = x;
      }
    } else
      _ = d.c ? null : "";
    return f && (_ = f(d.n || "", _)), _;
  }
  function m(d, f, p) {
    if (typeof p == "undefined") return;
    const v = d[f];
    v instanceof Array ? v.push(p) : f in d ? d[f] = [v, p] : d[f] = p;
  }
}({}), Wl = class Wl {
  constructor(t, e, s, i, o, r = !1, a) {
    if (this.aspectRatio = t, this.useEditor = r, this.running = !1, this.lastTime = 0, this.container = document.createElement("main"), this.container.id = "app", this.container.style.setProperty("--aspect-ratio", t.toFixed(4)), this.container.addEventListener("contextmenu", (l) => l.preventDefault()), document.body.appendChild(this.container), o) {
      const l = document.createElement("style");
      l.textContent = o, this.container.appendChild(l);
    }
    Dn.initialize(this.container, t), this.assetManager = a != null ? a : new nu(), this.sceneManager = new Tg(
      e,
      s,
      i,
      r,
      this.assetManager
    ), this.sceneManager.mount(this.container), r && Eu.initialize(this), this.start();
  }
  start() {
    if (this.running) return;
    this.running = !0, this.lastTime = 0;
    const t = /* @__PURE__ */ h((e) => {
      if (!this.running) return;
      this.lastTime === 0 && (this.lastTime = e);
      const s = Math.min(e - this.lastTime, Wl.MAX_DELTA_MS);
      this.lastTime = e, this.sceneManager.update(this, s), this.sceneManager.draw(this), Nn.reset(), requestAnimationFrame(t);
    }, "loop");
    requestAnimationFrame(t);
  }
  stop() {
    this.running = !1;
  }
  get isRunning() {
    return this.running;
  }
  getAssetManager() {
    return this.assetManager;
  }
};
h(Wl, "Game"), Wl.MAX_DELTA_MS = 50;
let Pg = Wl;
const dx = class dx {
  constructor() {
    this.systems = [], this.sceneInitCallbacks = [], this.useEditor = !1, this.sceneDefinitions = /* @__PURE__ */ new Map(), this.assetManager = new nu();
  }
  defineComponent(t, e) {
    const s = Vi(t, e);
    return hi.registerType({ type: s }), s;
  }
  registerTemplates(t, e) {
    for (const i of t)
      ha.register(i.name, i);
    const s = /* @__PURE__ */ h((i) => {
      var o, r;
      i.type === "composite" && ((o = i.children) == null || o.forEach((a) => s(a))), i.type !== "ui" && ((r = i.templates) == null || r.forEach((a) => ha.register(a.name, a)));
    }, "extractSceneTemplates");
    for (const i of e) s(i);
  }
  addSystem(t) {
    return this.systems.push(t), this;
  }
  onSceneInit(t) {
    return this.sceneInitCallbacks.push(t), this;
  }
  createAction(t) {
    const e = new Bg(t);
    return cr.register(e), e;
  }
  createAxis(t) {
    const e = new Hd(t);
    return To.register(e), e;
  }
  createAxis2D(t) {
    const e = new Gd(t);
    return To.register(e), e;
  }
  wrapSystemsWithInitListeners(t) {
    const e = this.sceneInitCallbacks;
    return e.length === 0 ? t : t.map((s) => {
      const i = /* @__PURE__ */ new WeakSet();
      return (o, r) => {
        if (o instanceof Tu && !i.has(o)) {
          i.add(o);
          for (const l of e) l(o);
          return;
        }
        s(o, r);
      };
    });
  }
  withEditor() {
    return this.useEditor = !0, this;
  }
  runWithXML(t) {
    const { success: e, error: s, data: i } = y8.safeParse(RH(t));
    if (!e) throw new Error("XML Validation Error: " + s.message);
    const { aspectRatio: o, name: r, globalStyle: a, firstSceneName: l, scenes: c, templates: u } = i;
    this.name = r, this.aspectRatio = o, this.globalStyle = a, this.firstSceneName = l;
    for (const d of c) this.sceneDefinitions.set(d.name, d);
    this.registerTemplates(u, c), document.title = this.name;
    const m = Array.from(this.sceneDefinitions.values());
    return new Pg(
      this.aspectRatio,
      m,
      this.firstSceneName,
      this.wrapSystemsWithInitListeners(this.systems),
      this.globalStyle,
      this.useEditor,
      this.assetManager
    );
  }
};
h(dx, "GameBuilder");
let vA = dx;
typeof window != "undefined" && window.GameEngine && window.GameEngine.__attachGlobalAliases && window.GameEngine.__attachGlobalAliases(window);
export {
  ia as Camera3D,
  $e as Easing,
  Hi as EventBus,
  vA as GameBuilder,
  Cp as GlobalState,
  zs as Health,
  rn as Light,
  ke as Material,
  qn as Mesh3D,
  Bl as Model3D,
  hn as Query,
  os as RigidBody3D,
  ht as Sprite,
  ue as Transform,
  ne as Transform3D,
  Pt as WorldTransform,
  hj as bakeSkeletalAnimationToSpriteSheet,
  zH as burstParticles,
  ZH as getAnimationSpeed,
  KN as getBoneEntity,
  HH as getBoneNames,
  XN as getCurrentSkeletalAnimation,
  FN as getPresetByName,
  GH as getSkeletalAnimationNames,
  M3 as getSkeletonDef,
  sj as getSpriteColor,
  QH as getSpriteFlipX,
  tj as getSpriteFlipY,
  qH as pauseAnimation,
  OH as pauseSkeletalAnimation,
  aj as pauseTween,
  kH as playSkeletalAnimation,
  jH as playSpriteAnimation,
  ij as resetSpriteColor,
  lj as resetTween,
  XH as resumeAnimation,
  $H as resumeSkeletalAnimation,
  cj as resumeTween,
  WH as setAnimationSpeed,
  FH as setSkeletalAnimationSpeed,
  ej as setSpriteColor,
  KH as setSpriteFlip,
  YH as setSpriteFlipX,
  JH as setSpriteFlipY,
  nj as setSpriteTint,
  LH as startEmitter,
  oj as startTween,
  NH as stopEmitter,
  UH as stopSkeletalAnimation,
  rj as stopTween,
  uj as tween,
  VH as zodV4
};
